1
00:00:00,000 --> 00:00:20,580
안녕하세요. 내 말 잘 들려요? 네, 잘 들립니다. 어서 오세요. 이 대화는 쿨하지 않아

2
00:00:20,580 --> 00:00:27,960
과대포장되거나 유행에 뒤떨어지지도 않아요. 모듈형 모놀리스에 관한 이야기입니다. 이에 대한 배경 지식

3
00:00:27,960 --> 00:00:35,120
이야기. 저는 트위터를 하고 있습니다. 몇 년 전에 저는 이런 말을 했습니다. 제대로 된 모놀리스를 만들 수 없다면,

4
00:00:35,120 --> 00:00:39,160
마이크로서비스는 신경 쓰지 마세요. 많은 사람들이 마이크로서비스에 뛰어드는 것을 보았습니다.

5
00:00:39,160 --> 00:00:50,480
실패할 수밖에 없었습니다. 저는 그것이 많은 지혜라고 생각했습니다. 그리고 305명의 다른 사람들도 그렇게 생각했습니다.

6
00:00:50,480 --> 00:01:00,920
맞아요. 하지만 박수는 잠시만요, 저는 건축가 클리피에게 완전히 밀렸어요.

7
00:01:00,920 --> 00:01:04,320
구조가 엉망인 모놀리스를 가지고 있군요. 이걸 좀 더 튼튼한 구조로 바꿔줄까요?

8
00:01:04,320 --> 00:01:11,840
구조화된 마이크로서비스 집합으로 변환할까요? 4,000. 한 배나 더 커진 셈이죠. 다른 방식으로 보면

9
00:01:11,840 --> 00:01:18,520
이 바로 그것입니다. 이것이 바로 이 강연의 핵심입니다. 다음과 같은 분들을 위해

10
00:01:18,519 --> 00:01:23,159
저는 소프트웨어 아키텍처를 전문으로 하는 독립 컨설턴트인 사이먼 브라운입니다.

11
00:01:23,159 --> 00:01:28,920
저는 leanpub.com에서 찾을 수 있는 두 권의 소프트웨어 아키텍처 책을 저술했습니다. I

12
00:01:28,920 --> 00:01:33,679
또한 최근에 밥 마틴 삼촌의 클린 아키텍처 책에 한 장을 썼습니다. 그 챕터

13
00:01:33,679 --> 00:01:40,759
이 챕터는 '사라진 장'이라고 불립니다. 제가 사본을 가지고 있기 때문에 거기에 있습니다. 그리고 모든 것들

14
00:01:40,759 --> 00:01:45,879
의 모든 내용이 이 강연의 본질적인 내용이기도 합니다. 또한

15
00:01:45,879 --> 00:01:50,159
이 모든 것들은 제가 C4 모델을 만든 장본인이기 때문에 잠시 후에 설명하겠습니다,

16
00:01:50,159 --> 00:01:54,319
간단히 말해서, 소프트웨어를 설명하기 위한 계층적 아키텍처 다이어그램의 집합입니다.

17
00:01:54,319 --> 00:02:00,560
아키텍처 시스템, 그리고 나는 창립자 슬래시 최고 코드 원숭이 슬래시 다른 모든 것들.

18
00:02:00,560 --> 00:02:06,199
아키텍처 다이어그램을 만드는 도구 세트인 Structuriser라는 회사를 설립했습니다.

19
00:02:06,199 --> 00:02:11,879
왜 이 두 가지 이야기를 꺼냈을까요? 첫 번째는 구조화 도구인 서버입니다.

20
00:02:11,879 --> 00:02:19,560
쪽은 기본적으로 두 개의 자바 스프링 웹 애플리케이션, 즉 피보탈에서 실행되는 두 개의 모듈형 모놀리스입니다.

21
00:02:19,560 --> 00:02:23,719
웹 서비스 클라우드 파운드리 플랫폼. 이 강연에서 제가 이야기하는 모든 것은

22
00:02:23,719 --> 00:02:28,240
실제로 사용하고 있습니다. 우리는 흔히 이를 도그푸딩이라고 부르는데, 이는 끔찍한 용어입니다.

23
00:02:28,240 --> 00:02:32,599
여기까지입니다. 저는 도커나 쿠버네티스, 마이크로서비스 등을 사용하지 않으니까요.

24
00:02:32,599 --> 00:02:39,199
이것은 구식입니다. 게다가 코드 구조가 좋으면 쉽게

25
00:02:39,200 --> 00:02:44,960
시각화하기 쉽습니다. 그래서 저는 모듈형 모놀리스 방식에 더 관심이 많습니다.

26
00:02:44,960 --> 00:02:52,560
에서. C4. C4는 제가 사용하는 다이어그램 기법입니다. 컨텍스트, 컨테이너, 컴포넌트, 그리고

27
00:02:52,560 --> 00:02:59,640
코드입니다. 이에 대한 자세한 내용은 c4model.com에서 확인할 수 있습니다. 다음은 시스템 컨텍스트입니다.

28
00:02:59,640 --> 00:03:04,940
예전에 제가 구축한 시스템의 다이어그램입니다. 기본적으로 저는 이 시스템을 다음과 같이 구축했습니다.

29
00:03:04,939 --> 00:03:11,340
사용자 유형과 다양한 시스템 연결로 구성했습니다. 이 시스템을 확대해서 보면

30
00:03:11,340 --> 00:03:16,300
컨테이너가 표시됩니다. 컨테이너는 애플리케이션 또는 데이터 저장소를 의미합니다. 여기에서 다음을 볼 수 있습니다.

31
00:03:16,300 --> 00:03:22,079
웹 애플리케이션, 또 다른 Java 애플리케이션, 그리고 여러 데이터 저장소가 있습니다. 확대합니다.

32
00:03:22,079 --> 00:03:27,699
을 확대하면 그 안에 있는 구성 요소를 볼 수 있습니다.

33
00:03:27,699 --> 00:03:33,500
자바 애플리케이션. 다시 말하지만, 이 방법은 쉽고 간단하며 계층적입니다. 다음에서 확인할 수 있습니다.

34
00:03:33,539 --> 00:03:40,620
오른쪽 상단에 트윗 컴포넌트가 있습니다. 이 경우 트윗 컴포넌트의 역할은 다음과 같습니다.

35
00:03:40,620 --> 00:03:47,379
트윗을 몽고 데이터 저장소에 넣고 다시 트윗을 내보내는 역할을 합니다. 이것은 레벨

36
00:03:47,379 --> 00:03:55,180
내 C4 다이어그램의 3번입니다. 이 단일 상자, 즉 트윗 컴포넌트를 확대하면 다음을 볼 수 있습니다.

37
00:03:55,180 --> 00:04:02,180
이를 구현하는 코드가 보입니다. 이제 무엇을 발견하셨나요? 이전 다이어그램에서

38
00:04:05,060 --> 00:04:10,099
트윗 컴포넌트라는 상자가 하나 있었습니다. 이제 코드를 보여드렸는데, 이제

39
00:04:10,099 --> 00:04:17,100
트윗 컴포넌트라는 상자가 하나도 없습니다. 사라졌습니다. 트윗 컴포넌트는 실제로 존재하지 않습니다.

40
00:04:18,860 --> 00:04:23,399
어디로 사라졌나요? 트윗 컴포넌트는 실제로 다음과 같은 자바 인터페이스의 집합입니다.

41
00:04:23,399 --> 00:04:30,399
케이스와 계층화된 아키텍처의 Java 클래스로 구성되어 있습니다. 이렇게 아주 간단한 스토리가 전개되고 있습니다,

42
00:04:32,599 --> 00:04:39,599
그리고 최종 코드 레벨에 도달했습니다. 스토리가 작동을 멈췄습니다. 이 시점에서

43
00:04:40,399 --> 00:04:45,399
트윗 컴포넌트가 존재하기 때문에 실제로는 중요하지 않다고 사람들이 말할 수 있습니다.

44
00:04:45,399 --> 00:04:52,399
개념적으로 말이죠. 네, 그런 것 같습니다. 제 말은, 이것은 개념적으로 여러 개의 자바 컴포넌트를

45
00:04:53,120 --> 00:04:58,760
인터페이스와 클래스를 개념적으로 그룹화한 것이지만, 여기서 중요한 건 그게 아닙니다. 여기서 요점은 모든 추상화는

46
00:04:58,760 --> 00:05:05,760
은 코드를 반영해야 하며 그 반대의 경우도 마찬가지입니다. 이는 본질적으로

47
00:05:07,080 --> 00:05:11,080
이 강연의 주제입니다. 소프트웨어 아키텍처에 관한 훌륭한 책이 있으니 참고하시기 바랍니다.

48
00:05:11,080 --> 00:05:16,400
조지 페어뱅크스의 저스트 이너프 소프트웨어 아키텍처라는 책이 있습니다. 이 책에서 George는

49
00:05:16,640 --> 00:05:23,160
는 모델 코드 갭에 대해 이야기합니다. 여러분이 일하고 있는 장면을 상상해 보세요.

50
00:05:23,160 --> 00:05:27,960
친구 및 동료들과 아키텍처에 대해 토론을 하고 있고, 이 토론 중에

51
00:05:27,960 --> 00:05:34,960
모듈, 컴포넌트, 서비스, 서브시스템, 레이어와 같은 단어를 사용하게 될 것입니다. Who's

52
00:05:38,800 --> 00:05:45,800
여기 자바 개발자가 있나요? 여러분 중 상당수가요. 훌륭하군요. 자바에서는 종종

53
00:05:46,079 --> 00:05:53,079
계층화된 애플리케이션을 구축합니다. 알겠어요? Java에 레이어 키워드가 있나요? 네. Java에 컴포넌트

54
00:05:56,400 --> 00:06:03,400
키워드가 있나요? 아니요. 그게 문제입니다. 우리가 사용하는 언어는 다음과 같습니다.

55
00:06:03,400 --> 00:06:09,439
대부분의 다른 언어에도 적용되며, 우리가 사용하는 언어에는 이러한 구조적 구조가 없습니다.

56
00:06:09,439 --> 00:06:16,439
일등 시민으로, 일등 키워드로 사용합니다. 이것이 바로 모델 코드 격차입니다. 우리는

57
00:06:16,719 --> 00:06:22,360
모듈, 서비스, 레이어 등의 개념을 코드 베이스에 매핑할 수 없다면 말입니다,

58
00:06:22,360 --> 00:06:27,399
이 두 가지 사고 방식, 즉 상향식 대 하향식 사이에 불일치가 발생합니다. 이

59
00:06:27,399 --> 00:06:34,399
이 모델 코드 갭입니다. 이에 대해 다른 방식으로 생각해 보면 다음과 같이 상상해 볼 수 있습니다.

60
00:06:35,280 --> 00:06:40,280
소프트웨어의 아키텍처 다이어그램을 그려달라고 하면 아마 높은 수준의 그림을 그려줄 것입니다.

61
00:06:40,280 --> 00:06:45,780
모듈, 컴포넌트, 레이어, 서비스 등, 그리고 이들이 런타임에 어떻게 상호 작용하는지. 만약

62
00:06:45,780 --> 00:06:52,780
실제 코드 베이스에서 다이어그램을 리버스 엔지니어링할 수 있는 툴을 찾으려면

63
00:06:53,160 --> 00:06:57,780
같은 다이어그램을 얻을 수는 없겠죠? 저는 매우 낮은 수준의 매우 정확한

64
00:06:57,820 --> 00:07:04,820
클래스, 인터페이스, 폴더, 파일, 네임스페이스, 패키지 계층구조, 그리고

65
00:07:04,980 --> 00:07:11,980
등등. 다시 말하지만, 이것은 잠재적으로 모델 코드 갭입니다. 모델 코드 갭은 다음과 같이 나타납니다.

66
00:07:13,900 --> 00:07:20,900
여러 가지 방식으로 나타납니다. 그 중 하나는 아주 간단합니다. 조직에 가서 물어보는 것입니다,

67
00:07:21,380 --> 00:07:25,460
아키텍처 다이어그램을 보여달라고 하면, 그 조직은 아주 멋지고 화려한 색상의

68
00:07:25,460 --> 00:07:29,020
아키텍처 다이어그램을 보여주면서 개발팀에게 물어보면, 이런 게

69
00:07:29,020 --> 00:07:35,820
의미가 있는지 물어보면 개발팀은 코드와 일치하지 않는다고 답하죠. 이런 일이 자주 발생합니다. 그게 바로

70
00:07:35,820 --> 00:07:42,820
이 부분도 고치고 싶습니다. 이 책에서 조지 페어뱅크스는 다음과 같이 말합니다.

71
00:07:44,040 --> 00:07:51,040
이 모델 코드 격차를 해결할 수 있는 방법 중 하나는 아키텍처적으로 분명한 코딩 스타일을 채택하는 것이라고 말합니다. 지금 당장,

72
00:07:51,040 --> 00:07:58,040
이것은 매우 거창하게 들리지만, 기본적으로 코드 구조가 다음과 같아야 한다는 뜻입니다.

73
00:07:59,240 --> 00:08:05,680
아키텍처 의도를 반영해야 한다는 것입니다. 따라서 우리가 생각하는 방식과 코드 구조 사이에는 깔끔한 매핑이 있습니다.

74
00:08:05,680 --> 00:08:10,560
하향식 관점에서 우리 시스템에 대해 생각하는 방식과 코드가 최종적으로 어떻게 보이는지 그리고

75
00:08:10,560 --> 00:08:16,960
구조화됩니다. 이제 코드를 어떻게 구조화하는지에 대해 알아봅시다,

76
00:08:16,960 --> 00:08:21,680
이를 수행하는 방법에는 여러 가지가 있습니다. 여기서는 몇 가지 더 많은

77
00:08:21,680 --> 00:08:25,960
이 경우에는 자바 코드를 정리하는 일반적인 방법이지만, 제가 이야기할 내용은 대부분

78
00:08:25,960 --> 00:08:31,960
다른 많은 언어에도 적용됩니다. 그 중 첫 번째를 패키지 바이 레이어라고 합니다.

79
00:08:31,960 --> 00:08:37,000
여기서 우리가 하려는 것은 코드가 무엇을 하는지에 따라 코드를 정리하는 것입니다.

80
00:08:37,000 --> 00:08:41,600
기술적인 관점에서요. 여러분은 이 코드를 백만 번도 더 보셨을 겁니다. 이것은

81
00:08:41,759 --> 00:08:48,759
일반적으로 패키징을 수평으로 자르고 레이어링하는 스타일로, 다음과 같이 끝납니다.

82
00:08:48,759 --> 00:08:53,120
코드베이스는 이렇게 생깁니다. 다음과 같은 작업을 수행하는 웹 애플리케이션을 구축한다고 상상해 보세요.

83
00:08:53,120 --> 00:08:59,000
를 처리하는 웹 애플리케이션을 만들고 있다고 가정해봅시다. 여기에는 주문 컨트롤러가 다음과 같은 작업을 수행하는 일종의 웹 레이어가 있을 수 있습니다.

84
00:08:59,000 --> 00:09:03,320
웹 작업 같은 거요. 주문 서비스 같은 비즈니스 서비스 같은 것이 있을 수 있습니다,

85
00:09:03,320 --> 00:09:09,779
그리고 맨 아래에 데이터 관련 내용이 있을 수 있습니다. 모두 익숙하시죠? 좋아요.

86
00:09:09,779 --> 00:09:13,779
다양한 유형의 계층형 아키텍처가 있습니다. 느슨한 접근 방식과 엄격한 접근 방식이 있습니다.

87
00:09:13,779 --> 00:09:18,899
레이어링에 대한 접근 방식이 있습니다. 차이점은 본질적으로 얼마나 많은 레이어를 호출할 수 있느냐에 달려 있습니다. Do you

88
00:09:18,899 --> 00:09:24,659
바로 아래 레이어만 호출할 수 있나요, 아니면 레이어를 건너뛸 수 있나요? 이것은

89
00:09:24,659 --> 00:09:31,659
엄격과 완화의 차이입니다. 왜 이렇게 할까요? 왜 이렇게 했을까요? The

90
00:09:31,659 --> 00:09:40,500
답은 모두가 우리에게 말하기 때문입니다. 이 경우 봄에 관한 책을 읽으면 다음과 같이 됩니다.

91
00:09:40,500 --> 00:09:44,620
이렇게 코드를 구성하고 여러 개의 레이어로 구성하라고 말합니다. 페이지를 넘기면

92
00:09:44,620 --> 00:09:52,620
를 넘기면 그 이유, 분리 문제, 테스트 가능성 등을 알려줍니다. 또한

93
00:09:52,620 --> 00:09:57,019
새로운 프레임워크의 샘플 코드 베이스를 다운로드할 때마다 샘플 코드 베이스가 표시됩니다,

94
00:09:57,019 --> 00:10:03,860
일반적으로 일반적으로 계층화된 아키텍처를 이해하기 쉬운 방식으로 구조화되어 있습니다.

95
00:10:03,860 --> 00:10:07,860
컨퍼런스에서 볼 수 있는 모든 데모도 일반적으로 계층화된 아키텍처입니다.

96
00:10:07,860 --> 00:10:14,059
등등. 카고 컬트 프로그래밍이라는 것이 있습니다.

97
00:10:14,059 --> 00:10:19,500
전에. 기본적으로, 이것은 당신이 해야 한다고 생각하지만 실제로는 하지 않는 일을 하는 것입니다.

98
00:10:19,500 --> 00:10:25,019
이유를 알기 때문입니다. 저는 계층화된 아키텍처와 코드를 일련의 계층으로 구조화하는 것이

99
00:10:25,019 --> 00:10:31,740
이 범주에 여러 번 속한다고 생각합니다. 우리는 종종 그 이유에 대해 신중하게 생각하지 않습니다.

100
00:10:31,740 --> 00:10:35,340
하는지에 대해 잘 생각하지 않습니다. 그냥 그래야 한다고 생각해서, 모든 사람이 그렇게 하니까 그렇게 하죠.

101
00:10:35,340 --> 00:10:44,340
그렇게 하거든요. 밥 마틴 삼촌이 '비명을 지르는 건축'이라는 멋진 블로그 게시물을 썼습니다.

102
00:10:44,340 --> 00:10:54,139
그는 기본적으로 대부분의 엔터프라이즈 코드 베이스를 보면 모두 똑같아 보인다고 말했습니다. 웹이죠,

103
00:10:54,139 --> 00:10:59,259
비즈니스 코드, 데이터 코드. 이는 일반적으로 다음과 같은 최상위 구조에 반영됩니다.

104
00:10:59,259 --> 00:11:04,819
폴더와 패키지, 네임스페이스와 코드 요소의 최상위 구조에 반영됩니다. 그는 이런 방식이

105
00:11:04,819 --> 00:11:09,779
건물 세계가 작동하는 방식이 아니므로, 도서관이나 집의 청사진 세트를 보면

106
00:11:09,779 --> 00:11:13,899
또는 박물관의 설계도만 봐도 도서관인지, 집인지, 박물관인지 알 수 있습니다.

107
00:11:13,899 --> 00:11:24,000
청사진. 이것은 우리를 다른 곳으로 인도합니다. 마틴 파울러는 이와 비슷한 말을 했습니다.

108
00:11:24,000 --> 00:11:29,440
음. 그는 이 계층화된 아키텍처, 계층화된 코드 구조가 다음과 같은 좋은 방법이라고 말했습니다.

109
00:11:29,440 --> 00:11:36,960
시작하기 좋은 방법이라고요. 사람들에게 설명하기에도 좋고 쉽습니다. 하지만 일단 규모를 확장하면

110
00:11:36,960 --> 00:11:43,879
프로젝트를 확장하려면 이제 제품 내부의 모듈화에 대해 생각해야 합니다.

111
00:11:43,879 --> 00:11:50,080
레이어에 대해 생각해야 합니다. 따라서 코드를 이렇게 쪼개는 대신 다음과 같이 쪼개야 할 수도 있습니다.

112
00:11:50,080 --> 00:11:57,480
로 잘라야 할 수도 있습니다. 여기서 염두에 두어야 할 또 다른 사항은 레이어가 있는 경우에는

113
00:11:57,480 --> 00:12:04,440
아키텍처를 사용하는 경우 웹 애플리케이션을 빌드하고 웹 페이지에 필드를 추가하려는 경우입니다,

114
00:12:04,440 --> 00:12:09,360
웹 페이지의 내용을 변경하고 웹 컨트롤러의 내용을 변경한 다음

115
00:12:09,360 --> 00:12:14,000
비즈니스 또는 서비스 계층과 데이터 계층에서도 변경됩니다. 변경 사항이 너무 많아서

116
00:12:14,000 --> 00:12:19,240
실제로는 모든 계층에 걸쳐 이루어집니다. 따라서 계층화된 아키텍처는

117
00:12:19,279 --> 00:12:26,919
은 이러한 관점에서 볼 때 코드를 구조화하는 데 특별히 훌륭하거나 효율적인 방법은 아닙니다.

118
00:12:26,919 --> 00:12:33,560
다른 접근 방식. 두 번째는 기능별로 패키징하는 것입니다. 이것은 기본적으로

119
00:12:33,560 --> 00:12:38,759
전체를 90도로 뒤집는 것입니다. 그리고 코드를 정리하고 코드를 그룹화하기보다는

120
00:12:38,759 --> 00:12:47,419
기술적인 것에 따라 그룹화하는 대신 기능적인 것에 따라 그룹화합니다. 기능 집합, 집계 경로,

121
00:12:47,420 --> 00:12:51,740
코드 기반을 수직으로 쪼개서 다음과 같이 말할 수 있는 방법은 여러 가지가 있습니다.

122
00:12:51,740 --> 00:12:58,180
처럼요. 물론 이 작업을 수행하는 방법은 전적으로 사용자에게 달려 있습니다. 하지만 중요한 것은 수직 슬라이싱입니다.

123
00:12:58,180 --> 00:13:03,340
특정 기능 세트 또는 집계 경로와 관련된 것들을 함께 그룹화하는 것입니다,

124
00:13:03,340 --> 00:13:10,680
예를 들어. 이렇게 보일 수 있습니다. 따라서 주문 기능 대신

125
00:13:10,680 --> 00:13:15,620
웹 패키지, 비즈니스 패키지, 데이터 패키지에 분산되어 있는 주문 기능을 모두

126
00:13:15,620 --> 00:13:30,940
단일 주문 패키지로 통합합니다. 이것이 레이어별 패키지보다 더 나은 방법일까요? 논쟁의 여지가 있습니다. 그냥 다를 뿐입니다.

127
00:13:30,940 --> 00:13:38,940
주문과 관련된 코드를 더 쉽게 찾을 수 있다는 점이 장점 중 하나로 꼽힙니다. I guess

128
00:13:38,940 --> 00:13:44,539
모든 것이 한곳에 있기 때문입니다. 하지만 최신 IDE를 사용하면 검색 기능을 사용할 수 있습니다. 그래서

129
00:13:44,539 --> 00:13:50,799
솔직히 말해서 이러한 인수의 대부분은 그다지 훌륭하지 않습니다. 하지만 다음과 같은 이유로 응집력이 높아집니다.

130
00:13:50,799 --> 00:13:56,079
모든 주문 내용이 한 곳에 모이기 때문입니다. 이 구조의 가장 큰 문제 중 하나는

131
00:13:56,079 --> 00:14:03,259
코드의 가장 큰 문제점은 주문과 고객이 있는 경우 둘 사이에 링크가 필요하다는 것입니다,

132
00:14:03,259 --> 00:14:09,039
그 연결 고리를 어디에서 만들까요? 따라서 몇 가지 흥미로운 부작용과 주의 사항이 있습니다.

133
00:14:09,039 --> 00:14:15,899
기능별로 패키징할 수 있습니다. 가끔 청중을 대상으로 설문 조사를 할 때

134
00:14:15,899 --> 00:14:19,860
레이어별로 패키지를 만들면 아무도 아무 말도 하지 않아서 누가 기능별로 패키지를 만들지 말라고 하면

135
00:14:19,860 --> 00:14:24,219
손이 몇 개 더 올라가고, 포트와 어댑터는 누가 하냐고 물으면 더 많은 손이 올라갑니다.

136
00:14:24,219 --> 00:14:30,299
올라갑니다. 이것은 모놀리식 애플리케이션을 구조화하는 데 있어 훨씬 더 일반적인 접근 방식인 것 같습니다.

137
00:14:30,299 --> 00:14:35,299
일입니다. 포트와 어댑터를 통해 기본적으로 여기서 하려는 것은

138
00:14:35,300 --> 00:14:42,080
도메인 관련 비즈니스 코드를 기술 또는 인프라 관련 코드와 분리하기 위해

139
00:14:42,080 --> 00:14:48,200
코드. 이것이 작동하는 방식은 내부와 외부가 있으며, 내부에는

140
00:14:48,200 --> 00:14:52,840
이 핵심 중심 아이디어에 대한 다양한 접근 방식과 주제가 있습니다. 일부

141
00:14:52,840 --> 00:14:56,120
들어보셨을 법한 육각형 아키텍처, 클린 아키텍처, 양파

142
00:14:56,120 --> 00:15:02,080
건축 등이 있습니다. 그래서 당신은 외부에 당신의 기술에 관한 외부가 있습니다.

143
00:15:02,080 --> 00:15:05,340
그리고 외부 세계와의 인터페이스가 있고, 내부가 있습니다.

144
00:15:05,340 --> 00:15:11,980
비즈니스 도메인입니다. 따라서 내부는 기술에 구애받지 않습니다. 도메인 기반에 익숙한 분들은

145
00:15:11,980 --> 00:15:17,820
디자인에 익숙하다면 일반적으로 내부의 개념을 DDD 언어로 표현하고 있을 것입니다,

146
00:15:17,820 --> 00:15:24,220
고객, 주문, 제품 등을 표현합니다. 바깥쪽은 텍스트와 관련된 내용입니다. 그래서

147
00:15:24,220 --> 00:15:29,100
데이터베이스와 외부 업체 및 API에 대한 인터페이스와 어댑터를 작성할 때 유용합니다,

148
00:15:29,100 --> 00:15:37,159
그 코드가 있는 곳입니다. 그리고 여기에는 기본적으로 한 가지 규칙이 있습니다. 외부에서는

149
00:15:37,159 --> 00:15:42,759
내부에 따라 달라지지 않습니다. 따라서 다음과 같이 보입니다. 도메인이 있습니다.

150
00:15:42,759 --> 00:15:48,720
가 중간에 있고, 인프라가 바깥쪽에 있으며, 모든 의존 화살표가

151
00:15:48,720 --> 00:15:55,279
화살표가 안쪽을 가리키도록 한다. 일종의 클래스 다이어그램 관점에서 보면 이렇게 보일 수 있습니다.

152
00:15:55,279 --> 00:16:01,259
입니다. 이 패키지는 안쪽의 도메인 내용을 나타내며 화살표는 다시 다음을 가리킵니다.

153
00:16:01,259 --> 00:16:21,019
을 가리킵니다. 코드 구조화에 대한 이러한 접근 방식은 화물 문화에도 많이 적용된다고 생각합니다. 그리고 하나

154
00:16:21,019 --> 00:16:26,600
제가 이렇게 말하는 이유 중 하나는 모든 프레임워크가 똑같이 만들어지는 것은 아니기 때문입니다. 그리고

155
00:16:26,600 --> 00:16:32,059
제 말은 어떤 프레임워크와 어떤 상호작용은

156
00:16:32,059 --> 00:16:37,840
외부 세계와 상호작용하는 것이 더 쉽다는 뜻입니다. 예를 들어 웹 애플리케이션을 개발 중인데 웹 애플리케이션이

157
00:16:37,840 --> 00:16:44,759
에 사용자에게 표시할 100개의 서로 다른 페이지가 있다고 가정해 보겠습니다. 기본적으로 100개의

158
00:16:44,759 --> 00:16:52,379
어댑터와 래퍼를 페이지당 하나씩 만들어야 합니다. 만약 100개의 페이지가 모두

159
00:16:52,379 --> 00:16:57,519
데이터베이스에 서너 개의 테이블이 있는 경우, 데이터베이스에 서너 개의 테이블을 래핑하는 것이 더 쉽습니다.

160
00:16:57,519 --> 00:17:04,779
래퍼와 어댑터를 100개의 웹 페이지에 제공하는 것보다 쉽습니다. 따라서 다음 사항에 주의해야 합니다.

161
00:17:04,779 --> 00:17:09,579
포트와 어댑터를 액면 그대로 받아들이면 결국 많은 어댑터 코드를 작성하게 될 수 있습니다.

162
00:17:09,579 --> 00:17:15,059
그리고 실제로 필요하지 않은 추상화 코드를 작성할 수 있기 때문입니다. 예를 들어, 저는 사람들이 프레임워크를 감싸는 것을 보았습니다.

163
00:17:15,059 --> 00:17:21,579
프레임워크를 감싸는 것을 보았습니다. Spring MVC는 이 외부에 위치하며 그 위에 추가 추상화를 추가합니다.

164
00:17:21,579 --> 00:17:28,119
에 추가 추상화를 추가하여 도메인 코드가 Spring MVC에 종속되지 않도록 합니다. 만약

165
00:17:28,119 --> 00:17:33,240
가 미친 짓이라고 생각하신다면, 맞습니다. Spring MVC는 이미 멋진 간단한 추상화를 제공합니다.

166
00:17:33,240 --> 00:17:38,419
를 제공합니다. 그래서 여러분은 마무리 작업을 마무리하고 있는 것입니다. 따라서 기본적으로

167
00:17:38,420 --> 00:17:45,700
조심하라는 뜻입니다. 이 모든 것을 말했으니 이제 다시

168
00:17:45,700 --> 00:17:52,940
간단한 레이어 예제입니다. 이 코드가 있습니다. 웹 콘텐츠, 비즈니스 콘텐츠, 데이터

169
00:17:52,940 --> 00:17:59,940
물건이 있습니다. 그리고 수천 줄의 코드로 구성된 멋진 대형 시스템이 있고 모두 잘 작동하고 있습니다.

170
00:17:59,940 --> 00:18:06,039
새로운 사람이 팀에 합류했습니다. 그리고 여러분은 "안녕하세요, 저한테 멋진 기능이 있어요"라고 말합니다.

171
00:18:06,039 --> 00:18:11,480
입문용 기능인데, 너무 까다롭지 않으니 코드 베이스에 추가해 주셨으면 합니다.

172
00:18:11,480 --> 00:18:16,480
새로운 사람이 들어와서 소스 코드 사본을 다운로드하고 살펴봅니다.

173
00:18:16,480 --> 00:18:19,680
소스 코드를 보고 무슨 일인지 알아내려고 하다가 "그래, 알 것 같아"라고 말하죠.

174
00:18:19,680 --> 00:18:33,079
이 기능을 추가하는 방법을요. 그리고는 이걸 가져가서 저걸 하죠. 그래요 이것은 아마도

175
00:18:33,079 --> 00:18:39,599
기능을 구현하는 가장 좋은 방법일 수 있습니다. 아닐 수도 있죠. 그리고 아마도 여러분은

176
00:18:39,599 --> 00:18:45,199
엄격한 계층적 접근 방식을 취하고 우회하지 말라는 원칙이 있을 수도 있습니다.

177
00:18:45,199 --> 00:18:48,639
레이어, 그러나 새로운 조인어에게 말하지 않았다면, 그들은 다음과 같은 이유로 그렇게 할 수 있습니다.

178
00:18:48,639 --> 00:18:58,119
더 효율적이라고 생각하기 때문이죠. 그리고 이를 방치하면 그렇게 될 수 있습니다.

179
00:18:58,119 --> 00:19:02,039
자바 같은 언어의 문제 중 하나는 사람들이 일반적으로 하는 행동이

180
00:19:02,079 --> 00:19:08,240
이것은 자바 패키지일 수 있습니다. 그리고 이것은 별도의 Java 패키지일 수 있습니다. 이렇게 하려면

181
00:19:08,240 --> 00:19:13,799
이 별도의 패키지에서 이것과 통신하려면, 이 패키지가 공개되어야 합니다. 일단

182
00:19:13,799 --> 00:19:18,480
이것은 공개되어 있고, 여기서 호출할 수 있지만, 어디에서나 호출할 수 있습니다.

183
00:19:18,480 --> 00:19:25,639
다른 코드 베이스에서 호출할 수도 있습니다. 예를 들어 C 샤프와 내부 키워드도 마찬가지입니다.

184
00:19:25,640 --> 00:19:35,880
다시 말하지만, 여기서도 조금 주의해야 합니다. 일반적으로 다음과 같은 결과를 얻을 수 있습니다.

185
00:19:35,880 --> 00:19:47,340
큰 진흙덩어리입니다. 우연적으로 구조화된 시스템인데, 저는 이 부분이 마음에 듭니다. 더 받아쓰기

186
00:19:47,340 --> 00:19:51,720
편의에 따라. 따라서 코드 베이스에 급하게 무언가를 추가해야 할 때, 네, 그렇습니다.

187
00:19:51,720 --> 00:19:58,120
가능한 한 가장 빠른 방법으로 작업을 수행합니다. 장기적으로는 좋지 않을 수도 있습니다.

188
00:19:58,120 --> 00:20:04,480
코드베이스의 구조, 코드베이스의 수명에 영향을 미칠 수 있습니다. 그래서 지금 이 시점입니다,

189
00:20:04,480 --> 00:20:08,039
누군가 이렇게 말하겠죠, 잠깐만요, 현실에서는 이렇게 하지 않아요.

190
00:20:08,039 --> 00:20:13,240
우리 팀에 있는 것은 일련의 아키텍처 원칙입니다. 그리고 이러한 아키텍처 원칙은

191
00:20:13,240 --> 00:20:21,120
제약과 가이드라인, 경계를 설정할 수 있습니다. 그리고 이러한 아키텍처를 통해

192
00:20:21,160 --> 00:20:26,720
원칙을 통해 사람들은 지름길을 택하지 않을 것입니다. 그리고 이러한 아키텍처 원칙은 일반적으로

193
00:20:26,720 --> 00:20:33,720
같은 것을 말합니다. 따라서 웹 컨트롤러는 데이터 액세스 리포지토리와 직접 대화해서는 안 됩니다.

194
00:20:33,720 --> 00:20:39,520
그들은 거의 나중에 이러한 서비스를 거칩니다. 이런 종류의 원칙을

195
00:20:39,519 --> 00:20:46,519
과거에? 네. 그런데 사람들에게 이걸 어떻게 시행하냐고 물어보면? 그러면 다들 무표정해지죠.

196
00:20:51,440 --> 00:20:58,440
그리고는 이렇게 대답하죠, 저는 이 질문에 답할 방법을 알고 있습니다. 우리는 개발자를 신뢰합니다. 왜냐하면

197
00:20:58,440 --> 00:21:07,440
민첩하기 때문입니다. 맞아요. 여러분에게는 어떻게 작용하나요? 어떤 경우에는 아주 훌륭하게 작동하기도 합니다.

198
00:21:07,440 --> 00:21:11,440
오해하지 마세요. 제가 함께 일했던 팀들 중에는 이런 일을 할 수 있는 팀들이 분명히 있었습니다.

199
00:21:11,440 --> 00:21:22,440
그들은 환상적이죠. 나머지 우리에겐 그렇죠. 우리 모두 인간이니까요. 그리고 우리가 빨리 움직여야 한다면,

200
00:21:23,740 --> 00:21:28,740
지름길을 택할 수도 있죠. 그리고 우리가 스크럼 열차에 탑승해 있다면

201
00:21:28,740 --> 00:21:32,880
스프린트, 스프린트, 스프린트, 딜리버리, 딜리버리, 딜리버리를 하려고 한다면, 우리는 더 많은 지름길을 택할 수 있습니다.

202
00:21:32,880 --> 00:21:37,480
더 많은 지름길을 택할 수도 있습니다. 그리고 몇 주가 지나면 리팩토링이 필요합니다.

203
00:21:37,480 --> 00:21:41,840
스프린트가 필요합니다. 코드베이스가 약간 엉망이 되었기 때문입니다. 죄송합니다. 그래서 이것은 당신이

204
00:21:41,840 --> 00:21:51,580
조심해야 할 부분입니다. 하지만 지금은 2018년입니다. 그리고 2018년이고 우리는 이 모든 것을 가지고 있습니다.

205
00:21:51,580 --> 00:21:56,280
머신 러닝과 인공지능이 발전하고 있다는 점을 고려하면

206
00:21:56,280 --> 00:22:01,840
잘 구조화된 코드베이스를 구축할 수 있어야 합니다. 다시 말해, 우리는 다음을 수행하는 데 도움이 되는 도구를 사용할 수 있어야 합니다.

207
00:22:01,879 --> 00:22:15,439
잘 구조화된 코드베이스를 만들 수 있어야 합니다. 이런 일을 하는 사람이 있나요? 이것은 흔한 일이 아닙니다. There's

208
00:22:15,439 --> 00:22:20,039
최근에 출간된 '진화적 아키텍처 구축'이라는 책이 있습니다. 그 책에서

209
00:22:20,039 --> 00:22:25,799
피트니스 기능에 대해 이야기합니다. 피트니스 기능은 본질적으로 매우 광범위하며, 여러분은

210
00:22:25,799 --> 00:22:30,839
품질 속성, 확장성, 성능, 보안 등을 증명하는 데 사용할 수 있습니다.

211
00:22:30,839 --> 00:22:36,159
를 빌드 프로세스의 일부로 사용할 수 있습니다. 또한 다음과 같은 방법으로 적합성 함수를 사용할 수 있습니다.

212
00:22:36,159 --> 00:22:43,079
코드베이스의 적합성에 대해 무언가를 어설프게 주장할 수도 있습니다. 즉, 순환적 복잡성, 커플링입니다,

213
00:22:43,079 --> 00:22:49,819
등등이 있습니다. 물론 이를 수행하는 방법 중 하나는 툴링을 사용하는 것입니다.

214
00:22:49,819 --> 00:22:54,000
피트니스 기능을 만드는 데 도움이 되는 다양한 도구가 시중에 나와 있습니다.

215
00:22:54,000 --> 00:23:04,000
객관적으로 코드가 얼마나 좋은지 나쁜지에 대한 어설션을 실행할 수 있습니다. 정적 분석 도구. 그리고 당신

216
00:23:04,000 --> 00:23:09,680
수많은 아키텍처 위반 검사 도구가 있습니다. JQ 어시스턴트 같은 것도 생각 중이에요.

217
00:23:09,680 --> 00:23:16,019
규칙을 작성할 수 있는 ArcJava, ArcUnit 등이 있습니다. 그리고 할 수 있는 일

218
00:23:16,019 --> 00:23:20,400
이런 도구로 다음과 같은 규칙을 정의할 수 있습니다. 즉, 다음과 같습니다.

219
00:23:20,400 --> 00:23:24,880
아키텍처 원칙과 동일합니다. 별표, 별표, 슬래시, 웹으로 입력하면 됩니다,

220
00:23:24,880 --> 00:23:30,080
웹 패키지는 별표, 별표, 슬래시, 데이터에 액세스할 수 없어야 합니다. 데이터에 있는 내용

221
00:23:30,080 --> 00:23:34,280
액세스 패키지. 그리고 이러한 것들을 빌드 프로세스와 통합하면 누군가가

222
00:23:34,280 --> 00:23:39,480
어리석은 짓을 하면 빌드가 중단됩니다. 그러면 귀찮아서 이 규칙을 끄게 되죠.

223
00:23:39,480 --> 00:23:48,240
하지만 그건 다른 이야기죠. 네, 우리 모두 그렇게 하죠? 무시 테스트에서요. 나는 친절하게

224
00:23:48,240 --> 00:23:55,120
지금보다 조금 더 나아질 수 있기 때문에 이 아이디어를 좋아합니다. 하지만,

225
00:23:55,120 --> 00:24:00,920
끔찍한 해킹처럼 느껴집니다. 그래서 우리는 검증을 위해 많은 외부 툴을 작성해야 합니다.

226
00:24:00,920 --> 00:24:06,140
우리가 만들고 있는 실제 도구의 품질이 괜찮은지 확인해야 합니다. 그리고 그것은 정말

227
00:24:06,140 --> 00:24:16,880
저와 잘 어울리지 않아요. 왜냐하면 우리는 그것을 끌 수 있기 때문입니다. 그래서 답은 무엇일까요? 정답은

228
00:24:17,080 --> 00:24:27,920
어쩌면 우리가 현재 사용할 수 있는 도구를 더 잘 사용해야 할지도 모릅니다. 컴파일러처럼요.

229
00:24:27,920 --> 00:24:31,000
그리고 이 시점에서 사람들은 궁극적으로 이렇게 말할 것입니다.

230
00:24:31,000 --> 00:24:41,680
컴파일러와 액세스 수정자를 사용하면 Java에 결함이 있다고 말합니다. 그리고 당신은 왜

231
00:24:41,680 --> 00:24:45,640
자바에 결함이 있냐고 묻는다면? 액세스에서 Java에 결함이 있는 모든 이유를 알려드립니다.

232
00:24:45,640 --> 00:24:53,759
수정자 관점에서. 패키지가 있다면 Java에는 서브패키지 같은 것이 없습니다.

233
00:24:53,759 --> 00:25:00,360
그리고 자바 패키징 시스템의 다양한 결함을 매우 빠르게 탐색할 수 있습니다. 그리고 액세스

234
00:25:00,360 --> 00:25:07,600
수정자 등을 살펴볼 수 있습니다. 어느 정도는 그럴 만합니다. 하지만 이것이 바로 우리가

235
00:25:07,600 --> 00:25:13,120
가지고 있습니다. 그리고 일류 키워드를 가진 새로운 언어를 작성하고 싶지 않다면

236
00:25:13,120 --> 00:25:16,880
레이어와 서비스, 컴포넌트 같은 것을 어떻게 사용할지 고민해야 할지도 모르겠습니다.

237
00:25:16,880 --> 00:25:23,880
을 사용하는 방법을 알아내야 합니다. 이를 염두에 두고 또 다른 옵션이 있습니다. 이 옵션은

238
00:25:23,880 --> 00:25:32,920
구성 요소별 패키지라고 부르는 것입니다. 이것은 패키지에 대한 일종의 하이브리드 접근 방식입니다.

239
00:25:32,920 --> 00:25:37,800
레이어별로 패키징하고 기능별로 패키징하는 일종의 하이브리드 접근 방식입니다. 제가 여기서 정말로 하려는 것은

240
00:25:37,799 --> 00:25:49,200
을 사용하여 한 컴포넌트에 속한 모든 코드를 같은 위치에 묶는 것입니다. What do

241
00:25:49,200 --> 00:25:54,240
컴포넌트라는 뜻인가요? 이것은 끔찍하게도 과부하가 걸린 용어이기 때문입니다. 컴포넌트의 의미

242
00:25:54,240 --> 00:25:59,000
는 본질적으로 이것입니다. 관련 기능의 그룹으로, 깔끔하게 정리되어 있기를 바랍니다,

243
00:25:59,000 --> 00:26:06,379
간단한 인터페이스. 그리고 이 컴포넌트는 애플리케이션과 같은 내부에서 실행됩니다. 만약 당신이

244
00:26:06,380 --> 00:26:12,820
이것이 어디에서 왔는지 궁금하다면, 제 C4 다이어그램 뒤에 있는 추상화에서 비롯된 것입니다. 소프트웨어

245
00:26:12,820 --> 00:26:18,620
시스템은 Docker가 아니라 애플리케이션과 데이터 소스로 구성된 컨테이너로 구성됩니다. 컨테이너

246
00:26:18,620 --> 00:26:23,980
는 구성 요소를 포함하고, 구성 요소는 코드 요소로 구축됩니다. 내가 하려는 것은

247
00:26:23,980 --> 00:26:27,980
코드 구조와 코드 보기를 결합하기 위해 세계의 아키텍처 뷰를

248
00:26:27,980 --> 00:26:35,900
의 구조와 결합합니다. 그리고 컴포넌트별 패키지는 기본적으로 이렇게 생겼습니다. 그래서 제 개인적인 선호도는

249
00:26:36,420 --> 00:26:39,500
여러 가지 방법이 있겠지만, 개인적으로 선호하는 방법은 항상

250
00:26:39,500 --> 00:26:45,780
을 유지하는 것을 선호합니다. 웹 UI나 API와 같은 UI 관련 항목은 비시각적 요소인

251
00:26:45,780 --> 00:26:51,460
분리해야 합니다. 예를 들어 주문 기능을 구축하는 경우, 주문 컨트롤러가 주문을 처리합니다.

252
00:26:51,460 --> 00:26:56,980
주문 컨트롤러가 있고 시각적이지 않은 주문 관련 기능이 많이 있습니다. 그래서, 비즈니스

253
00:26:56,980 --> 00:27:02,980
서비스, 비즈니스 로직, 데이터 액세스 등입니다. 따라서 이 모든 것을

254
00:27:02,980 --> 00:27:16,980
주문 컴포넌트입니다. 여기서 제가 하고자 하는 것은 본질적으로 컴포넌트 기반 사고를 적용하는 것입니다.

255
00:27:16,980 --> 00:27:21,819
를 모놀리식 코드베이스에 적용하는 것입니다. 이것은 구식 컴포넌트 기반 사고, 즉 컴포넌트 기반의

256
00:27:21,819 --> 00:27:29,559
디자인을 모놀리식 코드베이스에 적용하는 것입니다. 제가 여기서 하려는 것은 본질적으로 모놀리식 코드베이스에

257
00:27:29,559 --> 00:27:35,679
모듈성을 많은 아키텍처와 코드 구조의 기본 원칙으로 적용하는 것입니다.

258
00:27:35,679 --> 00:27:44,960
결정에 영향을 미칩니다. 그래서 저는 항상 크게 보면 어떤 것이 있는지 생각해요.

259
00:27:44,960 --> 00:27:49,720
무엇으로 시스템을 만들었으면 좋겠는가? 높은 수준의 구조적 건물은 무엇인가요?

260
00:27:49,720 --> 00:27:55,679
블록은 본질적으로 내 모놀리식 애플리케이션의 구성 요소인가요? 이것을 보는 다른 방법은 기본적으로 다음과 같습니다.

261
00:27:55,680 --> 00:27:59,360
저는 인터페이스와 구현을 분리하고 있습니다. 이것은 또 다른 좋은 구식 디자인입니다.

262
00:27:59,360 --> 00:28:13,200
기법입니다. 흥미롭게도 이것이 바로 마이크로서비스에서 볼 수 있는 것이죠?

263
00:28:13,200 --> 00:28:18,680
컴포넌트별 패키지를 사용하면 일종의 인터페이스, 일종의 공용

264
00:28:18,680 --> 00:28:27,519
Java 인터페이스, 그리고 패키지로 보호된 구현 코드가 있습니다. 마이크로서비스와 함께요,

265
00:28:27,519 --> 00:28:36,720
다시 말하지만, 일종의 공용 인터페이스, HTTPS를 통한 JSON, 일종의 네트워크, 그리고

266
00:28:36,720 --> 00:28:43,299
공개 API, 그리고 내부를 볼 수 없는 수많은 비공개 구현 코드가 있습니다. 만약 내가

267
00:28:43,299 --> 00:28:48,099
주문 마이크로서비스가 있다면 주문 마이크로서비스 내부의 내 데이터 레이어를 호출할 수 없습니다.

268
00:28:48,099 --> 00:28:51,339
왜냐하면 공개 API 뒤에 숨겨져 있기 때문입니다. 제가 시도하는 것도 마찬가지입니다.

269
00:28:51,339 --> 00:28:56,639
컴포넌트별 패키지와 관련이 있습니다. 내 컴포넌트 안에 수많은 클래스와 인터페이스가 있을 수 있습니다.

270
00:28:56,639 --> 00:29:00,180
자바 컴포넌트 안에 클래스와 인터페이스가 많을 수 있지만 자바의 패키지를 사용할 것이기 때문에 여기에 접근할 수 없습니다.

271
00:29:00,180 --> 00:29:05,299
보호 메커니즘을 사용하여 외부에서 볼 수 없도록 숨깁니다. 이것은 Java 당 하나의 컴포넌트입니다.

272
00:29:05,299 --> 00:29:14,379
패키지입니다. 내 코드에 경계를 설정하는 것입니다. 이것이 전부입니다.

273
00:29:14,379 --> 00:29:26,180
아주 쉽게 할 수 있습니다. 만세! 하지만 악마는 구현 세부 사항에 있습니다. 그래서 당신은 할 수 있습니다

274
00:29:26,180 --> 00:29:30,779
스토리를 끝까지 읽으시고 어떻게 하면

275
00:29:30,779 --> 00:29:36,180
코드베이스를 구조화하고 싶지만 마지막 장애물에서 모든 것이 무너지면

276
00:29:36,180 --> 00:29:40,420
큰 진흙 덩어리만 남게 되고 어떻게 그런 일이 일어났는지 모르게 됩니다. 이런 일이 일어나는 이유

277
00:29:40,420 --> 00:29:49,940
우리의 친구인 공개키워드 때문입니다. 말 그대로 지난번과 같은 횟수인

278
00:29:49,940 --> 00:29:53,779
지난 주에 제가 만든 코드를 읽다가 이런 생각이 들었어요.

279
00:29:53,779 --> 00:30:00,220
는 공개할 필요가 없습니다. 삭제하세요. 기본적으로 공개로 설정되어 있는데 왜 그런지 모르겠어요.

280
00:30:00,220 --> 00:30:04,940
근육 기억이죠. 우리가 사용하는 많은 도구, 즉 IDE는 마법사를 거쳐서

281
00:30:04,940 --> 00:30:09,299
수많은 공개 클래스를 만들죠. 그만하세요. 공개 키워드를 사용하지 마세요.

282
00:30:09,299 --> 00:30:16,860
절반은 필요 없어요. 공개 키워드에 무슨 문제가 있나요? 공개 키워드는

283
00:30:16,860 --> 00:30:22,980
코드를 정리하는 것과 코드를 캡슐화하는 것 사이에는 큰 차이가 있습니다. 사용의 문제

284
00:30:22,980 --> 00:30:29,400
공개 키워드를 사용하면 캡슐화와 관련된 많은 이점을 놓친다는 것입니다.

285
00:30:29,400 --> 00:30:37,040
이 두 가지 개념은 매우 다릅니다. 몇 가지 주문의 네 가지 예를 들어보겠습니다.

286
00:30:37,040 --> 00:30:45,280
관련 기능입니다. 첫째, 레이어별 패키지. 두 번째, 기능별 패키지.

287
00:30:45,280 --> 00:30:51,680
셋째, 포트와 어댑터. 네 번째, 구성 요소별 패키지 접근법. 만약 우리가

288
00:30:51,680 --> 00:30:59,160
이 네 가지 간단한 예제에서 모든 인터페이스와 클래스가 다음과 같다고 가정합니다.

289
00:30:59,160 --> 00:31:04,759
로 공개되었으므로 여기에도 Java 슬롯이 있지만 다른 언어에도 적용할 수 있습니다,

290
00:31:04,759 --> 00:31:11,240
예제에서 이러한 유형이 모두 공개되어 있다고 가정하면 네 가지 버전이 있습니다.

291
00:31:11,240 --> 00:31:15,440
개념적으로 매우 다른 동일한 것의 버전이므로 개념적으로 다릅니다.

292
00:31:15,440 --> 00:31:24,799
건축 양식과 구조가 다르지만 실제로는 구문상 동일합니다. 그래서 여기

293
00:31:24,799 --> 00:31:32,480
이 네 가지 예제를 나란히 배치한 것입니다. 레이어별 패키지, 기능별 패키지, 포트별 패키지

294
00:31:32,480 --> 00:31:37,160
그리고 어댑터, 구성 요소별 패키지. 이 모든 유형을 다음과 같이 가정하면

295
00:31:37,160 --> 00:31:43,360
에 있는 패키지가 모두 공개되어 있다고 가정하면, 우리가 이 패키지를 사용하는 용도는 조직화뿐입니다. 이들은

296
00:31:43,360 --> 00:31:52,700
폴더처럼요. 여기에는 캡슐화가 전혀 없습니다. 따라서 다음을 제거하면

297
00:31:52,700 --> 00:32:06,160
패키지를 제거하면 이렇게 됩니다. 모두 동일합니다. 깔끔한

298
00:32:06,160 --> 00:32:13,880
트릭이죠? 이걸 보면 가끔씩 제가 어떤 포트를 보면

299
00:32:13,880 --> 00:32:20,040
및 어댑터 코드베이스를 보면 계층화된 아키텍처처럼 보입니다. 종종 모든

300
00:32:20,040 --> 00:32:24,640
오류가 일치하기 때문입니다. 공용 클래스를 다른 패키지에 덤프하고 있지만

301
00:32:24,640 --> 00:32:33,560
캡슐화가 없습니다. 공개 키워드를 사용할 때는 매우 조심해야 합니다.

302
00:32:33,559 --> 00:32:39,119
Java 및 기타 언어의 액세스 수정자가 있습니다. 액세스 수정자를 사용하면

303
00:32:39,119 --> 00:32:44,179
를 적절히 사용하면 매우 다른 그림을 그릴 수 있습니다. 다시

304
00:32:44,179 --> 00:32:51,919
이 다이어그램에 패키지를 추가하고 페이드 아웃하고 구현을 회색으로 표시하겠습니다.

305
00:32:51,919 --> 00:32:58,099
잠재적으로 자바 패키지로 보호될 수 있는, 그래서 외부에 숨겨져 있는

306
00:32:58,100 --> 00:33:06,260
해당 패키지. 머릿속으로 이 문제를 해결해야 합니다. 계층화된 아키텍처에서

307
00:33:06,260 --> 00:33:11,420
예를 들어, 이 주문 컨트롤러는 이 주문 서비스에 대한 액세스 권한이 필요합니다. 서비스 인터페이스

308
00:33:11,420 --> 00:33:16,700
는 공개되어야 합니다. 구현 클래스는 패키지로 보호할 수 있습니다. 궁금한 점이 있다면

309
00:33:16,700 --> 00:33:22,260
패키지 보호 클래스를 어떻게 인스턴스화하는지 궁금하다면 Spring에 물어보세요. 이 서비스를 위해서는

310
00:33:22,259 --> 00:33:28,180
구현 클래스가 이 주문 저장소를 사용하려면 인터페이스가 공용이어야 하고, 구현은

311
00:33:28,180 --> 00:33:34,460
클래스를 다시 패키지 보호할 수 있습니다. 기능별 패키지를 사용하면 일종의

312
00:33:34,460 --> 00:33:40,099
해당 패키지에 대한 공용 진입점이 필요하며 그 외의 모든 것은 외부에서 숨길 수 있습니다.

313
00:33:40,099 --> 00:33:45,900
다른 슬라이스가 이 주문 패키지에 있는 물건에 접근할 필요가 없다고 가정합니다. 포트와

314
00:33:45,900 --> 00:33:51,759
어댑터 아키텍처를 사용하면 액세스 가능하므로 다시 공개해야 합니다.

315
00:33:51,759 --> 00:33:57,879
접근 가능하기 때문입니다. 이 인터페이스는 공개해야 합니다. 구현 클래스

316
00:33:57,879 --> 00:34:02,720
는 패키지로 보호될 수 있으며, 이 인터페이스는 종속적이기 때문에 공개해야 합니다.

317
00:34:02,720 --> 00:34:10,280
잠재적으로 패키지 보호된 구현 클래스에 의해 종속되기 때문에 공개해야 합니다. 내

318
00:34:10,280 --> 00:34:14,960
컴포넌트별 패키지를 보면, 다시 말하지만, 저건 그냥 공용이고, 공용 인터페이스가 있습니다.

319
00:34:14,960 --> 00:34:22,320
와 패키지로 보호된 구현 코드가 있습니다. 이제 실제로 계층화된

320
00:34:22,320 --> 00:34:27,240
아키텍처와 포트 어댑터는 어떻게 보느냐에 따라 크게 다르지 않다는 것을 알 수 있습니다,

321
00:34:27,240 --> 00:34:34,800
반면에 이 두 버전은 상당히 다릅니다. 그리고 그게 문제입니다. 항상

322
00:34:34,800 --> 00:34:40,300
생각의 여유를 갖고 실제로 구현하는 방식이

323
00:34:40,300 --> 00:34:45,480
을 구현하고 코드를 구조화하는 방식이 아키텍처가 의도하는 방식과 일치하는지 확인하는 것이 좋습니다.

324
00:34:45,480 --> 00:34:51,420
하향식 관점입니다. 여기서 해야 할 일 중 하나는 캡슐화를 사용하는 것입니다,

325
00:34:51,420 --> 00:34:57,539
캡슐화를 사용하여 잠재적인 종속성의 수를 최소화하는 것입니다. 다음과 같은 경우

326
00:34:57,539 --> 00:35:01,820
코드베이스가 있고 모든 것이 공개되어 있다면, 다른 모든 것에서 모든 것을 호출할 수 있습니다.

327
00:35:01,820 --> 00:35:06,440
많은 잠재적 종속성을 갖게 됩니다. 코드를 숨기고 정보 숨기기를 사용하기 시작하면

328
00:35:06,440 --> 00:35:13,519
및 캡슐화를 사용하면 공개 항목에만 종속성을 가질 수 있습니다. 더 적은 수의 공용 사물

329
00:35:13,519 --> 00:35:19,720
가 적을수록 잠재적인 종속성이 적습니다. 모든 내부의 표면적은

330
00:35:19,720 --> 00:35:24,360
퍼블릭 API의 표면적이 아키텍처 의도와 일치해야 합니다. 아키텍처 다이어그램이 있는 경우

331
00:35:24,360 --> 00:35:29,400
구성 요소 또는 모듈과 레이어 집합이 있는 아키텍처 다이어그램이 있다면 코드가 이를 반영하는지 확인하세요,

332
00:35:29,400 --> 00:35:34,840
사람들이 모듈이나 컴포넌트로 간주되는 것을 우회해서

333
00:35:34,840 --> 00:35:42,400
내부에 직접 접근하지 못하도록 합니다. 기본적으로 제가 여기서 말하는 것은 하나의 애플리케이션을 빌드하는 경우입니다,

334
00:35:42,400 --> 00:35:48,039
컴파일러를 사용하여 아키텍처 경계를 강제할 수 있는 몇 가지 옵션이 있다는 것입니다.

335
00:35:48,039 --> 00:35:57,079
그리고 여러분의 건축적 아이디어와 의도를 반영할 수 있습니다. 이것은 전체 이야기의 간단한 버전과 같습니다.

336
00:35:57,079 --> 00:36:02,440
이러한 아이디어를 가지고 나면 여러 단계를 더 진행할 수 있습니다. 다른 방법도 있습니다.

337
00:36:02,440 --> 00:36:09,639
코드 요소를 분리하세요. 예를 들어, 새로운 슬래시와 같은 모듈 프레임워크를 사용할 수 있습니다.

338
00:36:09,639 --> 00:36:14,940
아직 사람들이 사용하지 않는 이전 Java 9 모듈 프레임워크를 사용할 수 있습니다. Java 모듈 프레임워크는 다음을 허용합니다.

339
00:36:14,940 --> 00:36:22,119
를 사용하여 공개 유형과 게시 유형을 구분할 수 있습니다. 전체 코드베이스를 작성할 수 있습니다.

340
00:36:22,119 --> 00:36:26,639
를 여러 개의 공용 타입으로 작성하고 모듈 매니페스트를 생성할 때 내보내고

341
00:36:26,639 --> 00:36:31,840
해당 타입의 특정 하위 집합만 게시합니다. 누군가 여러분의 공용 타입을 사용하려고 하면

342
00:36:31,880 --> 00:36:35,960
공개되지 않은 유형을 사용하려고 하면 그렇게 할 수 없습니다. 이를 허용하는 모듈 프레임워크가 있습니다.

343
00:36:35,960 --> 00:36:43,160
이 구분, 즉 구현에서 인터페이스를 분리하는 것을 허용하는 모듈 프레임워크가 있습니다. 또한

344
00:36:43,160 --> 00:36:52,640
더 나아가 소스를 여러 부분으로 분할할 수도 있습니다. 여러 개의 Maven 모듈, Gradle 모듈

345
00:36:52,640 --> 00:36:59,960
등등. 사물, 모듈, 레이어당 하나의 소스 코드 트리가 있습니다,

346
00:37:00,639 --> 00:37:06,480
주의해야 합니다. 포트와 어댑터를 사용하는 경우, 별도의

347
00:37:06,480 --> 00:37:12,360
소스 트리를 분리하는 것이 권장되는 접근 방식이라고 생각합니다. 제가 포트와 어댑터에서 보는 안티 특허 중 하나는

348
00:37:12,360 --> 00:37:17,800
어댑터 스타일 아키텍처는 두 개의 코드 베이스가 있고, 하나는 중간에 있는 것들을 위한 것입니다.

349
00:37:17,800 --> 00:37:23,920
그리고 다른 하나는 외부의 모든 것을 위한 것입니다. 도메인 소스 트리와 인프라가 있습니다.

350
00:37:23,920 --> 00:37:30,639
소스 트리. 이 작업의 문제점은 하나의 소스 트리에 다음이 모두 포함된 경우입니다.

351
00:37:30,639 --> 00:37:36,960
이 모두 포함된 소스 트리가 하나만 있으면 인프라 코드가 서로 대화하기가 매우 쉽다는 것입니다.

352
00:37:36,960 --> 00:37:41,920
포트와 어댑터 코드 구조를 여러 개의 코드 트리로 분할하면 다음과 같이 할 수 있습니다.

353
00:37:41,920 --> 00:37:47,039
예를 들어 컴파일 타임에 이런 일이 발생하는 것을 막을 수 있습니다. 이렇게 할 때의 문제점은

354
00:37:47,039 --> 00:37:52,559
많은 장단점이 있다는 것입니다. 소스 트리가 많을수록 속도가 느려지고

355
00:37:52,599 --> 00:37:57,920
빌드 프로세스가 더 복잡해지기 때문입니다. 아마도 다음과 같은 조건에 따라

356
00:37:57,920 --> 00:38:02,440
빌드하는 대상의 크기와 복잡성에 따라 달라질 수 있습니다.

357
00:38:02,440 --> 00:38:08,360
물론 일반적으로 모든 디커플링 모드에는 서로 다른 장단점이 있습니다. 다음과 같은 경우

358
00:38:08,360 --> 00:38:13,880
다시 마이크로서비스로 돌아가 보겠습니다. 마이크로서비스는 원한다면, 궁극적으로

359
00:38:13,880 --> 00:38:18,799
디커플링 모드가 아닐까요? 동일한 프로세스에 여러 개의 코드를 배치하는 대신에

360
00:38:18,840 --> 00:38:23,840
주위에 경계가 있는 별도의 프로세스가 있고, 본질적으로 네트워크가 있는

361
00:38:23,840 --> 00:38:29,240
방식으로 분리됩니다. 이는 궁극적인 디커플링 모드이지만 다음과 같은 여러 가지 장단점이 있습니다.

362
00:38:29,240 --> 00:38:35,680
트레이드 오프가 있습니다. 이것은 다소 까다로운 질문을 제기합니다. 어떤 스타일의 아키텍처가

363
00:38:35,680 --> 00:38:43,000
적합한지 어떻게 알 수 있을까요? 모놀리스 또는 마이크로서비스 중 어떤 것을 선택해야 할까요? 안타깝게도 많은 사람들이

364
00:38:43,039 --> 00:38:50,039
마이크로서비스에 뛰어드는 사람들을 많이 봅니다. 그리고 그들은 실패하고 있습니다. 이것이 바로

365
00:38:53,280 --> 00:38:58,559
조지 페어뱅크스는 그의 저서에서 다양한 디자인의 아키텍처라고 불렀습니다. 아키텍처 선택,

366
00:38:58,559 --> 00:39:03,239
그냥 멋지다고 해서 스타일을 선택하면 안 될까요? 그리고 장단점을 제대로 생각하지 않고

367
00:39:03,239 --> 00:39:08,960
그리고 특정 아키텍처 선택에 대한 주의 사항을 고려하지 않는 것이죠. 제가 사람들에게 추천하는 것 중 하나는

368
00:39:09,000 --> 00:39:14,840
품질 속성으로 민첩성을 사용하는 것입니다. 품질 속성은 성능과 같은 것입니다,

369
00:39:14,840 --> 00:39:19,679
확장성, 가용성 등을 말합니다. 민첩성은 어떨까요? 민첩성은 얼마나 빨리 움직여야 하나요?

370
00:39:19,679 --> 00:39:24,519
얼마나 빨리 움직여야 할까요? 코드베이스의 어떤 부분, 시스템의 어떤 부분이 빠르게 움직여야 할까요? 어느

371
00:39:24,519 --> 00:39:30,000
코드베이스의 어떤 부분이 다른 부분보다 잠재적으로 더 변동성이 클까요? 이 정보를 사용할 수도 있습니다.

372
00:39:30,000 --> 00:39:35,800
을 사용하여 훨씬 더 정보에 입각한 결정을 내릴 수 있습니다. 어쩌면 코드의 대부분을

373
00:39:35,840 --> 00:39:41,840
모놀리스와 그 변동성을 필요로 하는 엣지 주변의 작은 서비스들, 즉

374
00:39:41,840 --> 00:39:47,880
변동성에 따라 변경할 수 있어야 합니다. 그리고 이 모든 것이 좋은 아키텍처

375
00:39:47,880 --> 00:39:54,120
민첩성을 제공합니다. 다시 한 번 말씀드리지만, 이 말이 이해가 되시나요? 여러분이 본 적이 있다면

376
00:39:54,120 --> 00:39:59,720
크고 끔찍한 코드베이스, 진흙 덩어리, 스파게티 코드 시스템을 본 적이 있다면

377
00:39:59,720 --> 00:40:02,720
여기서 뭔가를 변경하면 여기 있는 모든 것들이 깨지고 이유도 모른 채로

378
00:40:02,760 --> 00:40:08,680
속도가 느려집니다. 좋은 아키텍처는 민첩성을 제공합니다. 좋은 아키텍처란 바로 이런 것입니다,

379
00:40:08,680 --> 00:40:12,280
이것은 다소 주관적이지만, 제가 말하는 좋은 아키텍처란 높은

380
00:40:12,280 --> 00:40:19,280
모듈성을 가진 것입니다. 잘 정의된 좋은 구조를 가진 것입니다. 그리고 문제 중 하나는

381
00:40:19,280 --> 00:40:24,800
공짜로 얻을 수 없다는 것입니다. 따라서 미리 생각해야 합니다.

382
00:40:24,800 --> 00:40:31,800
멋지고 잘 정의된 구조를 만들기 위해 미리 설계해야 합니다. 그리고 이것이 바로

383
00:40:32,880 --> 00:40:39,880
사람들이 마이크로서비스에 뛰어드는 이유는 마이크로서비스가 분해 전략을 제공하기 때문입니다.

384
00:40:39,960 --> 00:40:45,960
모듈화 전략을 제공하기 때문입니다. 네트워크에서 실행되는 여러 개의 개별 프로세스입니다. 그래서 사람들은

385
00:40:45,960 --> 00:40:52,960
마이크로서비스 아키텍처를 사용하여 코드 경계를 강화합니다. 그리고 많은 컨퍼런스에서

386
00:40:53,040 --> 00:40:57,160
강연에서, 확실히 지난 몇 년 동안 사람들이 항상 이걸 비교하는 것을 볼 수 있습니다.

387
00:40:57,160 --> 00:41:00,440
여기 있는 이 끔찍한 덩어리진 진흙 덩어리들과 비교하는 것을 볼 수 있어요.

388
00:41:00,480 --> 00:41:05,599
불공평하죠. 역사적으로 모놀리식 애플리케이션은 이렇게 생겼습니다. 저는 확실히

389
00:41:05,599 --> 00:41:09,599
인정합니다. 하지만 이것은 정말 불공평한 비교입니다. 왜냐하면 제가 보는 많은 사람들이

390
00:41:09,599 --> 00:41:15,320
10년 또는 15년 동안 이런 것을 만들어왔다고 말하기 때문입니다,

391
00:41:15,320 --> 00:41:22,320
엉망진창이죠. 지금은 기능을 추가하기에는 너무 느리기 때문에 변경할 수도 없습니다. 그래서 뭐

392
00:41:22,320 --> 00:41:29,320
그 스타일로 처음부터 다시 작성해야 합니다. 왜 그런지 알겠네요. 나는

393
00:41:30,440 --> 00:41:34,559
사람들이 안 된다고 하는 게 보여요? 올해 많은 조직과 이야기를 나눴는데요.

394
00:41:34,559 --> 00:41:39,480
저에게 똑같은 이야기를 해줬어요. 그리고 안타깝게도 그들이 결국 하는 일은 다음과 같습니다.

395
00:41:39,480 --> 00:41:46,480
을 구축하기 위해 그들의 접근 방식을 취하고, 일반적으로 동기식 HTTPS를 고수한다는 것입니다.

396
00:41:47,480 --> 00:41:54,480
호출을 사용하여 모놀리스 내의 사물 간에 호출을 수행합니다. 그리고 더 나아가

397
00:41:55,159 --> 00:42:02,159
이 모든 것이 잠금 단계로 배포되어야 합니다. 하지만 우리는 Docker에서 마이크로서비스를 하고 있고

398
00:42:03,159 --> 00:42:08,599
Kubernetes. CV 중심 설계입니다. 따라서 기본적으로 다음과 같은 분산 버전이 됩니다.

399
00:42:08,599 --> 00:42:13,280
의 분산 버전을 사용하게 되는데, 이 버전은 성능이 매우 저조합니다. 이제 이

400
00:42:13,280 --> 00:42:19,400
이 훨씬 더 공정한 비교입니다. 저는 사람들이 이걸 먼저 해봤으면 좋겠습니다. 그래서

401
00:42:19,400 --> 00:42:24,159
이 강연에서 설명했듯이 모듈형 모놀리스를 만들 수 있습니다. You

402
00:42:24,839 --> 00:42:30,440
코드 구조가 아키텍처 아이디어와 의도를 반영하는지 확인해야 합니다. 그리고 다시,

403
00:42:30,440 --> 00:42:35,159
민첩성을 품질 속성으로 사용하세요. 아마도 대부분의 기능을 그 안에 넣고

404
00:42:35,159 --> 00:42:42,159
의 가장자리에 수많은 서비스가 떠다니고 있을 수 있습니다. 거기에는

405
00:42:43,159 --> 00:42:49,159
이 모든 것 중에서 약간 더 어려운 부분이 있는데, 바로 디자인을 하는 것입니다.

406
00:42:49,159 --> 00:42:53,480
사람들은 소프트웨어를 어떻게 디자인하냐고 묻습니다. 저는 전에도 해본 적이 있다고 대답합니다. 가서 보세요

407
00:42:53,800 --> 00:43:00,800
위키피디아에서 분해에 관한 페이지를 보여주면 되죠. 오, 그거 재밌네요. 그래

408
00:43:01,920 --> 00:43:06,800
그리고 어떤 사물을 더 작은 것으로 분해하는 방법에는 여러 가지가 있다고 말해줘요.

409
00:43:06,800 --> 00:43:11,360
오, 그것도 몰랐네. 그리고 우린 어떻게 하면

410
00:43:11,360 --> 00:43:15,159
어떻게 디자인을 하는지 설명할 능력을 잃은 것 같아요. 마치 사람들이 디자인만 할 뿐, 그 밑바탕에 깔려 있는

411
00:43:15,159 --> 00:43:19,199
원칙을 말해주지 않죠. 기능적 분해나 휘발성 같은 것들 말이죠.

412
00:43:19,200 --> 00:43:23,320
기반 분해 등등이 있죠. 그리고 마이크로서비스로 갈 때마다

413
00:43:23,320 --> 00:43:27,440
에 대해 이야기할 때마다 사람들은 파르나스 얘기를 하다가 결국에는

414
00:43:27,440 --> 00:43:32,480
모듈러라는 단어를 지우고 서비스나 마이크로서비스라는 단어를 넣습니다.

415
00:43:32,480 --> 00:43:36,960
그리고 우리가 과거에 배웠던 많은 것들이 있습니다. 이것은 70년대에 나온 것입니다.

416
00:43:36,960 --> 00:43:39,760
정말 흥미로운 논문이네요. 꼭 읽어보세요. 그리고 흥미로운 것들이 많이 있어요.

417
00:43:39,760 --> 00:43:46,760
좋은 디자인과 높은 응집력, 낮은 결합과 책임에 관한 과거에 관한 것들입니다.

418
00:43:47,280 --> 00:43:53,120
그리고 변동성. 그리고 우리는 이 모든 것을 잊어버렸습니다. 그리고 이 모든 것들은

419
00:43:53,120 --> 00:44:00,120
모든 유형의 소프트웨어 시스템에 적용됩니다. 좋은 아키텍처는 민첩성을 제공합니다.

420
00:44:00,360 --> 00:44:05,680
좋은 구조는 민첩성을 제공합니다. 그러면 사람들은 어떻게 하면 민첩성을 확보할 수 있냐고 묻습니다.

421
00:44:05,680 --> 00:44:10,480
어떻게 하냐고 묻습니다. 그러면 여러분은 더 많은 기술이 있다고 대답합니다. 가서 배워요.

422
00:44:10,920 --> 00:44:16,199
CRC라는 게 있어요. 오래된 작업장 기술이에요. 예전엔 꽤 잘 쓰였지

423
00:44:16,199 --> 00:44:23,199
합리적 통합 프로세스인 RUP 시대에 사용됐죠. 유행에서 벗어났죠. It has

424
00:44:23,400 --> 00:44:28,199
이름에 클래스, 클래스 책임 공동 작업자가 있습니다. 작업 쇼핑 기법입니다.

425
00:44:28,199 --> 00:44:33,719
클래스 수준 설계를 위한 것입니다. 우리는 더 이상 회의에서 수업 수준 설계를 하지 않습니다. 하지만

426
00:44:33,719 --> 00:44:39,719
이 접근 방식을 취하고 첫 번째 단어를 지우고 컴포넌트나 모듈로 만들면 됩니다.

427
00:44:40,560 --> 00:44:45,080
또는 마이크로서비스. 그리고 동일한 접근 방식, 동일한 협업 디자인 접근 방식을 얻게 됩니다.

428
00:44:45,080 --> 00:44:52,080
높은 수준의 추상화를 적용합니다. 그래서 디자인을 잘하게 됩니다. 디자인을 잘하게 됩니다.

429
00:44:53,800 --> 00:44:57,920
먼저 모놀리스에 물건을 던져 넣습니다. 디자인에 만족하고 분해에 만족하면

430
00:44:57,920 --> 00:45:03,920
모놀리스 안에서 접근한 다음, 필요하다면 마이크로서비스 세계로 물건을 꺼냅니다.

431
00:45:04,840 --> 00:45:10,760
따라서 마이크로서비스 아키텍처는 여러 가지 이점을 제공합니다. 민첩성, 확장성,

432
00:45:10,760 --> 00:45:15,680
복원력 등 수많은 이점을 제공합니다. 그러나 이것은 다루기가 훨씬 더 어렵습니다. 더 보기

433
00:45:15,680 --> 00:45:21,760
움직이는 부품, 자동 프로비저닝, 모니터링, 로그 집계. 또한 다음과 같이 더 많은 비용을 지불하고 있습니다.

434
00:45:21,760 --> 00:45:27,079
음. 그래서 제가 처음부터 Structurizer를 언급한 이유 중 하나는 바로 스타트업이기 때문입니다.

435
00:45:27,079 --> 00:45:31,599
1인 스타트업으로서 저는 물건을 빨리 전달하고 싶어요. 몇 달씩 시간을 허비하고 싶지 않아요.

436
00:45:31,599 --> 00:45:35,480
도커, 쿠버네티스, 로그 집계, 프레임워크 등 이런 것들로 몇 달을 허비하고 싶지 않아요.

437
00:45:35,480 --> 00:45:42,480
저는 웹에 무언가를 올려서 사람들이 사용하게 하고 싶어요. 그래서 제가 모든 것을 처리할 필요가 없습니다.

438
00:45:43,440 --> 00:45:49,119
아직은 아니지만 원한다면 할 수 있습니다. 따라서 다음과 같은 경우 마이크로서비스를 선택하세요.

439
00:45:49,119 --> 00:45:55,639
혜택을 준다면요. 지금 코드베이스가 엉망이라서가 아닙니다. 왜냐하면 그것은

440
00:45:55,639 --> 00:46:02,639
문제를 해결할 수 없기 때문입니다. 어떤 접근 방식을 선택하든, 그것이 모놀리스이든 아니면

441
00:46:03,039 --> 00:46:07,920
마이크로서비스 집합이든, 구현 세부 사항을 잊지 마세요. 그래서 확실히

442
00:46:07,920 --> 00:46:12,279
예를 들어 모놀리식을 구축할 때 공개 키워드를 과도하게 사용하는 것을 주의하세요.

443
00:46:12,279 --> 00:46:17,079
애플리케이션을 구축할 때 모델 코드 갭을 확실히 주의해야 합니다. 따라서

444
00:46:17,079 --> 00:46:22,960
아키텍처 다이어그램이 있다면 코드와 일치하는지 확인하세요. 그게 기본입니다. Thank

445
00:46:22,960 --> 00:46:23,519
정말 고마워요.

446
00:46:25,639 --> 00:46:26,639
고마워요.

