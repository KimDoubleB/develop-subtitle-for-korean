1
00:00:00,000 --> 00:00:06,799
to have you with us today. My name is Zvezda and I would like to welcome you in front of the

2
00:00:00,000 --> 00:00:06,799
<font color="#ffff54">오늘 여러분과 함께하게 되어 기쁩니다. 제 이름은 즈베즈다이고, 여러분을 환영합니다.</font>

3
00:00:06,799 --> 00:00:14,160
whole Jobrity team. For those who maybe don't know who we are, we are a developers community

4
00:00:06,799 --> 00:00:14,160
<font color="#ffff54">조브리티 팀 전체입니다. 우리가 누군지 모르시는 분들을 위해 설명하자면, 우리는 개발자 커뮤니티입니다.</font>

5
00:00:14,160 --> 00:00:22,400
with more than 70,000 users and a place where you can explore IT companies, IT jobs and read

6
00:00:14,160 --> 00:00:22,400
<font color="#ffff54">70,000명 이상의 사용자와 함께 IT 기업, IT 직무를 탐색하고 읽을 수 있는 공간입니다.</font>

7
00:00:22,400 --> 00:00:30,240
experiences from your colleagues from the industry. We are currently present in six markets

8
00:00:22,400 --> 00:00:30,240
<font color="#ffff54">업계 동료들의 경험을 공유할 수 있습니다. 현재 6개 시장에 진출해 있습니다.</font>

9
00:00:30,800 --> 00:00:40,240
Serbia, Croatia, Romania, Bulgaria, Macedonia and Slovenia and we strongly believe that sharing is

10
00:00:30,800 --> 00:00:40,240
<font color="#ffff54">세르비아, 크로아티아, 루마니아, 불가리아, 마케도니아, 슬로베니아에 진출해 있습니다.</font>

11
00:00:40,240 --> 00:00:47,359
caring and that is why we have started this series of free webinars with industry experts.

12
00:00:40,240 --> 00:00:47,359
<font color="#ffff54">배려라고 믿기 때문에 업계 전문가들과 함께 무료 웨비나 시리즈를 시작하게 되었습니다.</font>

13
00:00:48,079 --> 00:00:54,640
This is our eighth webinar and today we are going to be talking about modular monoliths.

14
00:00:48,079 --> 00:00:54,640
<font color="#ffff54">이번 웨비나는 여덟 번째 웨비나로, 오늘은 모듈형 모놀리스에 대해 이야기할 예정입니다.</font>

15
00:00:55,519 --> 00:01:07,120
We are happy to welcome Milan. Milan, welcome and thank you for being here. Milan is a software

16
00:00:55,519 --> 00:01:07,120
<font color="#ffff54">밀라노를 만나게 되어 반갑습니다. 밀란, 와주셔서 감사합니다. 밀라노는 소프트웨어입니다.</font>

17
00:01:07,120 --> 00:01:15,120
architect and tech youtuber and he will be sharing with us some tips and tricks on how to build the

18
00:01:07,120 --> 00:01:15,120
<font color="#ffff54">건축가이자 기술 유튜버로, 오늘 이 자리에서 소프트웨어 개발과 관련된 몇 가지 팁과 요령을 공유할 예정입니다.</font>

19
00:01:15,120 --> 00:01:21,520
modular monolith and lessons that he has learned along the way. And one more thing, we're going to

20
00:01:15,120 --> 00:01:21,520
<font color="#ffff54">모듈형 모놀리스를 만드는 방법과 그 과정에서 얻은 교훈을 공유합니다. 그리고 한 가지 더, 우리는</font>

21
00:01:21,520 --> 00:01:30,960
be having a Q&A session on the end of the webinar so please feel free to ask any questions that you

22
00:01:21,520 --> 00:01:30,960
<font color="#ffff54">웨비나 마지막에 Q&A 세션이 있을 예정이니 궁금한 점이 있으면 언제든지 질문해 주세요.</font>

23
00:01:30,960 --> 00:01:38,640
maybe have for Milan or for us in the Q&A section. I don't want to be wasting our precious time any

24
00:01:30,960 --> 00:01:38,640
<font color="#ffff54">Q&A 세션에서 밀라노나 저희에게 궁금한 점이 있으시다면 언제든지 질문해 주세요. 우리의 소중한 시간을 낭비하고 싶지 않습니다.</font>

25
00:01:38,640 --> 00:01:44,400
longer so Milan, the floor is all yours. Thank you for the delightful introduction.

26
00:01:38,640 --> 00:01:44,400
<font color="#ffff54">밀라노, 바닥은 모두 당신의 것입니다. 유쾌한 소개 감사합니다.</font>

27
00:01:45,200 --> 00:01:51,680
And thank you to Jyobrati for extending this invitation to me. It's an honor to be talking to

28
00:01:45,200 --> 00:01:51,680
<font color="#ffff54">그리고 저에게 초대를 해주신 조브라티에게도 감사드립니다. 함께 이야기할 수 있어서 영광입니다.</font>

29
00:01:51,680 --> 00:01:59,600
you today. My name is Milan. I'm a software architect by day and content creator in my spare time.

30
00:01:51,680 --> 00:01:59,600
<font color="#ffff54">영광입니다. 제 이름은 밀란입니다. 낮에는 소프트웨어 아키텍트, 여가 시간에는 콘텐츠 크리에이터로 일하고 있습니다.</font>

31
00:01:59,600 --> 00:02:04,240
Although you could argue that creating content is my primary occupation,

32
00:01:59,600 --> 00:02:04,240
<font color="#ffff54">콘텐츠 제작이 제 본업이라고 할 수도 있겠지만요,</font>

33
00:02:04,240 --> 00:02:11,759
given how much I share daily on the various social medias that I'm present on, you can find me on

34
00:02:04,240 --> 00:02:11,759
<font color="#ffff54">제가 현재 활동하고 있는 다양한 소셜 미디어에서 매일 얼마나 많은 것을 공유하는지를 고려할 때, 여러분은 저를 찾을 수 있습니다.</font>

35
00:02:11,759 --> 00:02:18,560
YouTube, LinkedIn, Twitter and on my website where I write a weekly blog. You can see all the links

36
00:02:11,759 --> 00:02:18,560
<font color="#ffff54">유튜브, 링크드인, 트위터, 그리고 제가 매주 블로그를 작성하는 웹사이트에서 찾을 수 있습니다. 모든 링크를 볼 수 있습니다.</font>

37
00:02:18,560 --> 00:02:24,959
on the screen. And without further ado, I'm going to jump into what you all came here for today,

38
00:02:18,560 --> 00:02:24,959
<font color="#ffff54">화면에서 볼 수 있습니다. 더 이상 고민할 필요 없이 여러분들이 오늘 이 자리에 모인 이유에 대해 알아보도록 하겠습니다,</font>

39
00:02:25,519 --> 00:02:32,719
which is modular monoliths. I'm going to talk about my experience using this architecture on

40
00:02:25,519 --> 00:02:32,719
<font color="#ffff54">모듈형 모놀리스입니다. 이 아키텍처를 사용한 제 경험에 대해 이야기하겠습니다.</font>

41
00:02:32,719 --> 00:02:40,319
a real project for the past two years. I'm going to explain as best as I can how you can build a

42
00:02:32,719 --> 00:02:40,319
<font color="#ffff54">지난 2년간 실제 프로젝트에 사용했습니다. 제가 할 수 있는 한 최선을 다해 설명해드리겠습니다.</font>

43
00:02:40,319 --> 00:02:46,319
modular monolith and what are some of the lessons that we learned along the way. Unfortunately,

44
00:02:40,319 --> 00:02:46,319
<font color="#ffff54">모듈형 모놀리스를 구축하는 방법과 그 과정에서 얻은 교훈이 무엇인지 설명하겠습니다. 불행히도,</font>

45
00:02:46,319 --> 00:02:52,479
we had to learn those lessons the hard way, but I'm hoping that in sharing my experience today,

46
00:02:46,319 --> 00:02:52,479
<font color="#ffff54">그 교훈을 힘들게 배워야 했지만, 오늘 제 경험을 공유하면서 그 교훈이 도움이 되었으면 좋겠습니다,</font>

47
00:02:52,479 --> 00:02:57,840
you're going to be able to learn those lessons right away and you won't make the same mistakes

48
00:02:52,479 --> 00:02:57,840
<font color="#ffff54">여러분은 그 교훈을 바로 배울 수 있고 같은 실수를 하지 않을 것입니다.</font>

49
00:02:57,840 --> 00:03:06,319
that we did. So what is our agenda for today? We're going to briefly talk about the monolith

50
00:02:57,840 --> 00:03:06,319
<font color="#ffff54">우리가 했던 것처럼요. 그럼 오늘의 의제는 무엇일까요? 모놀리스에 대해 간단히 이야기해 보겠습니다.</font>

51
00:03:06,319 --> 00:03:12,319
architecture. Then we're going to jump into microservices just on a high level. I'm also going

52
00:03:06,319 --> 00:03:12,319
<font color="#ffff54">아키텍처에 대해 간단히 이야기하겠습니다. 그런 다음 마이크로서비스에 대해 개괄적으로 살펴보겠습니다. 또한</font>

53
00:03:12,319 --> 00:03:19,359
to do a comparison between monoliths and microservices. And then we're going to do a deep

54
00:03:12,319 --> 00:03:19,359
<font color="#ffff54">모놀리스와 마이크로서비스를 비교해 보겠습니다. 그런 다음 심층적인 분석을 할 것입니다.</font>

55
00:03:19,359 --> 00:03:26,319
dive into modular monoliths. I'm going to explain what this architecture is, how you can build one,

56
00:03:19,359 --> 00:03:26,319
<font color="#ffff54">모듈형 모놀리스에 대해 알아보겠습니다. 이 아키텍처가 무엇인지, 어떻게 구축할 수 있는지 설명하겠습니다,</font>

57
00:03:26,879 --> 00:03:32,719
what are the challenges of actually building a proper modular monolith, and what are some of the

58
00:03:26,879 --> 00:03:32,719
<font color="#ffff54">실제로 제대로 된 모듈형 모놀리스를 구축하는 데 있어 어떤 어려움이 있는지, 그리고 어떤 점이</font>

59
00:03:32,719 --> 00:03:42,400
lessons that I learned along the way. So here you can see the monolith. What we mean when we say

60
00:03:32,719 --> 00:03:42,400
<font color="#ffff54">교훈을 얻었습니다. 여기 모놀리스가 보입니다. 우리가 말하는 의미는</font>

61
00:03:42,400 --> 00:03:49,199
monolith architecture is we have just one application representing the system. Typically,

62
00:03:42,400 --> 00:03:49,199
<font color="#ffff54">모놀리스 아키텍처는 시스템을 대표하는 애플리케이션이 하나뿐이라는 뜻입니다. 일반적으로,</font>

63
00:03:49,199 --> 00:03:55,759
it's going to be one solution if you are working in a .NET environment, so that one solution with

64
00:03:49,199 --> 00:03:55,759
<font color="#ffff54">이면 하나의 솔루션이 되지만, .NET 환경에서 작업하는 경우라면</font>

65
00:03:55,759 --> 00:04:03,199
one executable represents the monolith. And these days, it's considered kind of old-fashioned.

66
00:03:55,759 --> 00:04:03,199
<font color="#ffff54">하나의 실행 파일이 모놀리스를 나타냅니다. 그리고 요즘에는 다소 구식으로 간주됩니다.</font>

67
00:04:03,199 --> 00:04:09,199
Everybody wants to be working in some other kind of architecture because it looks cool on

68
00:04:03,199 --> 00:04:09,199
<font color="#ffff54">모두가 다른 종류의 아키텍처에서 일하고 싶어하는 이유는 그것이 멋져 보이기 때문입니다.</font>

69
00:04:09,199 --> 00:04:16,719
CVs, among other things, but I think there is a lot of beauty in creating a good solid monolith,

70
00:04:09,199 --> 00:04:16,719
<font color="#ffff54">이력서 등 여러 가지가 있겠지만, 좋은 견고한 모놀리스를 만드는 데는 많은 아름다움이 있다고 생각합니다,</font>

71
00:04:17,680 --> 00:04:22,719
which is why I'm trying to talk about modular monoliths, which are, in my opinion,

72
00:04:17,680 --> 00:04:22,719
<font color="#ffff54">그래서 저는 모듈형 모놀리스에 대해 이야기하려고 합니다,</font>

73
00:04:22,720 --> 00:04:29,440
a good way to build monoliths. And one of the issues with monoliths and why people

74
00:04:22,720 --> 00:04:29,440
<font color="#ffff54">모놀리스를 구축하는 좋은 방법이라고 생각합니다. 그리고 모놀리스의 문제점 중 하나와 사람들이 왜</font>

75
00:04:29,440 --> 00:04:37,680
moved away from them is limited scalability. And what I mean by this is you only have one

76
00:04:29,440 --> 00:04:37,680
<font color="#ffff54">모놀리스로부터 멀어지는 이유 중 하나는 확장성이 제한된다는 것입니다. 즉, 모놀리스에는 단 하나의</font>

77
00:04:37,680 --> 00:04:44,000
application, one system, and if you want to scale something, you only can scale that system. I'm

78
00:04:37,680 --> 00:04:44,000
<font color="#ffff54">애플리케이션, 하나의 시스템만 있고, 무언가를 확장하려면 해당 시스템만 확장할 수 있다는 뜻입니다. 나는</font>

79
00:04:44,000 --> 00:04:50,000
going to talk about this more in just a moment. On the other end of the spectrum, we have

80
00:04:44,000 --> 00:04:50,000
<font color="#ffff54">잠시 후에 이에 대해 더 자세히 설명하겠습니다. 스펙트럼의 다른 쪽 끝에는 다음이 있습니다.</font>

81
00:04:50,000 --> 00:04:57,199
microservices. So here's our representation of a very complicated system where each node on the

82
00:04:50,000 --> 00:04:57,199
<font color="#ffff54">마이크로서비스가 있습니다. 따라서 여기에서는 각 노드가</font>

83
00:04:57,199 --> 00:05:03,120
screen is one microservice. And I'm sure there are actually real-world systems that look a lot

84
00:04:57,199 --> 00:05:03,120
<font color="#ffff54">화면의 각 노드가 하나의 마이크로서비스입니다. 실제 시스템도 이와 비슷할 것입니다.</font>

85
00:05:03,120 --> 00:05:09,040
like this. And if you're working in a system like this, I am sure you're having a lot of fun.

86
00:05:03,120 --> 00:05:09,040
<font color="#ffff54">이렇게 생겼을 겁니다. 이런 시스템에서 일하고 계신다면 정말 재미있게 일하고 계실 겁니다.</font>

87
00:05:10,079 --> 00:05:17,199
So when we say microservices, we mean that many individual services, each doing their own job,

88
00:05:10,079 --> 00:05:17,199
<font color="#ffff54">마이크로 서비스란 각각 고유한 업무를 수행하는 수많은 개별 서비스를 의미합니다,</font>

89
00:05:17,920 --> 00:05:26,079
form the whole larger system. These days, it's considered cutting edge and cool. Everybody wants

90
00:05:17,920 --> 00:05:26,079
<font color="#ffff54">더 큰 전체 시스템을 구성합니다. 요즘에는 이런 방식이 최첨단이고 멋지다고 여겨집니다. 모두가 원하는</font>

91
00:05:26,079 --> 00:05:31,680
to be working with microservices because they are very popular, mainly because it's challenging to

92
00:05:26,079 --> 00:05:31,680
<font color="#ffff54">마이크로서비스가 매우 인기가 있기 때문에 마이크로서비스 작업을 하려고 합니다.</font>

93
00:05:31,680 --> 00:05:40,240
work with them, but it's also fun and exciting. And one strong advantage of microservices

94
00:05:31,680 --> 00:05:40,240
<font color="#ffff54">하지만 재미있고 흥미롭기도 합니다. 그리고 마이크로서비스의 강력한 장점 중 하나는</font>

95
00:05:40,879 --> 00:05:46,240
is that at least in theory, they are infinitely scalable because whenever you want to scale

96
00:05:40,879 --> 00:05:46,240
<font color="#ffff54">적어도 이론상으로는 무한히 확장할 수 있다는 것입니다.</font>

97
00:05:46,240 --> 00:05:52,240
something, you can scale that service either vertically or horizontally, or if you have

98
00:05:46,240 --> 00:05:52,240
<font color="#ffff54">무언가를 확장하고 싶을 때마다 해당 서비스를 수직 또는 수평으로 확장 할 수 있습니다.</font>

99
00:05:52,240 --> 00:05:56,639
a bottleneck, you can extract it into a separate service and then scale that independently.

100
00:05:52,240 --> 00:05:56,639
<font color="#ffff54">병목 현상이 발생하면 이를 별도의 서비스로 추출한 다음 독립적으로 확장할 수 있습니다.</font>

101
00:05:57,360 --> 00:06:04,000
So let's try to compare monoliths and microservices on a few points.

102
00:05:57,360 --> 00:06:04,000
<font color="#ffff54">이제 몇 가지 점에서 모놀리스와 마이크로서비스를 비교해 보겠습니다.</font>

103
00:06:05,759 --> 00:06:13,680
The first is in terms of deployment. For monoliths, we have one deployment artifact,

104
00:06:05,759 --> 00:06:13,680
<font color="#ffff54">첫 번째는 배포 측면입니다. 모놀리스의 경우 배포 아티팩트가 하나 있습니다,</font>

105
00:06:14,639 --> 00:06:21,519
whereas for microservices, we have many, or rather for each service that is part of our

106
00:06:14,639 --> 00:06:21,519
<font color="#ffff54">반면, 마이크로서비스의 경우, 우리는 많은, 아니 오히려 우리의 일부인 각 서비스에 대해</font>

107
00:06:21,519 --> 00:06:28,639
microservice system, we have a deployment artifact. And for microservices, you're going to find that

108
00:06:21,519 --> 00:06:28,639
<font color="#ffff54">마이크로서비스 시스템에는 배포 아티팩트가 있습니다. 그리고 마이크로서비스의 경우, 다음과 같은 것을 발견하게 될 것입니다.</font>

109
00:06:28,639 --> 00:06:35,120
deployment is generally a lot more complicated and a lot more things can go wrong than with monoliths.

110
00:06:28,639 --> 00:06:35,120
<font color="#ffff54">배포는 일반적으로 모놀리스보다 훨씬 더 복잡하고 더 많은 일이 잘못될 수 있습니다.</font>

111
00:06:36,960 --> 00:06:43,199
When it comes to communication, in a monolith, typically components talk to each other

112
00:06:36,960 --> 00:06:43,199
<font color="#ffff54">통신과 관련하여, 모놀리스에서는 일반적으로 컴포넌트가 서로 통신합니다.</font>

113
00:06:43,279 --> 00:06:50,479
by simple method calls, given the nature of the system is everything is in one physical

114
00:06:43,279 --> 00:06:50,479
<font color="#ffff54">간단한 메서드 호출로 모든 것이 하나의 물리적인 객체에 있다는 시스템의 특성을 고려할 때</font>

115
00:06:50,479 --> 00:06:57,920
application. And with microservices, it's a little bit different because each of your service is an

116
00:06:50,479 --> 00:06:57,920
<font color="#ffff54">애플리케이션에 있습니다. 그리고 마이크로서비스의 경우, 각 서비스가 개별적인</font>

117
00:06:57,920 --> 00:07:04,079
independent application running in its own server. So your services, if they want to talk to each

118
00:06:57,920 --> 00:07:04,079
<font color="#ffff54">자체 서버에서 실행되는 독립적인 애플리케이션입니다. 따라서 서비스가 각각의 서버와 통신하려면</font>

119
00:07:04,079 --> 00:07:11,599
other, they have to resort to using network calls, typically using HTTP, but there are other approaches

120
00:07:04,079 --> 00:07:11,599
<font color="#ffff54">다른 경우에는 네트워크 호출을 사용해야 합니다. 일반적으로 HTTP를 사용하지만 다른 접근 방식도 있습니다.</font>

121
00:07:11,600 --> 00:07:18,400
like messaging, for example. Now, when it comes to scalability, monoliths are usually

122
00:07:11,600 --> 00:07:18,400
<font color="#ffff54">메시징과 같은 다른 접근 방식도 있습니다. 이제 확장성과 관련하여 모놀리스는 일반적으로 다음과 같습니다.</font>

123
00:07:18,400 --> 00:07:24,480
vertically scalable very easily. You can always beef up that server where your monolith is running,

124
00:07:18,400 --> 00:07:24,480
<font color="#ffff54">수직적으로 매우 쉽게 확장할 수 있습니다. 모놀리스가 실행 중인 서버를 언제든지 강화할 수 있습니다,</font>

125
00:07:24,480 --> 00:07:31,600
make it a bigger machine, and you can horizontally scale a monolith, but the downside is you're

126
00:07:24,480 --> 00:07:31,600
<font color="#ffff54">더 큰 머신으로 만들 수 있고, 모놀리스를 수평으로 확장할 수 있지만, 단점이 있습니다.</font>

127
00:07:31,600 --> 00:07:37,200
scaling the entire application and not necessarily the bottleneck that is probably causing you

128
00:07:31,600 --> 00:07:37,200
<font color="#ffff54">전체 애플리케이션을 확장할 때 병목현상이 발생할 수 있다는 것입니다.</font>

129
00:07:37,199 --> 00:07:44,240
trouble. Where with microservices, you have the freedom to scale both horizontally and vertically

130
00:07:37,199 --> 00:07:44,240
<font color="#ffff54">문제. 마이크로서비스에서는 수평적, 수직적 확장이 자유롭습니다.</font>

131
00:07:45,279 --> 00:07:51,199
and even extract services from your existing services if you need to scale some part of your

132
00:07:45,279 --> 00:07:51,199
<font color="#ffff54">확장해야 하는 경우 기존 서비스에서 서비스를 추출할 수도 있습니다.</font>

133
00:07:51,199 --> 00:07:58,879
system further. When it comes to databases, in a monolith system, you will typically only have

134
00:07:51,199 --> 00:07:58,879
<font color="#ffff54">시스템을 더 확장할 수도 있습니다. 데이터베이스의 경우, 모놀리스 시스템에서는 일반적으로 다음과 같은 것만 있습니다.</font>

135
00:07:58,879 --> 00:08:06,159
one database, which is very easy to work with. And with microservices, you have usually one

136
00:07:58,879 --> 00:08:06,159
<font color="#ffff54">하나의 데이터베이스만 있어 작업하기가 매우 쉽습니다. 그리고 마이크로서비스의 경우 일반적으로 하나의</font>

137
00:08:06,160 --> 00:08:11,840
database per service, but your entire system is comprised of many individual databases,

138
00:08:06,160 --> 00:08:11,840
<font color="#ffff54">데이터베이스가 있지만, 전체 시스템은 여러 개의 개별 데이터베이스로 구성되어 있습니다,</font>

139
00:08:11,840 --> 00:08:14,000
which adds another layer of complexity.

140
00:08:11,840 --> 00:08:14,000
<font color="#ffff54">또 다른 복잡성 계층이 추가됩니다.</font>

141
00:08:16,480 --> 00:08:23,120
Transactions are available almost out of the box with monoliths because you are usually working

142
00:08:16,480 --> 00:08:23,120
<font color="#ffff54">모놀리스를 사용하면 트랜잭션을 거의 즉시 사용할 수 있습니다.</font>

143
00:08:23,120 --> 00:08:29,840
with just one database, so you are transactional by the nature of the system. And with microservices,

144
00:08:23,120 --> 00:08:29,840
<font color="#ffff54">단 하나의 데이터베이스로 작업하기 때문에 시스템 특성상 트랜잭션이 가능합니다. 그리고 마이크로서비스도 마찬가지입니다,</font>

145
00:08:29,840 --> 00:08:37,920
it becomes very interesting because if you want to enforce consistency among services,

146
00:08:29,840 --> 00:08:37,920
<font color="#ffff54">서비스 간에 일관성을 적용하려는 경우 매우 흥미로워집니다,</font>

147
00:08:37,920 --> 00:08:44,560
you have to resort to using distributed transactions, which they slow performance

148
00:08:37,920 --> 00:08:44,560
<font color="#ffff54">분산 트랜잭션을 사용해야 하므로 성능이 느려집니다.</font>

149
00:08:45,360 --> 00:08:51,040
and they introduce a lot of complexity the more services you're trying to keep consistent,

150
00:08:45,360 --> 00:08:51,040
<font color="#ffff54">그리고 일관성을 유지하려는 서비스가 많아질수록 복잡성이 커집니다,</font>

151
00:08:51,040 --> 00:08:59,440
which is why people typically tend to trade off consistency and embrace eventual consistency.

152
00:08:51,040 --> 00:08:59,440
<font color="#ffff54">그렇기 때문에 사람들은 일반적으로 일관성을 희생하고 궁극적인 일관성을 수용하는 경향이 있습니다.</font>

153
00:09:00,000 --> 00:09:06,480
Where you commit a transaction inside of a single service, which is transactional or consistent,

154
00:09:00,000 --> 00:09:06,480
<font color="#ffff54">단일 서비스 내에서 트랜잭션을 커밋하는 경우, 트랜잭션 또는 일관성,</font>

155
00:09:07,200 --> 00:09:13,600
and then you somehow notify the other services in your system of the change that happened,

156
00:09:07,200 --> 00:09:13,600
<font color="#ffff54">그리고 나서 어떻게든 시스템의 다른 서비스에 변경 사항을 알립니다,</font>

157
00:09:13,600 --> 00:09:17,360
and eventually your system converges to a consistent state.

158
00:09:13,600 --> 00:09:17,360
<font color="#ffff54">결국 시스템이 일관된 상태로 수렴합니다.</font>

159
00:09:19,360 --> 00:09:25,360
And when it comes to scaling teams, again, we have kind of opposing

160
00:09:19,360 --> 00:09:25,360
<font color="#ffff54">그리고 팀 확장에 관해서는, 다시 한 번 말씀드리지만, 우리는 일종의 반대 의견을 가지고 있습니다.</font>

161
00:09:25,840 --> 00:09:33,919
points. With a monolith, it becomes difficult to scale with a large team because everybody

162
00:09:25,840 --> 00:09:33,919
<font color="#ffff54">포인트가 있습니다. 모놀리스를 사용하면 모든 사람이 한 팀에 속해 있기 때문에 대규모 팀으로 확장하기가 어렵습니다.</font>

163
00:09:33,919 --> 00:09:40,159
is working in the same code base. There are a lot of conflicts, a lot of teams making changes to

164
00:09:33,919 --> 00:09:40,159
<font color="#ffff54">동일한 코드 베이스에서 작업하기 때문입니다. 많은 충돌이 발생하고, 많은 팀에서</font>

165
00:09:40,159 --> 00:09:46,480
potentially the same parts of code, and it's kind of messy to work with. With microservices,

166
00:09:40,159 --> 00:09:46,480
<font color="#ffff54">코드의 동일한 부분을 변경하는 경우가 많아서 작업하기가 다소 지저분합니다. 마이크로서비스에서는 더욱 그렇습니다,</font>

167
00:09:46,800 --> 00:09:57,680
you can make sure the service is large enough to fill the needs of your team and not small enough

168
00:09:46,800 --> 00:09:57,680
<font color="#ffff54">서비스가 팀의 요구 사항을 충족할 수 있을 만큼 충분히 큰지, 너무 작지는 않은지 확인할 수 있습니다.</font>

169
00:09:57,680 --> 00:10:04,080
so that nobody has enough work to do. So it's very easy to scale microservices with large teams,

170
00:09:57,680 --> 00:10:04,080
<font color="#ffff54">아무도 할 일이 부족하지 않도록 할 수 있습니다. 따라서 대규모 팀으로 마이크로서비스를 확장하기가 매우 쉽습니다,</font>

171
00:10:04,080 --> 00:10:10,399
where each team can be responsible for one or more services, depending on how big your services are.

172
00:10:04,080 --> 00:10:10,399
<font color="#ffff54">서비스 규모에 따라 각 팀이 하나 이상의 서비스를 담당할 수 있습니다.</font>

173
00:10:10,480 --> 00:10:17,039
So I have a quote here from a guy named Martin Fowler. You might have heard of him.

174
00:10:10,480 --> 00:10:17,039
<font color="#ffff54">마틴 파울러라는 사람의 말을 인용하겠습니다. 들어보셨을 겁니다.</font>

175
00:10:17,039 --> 00:10:23,360
He's actually very influential in our industry, and he said,

176
00:10:17,039 --> 00:10:23,360
<font color="#ffff54">그는 실제로 우리 업계에서 매우 영향력 있는 사람입니다,</font>

177
00:10:24,480 --> 00:10:30,159
you shouldn't start a new project with microservices, even if you're sure your

178
00:10:24,480 --> 00:10:30,159
<font color="#ffff54">마이크로서비스로 새 프로젝트를 시작해서는 안 된다고 말합니다.</font>

179
00:10:30,159 --> 00:10:35,840
application will be big enough to make it worthwhile. Now I'm going to give you a moment

180
00:10:30,159 --> 00:10:35,840
<font color="#ffff54">애플리케이션이 충분히 가치가 있다고 확신하더라도 말입니다. 이제 잠시 시간을 내어</font>

181
00:10:35,840 --> 00:10:44,240
to ponder on this quote and try to think of what he actually tried to tell us when he said this.

182
00:10:35,840 --> 00:10:44,240
<font color="#ffff54">이 인용문을 곰곰이 생각해보고 그가 실제로 이 말을 했을 때 우리에게 무엇을 말하려고 했는지 생각해보세요.</font>

183
00:10:47,280 --> 00:10:53,519
So in my eyes, the reason you shouldn't be starting a project with microservices

184
00:10:47,280 --> 00:10:53,519
<font color="#ffff54">제 생각에 마이크로서비스로 프로젝트를 시작해서는 안 되는 이유는 다음과 같습니다.</font>

185
00:10:54,160 --> 00:11:01,040
is because you are going to have a tendency to create, to make your system very granular.

186
00:10:54,160 --> 00:11:01,040
<font color="#ffff54">시스템을 매우 세분화해서 만들려는 경향이 있기 때문입니다.</font>

187
00:11:01,120 --> 00:11:06,879
You're going to want to make microservice for this and microservice for that. And before you know it,

188
00:11:01,120 --> 00:11:06,879
<font color="#ffff54">이것도 마이크로서비스, 저것도 마이크로서비스를 만들고 싶을 것입니다. 그러다 보면 어느새</font>

189
00:11:06,879 --> 00:11:13,039
you have dozens of microservices. Whereas if you started with a monolith application

190
00:11:06,879 --> 00:11:13,039
<font color="#ffff54">수십 개의 마이크로서비스를 갖게 됩니다. 반면에 모놀리스 애플리케이션으로 시작했다면</font>

191
00:11:13,759 --> 00:11:21,199
and then worked with that for as long as you could have, and the benefit of that is you're

192
00:11:13,759 --> 00:11:21,199
<font color="#ffff54">로 시작한 다음 가능한 한 오래 작업할 수 있으며, 그 이점은 다음과 같습니다.</font>

193
00:11:21,199 --> 00:11:27,599
going to naturally see where the bottlenecks are in your system. And when bottlenecks start to

194
00:11:21,199 --> 00:11:27,599
<font color="#ffff54">시스템의 병목 지점을 자연스럽게 파악할 수 있다는 것입니다. 그리고 병목 현상이 시작되면</font>

195
00:11:28,000 --> 00:11:34,080
appearing in your system, that's a very good sign that that part of your system can be scaled out

196
00:11:28,000 --> 00:11:34,080
<font color="#ffff54">이 나타나기 시작하면 시스템의 해당 부분을 확장할 수 있다는 매우 좋은 신호입니다.</font>

197
00:11:34,080 --> 00:11:39,120
into a separate service. So it's kind of a more natural evolution towards microservices.

198
00:11:34,080 --> 00:11:39,120
<font color="#ffff54">별도의 서비스로 확장할 수 있다는 뜻입니다. 따라서 마이크로서비스로의 자연스러운 진화라고 할 수 있습니다.</font>

199
00:11:40,800 --> 00:11:44,080
But again, if you build a monolith the traditional way,

200
00:11:40,800 --> 00:11:44,080
<font color="#ffff54">하지만 전통적인 방식으로 모놀리스를 구축한다면,</font>

201
00:11:45,279 --> 00:11:52,960
moving into microservices becomes a little bit difficult. So what if we could have the best

202
00:11:45,279 --> 00:11:52,960
<font color="#ffff54">마이크로서비스로 이동하는 것이 조금 어려워집니다. 그래서 만약 우리가 최고의</font>

203
00:11:53,519 --> 00:11:58,879
of both worlds? If we could get the physical architecture of a monolith,

204
00:11:53,519 --> 00:11:58,879
<font color="#ffff54">두 세계의 장점을 모두 누릴 수 있다면 어떨까요? 모놀리스의 물리적 아키텍처를 얻을 수 있다면요,</font>

205
00:12:00,240 --> 00:12:06,400
where everything is still inside of one system and one physical application, one deployment

206
00:12:00,240 --> 00:12:06,400
<font color="#ffff54">모든 것이 여전히 하나의 시스템과 하나의 물리적 애플리케이션, 하나의 배포 안에 있습니다.</font>

207
00:12:06,400 --> 00:12:13,120
artifact. And on the other hand, we have a logical architecture of microservices,

208
00:12:06,400 --> 00:12:13,120
<font color="#ffff54">아티팩트. 반면에 우리는 마이크로서비스의 논리적 아키텍처를 가지고 있습니다,</font>

209
00:12:13,840 --> 00:12:20,960
where individual features of the system are kind of naturally grouped together in a way that

210
00:12:13,840 --> 00:12:20,960
<font color="#ffff54">시스템의 개별 기능이 다음과 같은 방식으로 자연스럽게 그룹화됩니다.</font>

211
00:12:20,960 --> 00:12:25,519
are kind of naturally grouped together as they would be inside of a microservice.

212
00:12:20,960 --> 00:12:25,519
<font color="#ffff54">마이크로서비스 내부에 있는 것처럼 자연스럽게 함께 그룹화됩니다.</font>

213
00:12:26,720 --> 00:12:34,000
And another benefit is to have the ability to move to a microservice architecture easily.

214
00:12:26,720 --> 00:12:34,000
<font color="#ffff54">또 다른 이점은 마이크로서비스 아키텍처로 쉽게 이동할 수 있다는 것입니다.</font>

215
00:12:34,000 --> 00:12:43,120
So we can achieve this and it is called a modular monolith. So I'm going to try to explain now

216
00:12:34,000 --> 00:12:43,120
<font color="#ffff54">그래서 우리는 이를 달성할 수 있으며 이를 모듈형 모놀리스라고 부릅니다. 이제 설명해 보겠습니다.</font>

217
00:12:44,080 --> 00:12:50,240
what a modular monolith is. And I'm going to start by sharing a few definitions

218
00:12:44,080 --> 00:12:50,240
<font color="#ffff54">모듈형 모놀리스가 무엇인지 설명하겠습니다. 먼저 몇 가지 정의를 공유하면서 시작하겠습니다.</font>

219
00:12:50,879 --> 00:12:58,879
of the modular monolith with you. So the first definition says a modular monolith is a software

220
00:12:50,879 --> 00:12:58,879
<font color="#ffff54">모듈형 모놀리스에 대한 몇 가지 정의를 공유하겠습니다. 첫 번째 정의에 따르면 모듈형 모놀리스는 소프트웨어가 아닌</font>

221
00:12:58,879 --> 00:13:05,679
design approach in which a monolith is designed with an emphasis on interchangeable and potentially

222
00:12:58,879 --> 00:13:05,679
<font color="#ffff54">모놀리스가 상호 교환 가능하고 잠재적으로 확장 가능한 것에 중점을 두고 설계되는 디자인 접근 방식입니다.</font>

223
00:13:05,680 --> 00:13:13,840
reusable modules. So this is kind of a long definition, but the highlight is interchangeable

224
00:13:05,680 --> 00:13:13,840
<font color="#ffff54">재사용 가능한 모듈을 강조하는 설계 방식입니다. 정의가 다소 길지만, 핵심은 상호 교환이 가능하다는 것입니다.</font>

225
00:13:13,840 --> 00:13:22,000
and reusable modules. Okay, let's see another definition. So a modular monolith is an explicit

226
00:13:13,840 --> 00:13:22,000
<font color="#ffff54">재사용 가능한 모듈입니다. 자, 다른 정의를 살펴보겠습니다. 모듈형 모놀리스는 명시적으로</font>

227
00:13:22,000 --> 00:13:28,400
name for a monolith system designed in a modular way. So we can see that kind of everything revolves

228
00:13:22,000 --> 00:13:28,400
<font color="#ffff54">모듈 방식으로 설계된 모놀리스 시스템의 이름입니다. 그래서 우리는 그런 종류의 모든 것이 회전하는 것을 볼 수 있습니다.</font>

229
00:13:29,039 --> 00:13:38,879
around the word modular. And the definition of the word modular is consisting of separate parts

230
00:13:29,039 --> 00:13:38,879
<font color="#ffff54">모듈러라는 단어를 중심으로 돌아간다는 것을 알 수 있습니다. 그리고 모듈러라는 단어의 정의는 별도의 부품으로 구성되어 있습니다.</font>

231
00:13:39,439 --> 00:13:45,840
that when combined form a complete whole. I'm not going to read the rest of the definition,

232
00:13:39,439 --> 00:13:45,840
<font color="#ffff54">결합되었을 때 완전한 전체를 형성합니다. 나머지 정의는 읽지 않겠습니다,</font>

233
00:13:45,840 --> 00:13:54,879
but the main point here is you have distinct parts in your system that are kind of independent

234
00:13:45,840 --> 00:13:54,879
<font color="#ffff54">하지만 여기서 중요한 점은 시스템에는 독립적인 부분이 있다는 것입니다.</font>

235
00:13:54,879 --> 00:14:02,399
on their own, but together when they comprise, when they come together, they form a complete

236
00:13:54,879 --> 00:14:02,399
<font color="#ffff54">그 자체로는 독립적이지만, 함께 구성될 때, 함께 모이면 완전한</font>

237
00:14:02,399 --> 00:14:10,159
system. In our world, this is going to be an application. So everything is easier to visualize

238
00:14:02,399 --> 00:14:10,159
<font color="#ffff54">시스템이 됩니다. 우리 세계에서는 이것이 애플리케이션이 될 것입니다. 따라서 모든 것이 더 쉽게 시각화됩니다.</font>

239
00:14:10,799 --> 00:14:20,720
with a diagram. So I prepared a monolith diagram here of a sample eShop application or e-commerce

240
00:14:10,799 --> 00:14:20,720
<font color="#ffff54">다이어그램으로 시각화할 수 있습니다. 그래서 저는 여기에 샘플 eShop 애플리케이션 또는 전자 상거래의 모놀리스 다이어그램을 준비했습니다.</font>

241
00:14:20,720 --> 00:14:26,240
application, if you will. And I did actually work on a similar system for the previous two years.

242
00:14:20,720 --> 00:14:26,240
<font color="#ffff54">애플리케이션의 모놀리스 다이어그램을 준비했습니다. 저는 실제로 지난 2년 동안 비슷한 시스템에서 일한 적이 있습니다.</font>

243
00:14:26,240 --> 00:14:30,720
So I'm using that as an inspiration. So if it were a monolith, a typical monolith

244
00:14:26,240 --> 00:14:30,720
<font color="#ffff54">그래서 저는 그것을 영감으로 삼고 있습니다. 그래서 만약 그것이 모놀리스라면, 전형적인 모놀리스라면</font>

245
00:14:31,519 --> 00:14:38,080
architecture, you would have one application. For example, it can be on ASP.NET Core Web API.

246
00:14:31,519 --> 00:14:38,080
<font color="#ffff54">아키텍처라면 하나의 애플리케이션이 있을 것입니다. 예를 들어, ASP.NET 코어 웹 API에 있을 수 있습니다.</font>

247
00:14:39,519 --> 00:14:46,000
And all of the components in our system are going to be C-Sharp class libraries, for example.

248
00:14:39,519 --> 00:14:46,000
<font color="#ffff54">그리고 우리 시스템의 모든 컴포넌트는 예를 들어 C-Sharp 클래스 라이브러리가 될 것입니다.</font>

249
00:14:46,000 --> 00:14:55,600
And we have just one database in the system. Now, if we were to convert this system into

250
00:14:46,000 --> 00:14:55,600
<font color="#ffff54">그리고 시스템에는 단 하나의 데이터베이스가 있습니다. 이제 이 시스템을 다음과 같이 변환한다면</font>

251
00:14:55,600 --> 00:15:03,120
microservices, we could end up with something like this. So here you can see four separate

252
00:14:55,600 --> 00:15:03,120
<font color="#ffff54">마이크로서비스로 변환하면 다음과 같은 결과가 나올 수 있습니다. 따라서 여기에는 4개의 개별</font>

253
00:15:03,120 --> 00:15:10,480
microservices. We have the catalog service, which is responsible for telling us what products are

254
00:15:03,120 --> 00:15:10,480
<font color="#ffff54">마이크로서비스가 있습니다. 어떤 제품이 있는지 알려주는 카탈로그 서비스가 있습니다.</font>

255
00:15:10,480 --> 00:15:16,560
available in our system to be bought. Then we have the order service, which is responsible for

256
00:15:10,480 --> 00:15:16,560
<font color="#ffff54">구매할 수 있는 제품을 알려주는 역할을 합니다. 그런 다음 주문 서비스가 있는데, 이 서비스는 다음을 담당합니다.</font>

257
00:15:17,120 --> 00:15:23,840
creating, managing orders, shipping them, taking care of payments and so on. We have the customer

258
00:15:17,120 --> 00:15:23,840
<font color="#ffff54">주문 생성, 관리, 배송, 결제 처리 등을 담당합니다. 고객이 있습니다.</font>

259
00:15:23,840 --> 00:15:28,800
service, which takes care of the users in the system, which are rather the customers.

260
00:15:23,840 --> 00:15:28,800
<font color="#ffff54">시스템 내 사용자를 관리하는 서비스, 즉 고객입니다.</font>

261
00:15:29,440 --> 00:15:36,159
And then the collaboration service, which exists so that customers can interact with

262
00:15:29,440 --> 00:15:36,159
<font color="#ffff54">그리고 고객과 상호작용할 수 있도록 존재하는 협업 서비스입니다.</font>

263
00:15:36,399 --> 00:15:42,639
sales representatives to create an order because in this system, creating an order

264
00:15:36,399 --> 00:15:42,639
<font color="#ffff54">영업 담당자가 주문을 생성할 수 있도록 존재하는 협업 서비스입니다.</font>

265
00:15:42,639 --> 00:15:47,120
is very complicated. It's kind of a custom made e-commerce application.

266
00:15:42,639 --> 00:15:47,120
<font color="#ffff54">매우 복잡합니다. 일종의 맞춤형 전자 상거래 애플리케이션입니다.</font>

267
00:15:48,480 --> 00:15:55,919
So you can see kind of the contrast with these two systems. On the one hand, everything is monolithic

268
00:15:48,480 --> 00:15:55,919
<font color="#ffff54">이 두 시스템이 어떻게 대조되는지 알 수 있습니다. 한편으로는 모든 것이 모놀리식입니다.</font>

269
00:15:55,919 --> 00:16:03,439
together. On the other hand, everything is kind of nicely organized into individual services,

270
00:15:55,919 --> 00:16:03,439
<font color="#ffff54">함께. 반면에 모든 것이 개별 서비스로 잘 정리되어 있습니다,</font>

271
00:16:03,680 --> 00:16:10,160
where each of them provides its own functionalities. So if we were to try to combine

272
00:16:03,680 --> 00:16:10,160
<font color="#ffff54">각각 고유한 기능을 제공합니다. 따라서 만약 우리가</font>

273
00:16:10,720 --> 00:16:18,320
these two diagrams into one, where we want to achieve the physical architecture of a monolith,

274
00:16:10,720 --> 00:16:18,320
<font color="#ffff54">이 두 다이어그램을 하나로 합쳐서 모놀리스의 물리적 아키텍처를 구현하고자 합니다,</font>

275
00:16:18,320 --> 00:16:24,640
so that we have one system, and yet we want to keep this logical separation that we have

276
00:16:18,320 --> 00:16:24,640
<font color="#ffff54">그래서 우리는 하나의 시스템을 가지면서도 우리가 가지고 있는 이 논리적 분리를 유지하고 싶습니다.</font>

277
00:16:24,640 --> 00:16:31,280
with microservices, we would end up with something like this. So this is how a modular monolith would

278
00:16:24,640 --> 00:16:31,280
<font color="#ffff54">마이크로서비스를 사용하면 이렇게 될 것입니다. 따라서 모듈형 모놀리스는 이렇게 됩니다.</font>

279
00:16:32,079 --> 00:16:38,879
look like. Each of your services would now become a module inside of your modular monolith.

280
00:16:32,079 --> 00:16:38,879
<font color="#ffff54">처럼 보입니다. 이제 각 서비스는 모듈형 모놀리스 내부의 모듈이 됩니다.</font>

281
00:16:40,319 --> 00:16:46,000
But at the end of the day, this is still just one monolithic application. It's one physical

282
00:16:40,319 --> 00:16:46,000
<font color="#ffff54">하지만 결국 이것은 여전히 하나의 모놀리식 애플리케이션일 뿐입니다. 하나의 물리적</font>

283
00:16:46,000 --> 00:16:52,799
application. And all of your components or modules inside of the system are interacting with the

284
00:16:46,000 --> 00:16:52,799
<font color="#ffff54">애플리케이션입니다. 그리고 시스템 내부의 모든 컴포넌트 또는 모듈은</font>

285
00:16:52,799 --> 00:17:00,240
same database. Now I want to highlight here that there are explicit boundaries around the modules

286
00:16:52,799 --> 00:17:00,240
<font color="#ffff54">동일한 데이터베이스와 상호작용합니다. 이제 여기서 강조하고 싶은 것은 모듈 주변에 명시적인 경계가 있다는 것입니다.</font>

287
00:17:01,120 --> 00:17:07,120
and the arrows here are actually all pointing to the database. They don't represent interaction

288
00:17:01,120 --> 00:17:07,120
<font color="#ffff54">그리고 여기 화살표는 실제로 모두 데이터베이스를 가리키고 있습니다. 화살표는 상호 작용을 나타내지 않습니다.</font>

289
00:17:07,120 --> 00:17:16,000
between modules, although I will talk about that in a moment. So

290
00:17:07,120 --> 00:17:16,000
<font color="#ffff54">상호작용을 나타내지는 않지만, 이에 대해서는 잠시 후에 설명하겠습니다. 그래서</font>

291
00:17:18,720 --> 00:17:26,640
let's talk about what are the challenges of building a modular monolith. And as I walk

292
00:17:18,720 --> 00:17:26,640
<font color="#ffff54">모듈형 모놀리스를 구축할 때 어떤 어려움이 있는지 이야기해 보겠습니다. 그리고 제가 걸으면서</font>

293
00:17:26,640 --> 00:17:32,480
you through the challenges, it's going to become a lot clearer how you actually

294
00:17:26,640 --> 00:17:32,480
<font color="#ffff54">도전 과제를 해결해 나가다 보면, 실제로 어떻게 모듈형 모놀리스를</font>

295
00:17:32,480 --> 00:17:39,920
should build a modular monolith. So the first challenge is actually identifying and defining

296
00:17:32,480 --> 00:17:39,920
<font color="#ffff54">모듈형 모놀리스를 구축해야 하는지 알게 될 것입니다. 따라서 첫 번째 과제는 실제로 모듈형 모놀리스를</font>

297
00:17:39,920 --> 00:17:48,880
your modules and bounded contexts. The second challenge is solving communication between modules.

298
00:17:39,920 --> 00:17:48,880
<font color="#ffff54">모듈과 경계 컨텍스트를 식별하고 정의하는 것입니다. 두 번째 과제는 모듈 간의 통신을 해결하는 것입니다.</font>

299
00:17:48,880 --> 00:17:56,400
You'll see that there are multiple approaches to solve this. And the third challenge is solving

300
00:17:48,880 --> 00:17:56,400
<font color="#ffff54">이를 해결하기 위한 여러 가지 접근 방식이 있다는 것을 알 수 있습니다. 세 번째 과제는</font>

301
00:17:57,600 --> 00:18:03,520
data independence and isolation. I'll talk about this in depth in the last part.

302
00:17:57,600 --> 00:18:03,520
<font color="#ffff54">데이터 독립성과 격리입니다. 이에 대해서는 마지막 부분에서 자세히 설명하겠습니다.</font>

303
00:18:04,080 --> 00:18:13,280
So let's start with defining modules and bounded contexts. So what modules actually are supposed

304
00:18:04,080 --> 00:18:13,280
<font color="#ffff54">그럼 모듈과 바운디드 컨텍스트를 정의하는 것부터 시작하겠습니다. 모듈이란 실제로 어떤 것일까요?</font>

305
00:18:13,280 --> 00:18:21,680
to represent are cohesive sets of functionalities, where cohesive means something that naturally fits

306
00:18:13,280 --> 00:18:21,680
<font color="#ffff54">표현해야 하는 것은 응집력 있는 기능 집합이며, 여기서 응집력 있는 기능 집합이란</font>

307
00:18:21,680 --> 00:18:30,000
together. So if you recall from our previous example, we had a couple modules. For example,

308
00:18:21,680 --> 00:18:30,000
<font color="#ffff54">함께. 이전 예제에서 두 개의 모듈이 있었다는 것을 기억하실 것입니다. 예를 들어</font>

309
00:18:30,000 --> 00:18:36,880
probably something that you can easily relate to is orders. So everything around the orders

310
00:18:30,000 --> 00:18:36,880
<font color="#ffff54">아마도 여러분이 쉽게 공감할 수 있는 것은 주문일 것입니다. 따라서 주문과 관련된 모든 것</font>

311
00:18:37,279 --> 00:18:43,759
functionality will naturally flow together into a cohesive set of functionalities. We also call this

312
00:18:37,279 --> 00:18:43,759
<font color="#ffff54">의 모든 기능은 자연스럽게 하나의 응집력 있는 기능 집합으로 흘러갑니다. 우리는 이것을</font>

313
00:18:43,759 --> 00:18:49,920
a module. On the other hand, we have a catalog module, which covers everything related to

314
00:18:43,759 --> 00:18:49,920
<font color="#ffff54">모듈이라고도 합니다. 반면에 다음과 관련된 모든 것을 다루는 카탈로그 모듈이 있습니다.</font>

315
00:18:49,920 --> 00:18:58,960
representing line items and other things that are available inside of the eShop application. So one

316
00:18:49,920 --> 00:18:58,960
<font color="#ffff54">이 모듈은 eShop 애플리케이션 내에서 사용할 수 있는 품목 및 기타 항목을 나타냅니다. 그래서 하나</font>

317
00:19:01,600 --> 00:19:09,200
definition of what the module can be is the term bounded context, which comes from the book

318
00:19:01,600 --> 00:19:09,200
<font color="#ffff54">모듈이 무엇일 수 있는지에 대한 정의는 책에서 나온 용어인 바운드 컨텍스트입니다.</font>

319
00:19:09,200 --> 00:19:16,480
Domain Driven Design, which was written by Eric Evans. I recommend everyone should read this book,

320
00:19:09,200 --> 00:19:16,480
<font color="#ffff54">에릭 에반스가 쓴 도메인 중심 디자인(Domain Driven Design)에서 나온 용어입니다. 모든 사람이 이 책을 읽어보길 권합니다,</font>

321
00:19:16,480 --> 00:19:22,640
even though even if you may not like the ideas represented in the book and you don't want to use

322
00:19:16,480 --> 00:19:22,640
<font color="#ffff54">비록 이 책에 나오는 아이디어가 마음에 들지 않거나</font>

323
00:19:22,640 --> 00:19:27,920
them in your code, that's perfectly fine. But I think you're going to be a better engineer after

324
00:19:22,640 --> 00:19:27,920
<font color="#ffff54">코드에 사용하고 싶지 않더라도 괜찮습니다. 하지만 이 책을 읽고 나면 더 나은 엔지니어가 될 수 있을 겁니다.</font>

325
00:19:27,920 --> 00:19:36,799
reading this book because some ideas presented in the book are very, very good. One of those ideas

326
00:19:27,920 --> 00:19:36,799
<font color="#ffff54">이 책에 제시된 몇 가지 아이디어가 매우 훌륭하기 때문입니다. 그 아이디어 중 하나</font>

327
00:19:36,799 --> 00:19:45,039
is a bounded context. And what a bounded context means is it represents a boundary within a domain

328
00:19:36,799 --> 00:19:45,039
<font color="#ffff54">바운드 컨텍스트입니다. 바운디드 컨텍스트가 의미하는 바는 도메인 내의 경계를 나타냅니다.</font>

329
00:19:45,039 --> 00:19:55,519
where a particular domain model applies. So again, I'm coming back to the definition of modules,

330
00:19:45,039 --> 00:19:55,519
<font color="#ffff54">특정 도메인 모델이 적용되는 도메인 내의 경계를 나타냅니다. 다시 모듈의 정의로 돌아와서 설명하겠습니다,</font>

331
00:19:55,519 --> 00:20:02,399
where I highlighted that they kind of represent a boundary around a set of functionalities,

332
00:19:55,519 --> 00:20:02,399
<font color="#ffff54">여기서 저는 모듈이 일련의 기능을 둘러싼 경계를 나타낸다고 강조했습니다,</font>

333
00:20:02,399 --> 00:20:09,039
which also aligns with bounded contexts. And an interesting thing with bounded contexts is that

334
00:20:02,399 --> 00:20:09,039
<font color="#ffff54">이는 경계 컨텍스트와도 일치합니다. 바운디드 컨텍스트에서 흥미로운 점은</font>

335
00:20:09,039 --> 00:20:17,759
a single entity, or you can envision it as a table in the database, can belong to more than one

336
00:20:09,039 --> 00:20:17,759
<font color="#ffff54">단일 엔티티 또는 데이터베이스의 테이블로 상상할 수 있는 엔티티가 둘 이상에 속할 수 있다는 것입니다.</font>

337
00:20:17,759 --> 00:20:28,399
bounded context. An example of that can be a user. A user represents different things in the bounded

338
00:20:17,759 --> 00:20:28,399
<font color="#ffff54">바운드 컨텍스트에 속할 수 있습니다. 그 예로 사용자를 들 수 있습니다. 사용자는 바운드 컨텍스트에서 서로 다른 것을 나타냅니다.</font>

339
00:20:28,399 --> 00:20:34,639
context of an order and different thing in the bounded context of a payment and different thing

340
00:20:28,399 --> 00:20:34,639
<font color="#ffff54">주문과 다른 사물의 컨텍스트에서 결제와 다른 사물의 컨텍스트에서 다른 사물을 나타냅니다.</font>

341
00:20:34,640 --> 00:20:40,480
in the bounded context of a shipment, for example, but it's still the same physical entity.

342
00:20:34,640 --> 00:20:40,480
<font color="#ffff54">예를 들어, 배송의 경계 컨텍스트에서 다른 물건이지만 여전히 동일한 물리적 엔티티입니다.</font>

343
00:20:42,560 --> 00:20:50,960
So one way also to envision modules is that each module can be treated as a separate application.

344
00:20:42,560 --> 00:20:50,960
<font color="#ffff54">따라서 모듈을 구상하는 한 가지 방법은 각 모듈을 별도의 애플리케이션으로 취급할 수 있다는 것입니다.</font>

345
00:20:52,080 --> 00:20:59,200
This also has implications in how you define a module in your actual code, which I'm going to

346
00:20:52,080 --> 00:20:59,200
<font color="#ffff54">이는 실제 코드에서 모듈을 정의하는 방법에도 영향을 미칩니다.</font>

347
00:20:59,200 --> 00:21:06,799
talk about now. And I want to discuss how do you actually architect an individual module once you

348
00:20:59,200 --> 00:21:06,799
<font color="#ffff54">에 대해 이야기하겠습니다. 그리고 개별 모듈을 실제로 어떻게 설계하는지에 대해 논의하고 싶습니다.</font>

349
00:21:06,799 --> 00:21:14,240
have figured out what are these features that you believe belong to this module? What do you do next?

350
00:21:06,799 --> 00:21:14,240
<font color="#ffff54">이 모듈에 속한다고 생각되는 기능이 무엇인지 알아냈나요? 그 다음에는 무엇을 할까요?</font>

351
00:21:15,600 --> 00:21:22,559
So I said that you can envision a module as a separate application, which means that you need

352
00:21:15,600 --> 00:21:22,559
<font color="#ffff54">모듈을 별도의 애플리케이션으로 상상할 수 있다고 말씀드렸는데, 이는 다음이 필요하다는 뜻입니다.</font>

353
00:21:22,559 --> 00:21:28,400
to apply some sort of architecture to your module. And you're going to have many modules potentially

354
00:21:22,559 --> 00:21:28,400
<font color="#ffff54">이 필요하다는 뜻입니다. 그리고 잠재적으로 많은 모듈을 갖게 될 것입니다.</font>

355
00:21:28,400 --> 00:21:35,920
inside of your modular monolith. One example architecture that you can apply is the layered

356
00:21:28,400 --> 00:21:35,920
<font color="#ffff54">모듈 모놀리스 안에 잠재적으로 많은 모듈이 있을 것입니다. 적용할 수 있는 아키텍처의 한 가지 예는 계층화된</font>

357
00:21:35,920 --> 00:21:41,519
architecture, which is very standard. You have just three layers, one for your user interface,

358
00:21:35,920 --> 00:21:41,519
<font color="#ffff54">아키텍처가 매우 표준적입니다. 사용자 인터페이스를 위한 레이어는 세 개뿐입니다,</font>

359
00:21:41,519 --> 00:21:47,360
which in our case is probably going to be an API. Then you have one layer for your business logic

360
00:21:41,519 --> 00:21:47,360
<font color="#ffff54">이 경우 아마도 API가 될 것입니다. 그리고 비즈니스 로직을 위한 하나의 레이어가 있습니다.</font>

361
00:21:47,360 --> 00:21:55,600
and one more layer for the database. Another option for how you can architect a module is using

362
00:21:47,360 --> 00:21:55,600
<font color="#ffff54">그리고 데이터베이스용 레이어가 하나 더 있습니다. 모듈을 설계하는 방법에 대한 또 다른 옵션은</font>

363
00:21:55,600 --> 00:22:02,640
the clean architecture. If you're following me on social media, you probably know that I'm a big fan

364
00:21:55,600 --> 00:22:02,640
<font color="#ffff54">를 사용하는 것입니다. 소셜 미디어에서 저를 팔로우하고 계신다면 제가 열렬한 팬이라는 것을 알고 계실 겁니다.</font>

365
00:22:02,640 --> 00:22:09,440
of the clean architecture. This is because I've used it extensively on many projects and I have

366
00:22:02,640 --> 00:22:09,440
<font color="#ffff54">팬이라는 것을 알고 계실 겁니다. 여러 프로젝트에서 광범위하게 사용해왔고, 그 결과 저는</font>

367
00:22:09,440 --> 00:22:17,920
found it to be very good for solving many problems. With the clean architecture, you can represent

368
00:22:09,440 --> 00:22:17,920
<font color="#ffff54">많은 문제를 해결하는 데 매우 유용하다는 것을 알게 되었습니다. 깔끔한 아키텍처로 다음을 표현할 수 있습니다.</font>

369
00:22:17,920 --> 00:22:28,240
your layers of your domain. And when comprised together, all of the layers represent one module

370
00:22:17,920 --> 00:22:28,240
<font color="#ffff54">도메인의 레이어를 표현할 수 있습니다. 그리고 모든 레이어를 함께 구성하면 하나의 모듈을 나타냅니다.</font>

371
00:22:28,240 --> 00:22:35,200
and you can have more than one individual modules. And lastly, one architecture that has been gaining

372
00:22:28,240 --> 00:22:35,200
<font color="#ffff54">하나 이상의 개별 모듈을 가질 수 있습니다. 마지막으로, 최근 각광받고 있는 아키텍처 중 하나는</font>

373
00:22:35,200 --> 00:22:42,960
a lot of popularity recently is the vertical slice architecture, where you have a vertical slice

374
00:22:35,200 --> 00:22:42,960
<font color="#ffff54">최근 많은 인기를 얻고 있는 아키텍처는 수직 슬라이스 아키텍처입니다.</font>

375
00:22:42,960 --> 00:22:49,519
spanning all of the, for example, here are layers of the layered architecture, but kind of all of

376
00:22:42,960 --> 00:22:49,519
<font color="#ffff54">를 모두 아우르는, 예를 들어 여기에는 레이어드 아키텍처의 레이어가 있습니다.</font>

377
00:22:49,519 --> 00:22:55,920
them are physically placed together so that it's easier to navigate individual features.

378
00:22:49,519 --> 00:22:55,920
<font color="#ffff54">물리적으로 함께 배치되어 개별 기능을 더 쉽게 탐색할 수 있습니다.</font>

379
00:22:56,960 --> 00:23:03,360
So it doesn't matter really which architecture you choose for your modules. You even have the

380
00:22:56,960 --> 00:23:03,360
<font color="#ffff54">따라서 모듈에 어떤 아키텍처를 선택하든 상관없습니다. 심지어</font>

381
00:23:03,360 --> 00:23:09,600
freedom to choose different architectures for different modules. But what I want you to take

382
00:23:03,360 --> 00:23:09,600
<font color="#ffff54">모듈마다 다른 아키텍처를 선택할 수 있는 자유도 있습니다. 하지만 제가 원하는 것은</font>

383
00:23:09,600 --> 00:23:18,080
out of this is that one module should be architected like an individual application,

384
00:23:09,600 --> 00:23:18,080
<font color="#ffff54">하나의 모듈을 개별 애플리케이션처럼 아키텍처를 설계해야 한다는 것입니다,</font>

385
00:23:18,080 --> 00:23:27,520
even though it's part of your monolith. If you want to see a good example of what a

386
00:23:18,080 --> 00:23:27,520
<font color="#ffff54">모놀리스의 일부이긴 하지만요. 모놀리스의 좋은 예가 무엇인지 알고 싶다면</font>

387
00:23:27,520 --> 00:23:35,120
modular monolith looks like, here's a link to a repository on GitHub, which contains an example of

388
00:23:27,520 --> 00:23:35,120
<font color="#ffff54">모듈형 모놀리스가 어떻게 생겼는지 보고 싶으시다면, GitHub의 리포지토리로 연결되는 링크를 참조하세요.</font>

389
00:23:35,120 --> 00:23:41,920
a modular monolith with domain-driven design. I personally used this repository during my research

390
00:23:35,120 --> 00:23:41,920
<font color="#ffff54">도메인 중심 설계의 모듈형 모놀리스입니다. 저는 개인적으로 이 리포지토리를 연구하는 동안 이 리포지토리를 사용했습니다.</font>

391
00:23:41,920 --> 00:23:51,440
of modular monoliths and I found it very, very nice to kind of see what the concept is

392
00:23:41,920 --> 00:23:51,440
<font color="#ffff54">모듈형 모놀리스의 개념이 무엇인지 알 수 있어서 매우 좋았습니다.</font>

393
00:23:52,240 --> 00:23:56,160
and then try to kind of expand it with my own ideas.

394
00:23:52,240 --> 00:23:56,160
<font color="#ffff54">그리고 제 아이디어로 확장하려고 노력했습니다.</font>

395
00:24:00,160 --> 00:24:02,480
Thank you very much for sharing the link in the chat.

396
00:24:00,160 --> 00:24:02,480
<font color="#ffff54">채팅에서 링크를 공유해 주셔서 감사합니다.</font>

397
00:24:05,200 --> 00:24:11,280
So moving on, let's talk about communication between modules.

398
00:24:05,200 --> 00:24:11,280
<font color="#ffff54">이제 모듈 간의 통신에 대해 이야기해 보겠습니다.</font>

399
00:24:13,360 --> 00:24:20,480
So every module is going to expose some sort of public API that other modules can call.

400
00:24:13,360 --> 00:24:20,480
<font color="#ffff54">모든 모듈은 다른 모듈이 호출할 수 있는 일종의 공용 API를 노출하게 됩니다.</font>

401
00:24:21,440 --> 00:24:28,880
This public API can be maybe an interface that other modules can call to interact with that

402
00:24:21,440 --> 00:24:28,880
<font color="#ffff54">이 공용 API는 다른 모듈이 호출하여 상호 작용할 수 있는 인터페이스가 될 수 있습니다.</font>

403
00:24:28,880 --> 00:24:34,480
module that is exposing the public API, or it can be something else. I'm going to talk about that in

404
00:24:28,880 --> 00:24:34,480
<font color="#ffff54">모듈이 공개 API를 노출하는 인터페이스일 수도 있고, 다른 것일 수도 있습니다. 이에 대해서는</font>

405
00:24:34,480 --> 00:24:43,680
just a moment. Now, it's important that there are no references allowed to other modules in the

406
00:24:34,480 --> 00:24:43,680
<font color="#ffff54">잠시만요. 이제 다른 모듈에 대한 참조가 허용되지 않는 것이 중요합니다.</font>

407
00:24:43,680 --> 00:24:52,240
system except the public API. So if we have two modules, let's for example say that they are

408
00:24:43,680 --> 00:24:52,240
<font color="#ffff54">시스템에서 공용 API를 제외한 다른 모듈에 대한 참조가 허용되지 않는다는 것입니다. 예를 들어 두 개의 모듈이 있다고 가정해 보겠습니다.</font>

409
00:24:52,240 --> 00:25:01,759
architected using the vertical slice architecture, they are only allowed to call the public APIs that

410
00:24:52,240 --> 00:25:01,759
<font color="#ffff54">수직 슬라이스 아키텍처를 사용하여 설계된 두 모듈이 있다고 가정할 때, 이 모듈은 다음 두 모듈에 해당하는</font>

411
00:25:01,759 --> 00:25:10,240
they expose, and they cannot reference anything else inside of other modules. Now, this, how you

412
00:25:01,759 --> 00:25:10,240
<font color="#ffff54">만 호출할 수 있으며, 다른 모듈 내부의 다른 어떤 것도 참조할 수 없습니다. 이제, 어떻게</font>

413
00:25:10,240 --> 00:25:17,519
achieve this is you hide implementation details of your module modules internally. In C-Sharp,

414
00:25:10,240 --> 00:25:17,519
<font color="#ffff54">이를 달성하는 방법은 내부적으로 모듈 모듈의 구현 세부 사항을 숨기는 것입니다. C-Sharp에서,</font>

415
00:25:17,519 --> 00:25:25,279
you can achieve this using the internal keyword, which helps you hide the given class that is

416
00:25:17,519 --> 00:25:25,279
<font color="#ffff54">내부 키워드를 사용하여 이를 달성할 수 있는데, 이는 주어진 클래스를 숨기는 데 도움이 됩니다.</font>

417
00:25:25,279 --> 00:25:30,240
decorated with this keyword inside of that project. So this is how you can achieve kind

418
00:25:25,279 --> 00:25:30,240
<font color="#ffff54">이 키워드로 장식된 클래스를 프로젝트 내부에서 숨길 수 있습니다. 이렇게 하면 다음과 같이</font>

419
00:25:30,240 --> 00:25:36,880
of implementation hiding between modules and only expose a public API that other modules can call.

420
00:25:30,240 --> 00:25:36,880
<font color="#ffff54">의 구현을 모듈 사이에 숨기고 다른 모듈이 호출할 수 있는 공용 API만 노출합니다.</font>

421
00:25:37,440 --> 00:25:46,480
Now, when it comes to actually implementing this, you have two approaches. One approach is using

422
00:25:37,440 --> 00:25:46,480
<font color="#ffff54">이제 이를 실제로 구현할 때는 두 가지 접근 방식이 있습니다. 한 가지 접근 방식은</font>

423
00:25:46,480 --> 00:25:54,799
metacalls. So let's say the catalog module is exposing a public API and the other module is

424
00:25:46,480 --> 00:25:54,799
<font color="#ffff54">메타콜을 사용하는 것입니다. 카탈로그 모듈이 퍼블릭 API를 노출하고 있고 다른 모듈이</font>

425
00:25:54,799 --> 00:26:02,000
interested in calling that API. This is going to be an interface for the catalog module and also

426
00:25:54,799 --> 00:26:02,000
<font color="#ffff54">를 호출하는 데 관심이 있다고 가정해 보겠습니다. 이것은 카탈로그 모듈의 인터페이스가 될 것이며, 또한</font>

427
00:26:02,000 --> 00:26:07,119
the implementation is going to reside there, but the order module will be allowed to reference this

428
00:26:02,000 --> 00:26:07,119
<font color="#ffff54">구현은 거기에 상주하지만 주문 모듈은 이것을 참조할 수 있습니다.</font>

429
00:26:07,119 --> 00:26:15,200
interface and at runtime it's going to be provided the actual implementation. So the benefit of this

430
00:26:07,119 --> 00:26:15,200
<font color="#ffff54">인터페이스를 참조할 수 있게 되고 런타임에 실제 구현이 제공될 것입니다. 따라서 이것의 이점은</font>

431
00:26:15,200 --> 00:26:21,839
approach is it's really fast because you're relying on in-memory calls which are both reliable

432
00:26:15,200 --> 00:26:21,839
<font color="#ffff54">접근 방식의 장점은 신뢰할 수 있는 인메모리 호출에 의존하기 때문에 매우 빠르다는 것입니다.</font>

433
00:26:21,840 --> 00:26:31,120
and performant. You can only call the public API of other modules and the problem is,

434
00:26:21,840 --> 00:26:31,120
<font color="#ffff54">성능도 뛰어납니다. 다른 모듈의 공용 API만 호출할 수 있다는 점이 문제입니다,</font>

435
00:26:31,680 --> 00:26:39,840
and potential pain point, that this introduces runtime coupling. So you are calling the public

436
00:26:31,680 --> 00:26:39,840
<font color="#ffff54">런타임 커플링이 발생한다는 점과 잠재적인 문제점이 있습니다. 따라서 공용</font>

437
00:26:39,840 --> 00:26:47,360
interface of another module, but at runtime an interface can be instantiated. So if you are using

438
00:26:39,840 --> 00:26:47,360
<font color="#ffff54">인터페이스를 호출할 수 있지만 런타임에 인터페이스가 인스턴스화될 수 있습니다. 따라서 만약 당신이</font>

439
00:26:47,360 --> 00:26:52,800
the interface, something has to implement that interface and actually run that code. So you're

440
00:26:47,360 --> 00:26:52,800
<font color="#ffff54">을 사용한다면, 무언가가 해당 인터페이스를 구현하고 실제로 해당 코드를 실행해야 합니다. 따라서 여러분은</font>

441
00:26:52,800 --> 00:26:59,360
introducing coupling at runtime, which may not be apparent, but it's something you have to consider,

442
00:26:52,800 --> 00:26:59,360
<font color="#ffff54">런타임에 커플링을 도입하는 것인데, 눈에 잘 띄지 않을 수도 있지만 반드시 고려해야 할 사항입니다,</font>

443
00:26:59,360 --> 00:27:07,680
and that is because if you ever wanted to extract individual modules into separate services,

444
00:26:59,360 --> 00:27:07,680
<font color="#ffff54">개별 모듈을 별도의 서비스로 추출하고 싶을 때가 있기 때문입니다,</font>

445
00:27:07,680 --> 00:27:13,200
so now you're moving from a modular monolith into a microservice system, and you were using

446
00:27:07,680 --> 00:27:13,200
<font color="#ffff54">따라서 이제 모듈형 모놀리스에서 마이크로서비스 시스템으로 이동하고 있고, 여러분은</font>

447
00:27:13,200 --> 00:27:19,680
method calls, your implementation would break because now your other module, for example,

448
00:27:13,200 --> 00:27:19,680
<font color="#ffff54">메서드 호출을 사용했다면 이제 다른 모듈, 예를 들어</font>

449
00:27:19,680 --> 00:27:25,120
let's say the catalog module here, if it were a separate application, then those are different

450
00:27:19,680 --> 00:27:25,120
<font color="#ffff54">여기서 카탈로그 모듈이 별도의 애플리케이션이라고 가정해 보겠습니다.</font>

451
00:27:25,120 --> 00:27:32,080
memories and you can't execute memory calls. So you would have to re-implement that public

452
00:27:25,120 --> 00:27:32,080
<font color="#ffff54">메모리 호출을 실행할 수 없습니다. 따라서 해당 공개 모듈을 다시 구현해야 합니다.</font>

453
00:27:32,080 --> 00:27:39,600
interface, probably using HTTP calls over the network to be able to talk to other modules.

454
00:27:32,080 --> 00:27:39,600
<font color="#ffff54">인터페이스를 다시 구현해야 하며, 아마도 다른 모듈과 통신하기 위해 네트워크를 통해 HTTP 호출을 사용해야 할 것입니다.</font>

455
00:27:40,560 --> 00:27:49,440
So now you switched runtime coupling for strong coupling over HTTP. So because of this,

456
00:27:40,560 --> 00:27:49,440
<font color="#ffff54">이제 런타임 커플링을 HTTP를 통한 강력한 커플링으로 전환했습니다. 그래서 이 때문에</font>

457
00:27:50,880 --> 00:27:57,120
there's a different approach, which I'm very, I'm more a fan of than the previous one,

458
00:27:50,880 --> 00:27:57,120
<font color="#ffff54">다른 접근 방식이 생겼는데, 저는 이 접근 방식이 이전 방식보다 더 마음에 듭니다,</font>

459
00:27:57,680 --> 00:28:05,840
and this is module communication using messaging. So the benefit of this approach is that it is

460
00:27:57,680 --> 00:28:05,840
<font color="#ffff54">메시징을 이용한 모듈 통신입니다. 이 접근법의 장점은 다음과 같습니다.</font>

461
00:28:05,840 --> 00:28:13,760
asynchronous. If modules want to interact with each other, they send messages over a message bus.

462
00:28:05,840 --> 00:28:13,760
<font color="#ffff54">비동기식입니다. 모듈이 서로 상호 작용하려면 메시지 버스를 통해 메시지를 보냅니다.</font>

463
00:28:15,280 --> 00:28:23,520
It is also possible to implement RPC-like calls over a message bus. So if you're familiar with

464
00:28:15,280 --> 00:28:23,520
<font color="#ffff54">메시지 버스를 통해 RPC와 유사한 호출을 구현할 수도 있습니다. 따라서</font>

465
00:28:24,080 --> 00:28:31,920
a library that is called mass transit, it implements this request response communication

466
00:28:24,080 --> 00:28:31,920
<font color="#ffff54">라는 라이브러리에서 이러한 요청 응답 통신을 구현합니다.</font>

467
00:28:31,920 --> 00:28:39,440
model, where let's say the order module wants to request something from the catalog module.

468
00:28:31,920 --> 00:28:39,440
<font color="#ffff54">모델에서 주문 모듈이 카탈로그 모듈에 무언가를 요청한다고 가정해 보겠습니다.</font>

469
00:28:40,160 --> 00:28:45,600
It would send a message to the queue. The catalog module would receive this message,

470
00:28:40,160 --> 00:28:45,600
<font color="#ffff54">이 모듈은 대기열에 메시지를 보냅니다. 카탈로그 모듈은 이 메시지를 수신합니다,</font>

471
00:28:45,600 --> 00:28:50,640
handle it, and then send the message back, which would go back to the order module. Now, of course,

472
00:28:45,600 --> 00:28:50,640
<font color="#ffff54">처리한 다음 메시지를 다시 보내면 주문 모듈로 다시 전달됩니다. 물론 이제</font>

473
00:28:50,640 --> 00:28:56,720
this subtracts away some important implementation details, like which queues are being used,

474
00:28:50,640 --> 00:28:56,720
<font color="#ffff54">이렇게 하면 어떤 대기열이 사용 중인지와 같은 중요한 구현 세부 정보가 사라집니다,</font>

475
00:28:56,720 --> 00:29:02,240
and also you need some sort of correlation ID between messages so that you know what message

476
00:28:56,720 --> 00:29:02,240
<font color="#ffff54">또한 어떤 메시지가 어떤 메시지인지 알 수 있도록 메시지 간의 일종의 상관 관계 ID가 필요합니다.</font>

477
00:29:02,240 --> 00:29:07,839
you are waiting back. But if you don't want to deal with these complexities, the mass transit

478
00:29:02,240 --> 00:29:07,839
<font color="#ffff54">를 기다리고 있는지 알 수 있습니다. 그러나 이러한 복잡성을 처리하고 싶지 않다면 대량 전송</font>

479
00:29:07,839 --> 00:29:18,319
library implements this very nicely. So how you interact between modules using messaging is you

480
00:29:07,839 --> 00:29:18,319
<font color="#ffff54">라이브러리가 이를 매우 훌륭하게 구현합니다. 따라서 메시지를 사용하여 모듈 간에 상호 작용하는 방법은 여러분이</font>

481
00:29:18,319 --> 00:29:26,640
define contracts or interfaces for your messages, and you can share these contracts using maybe a

482
00:29:18,319 --> 00:29:26,640
<font color="#ffff54">메시지에 대한 컨트랙트나 인터페이스를 정의하고, 아마도</font>

483
00:29:27,440 --> 00:29:33,280
NuGet package or a shared library where either all your contracts for a single module reside,

484
00:29:27,440 --> 00:29:33,280
<font color="#ffff54">NuGet 패키지 또는 단일 모듈에 대한 모든 컨트랙트가 있는 공유 라이브러리를 사용할 수 있습니다,</font>

485
00:29:33,840 --> 00:29:39,200
or you can even share all of the contracts for the entire application and kind of manage them all in

486
00:29:33,840 --> 00:29:39,200
<font color="#ffff54">또는 전체 애플리케이션에 대한 모든 컨트랙트를 공유하고 이를 모두</font>

487
00:29:39,200 --> 00:29:46,640
one place. So the benefit of communication like this is that it is decoupled. If you do a thought

488
00:29:39,200 --> 00:29:46,640
<font color="#ffff54">한 곳에서 관리할 수 있습니다. 이와 같은 커뮤니케이션의 장점은 분리되어 있다는 것입니다. 생각을 하면</font>

489
00:29:46,640 --> 00:29:52,720
experiment, let's say we want to again pull out the catalog module into a separate service.

490
00:29:46,640 --> 00:29:52,720
<font color="#ffff54">다시 카탈로그 모듈을 별도의 서비스로 분리한다고 가정해 보겠습니다.</font>

491
00:29:53,120 --> 00:29:59,120
If we were using a message bus and everything was going over the bus by sending messages,

492
00:29:53,120 --> 00:29:59,120
<font color="#ffff54">메시지 버스를 사용하고 있고 모든 것이 메시지 전송을 통해 버스를 통해 이루어지고 있다고 가정해 봅시다,</font>

493
00:30:00,000 --> 00:30:05,600
everything would still function the same because we are not relying on in-memory call to implement

494
00:30:00,000 --> 00:30:05,600
<font color="#ffff54">구현하기 위해 인메모리 호출에 의존하지 않기 때문에 모든 것이 여전히 동일하게 작동합니다.</font>

495
00:30:05,600 --> 00:30:12,480
communication. We are using an external system which still exists even if we were to go from a

496
00:30:05,600 --> 00:30:12,480
<font color="#ffff54">통신을 구현하기 위해 인메모리 호출에 의존하지 않기 때문입니다. 우리는 여전히 존재하는 외부 시스템을 사용하고 있습니다.</font>

497
00:30:12,480 --> 00:30:18,480
modular monolith into microservices. So this is one very big advantage of this approach. Of course,

498
00:30:12,480 --> 00:30:18,480
<font color="#ffff54">모듈형 모놀리스를 마이크로서비스로 전환하더라도 여전히 존재하는 외부 시스템을 사용하고 있습니다. 이것이 바로 이 접근 방식의 매우 큰 장점입니다. 물론이죠,</font>

499
00:30:19,279 --> 00:30:26,160
the downside is that you do get reduced performance if you rely on too much messaging.

500
00:30:19,279 --> 00:30:26,160
<font color="#ffff54">단점은 너무 많은 메시징에 의존하면 성능이 저하될 수 있다는 것입니다.</font>

501
00:30:27,200 --> 00:30:35,120
So you're making a trade-off. If you expect that your modular monolith is realistically going to

502
00:30:27,200 --> 00:30:35,120
<font color="#ffff54">그래서 절충안을 만들어야 합니다. 모듈형 모놀리스가 현실적으로 다음과 같은 성능을 낼 것으로 예상한다면</font>

503
00:30:35,120 --> 00:30:40,240
move into microservices, maybe you're better off using this approach from the start of your project.

504
00:30:35,120 --> 00:30:40,240
<font color="#ffff54">마이크로서비스로 전환하는 것이 현실적으로 어렵다면 프로젝트 시작부터 이 접근 방식을 사용하는 것이 더 나을 수도 있습니다.</font>

505
00:30:41,680 --> 00:30:46,799
And again, the benefit is it's easy to extract modules into separate services.

506
00:30:41,680 --> 00:30:46,799
<font color="#ffff54">다시 말하지만, 모듈을 별도의 서비스로 추출하기가 쉽다는 이점이 있습니다.</font>

507
00:30:48,480 --> 00:30:56,559
This is kind of the high level of how you communicate between your modules. You can either use

508
00:30:48,480 --> 00:30:56,559
<font color="#ffff54">이것은 모듈 간에 통신하는 방법의 높은 수준입니다. 다음 중 하나를 사용할 수 있습니다.</font>

509
00:30:57,279 --> 00:31:03,120
memory in-memory metal calls or you can use messaging over a message bus. For example,

510
00:30:57,279 --> 00:31:03,120
<font color="#ffff54">메모리 인메모리 메탈 호출을 사용하거나 메시지 버스를 통한 메시징을 사용할 수 있습니다. 예를 들어</font>

511
00:31:03,120 --> 00:31:14,559
we used a Revit MQ. Now another important thing that you need to consider apart from messaging is

512
00:31:03,120 --> 00:31:14,559
<font color="#ffff54">에서는 Revit MQ를 사용했습니다. 이제 메시징과 별도로 고려해야 할 또 다른 중요한 사항이 있습니다.</font>

513
00:31:15,359 --> 00:31:23,359
the independence of data between modules. So every module is responsible for its own data.

514
00:31:15,359 --> 00:31:23,359
<font color="#ffff54">모듈 간 데이터의 독립성입니다. 즉, 모든 모듈은 자체 데이터를 책임집니다.</font>

515
00:31:28,240 --> 00:31:37,200
So this is a constraint that you have to impose on the system because if you break this and you

516
00:31:28,240 --> 00:31:37,200
<font color="#ffff54">따라서 이것은 시스템에 부과해야 하는 제약 조건입니다. 왜냐하면 이것을 위반하면</font>

517
00:31:37,200 --> 00:31:44,160
allow sharing of data between your modules, then you're going to end up with a mess.

518
00:31:37,200 --> 00:31:44,160
<font color="#ffff54">모듈 간에 데이터 공유를 허용하면 결국 엉망이 될 것이기 때문입니다.</font>

519
00:31:45,519 --> 00:31:55,440
So another rule that you have to enforce in your application is that querying data directly

520
00:31:45,519 --> 00:31:55,440
<font color="#ffff54">따라서 애플리케이션에 적용해야 하는 또 다른 규칙은 데이터를 직접 쿼리하는 것은</font>

521
00:31:55,440 --> 00:32:03,039
from different modules in the system is not allowed, which comes hand in hand with the fact

522
00:31:55,440 --> 00:32:03,039
<font color="#ffff54">데이터를 직접 쿼리하는 것은 허용되지 않는다는 것입니다.</font>

523
00:32:03,039 --> 00:32:11,920
that every module needs to be responsible for its own data. And to achieve this, you have different

524
00:32:03,039 --> 00:32:11,920
<font color="#ffff54">모든 모듈이 자신의 데이터를 책임져야 한다는 사실과 관련이 있습니다. 그리고 이를 달성하기 위해</font>

525
00:32:11,920 --> 00:32:18,480
levels of data isolation that you can resort to. And I'm going to talk about these data isolation

526
00:32:11,920 --> 00:32:18,480
<font color="#ffff54">데이터 격리 수준을 선택할 수 있습니다. 이러한 데이터 격리에 대해 설명하겠습니다.</font>

527
00:32:18,480 --> 00:32:26,480
levels right now. But again, I want to stress and highlight this again. Every module in your system

528
00:32:18,480 --> 00:32:26,480
<font color="#ffff54">수준에 대해 설명하겠습니다. 하지만 다시 한 번 강조하고 강조하고 싶습니다. 시스템의 모든 모듈</font>

529
00:32:26,480 --> 00:32:34,160
has to be responsible for its own data and there is no querying of data from other modules. So you

530
00:32:26,480 --> 00:32:34,160
<font color="#ffff54">는 자체 데이터를 책임져야 하며 다른 모듈의 데이터를 쿼리할 수 없습니다. 따라서</font>

531
00:32:34,160 --> 00:32:41,920
can't directly access the database of other modules. So let's talk about how we can isolate

532
00:32:34,160 --> 00:32:41,920
<font color="#ffff54">다른 모듈의 데이터베이스에 직접 액세스할 수 없습니다. 따라서 어떻게 분리할 수 있는지 이야기해 보겠습니다.</font>

533
00:32:41,920 --> 00:32:50,480
data between modules. So there are four levels and the first level is no isolation. So everything is

534
00:32:41,920 --> 00:32:50,480
<font color="#ffff54">데이터를 격리하는 방법에 대해 알아보겠습니다. 네 가지 수준이 있으며 첫 번째 수준은 격리가 없습니다. 따라서 모든 것이</font>

535
00:32:51,120 --> 00:32:57,599
in one physical database and there is no isolation between modules. And this is

536
00:32:51,120 --> 00:32:57,599
<font color="#ffff54">하나의 물리적 데이터베이스에 있으며 모듈 간에 격리되지 않습니다. 그리고 이것은</font>

537
00:32:58,480 --> 00:33:03,519
the worst approach possible and definitely the one that you should not even consider.

538
00:32:58,480 --> 00:33:03,519
<font color="#ffff54">최악의 접근 방식이며 절대 고려하지 말아야 할 접근 방식입니다.</font>

539
00:33:04,559 --> 00:33:12,799
So here the problem is you are probably using foreign keys between tables in different modules,

540
00:33:04,559 --> 00:33:12,799
<font color="#ffff54">여기서 문제는 아마도 다른 모듈의 테이블 간에 외래 키를 사용하고 있다는 것입니다,</font>

541
00:33:12,799 --> 00:33:18,480
which introduces coupling. So if you tried to extract these tables, you would run into a problem

542
00:33:12,799 --> 00:33:18,480
<font color="#ffff54">를 사용하여 커플링이 발생한다는 것입니다. 따라서 이러한 테이블을 추출하려고 하면 다음과 같은 문제가 발생합니다.</font>

543
00:33:18,480 --> 00:33:25,360
because your foreign keys would now break and so on. So one level up in terms of isolation

544
00:33:18,480 --> 00:33:25,360
<font color="#ffff54">외래 키가 깨지는 등의 문제가 발생합니다. 따라서 분리 측면에서 한 단계 업그레이드되었습니다.</font>

545
00:33:26,160 --> 00:33:33,759
is still using the same database, but using a different schema per module. So now you're,

546
00:33:26,160 --> 00:33:33,759
<font color="#ffff54">는 여전히 동일한 데이터베이스를 사용하지만 모듈별로 다른 스키마를 사용합니다. 이제 여러분은</font>

547
00:33:34,559 --> 00:33:39,519
okay, you're still in the same database, but you're achieving at least logical separation

548
00:33:34,559 --> 00:33:39,519
<font color="#ffff54">좋아, 여전히 같은 데이터베이스를 사용하고 있지만 최소한 논리적 분리는 이루어지고 있습니다.</font>

549
00:33:40,079 --> 00:33:47,599
of tables inside of the database. So in the example here, each of the modules from our example

550
00:33:40,079 --> 00:33:47,599
<font color="#ffff54">의 테이블을 분리합니다. 따라서 여기 예제에서 예제의 각 모듈은</font>

551
00:33:47,600 --> 00:33:57,120
architecture has its own schema. And another thing that you want to impose here is to not use

552
00:33:47,600 --> 00:33:57,120
<font color="#ffff54">아키텍처에는 고유한 스키마가 있습니다. 그리고 여기서 한 가지 더 강조하고 싶은 것은</font>

553
00:33:57,120 --> 00:34:04,720
foreign keys, even though you can, because this is going to make it easier for you to migrate into

554
00:33:57,120 --> 00:34:04,720
<font color="#ffff54">외래 키를 사용할 수 있지만, 이렇게 하면 마이그레이션이 더 쉬워지므로</font>

555
00:34:04,720 --> 00:34:12,640
more constructive levels of data isolation. And again, each module can only query the tables from

556
00:34:04,720 --> 00:34:12,640
<font color="#ffff54">보다 건설적인 수준의 데이터 격리가 가능합니다. 그리고 다시 말하지만, 각 모듈은 다음의 테이블만 쿼리할 수 있습니다.</font>

557
00:34:12,639 --> 00:34:17,920
its own schema. So no querying between schemas. That's very important to have a proper modular

558
00:34:12,639 --> 00:34:17,920
<font color="#ffff54">까지만 쿼리할 수 있습니다. 따라서 스키마 간 쿼리는 불가능합니다. 이는 제대로 된 모듈형 데이터베이스에 매우 중요합니다.</font>

559
00:34:17,920 --> 00:34:28,239
modulif. Now the next level of isolation, if separate schemas are not enough, is using

560
00:34:17,920 --> 00:34:28,239
<font color="#ffff54">모듈리프. 이제 분리된 스키마로 충분하지 않은 경우 다음 단계의 격리는</font>

561
00:34:28,239 --> 00:34:35,440
different physical databases. So let's say we're still using SQL, but each of our modules has its

562
00:34:28,239 --> 00:34:35,440
<font color="#ffff54">다른 물리적 데이터베이스를 사용하는 것입니다. 따라서 여전히 SQL을 사용하고 있지만 각 모듈에 각각</font>

563
00:34:35,440 --> 00:34:42,400
own database. Now this can all be on the same database server, but at least it's a separate

564
00:34:35,440 --> 00:34:42,400
<font color="#ffff54">자체 데이터베이스를 가지고 있습니다. 이제 이 모든 것이 동일한 데이터베이스 서버에 있을 수도 있지만, 적어도 별도의</font>

565
00:34:42,400 --> 00:34:48,079
physically isolated database. So you can't really easily query between the databases without

566
00:34:42,400 --> 00:34:48,079
<font color="#ffff54">물리적으로 격리된 데이터베이스입니다. 따라서 데이터베이스 간에 쉽게 쿼리할 수 없습니다.</font>

567
00:34:48,079 --> 00:34:54,800
introducing a distributed transaction and you don't want to go there. So this is probably

568
00:34:48,079 --> 00:34:54,800
<font color="#ffff54">분산 트랜잭션을 도입하지 않고는 쉽게 쿼리할 수 없습니다. 따라서 이것은 아마도</font>

569
00:34:55,440 --> 00:35:00,559
something that you may want to consider, either this approach or this approach, if you were to

570
00:34:55,440 --> 00:35:00,559
<font color="#ffff54">이 접근 방식이나 이 접근 방식 중 하나를 고려할 수 있습니다.</font>

571
00:35:00,559 --> 00:35:07,519
start out. And then there is one more level, which is kind of exotic, but if you need this

572
00:35:00,559 --> 00:35:07,519
<font color="#ffff54">시작하세요. 그리고 한 단계 더 있는데, 다소 이색적이지만 다음과 같은 방법이 필요합니다.</font>

573
00:35:07,519 --> 00:35:16,079
kind of isolation, it's very interesting. And that is, now you have different databases for each

574
00:35:07,519 --> 00:35:16,079
<font color="#ffff54">고립된 상태라면 매우 흥미롭습니다. 즉, 이제 각각에 대해 서로 다른 데이터베이스를 갖게 됩니다.</font>

575
00:35:16,079 --> 00:35:23,440
module, but you're also using different database type or database management system. So let's say

576
00:35:16,079 --> 00:35:23,440
<font color="#ffff54">모듈에 대해 서로 다른 데이터베이스 유형 또는 데이터베이스 관리 시스템을 사용하고 있다는 것입니다. 따라서 다음과 같이 가정해 보겠습니다.</font>

577
00:35:24,400 --> 00:35:31,440
for the order module, we want that relational guarantees and joins. So we opted for a SQL

578
00:35:24,400 --> 00:35:31,440
<font color="#ffff54">주문 모듈의 경우 관계형 보증 및 조인이 필요합니다. 그래서 우리는 SQL</font>

579
00:35:31,440 --> 00:35:37,360
database. Now for the catalog module, where we are dealing with products and product information

580
00:35:31,440 --> 00:35:37,360
<font color="#ffff54">데이터베이스를 선택했습니다. 이제 제품 및 제품 정보를 다루는 카탈로그 모듈을 살펴보겠습니다.</font>

581
00:35:37,360 --> 00:35:44,240
and a lot of unstructured data, we want to use maybe a document database. For the customers

582
00:35:37,360 --> 00:35:44,240
<font color="#ffff54">그리고 많은 비정형 데이터는 문서 데이터베이스를 사용하려고 합니다. 고객을 위해</font>

583
00:35:44,240 --> 00:35:49,920
module, where we have a lot of relationships between customers, we opted for a graph database

584
00:35:44,240 --> 00:35:49,920
<font color="#ffff54">모듈의 경우 고객 간의 관계가 많기 때문에 그래프 데이터베이스를 선택했습니다.</font>

585
00:35:49,920 --> 00:35:54,720
and for collaboration for some reason, just to make this slide look better probably,

586
00:35:49,920 --> 00:35:54,720
<font color="#ffff54">그리고 어떤 이유에서인지 협업을 위해, 아마도 이 슬라이드를 더 보기 좋게 만들기 위해서였을 것입니다,</font>

587
00:35:54,720 --> 00:36:01,519
we used a column store database. So you can even do something like this, where you have both

588
00:35:54,720 --> 00:36:01,519
<font color="#ffff54">열 저장소 데이터베이스를 사용했습니다. 따라서 다음과 같은 작업을 수행할 수도 있습니다.</font>

589
00:36:01,519 --> 00:36:07,680
physically separate databases between modules and also an entirely different database type,

590
00:36:01,519 --> 00:36:07,680
<font color="#ffff54">모듈 간에 물리적으로 분리된 데이터베이스와 완전히 다른 데이터베이스 유형을 사용할 수도 있습니다,</font>

591
00:36:07,680 --> 00:36:16,800
which fits the needs of that module. So you have a lot of freedom when it comes to

592
00:36:07,680 --> 00:36:16,800
<font color="#ffff54">모듈의 필요에 맞는 데이터베이스를 만들 수 있습니다. 따라서 다음과 같은 측면에서 많은 자유를 누릴 수 있습니다.</font>

593
00:36:17,680 --> 00:36:25,440
how much isolation you want to impose on your database. A good start again is probably using

594
00:36:17,680 --> 00:36:25,440
<font color="#ffff54">데이터베이스에 얼마나 많은 격리를 적용할지 결정할 수 있습니다. 다시 시작하는 것이 좋습니다.</font>

595
00:36:25,440 --> 00:36:32,000
either the same database and a different schema per module or using different databases,

596
00:36:25,440 --> 00:36:32,000
<font color="#ffff54">동일한 데이터베이스와 모듈마다 다른 스키마를 사용하거나 다른 데이터베이스를 사용하는 것입니다,</font>

597
00:36:32,000 --> 00:36:37,519
but still using the same database type. For example, all of your databases are PostgreSQL.

598
00:36:32,000 --> 00:36:37,519
<font color="#ffff54">이지만 여전히 동일한 데이터베이스 유형을 사용합니다. 예를 들어 모든 데이터베이스가 PostgreSQL인 경우입니다.</font>

599
00:36:37,519 --> 00:36:47,840
And this more or less wraps up the story of how you can build a modular monolith.

600
00:36:37,519 --> 00:36:47,840
<font color="#ffff54">이것으로 모듈형 모놀리스를 구축하는 방법에 대한 이야기가 어느 정도 마무리되었습니다.</font>

601
00:36:47,840 --> 00:36:54,880
And I want to share with you a few lessons, a few hardships that we encountered

602
00:36:47,840 --> 00:36:54,880
<font color="#ffff54">그리고 몇 가지 교훈과 우리가 겪은 몇 가지 어려움을 여러분과 나누고 싶습니다.</font>

603
00:36:56,320 --> 00:36:59,679
in the previous two years while working on this architecture,

604
00:36:56,320 --> 00:36:59,679
<font color="#ffff54">지난 2년간 이 아키텍처를 개발하면서 겪었던 어려움들을요,</font>

605
00:37:00,880 --> 00:37:05,039
so that you don't have to make the same mistakes that we did.

606
00:37:00,880 --> 00:37:05,039
<font color="#ffff54">여러분은 우리와 같은 실수를 하지 않아도 됩니다.</font>

607
00:37:08,400 --> 00:37:16,239
So the first lesson or learning that I would like to share is you should spend more time

608
00:37:08,400 --> 00:37:16,239
<font color="#ffff54">그래서 제가 나누고 싶은 첫 번째 교훈이나 배움은 더 많은 시간을 투자해야 한다는 것입니다.</font>

609
00:37:17,199 --> 00:37:22,719
defining module boundaries, and I promise it's going to pay dividends later.

610
00:37:17,199 --> 00:37:22,719
<font color="#ffff54">모듈 경계를 정의하는 데 더 많은 시간을 투자해야 한다는 것입니다.</font>

611
00:37:24,480 --> 00:37:32,719
This is because when you're first starting out, it really isn't apparent how your system is going

612
00:37:24,480 --> 00:37:32,719
<font color="#ffff54">처음 시작할 때는 시스템이 어떻게 돌아가는지 명확하지 않기 때문입니다.</font>

613
00:37:32,720 --> 00:37:38,800
to evolve. So if you spend a considerable amount of time at the beginning of the project,

614
00:37:32,720 --> 00:37:38,800
<font color="#ffff54">진화할지 알 수 없기 때문입니다. 따라서 프로젝트 초기에 상당한 시간을 할애하면</font>

615
00:37:39,680 --> 00:37:46,160
just thinking how your system is going to grow, what are the parts of the system that kind of

616
00:37:39,680 --> 00:37:46,160
<font color="#ffff54">시스템이 어떻게 성장할지, 시스템의 어떤 부분이 어떤 식으로</font>

617
00:37:46,720 --> 00:37:52,800
we may want to make independent in the future, you're going to end up with a lot better defined

618
00:37:46,720 --> 00:37:52,800
<font color="#ffff54">우리가 미래에 독립하고 싶을지도 모른다고 생각하면, 훨씬 더 잘 정의되고</font>

619
00:37:52,800 --> 00:38:00,080
modules. And this is going to allow you to both develop your system faster and kind of later

620
00:37:52,800 --> 00:38:00,080
<font color="#ffff54">모듈을 갖게 될 것입니다. 이렇게 하면 시스템을 더 빠르게 개발할 수 있을 뿐 아니라 나중에</font>

621
00:38:00,079 --> 00:38:08,559
scale it out in a much more performant way. So the next thing is about eventual consistency,

622
00:38:00,079 --> 00:38:08,559
<font color="#ffff54">훨씬 더 고성능으로 확장할 수 있습니다. 다음은 최종적인 일관성에 관한 것입니다,</font>

623
00:38:09,199 --> 00:38:16,239
and eventual consistency is great. You can achieve it in a modular system, in a modular

624
00:38:09,199 --> 00:38:16,239
<font color="#ffff54">그리고 최종적인 일관성은 훌륭합니다. 모듈형 시스템에서, 모듈형 시스템에서, 모듈형 시스템에서 이를 달성할 수 있습니다.</font>

625
00:38:16,239 --> 00:38:23,679
monolith system. You should definitely use it, but you need to plan for it. So one issue that we ran

626
00:38:16,239 --> 00:38:23,679
<font color="#ffff54">모놀리스 시스템. 반드시 사용해야 하지만 이에 대한 계획이 필요합니다. 그래서 우리가 실행한 한 가지 이슈는</font>

627
00:38:23,679 --> 00:38:33,759
into was we designed all of our modules to be independent and they were communicating by using

628
00:38:23,679 --> 00:38:33,759
<font color="#ffff54">모든 모듈을 독립적으로 설계하고, 모듈이 통신할 때</font>

629
00:38:34,319 --> 00:38:40,559
messages over the service bus. And we kind of implemented the entire system to be eventually

630
00:38:34,319 --> 00:38:40,559
<font color="#ffff54">메시지를 사용하여 통신했습니다. 그리고 전체 시스템을 구현하여 결국에는</font>

631
00:38:40,559 --> 00:38:47,839
consistent. And we ran into an issue where kind of the eventual consistency came back to bite us.

632
00:38:40,559 --> 00:38:47,839
<font color="#ffff54">일관성을 유지했습니다. 그런데 이 일관성이 결국 문제가 되어 돌아왔습니다.</font>

633
00:38:48,720 --> 00:38:56,079
So you have to consider how eventual consistency is going to reflect on your user experience

634
00:38:48,720 --> 00:38:56,079
<font color="#ffff54">따라서 최종적인 일관성이 사용자 경험에 어떻게 반영될지 고려해야 합니다.</font>

635
00:38:57,519 --> 00:39:03,440
and maybe where you don't have the luxury of using eventual consistency,

636
00:38:57,519 --> 00:39:03,440
<font color="#ffff54">최종 일관성을 사용할 여건이 되지 않을 수도 있습니다,</font>

637
00:39:05,200 --> 00:39:11,440
because some changes in your data may be slow to reflect on the user interface,

638
00:39:05,200 --> 00:39:11,440
<font color="#ffff54">데이터의 일부 변경 사항이 사용자 인터페이스에 반영되는 속도가 느릴 수 있기 때문입니다,</font>

639
00:39:11,440 --> 00:39:19,039
and this is going to lead to bad user experience. Now there are ways to go around this.

640
00:39:11,440 --> 00:39:19,039
<font color="#ffff54">이는 사용자 경험 저하로 이어질 수 있습니다. 이제 이 문제를 해결할 수 있는 방법이 있습니다.</font>

641
00:39:19,679 --> 00:39:27,920
For example, your user interface can do eager updates, kind of behave like the update is already

642
00:39:19,679 --> 00:39:27,920
<font color="#ffff54">예를 들어, 사용자 인터페이스에서 업데이트가 이미 완료된 것처럼 동작하도록 할 수 있습니다.</font>

643
00:39:27,920 --> 00:39:34,880
applied in the database and wait for the server to respond to kind of confirm, yes, this went through

644
00:39:27,920 --> 00:39:34,880
<font color="#ffff54">데이터베이스에 적용하고 서버가 일종의 확인을 위해 응답할 때까지 기다립니다.</font>

645
00:39:35,440 --> 00:39:44,160
or no, it didn't. Another thing is you can have maybe some sort of WebSockets connection

646
00:39:35,440 --> 00:39:44,160
<font color="#ffff54">또는 아니요, 그렇지 않습니다. 또 다른 한 가지는 아마도 웹 소켓 연결의 일종인</font>

647
00:39:44,160 --> 00:39:49,200
between your backend and your front end, where as soon as the system converges

648
00:39:44,160 --> 00:39:49,200
<font color="#ffff54">백엔드와 프론트엔드 사이에서 시스템이 수렴하자마자</font>

649
00:39:49,200 --> 00:39:54,400
into an eventually consistent state, you notify your application, your front end application,

650
00:39:49,200 --> 00:39:54,400
<font color="#ffff54">결국 일관된 상태가 되면 프론트엔드 애플리케이션인 애플리케이션에 알립니다,</font>

651
00:39:55,360 --> 00:40:04,079
or other times you're going to have to resort to some way to manage consistency so that it's not

652
00:39:55,360 --> 00:40:04,079
<font color="#ffff54">또는 다른 경우에는 일관성을 관리하기 위해 어떤 방법을 사용해야 합니다.</font>

653
00:40:04,079 --> 00:40:10,159
eventual, either using distributed transactions, which is something you don't want to do because

654
00:40:04,079 --> 00:40:10,159
<font color="#ffff54">결국에는 분산 트랜잭션을 사용하거나, 분산 트랜잭션을 사용하지 않는 것이 좋습니다.</font>

655
00:40:10,159 --> 00:40:17,119
it's very complicated and slow. Also maybe something like a two-phase commit, which is again

656
00:40:10,159 --> 00:40:17,119
<font color="#ffff54">매우 복잡하고 느리기 때문입니다. 또한 2단계 커밋과 같은 것일 수도 있습니다.</font>

657
00:40:18,079 --> 00:40:23,920
leaning into distributed transactions, or you may come to the natural conclusion that,

658
00:40:18,079 --> 00:40:23,920
<font color="#ffff54">분산 트랜잭션에 기대거나, 아니면 자연스럽게 결론에 도달할 수도 있습니다,</font>

659
00:40:24,719 --> 00:40:32,880
okay, we need consistency here. We can't rely on eventual consistency. So maybe these modules

660
00:40:24,719 --> 00:40:32,880
<font color="#ffff54">여기에는 일관성이 필요합니다. 우리는 최종적인 일관성에 의존할 수 없습니다. 따라서 이 모듈은</font>

661
00:40:32,880 --> 00:40:40,400
should be merged together. And this is also something that we kind of learned along the way,

662
00:40:32,880 --> 00:40:40,400
<font color="#ffff54">을 병합해야 합니다. 이 또한 우리가 그 과정에서 배운 점입니다,</font>

663
00:40:40,400 --> 00:40:47,920
and it comes kind of as a conclusion of my first point here, that you should spend more time

664
00:40:40,400 --> 00:40:47,920
<font color="#ffff54">그리고 이것은 제 첫 번째 요점의 결론으로, 여러분이 더 많은 시간을 할애해야 한다는 것입니다.</font>

665
00:40:47,920 --> 00:40:55,440
defining your modules. What we did was we made possibly too many modules and some of them ended

666
00:40:47,920 --> 00:40:55,440
<font color="#ffff54">모듈을 정의하는 데 더 많은 시간을 할애해야 한다는 것입니다. 우리가 한 일은 아마도 너무 많은 모듈을 만들었고 그 중 일부는 끝났습니다.</font>

667
00:40:55,440 --> 00:41:02,079
up being chatty. What I mean by this is you're going to see that some parts in your system,

668
00:40:55,440 --> 00:41:02,079
<font color="#ffff54">수다스러워졌습니다. 무슨 말이냐면, 시스템에서 어떤 부분이 작동을 멈추는 것을 보게 될 것입니다,</font>

669
00:41:02,079 --> 00:41:06,239
from different modules, are going to be communicating with each other very frequently.

670
00:41:02,079 --> 00:41:06,239
<font color="#ffff54">서로 다른 모듈의 일부가 매우 자주 통신하게 될 것입니다.</font>

671
00:41:07,039 --> 00:41:13,840
We can say that they are chatty. So this should lead you to either two conclusions.

672
00:41:07,039 --> 00:41:13,840
<font color="#ffff54">수다스럽다고 말할 수 있습니다. 따라서 두 가지 결론을 내릴 수 있습니다.</font>

673
00:41:14,639 --> 00:41:21,920
One is that your module boundaries are messed up. So you put some things of your system into

674
00:41:14,639 --> 00:41:21,920
<font color="#ffff54">하나는 모듈 경계가 엉망이라는 것입니다. 그래서 시스템의 일부를</font>

675
00:41:21,920 --> 00:41:29,599
separated modules and they shouldn't be, they should be together. Or your modules are too

676
00:41:21,920 --> 00:41:29,599
<font color="#ffff54">분리된 모듈에 넣어서는 안 되고 함께 있어야 합니다. 또는 모듈이 너무</font>

677
00:41:29,599 --> 00:41:36,319
granular. So you should merge them maybe into one big module and this is going to solve the

678
00:41:29,599 --> 00:41:36,319
<font color="#ffff54">세분화되어 있을 수도 있습니다. 따라서 모듈을 하나의 큰 모듈로 병합해야 하며 이렇게 하면</font>

679
00:41:36,319 --> 00:41:46,799
chattiness. And one last point I want to highlight is that you need to carefully plan how you're

680
00:41:36,319 --> 00:41:46,799
<font color="#ffff54">수다스러움을 해결할 수 있습니다. 마지막으로 한 가지 강조하고 싶은 점은 어떻게 하면</font>

681
00:41:46,799 --> 00:41:54,960
going to share data between your modules. So, and this goes hand in hand with chattiness because

682
00:41:46,799 --> 00:41:54,960
<font color="#ffff54">모듈 간에 데이터를 어떻게 공유할 것인지 신중하게 계획해야 한다는 것입니다. 이는 수다스러움과도 밀접한 관련이 있습니다.</font>

683
00:41:54,960 --> 00:42:06,480
chattiness is, occurs because you're probably missing data from one module in the other,

684
00:41:54,960 --> 00:42:06,480
<font color="#ffff54">수다스러움은 한 모듈의 데이터가 다른 모듈에 누락되어 있기 때문에 발생합니다,</font>

685
00:42:06,480 --> 00:42:12,800
so they have to constantly talk to each other. So how do you share data between modules?

686
00:42:06,480 --> 00:42:12,800
<font color="#ffff54">따라서 서로 끊임없이 대화해야 합니다. 그렇다면 모듈 간에 데이터를 어떻게 공유할 수 있을까요?</font>

687
00:42:14,159 --> 00:42:20,559
Probably the most decoupled solution to this, and the one I think you should consider, is

688
00:42:14,159 --> 00:42:20,559
<font color="#ffff54">아마도 이 문제에 대한 가장 분리된 솔루션이자 여러분이 고려해야 할 솔루션은 다음과 같습니다.</font>

689
00:42:21,519 --> 00:42:29,039
you want your modules to be publishing messages whenever some important change occurs. And then

690
00:42:21,519 --> 00:42:29,039
<font color="#ffff54">중요한 변경 사항이 발생할 때마다 모듈이 메시지를 게시하도록 하는 것입니다. 그리고</font>

691
00:42:29,039 --> 00:42:36,000
the other modules can subscribe to that and possibly store that data into a local copy.

692
00:42:29,039 --> 00:42:36,000
<font color="#ffff54">에 메시지를 게시하면 다른 모듈이 이를 구독하고 해당 데이터를 로컬 복사본에 저장할 수 있습니다.</font>

693
00:42:36,000 --> 00:42:41,840
So that when they need this data, they no need to go to the other module to get it at runtime.

694
00:42:36,000 --> 00:42:41,840
<font color="#ffff54">따라서 이 데이터가 필요할 때 다른 모듈로 이동하여 런타임에 데이터를 가져올 필요가 없습니다.</font>

695
00:42:41,840 --> 00:42:49,039
So that's one approach. The other approach would be maybe using some sort of caching mechanism.

696
00:42:41,840 --> 00:42:49,039
<font color="#ffff54">이것이 한 가지 접근 방식입니다. 다른 접근 방식은 일종의 캐싱 메커니즘을 사용하는 것입니다.</font>

697
00:42:49,840 --> 00:42:57,679
So, okay, if I have to go to the other module to get some piece of information, I'll pay the cost

698
00:42:49,840 --> 00:42:57,679
<font color="#ffff54">좋아요, 어떤 정보를 얻기 위해 다른 모듈로 이동해야 한다면 그 비용을 지불할게요.</font>

699
00:42:57,679 --> 00:43:03,279
of a network round trip once, and I'm going to cache that data locally so that I can reuse it

700
00:42:57,679 --> 00:43:03,279
<font color="#ffff54">의 네트워크 왕복 비용을 지불하고, 그 데이터를 재사용할 수 있도록 로컬에 캐시할 것입니다.</font>

701
00:43:03,279 --> 00:43:14,719
for some given period of time while that cache is valid. So this kind of wraps up the main pain

702
00:43:03,279 --> 00:43:14,719
<font color="#ffff54">캐시가 유효한 동안 일정 기간 동안 재사용할 수 있습니다. 이렇게 하면 큰 문제가 해결됩니다.</font>

703
00:43:14,800 --> 00:43:21,280
points that we had in building a modular monolith, and I hope that this was informative.

704
00:43:14,800 --> 00:43:21,280
<font color="#ffff54">모듈형 모놀리스를 구축할 때 겪었던 어려움에 대해 설명해 드렸는데, 도움이 되셨기를 바랍니다.</font>

705
00:43:22,320 --> 00:43:26,880
So with this, I'm going to move into the Q&A section.

706
00:43:22,320 --> 00:43:26,880
<font color="#ffff54">이것으로 Q&A 섹션으로 넘어가겠습니다.</font>
