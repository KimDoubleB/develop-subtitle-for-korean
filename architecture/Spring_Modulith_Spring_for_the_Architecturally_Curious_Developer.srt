1
00:00:00,000 --> 00:00:08,679
So while the last ones are joining, welcome everyone to the session on Spring for Architecturally

2
00:00:00,000 --> 00:00:08,679
<font color="#ffff54">마지막 참가자들이 합류하는 동안, 건축을 위한 봄 세션에 오신 모든 분들을 환영합니다.</font>

3
00:00:08,679 --> 00:00:10,480
Curious Developers.

4
00:00:08,679 --> 00:00:10,480
<font color="#ffff54">호기심 많은 개발자.</font>

5
00:00:10,480 --> 00:00:11,480
My name is Oliver Drudbom.

6
00:00:10,480 --> 00:00:11,480
<font color="#ffff54">제 이름은 올리버 드루드봄입니다.</font>

7
00:00:11,480 --> 00:00:14,519
I work for VMware in the Spring engineering team.

8
00:00:11,480 --> 00:00:14,519
<font color="#ffff54">저는 VMware의 Spring 엔지니어링 팀에서 일하고 있습니다.</font>

9
00:00:14,519 --> 00:00:21,339
I've done Spring data for, oh my gosh, over a decade, I think.

10
00:00:14,519 --> 00:00:21,339
<font color="#ffff54">저는 10년 넘게 Spring 데이터 작업을 해온 것 같습니다.</font>

11
00:00:21,339 --> 00:00:25,620
So everything that is named quote unquote repository, that's kind of the stuff that

12
00:00:21,339 --> 00:00:25,620
<font color="#ffff54">그러니까 따옴표 제거 저장소라는 이름이 붙은 모든 것, 즉</font>

13
00:00:25,620 --> 00:00:27,440
my team and I have been working on.

14
00:00:25,620 --> 00:00:27,440
<font color="#ffff54">제 팀과 제가 작업해 온 것들입니다.</font>

15
00:00:27,760 --> 00:00:32,200
I've moved on into some, let's say, more architecturally related work like two years ago,

16
00:00:27,760 --> 00:00:32,200
<font color="#ffff54">2년 전과 마찬가지로 좀 더 건축과 관련된 작업으로 넘어갔습니다,</font>

17
00:00:32,200 --> 00:00:33,200
around about.

18
00:00:32,200 --> 00:00:33,200
<font color="#ffff54">정도입니다.</font>

19
00:00:33,399 --> 00:00:38,760
And I want to present you on things that we've been working on, like a couple of folks within

20
00:00:33,399 --> 00:00:38,760
<font color="#ffff54">그리고 지난 몇 달간 우리가 작업해온 것들을 여러분께 소개해드리고 싶습니다.</font>

21
00:00:38,760 --> 00:00:42,120
the Spring team and what we want to achieve with that.

22
00:00:38,760 --> 00:00:42,120
<font color="#ffff54">스프링 팀과 이를 통해 달성하고자 하는 목표에 대해 말씀드리겠습니다.</font>

23
00:00:42,400 --> 00:00:43,400
Right.

24
00:00:42,400 --> 00:00:43,400
<font color="#ffff54">맞아요.</font>

25
00:00:44,040 --> 00:00:45,040
It's also a book coming.

26
00:00:44,040 --> 00:00:45,040
<font color="#ffff54">책도 오고 있어요.</font>

27
00:00:45,040 --> 00:00:50,040
So we got the advertisement out by the end of 23.

28
00:00:45,040 --> 00:00:50,040
<font color="#ffff54">그래서 23일까지 광고가 나왔어요.</font>

29
00:00:50,040 --> 00:00:52,600
I mean, you know, with books, it's the same as with software.

30
00:00:50,040 --> 00:00:52,600
<font color="#ffff54">책도 소프트웨어와 똑같아요.</font>

31
00:00:52,600 --> 00:00:53,600
They're usually late.

32
00:00:52,600 --> 00:00:53,600
<font color="#ffff54">그들은 보통 늦어요.</font>

33
00:00:54,600 --> 00:00:58,600
But yeah, that's at least it's still planned for this year.

34
00:00:54,600 --> 00:00:58,600
<font color="#ffff54">하지만 적어도 올해에는 아직 계획되어 있습니다.</font>

35
00:00:58,600 --> 00:00:59,600
All right.

36
00:00:58,600 --> 00:00:59,600
<font color="#ffff54">알았어.</font>

37
00:00:59,600 --> 00:01:04,599
So I want to start with a bit of an introduction into some domain that we're going to look

38
00:00:59,600 --> 00:01:04,599
<font color="#ffff54">먼저 우리가 살펴볼 도메인에 대한 소개부터 시작하겠습니다.</font>

39
00:01:04,599 --> 00:01:11,599
at because it's fundamentally we're going to talk about how to build or structure applications,

40
00:01:04,599 --> 00:01:11,599
<font color="#ffff54">기본적으로 애플리케이션을 구축하거나 구조화하는 방법에 대해 이야기할 것이기 때문입니다,</font>

41
00:01:11,599 --> 00:01:15,599
how to structure Spring applications in a way that it actually supports development.

42
00:01:11,599 --> 00:01:15,599
<font color="#ffff54">스프링 애플리케이션을 실제로 개발을 지원하는 방식으로 구조화하는 방법에 대해 설명합니다.</font>

43
00:01:15,599 --> 00:01:16,599
Right.

44
00:01:15,599 --> 00:01:16,599
<font color="#ffff54">맞습니다.</font>

45
00:01:16,599 --> 00:01:21,599
So the example domain I'm usually using in my talks is the domain of an e-commerce system

46
00:01:16,599 --> 00:01:21,599
<font color="#ffff54">제가 강연에서 주로 사용하는 예제 도메인은 전자 상거래 시스템의 도메인입니다.</font>

47
00:01:21,600 --> 00:01:26,600
because that's something that everyone can relate to both from a often like or at least

48
00:01:21,600 --> 00:01:26,600
<font color="#ffff54">왜냐하면 그것은 모든 사람들이 자주 좋아하거나 적어도 공감할 수 있는 것이기 때문입니다.</font>

49
00:01:26,600 --> 00:01:31,600
from a user perspective, like you've all shopped stuff on Amazon, but also from, let's say,

50
00:01:26,600 --> 00:01:31,600
<font color="#ffff54">아마존에서 쇼핑을 해본 경험이 있는 사용자 관점에서 볼 수 있습니다,</font>

51
00:01:31,600 --> 00:01:36,600
kind of understanding how some internals might work when you develop such systems.

52
00:01:31,600 --> 00:01:36,600
<font color="#ffff54">그런 시스템을 개발할 때 내부가 어떻게 작동하는지 이해할 수 있습니다.</font>

53
00:01:36,600 --> 00:01:43,600
So what we're going to look at is just the simple process of issuing an order and that

54
00:01:36,600 --> 00:01:43,600
<font color="#ffff54">그래서 우리가 살펴볼 것은 주문을 발행하는 간단한 프로세스입니다.</font>

55
00:01:43,600 --> 00:01:48,600
order going through some lifecycle and then eventually being completed for whatever that

56
00:01:43,600 --> 00:01:48,600
<font color="#ffff54">주문이 어떤 라이프사이클을 거쳐서 결국 완료되는 과정을 살펴볼 것입니다.</font>

57
00:01:48,600 --> 00:01:49,600
means to the domain.

58
00:01:48,600 --> 00:01:49,600
<font color="#ffff54">을 의미합니다.</font>

59
00:01:49,600 --> 00:01:54,600
But the particular aspect we want to look on is that that completion actually is triggering

60
00:01:49,600 --> 00:01:54,600
<font color="#ffff54">하지만 우리가 주목해야 할 특별한 측면은 이 완료가 실제로 다음과 같이 트리거된다는 것입니다.</font>

61
00:01:54,600 --> 00:01:57,600
other functionality in other parts of the system.

62
00:01:54,600 --> 00:01:57,600
<font color="#ffff54">시스템의 다른 부분의 다른 기능을 트리거한다는 것입니다.</font>

63
00:01:57,600 --> 00:01:58,600
Right.

64
00:01:57,600 --> 00:01:58,600
<font color="#ffff54">맞습니다.</font>

65
00:01:58,600 --> 00:02:03,600
So we have let's assume we have just subdivided our very simplistic system here into these

66
00:01:58,600 --> 00:02:03,600
<font color="#ffff54">이제 매우 단순한 시스템을 다음과 같이 세분화했다고 가정해 봅시다.</font>

67
00:02:03,600 --> 00:02:08,600
two parts, the order processing part and the inventory part that keeps track of, let's

68
00:02:03,600 --> 00:02:08,600
<font color="#ffff54">두 부분, 주문 처리 부분과 재고를 추적하는 재고 부분으로 세분화해 봅시다.</font>

69
00:02:08,600 --> 00:02:11,600
say, how many TVs are still in stock and what have you.

70
00:02:08,600 --> 00:02:11,600
<font color="#ffff54">예를 들어, 아직 몇 대의 TV가 재고가 있는지 등을 추적합니다.</font>

71
00:02:11,600 --> 00:02:12,600
Right.

72
00:02:11,600 --> 00:02:12,600
<font color="#ffff54">맞아요.</font>

73
00:02:12,600 --> 00:02:14,600
So it's very, very focused on that.

74
00:02:12,600 --> 00:02:14,600
<font color="#ffff54">그래서 그것에 아주, 아주 집중하고 있습니다.</font>

75
00:02:14,600 --> 00:02:17,600
I guess you have more complex domains to deal with.

76
00:02:14,600 --> 00:02:17,600
<font color="#ffff54">다루어야 할 도메인이 더 복잡한 것 같네요.</font>

77
00:02:17,599 --> 00:02:18,599
Hopefully.

78
00:02:17,599 --> 00:02:18,599
<font color="#ffff54">그러길 바랄게요.</font>

79
00:02:18,599 --> 00:02:24,599
And the end of, let's say, such an analysis, usually as you've been through some event

80
00:02:18,599 --> 00:02:24,599
<font color="#ffff54">이런 분석의 끝은 보통 어떤 사건을 겪은 후라고 가정해 봅시다.</font>

81
00:02:24,599 --> 00:02:30,599
storming, you have a whiteboard full of post-its, you've kind of come to an initial design.

82
00:02:24,599 --> 00:02:30,599
<font color="#ffff54">화이트보드에 포스트잇이 가득하고 초기 디자인이 어느 정도 완성되었다고 가정해 보겠습니다.</font>

83
00:02:30,599 --> 00:02:34,599
OK, these are the functional parts that I want my application to consist of.

84
00:02:30,599 --> 00:02:34,599
<font color="#ffff54">자, 애플리케이션을 구성할 기능적인 부분을 정리했습니다.</font>

85
00:02:34,599 --> 00:02:38,599
And then that happens.

86
00:02:34,599 --> 00:02:38,599
<font color="#ffff54">그리고 이런 일이 일어납니다.</font>

87
00:02:38,599 --> 00:02:39,599
Right.

88
00:02:38,599 --> 00:02:39,599
<font color="#ffff54">맞아요.</font>

89
00:02:39,599 --> 00:02:43,599
So we have this developer team assembled in our room and then we have these post-its.

90
00:02:39,599 --> 00:02:43,599
<font color="#ffff54">개발자 팀이 방에 모여서 포스트잇을 붙이고 있습니다.</font>

91
00:02:43,599 --> 00:02:46,599
But unfortunately, except you work in Myro, they don't work, run in production.

92
00:02:43,599 --> 00:02:46,599
<font color="#ffff54">하지만 안타깝게도 마이로에서 일하지 않는 이상 프로덕션에서 실행되지 않습니다.</font>

93
00:02:46,599 --> 00:02:53,599
So you somehow you have to translate that logical domain structure into your application

94
00:02:46,599 --> 00:02:53,599
<font color="#ffff54">그래서 어떻게든 그 논리적 도메인 구조를 애플리케이션으로 변환해야 합니다.</font>

95
00:02:53,599 --> 00:02:59,599
code and have to arrange your code in some way that, in the best case, actually helps

96
00:02:53,599 --> 00:02:59,599
<font color="#ffff54">코드로 변환하고, 최상의 경우 실제로 도움이 되는 방식으로 코드를 정렬해야 합니다.</font>

97
00:02:59,599 --> 00:03:05,599
you developing these individual parts and developing new requirements.

98
00:02:59,599 --> 00:03:05,599
<font color="#ffff54">이러한 개별 부품을 개발하고 새로운 요구 사항을 개발해야 합니다.</font>

99
00:03:05,599 --> 00:03:10,599
So let's say you're coming out of this brainstorming process.

100
00:03:05,599 --> 00:03:10,599
<font color="#ffff54">이제 이 브레인스토밍 프로세스에서 벗어났다고 가정해 봅시다.</font>

101
00:03:10,599 --> 00:03:13,599
Let's say you're coming out of this brainstorming room, right?

102
00:03:10,599 --> 00:03:13,599
<font color="#ffff54">이 브레인스토밍 회의실에서 나온다고 가정해 봅시다.</font>

103
00:03:13,599 --> 00:03:15,599
You get to your computer.

104
00:03:13,599 --> 00:03:15,599
<font color="#ffff54">컴퓨터로 이동합니다.</font>

105
00:03:15,599 --> 00:03:19,599
The first thing you go to when you start a new project is start.spring.io.

106
00:03:15,599 --> 00:03:19,599
<font color="#ffff54">새 프로젝트를 시작할 때 가장 먼저 가는 곳은 start.spring.io입니다.</font>

107
00:03:19,599 --> 00:03:21,599
You select a couple of dependencies.

108
00:03:19,599 --> 00:03:21,599
<font color="#ffff54">몇 가지 종속성을 선택합니다.</font>

109
00:03:21,599 --> 00:03:24,599
You're building a web application here.

110
00:03:21,599 --> 00:03:24,599
<font color="#ffff54">여기서 웹 애플리케이션을 빌드하고 있습니다.</font>

111
00:03:24,599 --> 00:03:29,599
We choose JPA as persistence mechanism, a bit of dev tools for convenient programming.

112
00:03:24,599 --> 00:03:29,599
<font color="#ffff54">우리는 편리한 프로그래밍을 위한 약간의 개발 도구인 JPA를 지속성 메커니즘으로 선택합니다.</font>

113
00:03:29,599 --> 00:03:30,599
That's kind of it.

114
00:03:29,599 --> 00:03:30,599
<font color="#ffff54">여기까지입니다.</font>

115
00:03:30,599 --> 00:03:31,599
Right.

116
00:03:30,599 --> 00:03:31,599
<font color="#ffff54">그렇군요.</font>

117
00:03:31,599 --> 00:03:36,599
So you get some kind of skeleton that's a technically structured skeleton, a typical

118
00:03:31,599 --> 00:03:36,599
<font color="#ffff54">따라서 기술적으로 구조화된 스켈레톤인 일종의 스켈레톤을 얻게 됩니다.</font>

119
00:03:36,599 --> 00:03:43,599
Maven based project structure with a Spring Boot main class and one test that basically

120
00:03:36,599 --> 00:03:43,599
<font color="#ffff54">스프링 부트 메인 클래스와 하나의 테스트가 있는 Maven 기반 프로젝트 구조는 기본적으로</font>

121
00:03:43,599 --> 00:03:45,599
makes sure that the application bootstraps.

122
00:03:43,599 --> 00:03:45,599
<font color="#ffff54">애플리케이션이 부트스트랩되는지 확인합니다.</font>

123
00:03:45,599 --> 00:03:47,599
So that's great.

124
00:03:45,599 --> 00:03:47,599
<font color="#ffff54">훌륭하군요.</font>

125
00:03:47,599 --> 00:03:50,599
But now what?

126
00:03:47,599 --> 00:03:50,599
<font color="#ffff54">하지만 이제 뭐죠?</font>

127
00:03:50,599 --> 00:03:56,599
So there's no real guidance on, let's say, how you go ahead and structure your system.

128
00:03:50,599 --> 00:03:56,599
<font color="#ffff54">시스템을 어떻게 구성해야 하는지에 대한 실질적인 지침이 없습니다.</font>

129
00:03:56,599 --> 00:04:03,599
Whether you want to structure it technically or want to structure it along the lines of

130
00:03:56,599 --> 00:04:03,599
<font color="#ffff54">기술적으로 구조화하든, 아니면 다음과 같은 라인을 따라 구조화하든 간에</font>

131
00:04:03,599 --> 00:04:08,599
your functional decomposition, there's nothing that the Spring team actually gives you here.

132
00:04:03,599 --> 00:04:08,599
<font color="#ffff54">의 함수 분해에 대해서는 스프링 팀에서 실제로 제공하는 것이 없습니다.</font>

133
00:04:08,599 --> 00:04:14,599
We've been like, or at least I have been promoting a certain approach to this for quite a while.

134
00:04:08,599 --> 00:04:14,599
<font color="#ffff54">우리는 꽤 오랫동안 이 문제에 대한 특정 접근법을 홍보해왔거나 적어도 저는 그렇게 해왔습니다.</font>

135
00:04:14,599 --> 00:04:17,600
But that's kind of talk usually, right?

136
00:04:14,599 --> 00:04:17,600
<font color="#ffff54">하지만 그런 얘기는 보통 하는 거잖아요, 그렇죠?</font>

137
00:04:17,600 --> 00:04:20,600
Presenting at conferences, discussing stuff in hallways.

138
00:04:17,600 --> 00:04:20,600
<font color="#ffff54">회의에서 발표하고, 복도에서 토론하고.</font>

139
00:04:20,600 --> 00:04:22,600
But there's no technical support there.

140
00:04:20,600 --> 00:04:22,600
<font color="#ffff54">하지만 거기에는 기술 지원이 없습니다.</font>

141
00:04:22,600 --> 00:04:27,600
That would be nice to have because that would just make your life easier, right?

142
00:04:22,600 --> 00:04:27,600
<font color="#ffff54">기술지원이 있다면 정말 좋을 텐데, 그럼 삶이 더 편해지겠죠?</font>

143
00:04:27,600 --> 00:04:31,600
If you've got some guidance and then based on that guidance, you actually get some help

144
00:04:27,600 --> 00:04:31,600
<font color="#ffff54">지침이 있고 그 지침에 따라 실제로 도움을 받을 수 있다면 말이죠.</font>

145
00:04:31,600 --> 00:04:34,600
from the framework maybe to do that stuff.

146
00:04:31,600 --> 00:04:34,600
<font color="#ffff54">프레임워크에서 그런 일을 할 수 있을지도 모르죠.</font>

147
00:04:34,600 --> 00:04:39,600
So the fundamental question I want to discuss here is how do we actually represent the functional

148
00:04:34,600 --> 00:04:39,600
<font color="#ffff54">그래서 제가 여기서 논의하고 싶은 근본적인 질문은 우리가 실제로 어떻게 기능적인 것을 표현할 수 있는가입니다.</font>

149
00:04:39,600 --> 00:04:41,600
architecture in the code base?

150
00:04:39,600 --> 00:04:41,600
<font color="#ffff54">아키텍처를 코드 베이스에서 어떻게 표현할 것인가?</font>

151
00:04:41,600 --> 00:04:47,600
And I'm going to go ahead and explain why that or structuring your code base along the lines of your

152
00:04:41,600 --> 00:04:47,600
<font color="#ffff54">그리고 그 이유나 코드 베이스의 구조화에 대해 설명해 드리겠습니다.</font>

153
00:04:47,600 --> 00:04:50,600
functional decomposition is an important thing.

154
00:04:47,600 --> 00:04:50,600
<font color="#ffff54">기능적 분해가 중요한 이유입니다.</font>

155
00:04:50,600 --> 00:04:52,600
Let's do that first, actually.

156
00:04:50,600 --> 00:04:52,600
<font color="#ffff54">그거 먼저 해봅시다.</font>

157
00:04:52,600 --> 00:04:59,600
If you or that's basically the package structure that we often find in our users or customers

158
00:04:52,600 --> 00:04:59,600
<font color="#ffff54">사용자나 고객에게서 흔히 볼 수 있는 패키지 구조는 다음과 같습니다.</font>

159
00:04:59,600 --> 00:05:01,600
projects.

160
00:04:59,600 --> 00:05:01,600
<font color="#ffff54">프로젝트.</font>

161
00:05:01,600 --> 00:05:03,600
So a very technical separation, right?

162
00:05:01,600 --> 00:05:03,600
<font color="#ffff54">아주 기술적으로 분리된 거죠?</font>

163
00:05:03,600 --> 00:05:09,600
You have the domain code and you have a bit of persistence and service layer, especially if you've

164
00:05:03,600 --> 00:05:09,600
<font color="#ffff54">도메인 코드가 있고 약간의 지속성 및 서비스 계층이 있습니다.</font>

165
00:05:09,600 --> 00:05:14,600
been influenced by the core Spring abstractions with the add service annotation, the add controller

166
00:05:09,600 --> 00:05:14,600
<font color="#ffff54">추가 서비스 어노테이션, 추가 컨트롤러와 함께 핵심 Spring 추상화의 영향을 받았습니다.</font>

167
00:05:14,600 --> 00:05:16,600
annotation that goes into the web package.

168
00:05:14,600 --> 00:05:16,600
<font color="#ffff54">어노테이션이 웹 패키지에 추가되었습니다.</font>

169
00:05:16,600 --> 00:05:21,600
Everything that's at repository or Spring data repositories goes into some repositories or

170
00:05:16,600 --> 00:05:21,600
<font color="#ffff54">리포지토리 또는 스프링 데이터 리포지토리에 있는 모든 것은 일부 리포지토리 또는</font>

171
00:05:21,600 --> 00:05:22,600
persistence package.

172
00:05:21,600 --> 00:05:22,600
<font color="#ffff54">지속성 패키지.</font>

173
00:05:22,600 --> 00:05:28,600
And then you have this other code that's usually annotated with JPA annotations that goes into the

174
00:05:22,600 --> 00:05:28,600
<font color="#ffff54">그리고 보통 JPA 어노테이션으로 주석이 달린 다른 코드가 있는데, 이 코드는</font>

175
00:05:28,600 --> 00:05:31,600
domain, but it's also a bit of persistence.

176
00:05:28,600 --> 00:05:31,600
<font color="#ffff54">도메인에 들어가지만 약간의 지속성이 있습니다.</font>

177
00:05:31,600 --> 00:05:33,600
So where does it really go?

178
00:05:31,600 --> 00:05:33,600
<font color="#ffff54">그렇다면 실제로 어디로 갈까요?</font>

179
00:05:33,600 --> 00:05:34,600
And you can exchange that.

180
00:05:33,600 --> 00:05:34,600
<font color="#ffff54">그리고 그걸 교환할 수 있어요.</font>

181
00:05:34,600 --> 00:05:37,600
That's classical layering here with the exception of domain.

182
00:05:34,600 --> 00:05:37,600
<font color="#ffff54">도메인을 제외하고는 고전적인 레이어링입니다.</font>

183
00:05:37,600 --> 00:05:41,600
But you can also exchange that with anything more modern, right?

184
00:05:37,600 --> 00:05:41,600
<font color="#ffff54">하지만 좀 더 현대적인 것으로 바꿀 수도 있겠죠?</font>

185
00:05:41,600 --> 00:05:44,600
People, we don't do layers anymore.

186
00:05:41,600 --> 00:05:44,600
<font color="#ffff54">여러분, 우린 더 이상 레이어를 하지 않아요.</font>

187
00:05:44,600 --> 00:05:48,600
We now do ports and adapters or we do onions or what have you.

188
00:05:44,600 --> 00:05:48,600
<font color="#ffff54">이제 우리는 포트와 어댑터를 만들거나 양파를 만들거나 뭐 그런 걸 하죠.</font>

189
00:05:48,600 --> 00:05:49,600
Right.

190
00:05:48,600 --> 00:05:49,600
<font color="#ffff54">맞아요.</font>

191
00:05:49,600 --> 00:05:51,600
But it's still all technical arrangement.

192
00:05:49,600 --> 00:05:51,600
<font color="#ffff54">하지만 여전히 기술적인 배열입니다.</font>

193
00:05:51,600 --> 00:05:53,600
And that actually is a problem.

194
00:05:51,600 --> 00:05:53,600
<font color="#ffff54">그리고 그것은 실제로 문제입니다.</font>

195
00:05:53,600 --> 00:05:56,600
Why is that?

196
00:05:53,600 --> 00:05:56,600
<font color="#ffff54">왜 그럴까요?</font>

197
00:05:56,600 --> 00:06:02,600
The problem is that these technical groupings are not just sole groupings.

198
00:05:56,600 --> 00:06:02,600
<font color="#ffff54">문제는 이러한 기술적 그룹이 단순한 그룹이 아니라는 것입니다.</font>

199
00:06:02,600 --> 00:06:04,600
They're not units of cohesion.

200
00:06:02,600 --> 00:06:04,600
<font color="#ffff54">그것들은 응집력의 단위가 아닙니다.</font>

201
00:06:04,600 --> 00:06:08,600
The controllers in your application rarely depend on each other.

202
00:06:04,600 --> 00:06:08,600
<font color="#ffff54">애플리케이션의 컨트롤러는 서로 의존하는 경우가 거의 없습니다.</font>

203
00:06:08,600 --> 00:06:09,600
Right.

204
00:06:08,600 --> 00:06:09,600
<font color="#ffff54">맞습니다.</font>

205
00:06:09,600 --> 00:06:14,600
So all the dependencies that you have to establish to actually get something meaningful done are

206
00:06:09,600 --> 00:06:14,600
<font color="#ffff54">따라서 실제로 의미 있는 작업을 수행하기 위해 설정해야 하는 모든 의존성은 다음과 같습니다.</font>

207
00:06:14,600 --> 00:06:15,600
across these boundaries.

208
00:06:14,600 --> 00:06:15,600
<font color="#ffff54">이 경계를 넘나듭니다.</font>

209
00:06:15,600 --> 00:06:16,600
Right.

210
00:06:15,600 --> 00:06:16,600
<font color="#ffff54">맞아요.</font>

211
00:06:16,600 --> 00:06:17,600
The controller depends on the service.

212
00:06:16,600 --> 00:06:17,600
<font color="#ffff54">컨트롤러는 서비스에 따라 다릅니다.</font>

213
00:06:17,600 --> 00:06:21,600
The service depends on the repository and the repository connects to the database.

214
00:06:17,600 --> 00:06:21,600
<font color="#ffff54">서비스가 리포지토리에 의존하며 리포지토리가 데이터베이스에 연결됩니다.</font>

215
00:06:21,600 --> 00:06:22,600
Right.

216
00:06:21,600 --> 00:06:22,600
<font color="#ffff54">Right.</font>

217
00:06:22,600 --> 00:06:26,600
So all the meaningful connections are across the boundaries, not within the boundaries.

218
00:06:22,600 --> 00:06:26,600
<font color="#ffff54">모든 의미 있는 연결은 경계 안에 있는 것이 아니라 경계 너머에 있습니다.</font>

219
00:06:26,600 --> 00:06:30,600
So that fundamentally subverts the idea of encapsulation.

220
00:06:26,600 --> 00:06:30,600
<font color="#ffff54">그래서 캡슐화라는 개념이 근본적으로 전복됩니다.</font>

221
00:06:30,600 --> 00:06:35,600
Because if you wanted to design your packages for encapsulation, you would actually make

222
00:06:30,600 --> 00:06:35,600
<font color="#ffff54">캡슐화를 위해 패키지를 디자인하려면 실제로는</font>

223
00:06:35,600 --> 00:06:39,600
sure that most of the dependencies happen within one package.

224
00:06:35,600 --> 00:06:39,600
<font color="#ffff54">대부분의 종속성이 하나의 패키지 내에서 발생하도록 해야 합니다.</font>

225
00:06:39,600 --> 00:06:40,600
Right.

226
00:06:39,600 --> 00:06:40,600
<font color="#ffff54">맞습니다.</font>

227
00:06:40,600 --> 00:06:43,600
So you want to get to a different scheme.

228
00:06:40,600 --> 00:06:43,600
<font color="#ffff54">그래서 다른 계획으로 넘어가고 싶군요.</font>

229
00:06:43,600 --> 00:06:49,600
And that's something that then North recently pointed out in a blog post called Cupid for

230
00:06:43,600 --> 00:06:49,600
<font color="#ffff54">이는 노스가 최근 큐피드라는 블로그 포스트에서 지적한 내용입니다.</font>

231
00:06:49,600 --> 00:06:54,600
Joyful Coding in an attempt to form some alternative to the solid principles.

232
00:06:49,600 --> 00:06:54,600
<font color="#ffff54">견고한 원칙에 대한 대안을 제시하기 위해 즐거운 코딩을 시도합니다.</font>

233
00:06:54,600 --> 00:07:02,600
He came up with this Cupid acronym for which the D actually stays for domain based structure

234
00:06:54,600 --> 00:07:02,600
<font color="#ffff54">그는 도메인 기반 구조를 위해 D가 실제로 유지되는 이 큐피드 약어를 생각해 냈습니다.</font>

235
00:07:02,600 --> 00:07:03,600
and domain based boundaries.

236
00:07:02,600 --> 00:07:03,600
<font color="#ffff54">도메인 기반 경계를 나타냅니다.</font>

237
00:07:03,600 --> 00:07:08,600
And he basically says that all the frameworks, the general, let's say, architecturally high

238
00:07:03,600 --> 00:07:08,600
<font color="#ffff54">그리고 그는 기본적으로 모든 프레임워크, 일반적인, 말하자면 아키텍처적으로 높다고 말합니다.</font>

239
00:07:08,600 --> 00:07:14,600
level frameworks, something like Ruby on Rails or yeah, that's the example I think he uses.

240
00:07:08,600 --> 00:07:14,600
<font color="#ffff54">루비 온 레일즈와 같은 프레임워크를 예로 들었습니다.</font>

241
00:07:14,600 --> 00:07:17,600
They all focus on some technical structure.

242
00:07:14,600 --> 00:07:17,600
<font color="#ffff54">모두 기술적 구조에 초점을 맞추고 있습니다.</font>

243
00:07:17,600 --> 00:07:18,600
Right.

244
00:07:17,600 --> 00:07:18,600
<font color="#ffff54">맞아요.</font>

245
00:07:18,600 --> 00:07:19,600
I think it's actions.

246
00:07:18,600 --> 00:07:19,600
<font color="#ffff54">행동이라고 생각해요.</font>

247
00:07:19,600 --> 00:07:21,600
I'm not too familiar with that space.

248
00:07:19,600 --> 00:07:21,600
<font color="#ffff54">저 공간에 익숙하지 않아요.</font>

249
00:07:21,600 --> 00:07:28,600
But these frameworks usually give you guidance on a technical way because that's the problem

250
00:07:21,600 --> 00:07:28,600
<font color="#ffff54">하지만 이러한 프레임워크는 일반적으로 기술적인 방법에 대한 지침을 제공합니다.</font>

251
00:07:28,600 --> 00:07:29,600
domain they address.

252
00:07:28,600 --> 00:07:29,600
<font color="#ffff54">도메인을 지정합니다.</font>

253
00:07:29,600 --> 00:07:30,600
Right.

254
00:07:29,600 --> 00:07:30,600
<font color="#ffff54">맞습니다.</font>

255
00:07:30,600 --> 00:07:32,600
In Spring Framework, you have the add repository annotation.

256
00:07:30,600 --> 00:07:32,600
<font color="#ffff54">스프링 프레임워크에는 저장소 추가 어노테이션이 있습니다.</font>

257
00:07:32,600 --> 00:07:37,600
You have the add service annotation because this is the abstractions that the framework

258
00:07:32,600 --> 00:07:37,600
<font color="#ffff54">프레임워크가 추상화하기 때문에 서비스 추가 어노테이션이 있습니다.</font>

259
00:07:37,600 --> 00:07:39,600
actually gets active on.

260
00:07:37,600 --> 00:07:39,600
<font color="#ffff54">에서 실제로 활성화되기 때문입니다.</font>

261
00:07:39,600 --> 00:07:40,600
Right.

262
00:07:39,600 --> 00:07:40,600
<font color="#ffff54">맞습니다.</font>

263
00:07:40,600 --> 00:07:42,600
Services are the level that you apply transactions on.

264
00:07:40,600 --> 00:07:42,600
<font color="#ffff54">서비스는 트랜잭션을 적용하는 레벨입니다.</font>

265
00:07:42,600 --> 00:07:47,600
Repositories are needed for exception translation, for example, from the data access technology

266
00:07:42,600 --> 00:07:47,600
<font color="#ffff54">리포지토리는 예를 들어 데이터 액세스 기술에서 예외 변환을 위해 필요합니다.</font>

267
00:07:47,600 --> 00:07:52,600
that you're using into the common Spring data access exception hierarchy.

268
00:07:47,600 --> 00:07:52,600
<font color="#ffff54">를 일반적인 Spring 데이터 액세스 예외 계층 구조로 변환해야 합니다.</font>

269
00:07:52,600 --> 00:07:55,600
So that's the abstractions they expose.

270
00:07:52,600 --> 00:07:55,600
<font color="#ffff54">이것이 바로 그들이 노출하는 추상화입니다.</font>

271
00:07:55,600 --> 00:08:01,600
And that's why it's not surprising that developers follow those conventions.

272
00:07:55,600 --> 00:08:01,600
<font color="#ffff54">그렇기 때문에 개발자들이 이러한 규칙을 따르는 것은 놀라운 일이 아닙니다.</font>

273
00:08:01,600 --> 00:08:04,600
The problem is exactly what I just described.

274
00:08:01,600 --> 00:08:04,600
<font color="#ffff54">문제는 바로 제가 방금 설명한 것과 같습니다.</font>

275
00:08:04,600 --> 00:08:05,600
Right.

276
00:08:04,600 --> 00:08:05,600
<font color="#ffff54">맞아요.</font>

277
00:08:05,600 --> 00:08:09,600
That you basically have all the meaningful dependencies across the boundaries.

278
00:08:05,600 --> 00:08:09,600
<font color="#ffff54">기본적으로 경계를 가로지르는 모든 의미 있는 종속성을 가지고 있습니다.</font>

279
00:08:09,600 --> 00:08:14,600
And you can actually change that and then also make your domain more expressive in your

280
00:08:09,600 --> 00:08:14,600
<font color="#ffff54">그리고 실제로 이를 변경하고 도메인을 더 표현력 있게 만들 수 있습니다.</font>

281
00:08:14,600 --> 00:08:17,600
code base by just having functional packages on the top level.

282
00:08:14,600 --> 00:08:17,600
<font color="#ffff54">코드 베이스에 기능 패키지를 추가하여 도메인의 표현력을 높일 수 있습니다.</font>

283
00:08:17,600 --> 00:08:18,600
Right.

284
00:08:17,600 --> 00:08:18,600
<font color="#ffff54">맞습니다.</font>

285
00:08:18,600 --> 00:08:23,600
There's no problem at all with having these these technical packages on lower levels like

286
00:08:18,600 --> 00:08:23,600
<font color="#ffff54">다음과 같은 하위 레벨에서 이러한 기술 패키지를 사용하는 데 전혀 문제가 없습니다.</font>

287
00:08:23,600 --> 00:08:24,600
in nested cases.

288
00:08:23,600 --> 00:08:24,600
<font color="#ffff54">중첩된 경우.</font>

289
00:08:24,600 --> 00:08:30,600
But we generally recommend to start with just functional packages on the very top level.

290
00:08:24,600 --> 00:08:30,600
<font color="#ffff54">하지만 일반적으로 최상위 레벨의 기능 패키지부터 시작하는 것이 좋습니다.</font>

291
00:08:30,600 --> 00:08:35,600
Because in the easiest case, you could just put, let's say, the controller, the service,

292
00:08:30,600 --> 00:08:35,600
<font color="#ffff54">가장 쉬운 경우에는 컨트롤러와 서비스만 넣으면 되기 때문입니다,</font>

293
00:08:35,600 --> 00:08:38,600
the repository into the same package.

294
00:08:35,600 --> 00:08:38,600
<font color="#ffff54">저장소를 같은 패키지에 넣으면 됩니다.</font>

295
00:08:38,600 --> 00:08:43,600
And then even some grad student just coming out of university will probably have learned

296
00:08:38,600 --> 00:08:43,600
<font color="#ffff54">그리고 이제 막 대학을 졸업한 대학원생이라도</font>

297
00:08:43,600 --> 00:08:48,600
that there is something called layering going on here and then know or it could even set

298
00:08:43,600 --> 00:08:48,600
<font color="#ffff54">레이어링이라는 것이 있다는 것을 알게 될 것이고, 심지어는 그 레이어링이</font>

299
00:08:48,600 --> 00:08:53,600
up some arcc unit rules or what have you to basically still express, hey, repositories

300
00:08:48,600 --> 00:08:53,600
<font color="#ffff54">아크 단위 규칙을 설정하거나 기본적으로 여전히 저장소를 표현할 수 있습니다.</font>

301
00:08:53,600 --> 00:09:00,600
must not depend on the controllers because that's kind of the rather easy stuff to control.

302
00:08:53,600 --> 00:09:00,600
<font color="#ffff54">는 컨트롤러에 의존하지 않아야 합니다. 왜냐하면 그것은 제어하기 쉬운 것들이기 때문입니다.</font>

303
00:09:00,600 --> 00:09:02,600
You don't need packages for that.

304
00:09:00,600 --> 00:09:02,600
<font color="#ffff54">패키지가 필요하지 않습니다.</font>

305
00:09:02,600 --> 00:09:09,600
But it's kind of interesting to develop, let's say, in a really or an idea of like in this

306
00:09:02,600 --> 00:09:09,600
<font color="#ffff54">하지만 다음과 같이 실제로 또는 아이디어로 개발하는 것은 흥미롭습니다.</font>

307
00:09:09,600 --> 00:09:14,600
case here for customer inventory and order, in which order do they actually depend on

308
00:09:09,600 --> 00:09:14,600
<font color="#ffff54">고객 재고와 주문에 대한 경우, 실제로 어떤 순서에 의존합니까?</font>

309
00:09:14,600 --> 00:09:15,600
each other?

310
00:09:14,600 --> 00:09:15,600
<font color="#ffff54">서로?</font>

311
00:09:15,600 --> 00:09:16,600
Right.

312
00:09:15,600 --> 00:09:16,600
<font color="#ffff54">맞아요.</font>

313
00:09:16,600 --> 00:09:21,600
And that's kind of the stuff that at least in the projects we see usually leads to messy

314
00:09:16,600 --> 00:09:21,600
<font color="#ffff54">그리고 적어도 우리가 보는 프로젝트에서 이런 종류의 것들은 보통 지저분해집니다.</font>

315
00:09:21,600 --> 00:09:27,600
code bases because every kind of functional unit is depending on any other functional

316
00:09:21,600 --> 00:09:27,600
<font color="#ffff54">모든 종류의 기능 단위가 다른 기능에 의존하고 있기 때문입니다.</font>

317
00:09:27,600 --> 00:09:28,600
unit.

318
00:09:27,600 --> 00:09:28,600
<font color="#ffff54">단위.</font>

319
00:09:28,600 --> 00:09:30,600
So you much rather want to control those things.

320
00:09:28,600 --> 00:09:30,600
<font color="#ffff54">그래서 당신은 그런 것들을 통제하고 싶군요.</font>

321
00:09:30,600 --> 00:09:37,600
And it's easier if you have them in well cohesively designed packages.

322
00:09:30,600 --> 00:09:37,600
<font color="#ffff54">그리고 그것들을 잘 짜임새 있게 디자인된 패키지에 넣으면 더 쉬워지죠.</font>

323
00:09:37,600 --> 00:09:38,600
Right.

324
00:09:37,600 --> 00:09:38,600
<font color="#ffff54">맞아요.</font>

325
00:09:38,600 --> 00:09:42,600
So you want to get to the picture on the right and not to the picture on the on the on the

326
00:09:38,600 --> 00:09:42,600
<font color="#ffff54">그래서 당신은 왼쪽 그림이 아니라 오른쪽 그림으로 가고 싶어요.</font>

327
00:09:42,600 --> 00:09:43,600
left.

328
00:09:42,600 --> 00:09:43,600
<font color="#ffff54">왼쪽</font>

329
00:09:43,600 --> 00:09:46,600
And that's where you why you should start with that very simple idea.

330
00:09:43,600 --> 00:09:46,600
<font color="#ffff54">아주 간단한 아이디어로 시작해야 하는 이유가 바로 여기에 있습니다.</font>

331
00:09:46,600 --> 00:09:47,600
Right.

332
00:09:46,600 --> 00:09:47,600
<font color="#ffff54">맞아요.</font>

333
00:09:47,600 --> 00:09:50,600
It doesn't sound like much, but it actually makes a real difference.

334
00:09:47,600 --> 00:09:50,600
<font color="#ffff54">별것 아닌 것 같지만 실제로는 큰 차이를 만들어냅니다.</font>

335
00:09:50,600 --> 00:09:51,600
We're going to see this.

336
00:09:50,600 --> 00:09:51,600
<font color="#ffff54">이걸 보러 가자.</font>

337
00:09:51,600 --> 00:09:58,600
And having seen a lot of spring projects or spring projects working with that functional

338
00:09:51,600 --> 00:09:58,600
<font color="#ffff54">그리고 많은 스프링 프로젝트나 스프링 프로젝트가 그 기능으로 작업하는 것을 보았습니다.</font>

339
00:09:58,600 --> 00:10:03,600
decomposition approach, we thought, OK, it might be nice if we if there was some or there's

340
00:09:58,600 --> 00:10:03,600
<font color="#ffff54">분해 접근 방식이 있다면 좋겠다고 생각했습니다.</font>

341
00:10:03,600 --> 00:10:10,600
some obvious like questions you can or follow up ideas that you can come if you have these

342
00:10:03,600 --> 00:10:10,600
<font color="#ffff54">당신이 할 수있는 질문이나 후속 아이디어와 같은 몇 가지 명백한 질문이 있으면 올 수 있습니다.</font>

343
00:10:10,600 --> 00:10:17,600
functional packages that it would be nice that the framework actually supported those

344
00:10:10,600 --> 00:10:17,600
<font color="#ffff54">프레임워크가 실제로 그런 기능들을 지원하면 좋을 것 같은 기능 패키지들 말이죠.</font>

345
00:10:17,600 --> 00:10:18,600
ideas.

346
00:10:17,600 --> 00:10:18,600
<font color="#ffff54">아이디어.</font>

347
00:10:18,600 --> 00:10:19,600
Right.

348
00:10:18,600 --> 00:10:19,600
<font color="#ffff54">맞아요.</font>

349
00:10:19,600 --> 00:10:20,600
Things like, oh, can I actually test?

350
00:10:19,600 --> 00:10:20,600
<font color="#ffff54">아, 실제로 테스트할 수 있을까?</font>

351
00:10:20,600 --> 00:10:22,600
Yeah, that's nice.

352
00:10:20,600 --> 00:10:22,600
<font color="#ffff54">네, 좋네요.</font>

353
00:10:22,600 --> 00:10:30,600
But now it would be nice to actually be able to test these functional approaches in or

354
00:10:22,600 --> 00:10:30,600
<font color="#ffff54">하지만 이제 이러한 기능적 접근 방식을 실제로 테스트할 수 있다면 좋을 것 같습니다.</font>

355
00:10:30,600 --> 00:10:32,600
these functional slices individually.

356
00:10:30,600 --> 00:10:32,600
<font color="#ffff54">이러한 기능적 슬라이스를 개별적으로 테스트할 수 있습니다.</font>

357
00:10:32,600 --> 00:10:38,600
We've seen customers that move to microservices for only only for the reason that they basically

358
00:10:32,600 --> 00:10:38,600
<font color="#ffff54">마이크로서비스로 이동하는 고객들은 기본적으로 다음과 같은 이유 때문에 마이크로서비스로 이동하는 것을 보았습니다.</font>

359
00:10:38,600 --> 00:10:41,600
tend, OK, we want to test individual parts of the system separately.

360
00:10:38,600 --> 00:10:41,600
<font color="#ffff54">시스템의 개별 부분을 개별적으로 테스트하려는 경향이 있습니다.</font>

361
00:10:41,600 --> 00:10:48,600
Well, if you design them, design your monolithic system, sorry, getting ahead of myself in

362
00:10:41,600 --> 00:10:48,600
<font color="#ffff54">모놀리식 시스템을 설계한다면, 미안, 내가 너무 앞서 나갔네.</font>

363
00:10:48,600 --> 00:10:53,600
that way, in that functional way, there is actually a way to just bootstrap that particular

364
00:10:48,600 --> 00:10:53,600
<font color="#ffff54">그런 식으로, 그런 기능적인 방식으로, 실제로는 그 특정 부트스트랩을</font>

365
00:10:53,600 --> 00:10:54,600
functional slice.

366
00:10:53,600 --> 00:10:54,600
<font color="#ffff54">기능적 슬라이스.</font>

367
00:10:54,600 --> 00:10:55,600
And we're going to see that in a bit.

368
00:10:54,600 --> 00:10:55,600
<font color="#ffff54">잠시 후에 살펴보겠습니다.</font>

369
00:10:55,600 --> 00:10:56,600
Right.

370
00:10:55,600 --> 00:10:56,600
<font color="#ffff54">그렇군요.</font>

371
00:10:56,600 --> 00:11:00,600
And that's a bit of code and a project that we've just started.

372
00:10:56,600 --> 00:11:00,600
<font color="#ffff54">이제 막 시작한 코드와 프로젝트입니다.</font>

373
00:11:00,600 --> 00:11:05,600
And that's in experimental state right now to support you with with exactly that.

374
00:11:00,600 --> 00:11:05,600
<font color="#ffff54">이 프로젝트는 현재 여러분을 지원하기 위해 실험적인 상태입니다.</font>

375
00:11:05,600 --> 00:11:11,600
I've prepared a sample sample repo in my personal GitHub argument evidence spring.

376
00:11:05,600 --> 00:11:11,600
<font color="#ffff54">제 개인 깃허브 인수 증거 스프링에 샘플 샘플 리포지토리를 준비했습니다.</font>

377
00:11:11,600 --> 00:11:16,600
It's a it's a repo that basically that uses commits in a way that you basically it takes

378
00:11:11,600 --> 00:11:16,600
<font color="#ffff54">기본적으로 다음과 같은 방식으로 커밋을 사용하는 리포지토리입니다.</font>

379
00:11:16,600 --> 00:11:19,600
you through the through the entire thing on a step by step basis.

380
00:11:16,600 --> 00:11:19,600
<font color="#ffff54">단계별로 전체 내용을 살펴볼 수 있습니다.</font>

381
00:11:19,600 --> 00:11:22,600
So it's not really like latest commit on top.

382
00:11:19,600 --> 00:11:22,600
<font color="#ffff54">최신 커밋이 맨 위에 있는 것과는 다르다.</font>

383
00:11:22,600 --> 00:11:28,600
So for today's edition, you want to check out the events slash the other the other Voxday

384
00:11:22,600 --> 00:11:28,600
<font color="#ffff54">오늘은 다른 복스데이의 이벤트 슬래시를 확인해보자.</font>

385
00:11:28,600 --> 00:11:31,600
Zurich tag if you want to want to follow along.

386
00:11:28,600 --> 00:11:31,600
<font color="#ffff54">따라하고 싶으면 취리히 태그를 달아주세요.</font>

387
00:11:31,600 --> 00:11:37,600
We only have a going to have a look at two of the commits in there because that's just

388
00:11:31,600 --> 00:11:37,600
<font color="#ffff54">여기서는 커밋 중 두 개만 살펴보도록 하겠습니다.</font>

389
00:11:37,600 --> 00:11:39,600
45 minutes.

390
00:11:37,600 --> 00:11:39,600
<font color="#ffff54">45분</font>

391
00:11:39,600 --> 00:11:42,600
But the rest of it is demo time now.

392
00:11:39,600 --> 00:11:42,600
<font color="#ffff54">이제 나머지는 데모 시간입니다.</font>

393
00:11:42,600 --> 00:11:47,600
So does that work in size terms, actually?

394
00:11:42,600 --> 00:11:47,600
<font color="#ffff54">실제로 크기 면에서 작동하나요?</font>

395
00:11:47,600 --> 00:11:50,600
If I don't hear any complaints, then we're going to go with that.

396
00:11:47,600 --> 00:11:50,600
<font color="#ffff54">별다른 불만이 없으면 이걸로 할게요.</font>

397
00:11:50,600 --> 00:11:56,600
So the idea is fundamentally that I have prepared the example project in just the way that I

398
00:11:50,600 --> 00:11:56,600
<font color="#ffff54">그래서 기본적으로 제가 예제 프로젝트를 다음과 같은 방식으로 준비했습니다.</font>

399
00:11:56,600 --> 00:11:59,600
suggested, and it's kind of an arrangement.

400
00:11:56,600 --> 00:11:59,600
<font color="#ffff54">제안한 방식으로 준비했다는 것입니다.</font>

401
00:11:59,600 --> 00:12:03,600
I've kind of simplified this to to the very point that I'm trying to make here.

402
00:11:59,600 --> 00:12:03,600
<font color="#ffff54">제가 여기서 말하고자 하는 바로 그 요점으로 단순화했습니다.</font>

403
00:12:03,600 --> 00:12:04,600
Right.

404
00:12:03,600 --> 00:12:04,600
<font color="#ffff54">맞아요.</font>

405
00:12:04,600 --> 00:12:08,600
It's not about like what does the order do and how does the how does the inventory actually

406
00:12:04,600 --> 00:12:08,600
<font color="#ffff54">주문이 무엇을 하느냐, 인벤토리가 실제로 어떻게 되느냐와 같은 문제가 아닙니다.</font>

407
00:12:08,600 --> 00:12:09,600
handle the orders?

408
00:12:08,600 --> 00:12:09,600
<font color="#ffff54">주문을 처리하나요?</font>

409
00:12:09,600 --> 00:12:13,600
It's all about the spring beans, the components and the relationships between them.

410
00:12:09,600 --> 00:12:13,600
<font color="#ffff54">원두, 구성 요소, 그리고 이들 간의 관계에 관한 모든 것입니다.</font>

411
00:12:13,600 --> 00:12:17,600
And how do we arrange them for improved modularity?

412
00:12:13,600 --> 00:12:17,600
<font color="#ffff54">그리고 모듈성을 향상시키기 위해 어떻게 배열할까요?</font>

413
00:12:17,600 --> 00:12:20,600
That's kind of the question I want to answer.

414
00:12:17,600 --> 00:12:20,600
<font color="#ffff54">제가 대답하고 싶은 질문이 바로 그겁니다.</font>

415
00:12:20,600 --> 00:12:22,600
So we have this order domain class.

416
00:12:20,600 --> 00:12:22,600
<font color="#ffff54">이 주문 도메인 클래스가 있습니다.</font>

417
00:12:22,600 --> 00:12:26,600
That's just an aggregate relating to a customer identifier.

418
00:12:22,600 --> 00:12:26,600
<font color="#ffff54">이것은 고객 식별자와 관련된 집계일 뿐입니다.</font>

419
00:12:26,600 --> 00:12:28,600
So there's an entity to entity relationship here.

420
00:12:26,600 --> 00:12:28,600
<font color="#ffff54">여기에는 엔티티와 엔티티 간의 관계가 있습니다.</font>

421
00:12:28,600 --> 00:12:34,600
And there is this order management like a typical service that would be used by a spring

422
00:12:28,600 --> 00:12:34,600
<font color="#ffff54">그리고 스프링에서 사용하는 일반적인 서비스와 같은 주문 관리가 있습니다.</font>

423
00:12:34,600 --> 00:12:38,600
MVC controller method to then basically trigger state transitions of the order.

424
00:12:34,600 --> 00:12:38,600
<font color="#ffff54">MVC 컨트롤러 메서드를 사용하여 기본적으로 주문의 상태 전환을 트리거합니다.</font>

425
00:12:38,600 --> 00:12:44,600
And the interesting state transition for us being that completion that completion step

426
00:12:38,600 --> 00:12:44,600
<font color="#ffff54">그리고 우리에게 흥미로운 상태 전환은 완료 단계가 완료된다는 것입니다.</font>

427
00:12:44,600 --> 00:12:45,600
here. Right.

428
00:12:44,600 --> 00:12:45,600
<font color="#ffff54">입니다. 그렇군요.</font>

429
00:12:45,600 --> 00:12:49,600
So something you're basically checking out and you get done paying and then the orders

430
00:12:45,600 --> 00:12:49,600
<font color="#ffff54">그러니까 기본적으로 체크아웃을 하고 결제를 완료한 다음 주문이 들어오는 경우입니다.</font>

431
00:12:49,600 --> 00:12:52,600
has to be processed by some shipment or what have you.

432
00:12:49,600 --> 00:12:52,600
<font color="#ffff54">어떤 배송이나 뭐 그런 걸로 처리해야 하는 거죠.</font>

433
00:12:52,600 --> 00:12:56,600
There is this other module that basically just consists of that spring service that

434
00:12:52,600 --> 00:12:56,600
<font color="#ffff54">기본적으로 스프링 서비스로만 구성된 다른 모듈이 있습니다.</font>

435
00:12:56,600 --> 00:13:00,600
is likely to be a spring repository beneath it.

436
00:12:56,600 --> 00:13:00,600
<font color="#ffff54">그 밑에 스프링 저장소가 있을 가능성이 높습니다.</font>

437
00:13:00,600 --> 00:13:06,600
But it's just exposing that method to update the stock relating back to our initially

438
00:13:00,600 --> 00:13:06,600
<font color="#ffff54">하지만 이 메서드를 노출시켜서 처음에 생성한 저장소인</font>

439
00:13:06,600 --> 00:13:07,600
given example.

440
00:13:06,600 --> 00:13:07,600
<font color="#ffff54">로 업데이트합니다.</font>

441
00:13:07,600 --> 00:13:11,600
So that's what we start with.

442
00:13:07,600 --> 00:13:11,600
<font color="#ffff54">이것이 우리가 시작하는 것입니다.</font>

443
00:13:11,600 --> 00:13:17,600
There is some API in spring module if the project I'm talking about basically that allows

444
00:13:11,600 --> 00:13:17,600
<font color="#ffff54">내가 말하는 프로젝트가 기본적으로 다음을 허용하는 경우 스프링 모듈에 일부 API가 있습니다.</font>

445
00:13:17,600 --> 00:13:22,600
you to basically point you or you have to point it to your spring boot application

446
00:13:17,600 --> 00:13:22,600
<font color="#ffff54">를 가리키거나 스프링 부트 애플리케이션을 가리켜야 합니다.</font>

447
00:13:22,600 --> 00:13:23,600
class.

448
00:13:22,600 --> 00:13:23,600
<font color="#ffff54">클래스.</font>

449
00:13:23,600 --> 00:13:26,600
And you would usually do that in a test.

450
00:13:23,600 --> 00:13:26,600
<font color="#ffff54">보통 시험에서 이런 식으로 하죠.</font>

451
00:13:26,600 --> 00:13:31,600
It's just building up this application modules instance here.

452
00:13:26,600 --> 00:13:31,600
<font color="#ffff54">여기서 이 애플리케이션 모듈 인스턴스를 빌드하고 있습니다.</font>

453
00:13:31,600 --> 00:13:36,600
And if you run this and you can basically then just render this to your to your console.

454
00:13:31,600 --> 00:13:36,600
<font color="#ffff54">그리고 이것을 실행하면 기본적으로 콘솔에 렌더링할 수 있습니다.</font>

455
00:13:36,600 --> 00:13:45,600
If you run this you're going to see that what it's what it actually looks like or what it

456
00:13:36,600 --> 00:13:45,600
<font color="#ffff54">이걸 실행하면 실제로 어떻게 생겼는지 또는 어떤 모습인지 확인할 수 있습니다.</font>

457
00:13:45,600 --> 00:13:49,600
prints out is all the logical modules it finds in your application.

458
00:13:45,600 --> 00:13:49,600
<font color="#ffff54">가 출력하는 것은 애플리케이션에서 찾은 모든 논리 모듈입니다.</font>

459
00:13:49,600 --> 00:13:54,600
So it applies exactly the packaging scheme that I've just described.

460
00:13:49,600 --> 00:13:54,600
<font color="#ffff54">따라서 방금 설명한 패키징 체계를 정확히 적용합니다.</font>

461
00:13:54,600 --> 00:13:59,600
Right. So here's the top level package in the upper right here upper left here.

462
00:13:54,600 --> 00:13:59,600
<font color="#ffff54">맞습니다. 여기 오른쪽 상단 왼쪽 상단에 최상위 패키지가 있습니다.</font>

463
00:13:59,600 --> 00:14:00,600
There's the top level package.

464
00:13:59,600 --> 00:14:00,600
<font color="#ffff54">최상위 패키지가 있습니다.</font>

465
00:14:00,600 --> 00:14:05,600
It has this application class in every direct sub package is kind of considered a functional

466
00:14:00,600 --> 00:14:05,600
<font color="#ffff54">모든 직접 하위 패키지에 이 애플리케이션 클래스가 있습니다.</font>

467
00:14:05,600 --> 00:14:07,600
module by default.

468
00:14:05,600 --> 00:14:07,600
<font color="#ffff54">모듈로 간주됩니다.</font>

469
00:14:07,600 --> 00:14:11,600
There's ways to tweak that with annotations and a bit of configuration if you have to

470
00:14:07,600 --> 00:14:11,600
<font color="#ffff54">필요한 경우 어노테이션과 약간의 설정으로 이를 조정하는 방법이 있습니다.</font>

471
00:14:11,600 --> 00:14:14,600
deal with it with a with a different package arrangement.

472
00:14:11,600 --> 00:14:14,600
<font color="#ffff54">다른 패키지 배열로 처리할 수 있습니다.</font>

473
00:14:14,600 --> 00:14:16,600
But that's it for now.

474
00:14:14,600 --> 00:14:16,600
<font color="#ffff54">하지만 지금은 여기까지입니다.</font>

475
00:14:16,600 --> 00:14:20,600
I'm going to go into like slightly more complicated scenarios later on.

476
00:14:16,600 --> 00:14:20,600
<font color="#ffff54">나중에 조금 더 복잡한 시나리오를 살펴볼게요.</font>

477
00:14:20,600 --> 00:14:22,600
But that's it.

478
00:14:20,600 --> 00:14:22,600
<font color="#ffff54">하지만 여기까지입니다.</font>

479
00:14:22,600 --> 00:14:24,600
You see that OK that's the information it gathers.

480
00:14:22,600 --> 00:14:24,600
<font color="#ffff54">OK가 수집한 정보입니다.</font>

481
00:14:24,600 --> 00:14:30,600
It also analyzes the packages for the code that's contained in or in them.

482
00:14:24,600 --> 00:14:30,600
<font color="#ffff54">또한 패키지에 포함된 코드를 분석합니다.</font>

483
00:14:30,600 --> 00:14:35,600
Right. And it finds spring beans in particular it finds other architecturally relevant

484
00:14:30,600 --> 00:14:35,600
<font color="#ffff54">맞아요. 그리고 특히 스프링 빈을 찾아냅니다.</font>

485
00:14:35,600 --> 00:14:38,600
abstractions things like aggregate roots.

486
00:14:35,600 --> 00:14:38,600
<font color="#ffff54">집합 뿌리 같은 추상화도 찾아냅니다.</font>

487
00:14:38,600 --> 00:14:41,600
It finds events.

488
00:14:38,600 --> 00:14:41,600
<font color="#ffff54">이벤트를 찾습니다.</font>

489
00:14:41,600 --> 00:14:43,600
It finds spring configuration properties.

490
00:14:41,600 --> 00:14:43,600
<font color="#ffff54">스프링 구성 속성을 찾습니다.</font>

491
00:14:43,600 --> 00:14:49,600
So code that's that has some architectural role and it just point analyzes the dependencies

492
00:14:43,600 --> 00:14:49,600
<font color="#ffff54">따라서 아키텍처적 역할을 하는 코드는 종속성을 포인트 분석합니다.</font>

493
00:14:49,600 --> 00:14:52,600
between all of them and just prints this out here.

494
00:14:49,600 --> 00:14:52,600
<font color="#ffff54">종속성을 분석해서 여기에 출력합니다.</font>

495
00:14:52,600 --> 00:14:59,600
Right. So bottom line is we get a logical module a logical understanding we meaning

496
00:14:52,600 --> 00:14:59,600
<font color="#ffff54">맞아요. 결론은 우리가 의미하는 논리적 모듈을 논리적으로 이해한다는 것입니다.</font>

497
00:14:59,600 --> 00:15:04,600
that that's that piece of code here of the arrangement.

498
00:14:59,600 --> 00:15:04,600
<font color="#ffff54">이 배열의 코드 조각이라는 것을 말이죠.</font>

499
00:15:04,600 --> 00:15:10,600
So the first thing we can do is we can while this is nice and this is like I mean a bit

500
00:15:04,600 --> 00:15:10,600
<font color="#ffff54">그래서 우리가 할 수 있는 첫 번째 일은 이것이 좋은 동안에 할 수 있다는 것입니다.</font>

501
00:15:10,600 --> 00:15:16,600
of ASCII stuff in here that's not something you would actually present to some other developer

502
00:15:10,600 --> 00:15:16,600
<font color="#ffff54">여기에는 다른 개발자에게 실제로 제시할 수 있는 것이 아닌 아스키 코드가 많이 있습니다.</font>

503
00:15:16,600 --> 00:15:17,600
or what have you.

504
00:15:16,600 --> 00:15:17,600
<font color="#ffff54">뭐 그런 거요.</font>

505
00:15:17,600 --> 00:15:24,600
The first thing we can do is we can render this as ASCII documentation that creates a

506
00:15:17,600 --> 00:15:24,600
<font color="#ffff54">가장 먼저 할 수 있는 일은 이것을 아스키 문서로 렌더링하여</font>

507
00:15:24,600 --> 00:15:29,600
couple of files that would then look something like this.

508
00:15:24,600 --> 00:15:29,600
<font color="#ffff54">파일 두 개를 생성하면 다음과 같이 보입니다.</font>

509
00:15:29,600 --> 00:15:35,600
It would basically create UML diagrams or C4 model diagrams for you reflecting your

510
00:15:29,600 --> 00:15:35,600
<font color="#ffff54">기본적으로 UML 다이어그램이나 C4 모델 다이어그램을 생성하여 다음과 같이 반영합니다.</font>

511
00:15:35,600 --> 00:15:37,600
actual application architecture here.

512
00:15:35,600 --> 00:15:37,600
<font color="#ffff54">실제 애플리케이션 아키텍처를 반영합니다.</font>

513
00:15:37,600 --> 00:15:44,600
Right. So the overall architecture diagram component diagram plus and that's what you

514
00:15:37,600 --> 00:15:44,600
<font color="#ffff54">맞습니다. 전체 아키텍처 다이어그램 컴포넌트 다이어그램을 더하면 다음과 같습니다.</font>

515
00:15:44,600 --> 00:15:54,600
see down here tables that we call application module canvases that are kind of they look

516
00:15:44,600 --> 00:15:54,600
<font color="#ffff54">애플리케이션 모듈 캔버스라고 부르는 이 표를 보세요.</font>

517
00:15:54,600 --> 00:15:55,600
pretty simplistic.

518
00:15:54,600 --> 00:15:55,600
<font color="#ffff54">꽤 단순합니다.</font>

519
00:15:55,600 --> 00:16:00,600
They're going to look slightly more complicated later on but they basically gather interesting

520
00:15:55,600 --> 00:16:00,600
<font color="#ffff54">나중에 조금 더 복잡해 보이지만, 기본적으로 흥미롭게 모입니다.</font>

521
00:16:00,600 --> 00:16:06,600
information about the individual modules on exactly what I just described right.

522
00:16:00,600 --> 00:16:06,600
<font color="#ffff54">개별 모듈에 대한 정보를 수집합니다.</font>

523
00:16:06,600 --> 00:16:11,600
The architecturally relevant entry points into your system what services or into your

524
00:16:06,600 --> 00:16:11,600
<font color="#ffff54">어떤 서비스나 시스템에 대한 아키텍처 관련 엔트리 포인트가</font>

525
00:16:11,600 --> 00:16:17,600
module what services are exposed what controllers are part of the module what aggregate roots

526
00:16:11,600 --> 00:16:17,600
<font color="#ffff54">모듈 어떤 서비스가 노출되는지 어떤 컨트롤러가 모듈의 일부인지 어떤 집합 루트가 있는지</font>

527
00:16:17,600 --> 00:16:22,600
are in here what configuration spring boot configuration properties are exposed and what

528
00:16:17,600 --> 00:16:22,600
<font color="#ffff54">어떤 구성 스프링 부팅 구성 프로퍼티가 노출되었는지, 어떤</font>

529
00:16:22,600 --> 00:16:27,600
are the default values what events are published going to that going to get to that in a bit

530
00:16:22,600 --> 00:16:27,600
<font color="#ffff54">에 어떤 이벤트가 게시되는지 기본값은 다음과 같습니다.</font>

531
00:16:27,600 --> 00:16:32,600
as well which events are consumed all these kinds of things the stuff that makes up the

532
00:16:27,600 --> 00:16:32,600
<font color="#ffff54">또한 어떤 이벤트가 어떤 종류의 것들을 소비하는지</font>

533
00:16:32,600 --> 00:16:36,600
surface of your of your application module right.

534
00:16:32,600 --> 00:16:36,600
<font color="#ffff54">바로 잡을 수 있습니다.</font>

535
00:16:36,600 --> 00:16:43,600
Let's play with that a bit and it's you can it's just generated in a test case so we refer

536
00:16:36,600 --> 00:16:43,600
<font color="#ffff54">테스트 케이스에서 방금 생성된 것이므로 참조할 수 있습니다.</font>

537
00:16:43,600 --> 00:16:49,600
to that as architectural observability so you can always get an impression of what the

538
00:16:43,600 --> 00:16:49,600
<font color="#ffff54">아키텍처 관찰 가능성으로 참조할 수 있으므로 항상</font>

539
00:16:49,600 --> 00:16:53,600
structure and arrangement of your system looks like and it's guaranteed to be up to

540
00:16:49,600 --> 00:16:53,600
<font color="#ffff54">시스템의 구조와 배열이 어떻게 생겼는지 항상 파악할 수 있으며</font>

541
00:16:53,600 --> 00:16:59,600
date because it just reflects what you are what you have in your code base.

542
00:16:53,600 --> 00:16:59,600
<font color="#ffff54">날짜는 코드 베이스에 있는 그대로를 반영하기 때문입니다.</font>

543
00:16:59,600 --> 00:17:06,599
Let's stick with that. Let's start with something that's quite I mean when I say application

544
00:16:59,600 --> 00:17:06,599
<font color="#ffff54">계속해봅시다. 제가 애플리케이션이라고 할 때 의미하는 것부터 시작하겠습니다.</font>

545
00:17:06,599 --> 00:17:08,599
module what does that even mean right.

546
00:17:06,599 --> 00:17:08,599
<font color="#ffff54">모듈이 정확히 무슨 뜻인지 알아봅시다.</font>

547
00:17:08,599 --> 00:17:13,599
There's some form of encapsulation going on and the first thing that a service here would

548
00:17:08,599 --> 00:17:13,599
<font color="#ffff54">어떤 형태의 캡슐화가 진행 중이며, 여기서 서비스가 가장 먼저 하는 일은 다음과 같습니다.</font>

549
00:17:13,599 --> 00:17:23,599
probably use is let's go with a class call it inventory repository.

550
00:17:13,599 --> 00:17:23,599
<font color="#ffff54">인벤토리 저장소라는 클래스를 사용하는 것이 좋습니다.</font>

551
00:17:23,599 --> 00:17:33,599
It doesn't have to be a spring data one for now we just make it a repository and add that to our

552
00:17:23,599 --> 00:17:33,599
<font color="#ffff54">지금은 스프링 데이터일 필요는 없으니 그냥 저장소로 만들어서</font>

553
00:17:33,599 --> 00:17:40,599
to our inventory here and then just go ahead and add that as a dependency private final inventory

554
00:17:33,599 --> 00:17:40,599
<font color="#ffff54">인벤토리에 추가한 다음 종속성 개인 최종 인벤토리로 추가하면 됩니다.</font>

555
00:17:40,599 --> 00:17:45,599
repository and call that repository right.

556
00:17:40,599 --> 00:17:45,599
<font color="#ffff54">저장소를 생성하고 해당 저장소를 바로 호출합니다.</font>

557
00:17:45,599 --> 00:17:49,599
So we've established like within the module there's like two components now and we've

558
00:17:45,599 --> 00:17:49,599
<font color="#ffff54">이제 모듈 내에 두 개의 컴포넌트를 설정했고, 다음과 같이 설정했습니다.</font>

559
00:17:49,599 --> 00:17:51,599
established a relationship between them.

560
00:17:49,599 --> 00:17:51,599
<font color="#ffff54">그들 사이의 관계를 설정했습니다.</font>

561
00:17:51,599 --> 00:17:57,599
So let's have a look let's just rerun the test and have a look at how this actually changes

562
00:17:51,599 --> 00:17:57,599
<font color="#ffff54">이제 테스트를 다시 실행하여 실제로 어떻게 변경되는지 살펴봅시다.</font>

563
00:17:57,599 --> 00:18:01,599
the arrangement.

564
00:17:57,599 --> 00:18:01,599
<font color="#ffff54">배열이 바뀝니다.</font>

565
00:18:01,599 --> 00:18:08,599
It should it makes or makes the inventory repository appear in our module overview right

566
00:18:01,599 --> 00:18:08,599
<font color="#ffff54">모듈 개요에 인벤토리 저장소가 나타나거나 나타나게 해야 합니다.</font>

567
00:18:08,599 --> 00:18:14,599
because it's a public class in here so it's publicly available it's available to other

568
00:18:08,599 --> 00:18:14,599
<font color="#ffff54">여기는 공개 클래스이므로 공개적으로 사용할 수 있으므로 다른 사람이 사용할 수 있습니다.</font>

569
00:18:14,599 --> 00:18:18,599
to other components or other modules.

570
00:18:14,599 --> 00:18:18,599
<font color="#ffff54">다른 컴포넌트나 다른 모듈에서 사용할 수 있습니다.</font>

571
00:18:18,599 --> 00:18:23,599
So what we could do is within the order management we could actually go ahead and create a

572
00:18:18,599 --> 00:18:23,599
<font color="#ffff54">따라서 우리가 할 수 있는 일은 주문 관리 내에서 실제로 다음과 같이 할 수 있습니다.</font>

573
00:18:23,599 --> 00:18:31,599
relationship to that inventory repository.

574
00:18:23,599 --> 00:18:31,599
<font color="#ffff54">관계를 만들 수 있습니다.</font>

575
00:18:31,599 --> 00:18:34,599
So is that something that we want.

576
00:18:31,599 --> 00:18:34,599
<font color="#ffff54">이것이 우리가 원하는 것입니다.</font>

577
00:18:34,600 --> 00:18:40,600
Very likely it's not because the repository is an implementation detail of that would just

578
00:18:34,600 --> 00:18:40,600
<font color="#ffff54">리포지토리가 구현 세부 사항이기 때문에 그렇지 않을 가능성이 매우 높습니다.</font>

579
00:18:40,600 --> 00:18:43,600
I think that doesn't change anything about the documentation.

580
00:18:40,600 --> 00:18:43,600
<font color="#ffff54">문서에 대해 아무것도 바뀌지 않는 것 같아요.</font>

581
00:18:43,600 --> 00:18:48,600
It's just the point I'm trying to make is you can easily because of just dependency

582
00:18:43,600 --> 00:18:48,600
<font color="#ffff54">제가 말하고자 하는 것은 단지 의존성 때문에 쉽게 할 수 있다는 것입니다.</font>

583
00:18:48,600 --> 00:18:53,600
injection being a global thing you could easily refer to something that's internal to the other

584
00:18:48,600 --> 00:18:53,600
<font color="#ffff54">인젝션은 전역적인 것이기 때문에 다른 것의 내부에 있는 것을 쉽게 참조할 수 있다는 것입니다.</font>

585
00:18:53,600 --> 00:18:56,600
module and you would want to avoid that right.

586
00:18:53,600 --> 00:18:56,600
<font color="#ffff54">모듈의 내부에 있는 것을 참조하는 것을 피하고 싶을 것입니다.</font>

587
00:18:56,600 --> 00:19:03,600
There are tools that you could actually use to set up rules that basically say are services

588
00:18:56,600 --> 00:19:03,600
<font color="#ffff54">기본적으로 서비스인 규칙을 설정하는 데 실제로 사용할 수 있는 도구가 있습니다.</font>

589
00:19:03,600 --> 00:19:09,600
from this module must not use repositories from other modules like ArcUnit and actually

590
00:19:03,600 --> 00:19:09,600
<font color="#ffff54">이 모듈의 저장소를 사용해서는 안되며, 실제로는 ArcUnit과 같은 다른 모듈의 저장소를 사용해서는 안된다.</font>

591
00:19:09,600 --> 00:19:14,600
what's under the covers of this application modules abstraction that I've showed you before

592
00:19:09,600 --> 00:19:14,600
<font color="#ffff54">앞서 보여드린 애플리케이션 모듈 추상화의 이면에는 무엇이 있는지 알아봅시다.</font>

593
00:19:14,600 --> 00:19:15,600
actually is ArcUnit.

594
00:19:14,600 --> 00:19:15,600
<font color="#ffff54">실제로는 ArcUnit입니다.</font>

595
00:19:15,600 --> 00:19:21,600
It's just that you don't have we had basically put stuff in place that you don't have to

596
00:19:15,600 --> 00:19:21,600
<font color="#ffff54">우리가 기본적으로 넣을 필요가 없는 것들을 넣지 않았을 뿐입니다.</font>

597
00:19:21,600 --> 00:19:27,600
actually formulate the rules yourselves right because we kind of assume a certain ideal about

598
00:19:21,600 --> 00:19:27,600
<font color="#ffff54">우리가 어떤 이상에 대해 가정하고 있기 때문에 실제로는 스스로 규칙을 만들어야 합니다.</font>

599
00:19:27,600 --> 00:19:29,600
the about the arrangement.

600
00:19:27,600 --> 00:19:29,600
<font color="#ffff54">배열에 대해.</font>

601
00:19:29,600 --> 00:19:33,600
So we want to avoid this dependency to be possible here.

602
00:19:29,600 --> 00:19:33,600
<font color="#ffff54">그래서 우리는 여기서 이러한 의존성을 피하고 싶습니다.</font>

603
00:19:33,600 --> 00:19:38,600
So a very easy way and actually a way that's not even related to spring or anything at all

604
00:19:33,600 --> 00:19:38,600
<font color="#ffff54">그래서 아주 쉬운 방법이자 실제로 스프링이나 그 어떤 것과도 전혀 관련이 없는 방법이 있습니다.</font>

605
00:19:38,600 --> 00:19:43,600
would be to just go ahead and make the class package private.

606
00:19:38,600 --> 00:19:43,600
<font color="#ffff54">클래스 패키지를 비공개로 만드는 것입니다.</font>

607
00:19:43,600 --> 00:19:47,600
And that works because we have used functional packages.

608
00:19:43,600 --> 00:19:47,600
<font color="#ffff54">함수형 패키지를 사용했기 때문에 효과가 있습니다.</font>

609
00:19:47,600 --> 00:19:54,600
If that repository had lived in a repository package it would have to be public so that others

610
00:19:47,600 --> 00:19:54,600
<font color="#ffff54">만약 해당 리포지토리가 리포지토리 패키지에 있었다면, 다른 사람들이 볼 수 있도록 공개되어야 합니다.</font>

611
00:19:54,600 --> 00:19:57,600
from other packages could actually refer to it.

612
00:19:54,600 --> 00:19:57,600
<font color="#ffff54">다른 패키지에서 실제로 참조할 수 있습니다.</font>

613
00:19:57,600 --> 00:20:04,600
But now we can just use the compiler for general purpose rudimentary not dependency management

614
00:19:57,600 --> 00:20:04,600
<font color="#ffff54">하지만 이제 컴파일러를 의존성 관리가 아닌 범용적인 기초적인 용도로만 사용할 수 있습니다.</font>

615
00:20:04,600 --> 00:20:10,600
but we can basically distinguish the stuff that's like externally accessible from the stuff

616
00:20:04,600 --> 00:20:10,600
<font color="#ffff54">하지만 기본적으로 외부에서 접근할 수 있는 것과 그렇지 않은 것을 구분할 수 있습니다.</font>

617
00:20:10,600 --> 00:20:15,600
that's not externally accessible so we can avoid the compiler already helps us to avoid

618
00:20:10,600 --> 00:20:15,600
<font color="#ffff54">와 외부에서 접근할 수 없는 것을 구분할 수 있으므로 컴파일러가 이미 도와주는</font>

619
00:20:15,600 --> 00:20:17,600
that broken dependency here.

620
00:20:15,600 --> 00:20:17,600
<font color="#ffff54">여기서 깨진 종속성을 피할 수 있습니다.</font>

621
00:20:17,600 --> 00:20:24,600
So now let's say I guess I can read your minds and you say OK yeah well that's very simplistic

622
00:20:17,600 --> 00:20:24,600
<font color="#ffff54">이제 제가 여러분의 마음을 읽을 수 있다고 가정하고, 여러분이 알았다고 답한다고 가정해 봅시다.</font>

623
00:20:24,600 --> 00:20:26,600
example right you just have that single package.

624
00:20:24,600 --> 00:20:26,600
<font color="#ffff54">예제 오른쪽에는 하나의 패키지만 있습니다.</font>

625
00:20:26,600 --> 00:20:34,600
What if you actually have a sub package in here for some reason you would want to have a sub package

626
00:20:26,600 --> 00:20:34,600
<font color="#ffff54">만약 어떤 이유로 인해 실제로 여기에 서브 패키지가 있다면 어떨까요?</font>

627
00:20:34,600 --> 00:20:41,600
and you would have to want to have a component in that sub package and then the very like this

628
00:20:34,600 --> 00:20:41,600
<font color="#ffff54">그리고 그 하위 패키지에 컴포넌트를 갖고 싶을 것이고, 바로 다음과 같이</font>

629
00:20:41,600 --> 00:20:44,600
arrangement here right so that kind of stuff.

630
00:20:41,600 --> 00:20:44,600
<font color="#ffff54">이렇게 배치해야 합니다.</font>

631
00:20:44,600 --> 00:20:48,600
And in this case that using that package scope kind of fails right.

632
00:20:44,600 --> 00:20:48,600
<font color="#ffff54">이 경우 패키지 범위를 사용하면 제대로 작동하지 않습니다.</font>

633
00:20:48,600 --> 00:20:55,600
It doesn't work anymore because as I said for the inventory to refer to its internal implementation

634
00:20:48,600 --> 00:20:55,600
<font color="#ffff54">인벤토리가 내부 구현을 참조한다고 말했듯이 더 이상 작동하지 않습니다.</font>

635
00:20:55,600 --> 00:20:59,600
detail the repository would have to be public.

636
00:20:55,600 --> 00:20:59,600
<font color="#ffff54">저장소 세부 정보를 공개해야 합니다.</font>

637
00:21:04,600 --> 00:21:10,600
So it actually has to live in the or it lives in the in the in that nested package.

638
00:21:04,600 --> 00:21:10,600
<font color="#ffff54">따라서 실제로는 중첩된 패키지에 있거나 중첩된 패키지에 있어야 합니다.</font>

639
00:21:10,600 --> 00:21:20,600
And let's have a look at how the that changes the picture of our our documentation.

640
00:21:10,600 --> 00:21:20,600
<font color="#ffff54">그리고 그것이 우리 문서의 그림을 어떻게 바꾸는지 살펴봅시다.</font>

641
00:21:20,600 --> 00:21:23,600
Let me refresh that.

642
00:21:20,600 --> 00:21:23,600
<font color="#ffff54">다시 띄워볼게요.</font>

643
00:21:23,600 --> 00:21:27,600
Reopen something's gone wrong here.

644
00:21:23,600 --> 00:21:27,600
<font color="#ffff54">여기 뭔가 잘못됐어.</font>

645
00:21:27,600 --> 00:21:35,600
Yeah you see the repository is gone again and that's due to the fact that we implement a strategy

646
00:21:27,600 --> 00:21:35,600
<font color="#ffff54">네, 리포지토리가 다시 사라진 것을 볼 수 있으며 이는 우리가 전략을 구현했기 때문입니다.</font>

647
00:21:35,600 --> 00:21:42,600
that's pretty common in alternative like modularity approaches like OSGI or JPMS where you basically

648
00:21:35,600 --> 00:21:42,600
<font color="#ffff54">OSGI나 JPMS와 같은 모듈화 접근 방식에서 흔히 볼 수 있는 일입니다.</font>

649
00:21:42,600 --> 00:21:48,600
specify packages that you that you want to export explicitly right.

650
00:21:42,600 --> 00:21:48,600
<font color="#ffff54">내보내고자 하는 패키지를 명시적으로 지정하는 것이 좋습니다.</font>

651
00:21:48,600 --> 00:21:53,600
And in 90 percent of the cases that I've seen there's always this oh here's one API package

652
00:21:48,600 --> 00:21:53,600
<font color="#ffff54">그리고 제가 본 90%의 사례에서 항상 다음과 같은 API 패키지가 있습니다.</font>

653
00:21:53,600 --> 00:21:56,600
and all the other ones are kind of not exposed.

654
00:21:53,600 --> 00:21:56,600
<font color="#ffff54">나머지는 모두 노출되지 않죠.</font>

655
00:21:56,600 --> 00:21:58,600
And that's the that's the default we assume.

656
00:21:56,600 --> 00:21:58,600
<font color="#ffff54">이것이 우리가 가정하는 기본값입니다.</font>

657
00:21:58,600 --> 00:22:04,600
So the fundamental idea is that you put all of the stuff that you want other modules to be able to use

658
00:21:58,600 --> 00:22:04,600
<font color="#ffff54">따라서 기본 아이디어는 다른 모듈이 사용할 수 있도록 모든 것을 넣는 것입니다.</font>

659
00:22:04,600 --> 00:22:09,600
in the very base package of your module and everything else is hidden by default.

660
00:22:04,600 --> 00:22:09,600
<font color="#ffff54">모듈의 기본 패키지에 넣고 다른 모든 것은 기본적으로 숨기는 것입니다.</font>

661
00:22:09,600 --> 00:22:17,600
You can then selectively add or add some configuration to export other packages or other types as part of the

662
00:22:09,600 --> 00:22:17,600
<font color="#ffff54">그런 다음 다른 패키지나 다른 유형을 내보내도록 선택적으로 추가하거나 일부 구성을 추가할 수 있습니다.</font>

663
00:22:17,600 --> 00:22:23,600
API. But by default that's basically what what what we assume here.

664
00:22:17,600 --> 00:22:23,600
<font color="#ffff54">API. 하지만 기본적으로 여기서는 기본적으로 그렇게 가정합니다.</font>

665
00:22:23,600 --> 00:22:28,600
And that's also why the internal component doesn't show up in the in the documentation here.

666
00:22:23,600 --> 00:22:28,600
<font color="#ffff54">이것이 바로 여기 문서에 내부 컴포넌트가 표시되지 않는 이유이기도 합니다.</font>

667
00:22:28,600 --> 00:22:30,600
It's an implementation detail of the module.

668
00:22:28,600 --> 00:22:30,600
<font color="#ffff54">모듈의 구현 세부 사항입니다.</font>

669
00:22:30,600 --> 00:22:33,600
It's not of the business to other developers outside of the module.

670
00:22:30,600 --> 00:22:33,600
<font color="#ffff54">모듈 외부의 다른 개발자와는 상관없는 내용입니다.</font>

671
00:22:33,600 --> 00:22:37,600
So that's why it's not listed as entry point.

672
00:22:33,600 --> 00:22:37,600
<font color="#ffff54">그래서 진입점으로 나열되지 않습니다.</font>

673
00:22:37,600 --> 00:22:46,600
It not showing up in the documentation doesn't unfortunately prevent us from reintroducing that dependency

674
00:22:37,600 --> 00:22:46,600
<font color="#ffff54">문서에 표시되지 않는다고 해서 안타깝게도 해당 종속성을 다시 도입할 수는 없습니다.</font>

675
00:22:46,600 --> 00:22:48,600
here. Right. That would still work.

676
00:22:46,600 --> 00:22:48,600
<font color="#ffff54">여기. 그렇군요. 여전히 작동합니다.</font>

677
00:22:48,600 --> 00:22:53,600
Remember the compiler helped us when we were able to actually package scope the repository.

678
00:22:48,600 --> 00:22:53,600
<font color="#ffff54">저장소 범위를 실제로 패키지화할 수 있을 때 컴파일러가 도움이 되었다는 것을 기억하세요.</font>

679
00:22:53,600 --> 00:22:57,600
That was the compiler that basically said OK you can't actually see that other type.

680
00:22:53,600 --> 00:22:57,600
<font color="#ffff54">컴파일러는 기본적으로 다른 유형을 실제로 볼 수 없다고 말했죠.</font>

681
00:22:57,600 --> 00:23:00,600
So we can do that now because it has to be public.

682
00:22:57,600 --> 00:23:00,600
<font color="#ffff54">이제 공개해야 하니까 할 수 있습니다.</font>

683
00:23:00,600 --> 00:23:02,600
So what do we do about this.

684
00:23:00,600 --> 00:23:02,600
<font color="#ffff54">그럼 이제 어떻게 할까요?</font>

685
00:23:02,600 --> 00:23:09,600
Either write our own ARC unit rules or basically just call that verify method on the modules here.

686
00:23:02,600 --> 00:23:09,600
<font color="#ffff54">자체 ARC 단위 규칙을 작성하거나 기본적으로 여기 모듈에서 해당 확인 메서드를 호출합니다.</font>

687
00:23:09,600 --> 00:23:13,600
And if I run this this test should fail now.

688
00:23:09,600 --> 00:23:13,600
<font color="#ffff54">그리고 이걸 실행하면 이 테스트는 지금 실패해야 합니다.</font>

689
00:23:13,600 --> 00:23:14,600
And it does.

690
00:23:13,600 --> 00:23:14,600
<font color="#ffff54">그리고 성공합니다.</font>

691
00:23:16,600 --> 00:23:20,600
Because it basically says the first line is the interesting one.

692
00:23:16,600 --> 00:23:20,600
<font color="#ffff54">기본적으로 첫 번째 줄이 흥미로운 줄이라고 하니까.</font>

693
00:23:20,600 --> 00:23:26,600
Module order depends on non-exposed type inventory repository within module inventory.

694
00:23:20,600 --> 00:23:26,600
<font color="#ffff54">모듈 순서는 모듈 인벤토리 내 비노출형 인벤토리 저장소에 따라 달라집니다.</font>

695
00:23:26,600 --> 00:23:36,600
So you get some some next level check of of your dependency arrangement with these with these conventions applied.

696
00:23:26,600 --> 00:23:36,600
<font color="#ffff54">따라서 이러한 규칙을 적용하여 종속성 배열을 다음 단계로 점검할 수 있습니다.</font>

697
00:23:36,600 --> 00:23:42,600
And you have to note here we haven't declared any kind of additional metadata at all.

698
00:23:36,600 --> 00:23:42,600
<font color="#ffff54">그리고 여기서 주목해야 할 점은 추가 메타데이터를 전혀 선언하지 않았다는 점입니다.</font>

699
00:23:42,600 --> 00:23:45,600
Like no configuration of the tool yet.

700
00:23:42,600 --> 00:23:45,600
<font color="#ffff54">아직 도구를 구성하지 않은 것처럼 보입니다.</font>

701
00:23:45,600 --> 00:23:54,600
It's just like OK just arrange your code for encapsulation and then you basically get the verification for free.

702
00:23:45,600 --> 00:23:54,600
<font color="#ffff54">코드를 캡슐화할 수 있도록 정렬하기만 하면 기본적으로 무료로 검증을 받을 수 있습니다.</font>

703
00:23:54,600 --> 00:24:04,600
And it also means that until now it that that production code site here the source main Java thing is a spring boot application as it was before.

704
00:23:54,600 --> 00:24:04,600
<font color="#ffff54">그리고 그것은 또한 지금까지는 여기 프로덕션 코드 사이트에서 소스 메인 자바가 이전과 마찬가지로 스프링 부트 애플리케이션이라는 것을 의미합니다.</font>

705
00:24:04,600 --> 00:24:07,600
There's no references to anything spring module is so far.

706
00:24:04,600 --> 00:24:07,600
<font color="#ffff54">지금까지 스프링 모듈이 무엇인지에 대한 참조가 없습니다.</font>

707
00:24:07,600 --> 00:24:09,600
So it's not at its very core.

708
00:24:07,600 --> 00:24:09,600
<font color="#ffff54">그래서 핵심이 아닙니다.</font>

709
00:24:09,600 --> 00:24:15,600
It's very non-invasive to to you as a maybe seasoned spring boot developers.

710
00:24:09,600 --> 00:24:15,600
<font color="#ffff54">노련한 스프링 부트 개발자에게는 매우 비침습적입니다.</font>

711
00:24:15,600 --> 00:24:18,600
That's kind of that's kind of the idea here.

712
00:24:15,600 --> 00:24:18,600
<font color="#ffff54">그게 바로 이 아이디어의 핵심입니다.</font>

713
00:24:18,600 --> 00:24:26,600
Right. So try to be as less invasive as possible but at the same time give you all the architectural benefits for now.

714
00:24:18,600 --> 00:24:26,600
<font color="#ffff54">맞아요. 따라서 가능한 한 덜 침습적이면서 동시에 현재로서는 모든 건축적 이점을 제공하도록 노력하세요.</font>

715
00:24:26,600 --> 00:24:28,600
So that's the verification stuff.

716
00:24:26,600 --> 00:24:28,600
<font color="#ffff54">그게 바로 확인 작업입니다.</font>

717
00:24:28,600 --> 00:24:32,600
You can achieve that part of the story with other approaches as well.

718
00:24:28,600 --> 00:24:32,600
<font color="#ffff54">다른 접근 방식으로도 이 부분을 달성할 수 있습니다.</font>

719
00:24:32,600 --> 00:24:35,600
Right. The typical thing that's brought up is build modules.

720
00:24:32,600 --> 00:24:35,600
<font color="#ffff54">맞아요. 일반적으로 빌드 모듈을 사용하는 경우가 많습니다.</font>

721
00:24:35,600 --> 00:24:41,600
Of course you can actually have use build modules for that and spring module with would still work with them.

722
00:24:35,600 --> 00:24:41,600
<font color="#ffff54">물론 실제로 빌드 모듈을 사용할 수 있으며 스프링 모듈을 사용하면 여전히 작동합니다.</font>

723
00:24:41,600 --> 00:24:52,600
You don't necessarily need that verification then anymore because you basically you're forced to declare the dependencies explicitly and then you can have your API module and your implementation module.

724
00:24:41,600 --> 00:24:52,600
<font color="#ffff54">기본적으로 의존성을 명시적으로 선언하고 API 모듈과 구현 모듈을 가질 수 있기 때문에 더 이상 그런 검증이 필요하지 않습니다.</font>

725
00:24:52,600 --> 00:25:01,600
But for smaller applications I have this like this other thing that I do with this an example project for for spring module with with the TU Dresden.

726
00:24:52,600 --> 00:25:01,600
<font color="#ffff54">하지만 더 작은 애플리케이션을 위해 저는 드레스덴 공과대학교와 함께 스프링 모듈을 위한 예제 프로젝트를 가지고 있습니다.</font>

727
00:25:02,600 --> 00:25:04,600
There's like 15 logical modules in there.

728
00:25:02,600 --> 00:25:04,600
<font color="#ffff54">거기에는 15개의 논리적 모듈이 있습니다.</font>

729
00:25:04,600 --> 00:25:17,600
If I had to declare an API and implementation module for each of those I end up with 30 build modules and a lot of like built descriptors at like four with with modules ending up with modules with a single type in them.

730
00:25:04,600 --> 00:25:17,600
<font color="#ffff54">각각에 대해 API와 구현 모듈을 선언해야 한다면 30개의 빌드 모듈이 생기고, 모듈이 하나의 유형으로 끝나는 4개의 빌드 디스크립터와 같은 많은 빌드 디스크립터가 생깁니다.</font>

731
00:25:17,600 --> 00:25:19,600
That's a bit of an overkill.

732
00:25:17,600 --> 00:25:19,600
<font color="#ffff54">그건 좀 과하네요.</font>

733
00:25:19,600 --> 00:25:24,600
So whereas like in bigger projects it could be just very well a good solution.

734
00:25:19,600 --> 00:25:24,600
<font color="#ffff54">대규모 프로젝트에서는 아주 좋은 해결책이 될 수도 있겠지만.</font>

735
00:25:24,600 --> 00:25:30,600
Right. The build module. So it's not an either or it's more of an OK what's the easiest way to achieve something here.

736
00:25:24,600 --> 00:25:30,600
<font color="#ffff54">맞아요. 빌드 모듈이죠. 이도 저도 아니면 저도 안 된다는 식이 아니라, 여기서 가장 쉽게 무언가를 달성할 수 있는 방법이 무엇인지에 더 가깝죠.</font>

737
00:25:30,600 --> 00:25:35,600
And that's that's why it's why it's why it's kind of put in that verification stuff.

738
00:25:30,600 --> 00:25:35,600
<font color="#ffff54">그렇기 때문에 검증 기능을 넣는 거죠.</font>

739
00:25:35,600 --> 00:25:38,600
All right. So we have let's move on.

740
00:25:35,600 --> 00:25:38,600
<font color="#ffff54">알았어요. 그럼 계속 진행하죠.</font>

741
00:25:38,600 --> 00:25:48,600
We have what's the final state of we have to repair basically resolve our architectural problem here by deleting that line of code.

742
00:25:38,600 --> 00:25:48,600
<font color="#ffff54">이제 해당 코드 줄을 삭제하여 아키텍처 문제를 근본적으로 해결해야 하는 최종 상태가 되었습니다.</font>

743
00:25:48,600 --> 00:25:54,600
That's always the best solution deleting or solving problems by deleting code.

744
00:25:48,600 --> 00:25:54,600
<font color="#ffff54">항상 코드를 삭제하거나 삭제하여 문제를 해결하는 것이 가장 좋은 해결책입니다.</font>

745
00:25:54,600 --> 00:26:03,600
So we have our arrangement here and the other let's go back to the to the command line output.

746
00:25:54,600 --> 00:26:03,600
<font color="#ffff54">여기까지 정리했으니 이제 명령줄 출력으로 돌아가 봅시다.</font>

747
00:26:03,600 --> 00:26:14,600
We have you seen we've had these we have these three modules here and they currently they don't have a dependency really or like a dependency.

748
00:26:03,600 --> 00:26:14,600
<font color="#ffff54">여기 세 개의 모듈이 있는데 현재 이 모듈들은 실제로 종속성이 없거나 종속성처럼 보이지 않습니다.</font>

749
00:26:14,600 --> 00:26:17,600
There's no dependency between the modules.

750
00:26:14,600 --> 00:26:17,600
<font color="#ffff54">모듈 간에 의존성이 없습니다.</font>

751
00:26:18,600 --> 00:26:35,600
And what's what's kind of nice is that we can now go ahead or let's say we have a model of the of the of the module arrangement and we can use that model to bootstrap test integration test spring boot integration tests for the individual modules.

752
00:26:18,600 --> 00:26:35,600
<font color="#ffff54">그리고 좋은 점은 이제 모듈 배열에 대한 모델이 있고 이 모델을 사용하여 개별 모듈에 대한 통합 테스트 스프링 부트 통합 테스트를 부트스트랩할 수 있다는 것입니다.</font>

753
00:26:35,600 --> 00:26:47,600
And we do that by if you've used spring boot before they have a feature called slice tests where you can actually horizontally again like technically test individual layers right.

754
00:26:35,600 --> 00:26:47,600
<font color="#ffff54">그리고 스프링 부트를 사용해 본 적이 있다면 슬라이스 테스트라는 기능을 통해 개별 레이어를 기술적으로 바로 테스트하는 것처럼 실제로 수평적으로 다시 테스트할 수 있습니다.</font>

755
00:26:47,600 --> 00:26:55,600
You can have the data JPA test that would just bootstrap JPA repositories or you have the I think it's web at web test or something like that.

756
00:26:47,600 --> 00:26:55,600
<font color="#ffff54">JPA 리포지토리를 부트스트랩하는 데이터 JPA 테스트를 할 수도 있고, 웹에서 웹 테스트 같은 것을 할 수도 있습니다.</font>

757
00:26:55,600 --> 00:27:02,600
We see test I think that just bootstraps the controller level but expects mocks for all the services the controllers are using right.

758
00:26:55,600 --> 00:27:02,600
<font color="#ffff54">컨트롤러 레벨을 부트스트랩하지만 컨트롤러가 올바르게 사용하고 있는 모든 서비스에 대한 모의 테스트를 기대하는 테스트가 있는 것 같습니다.</font>

759
00:27:02,600 --> 00:27:17,600
So it's again horizontally oriented because that's the only structural information that spring framework or spring boot can actually have unless you have a functional separation model in place like we have now.

760
00:27:02,600 --> 00:27:17,600
<font color="#ffff54">지금처럼 기능 분리 모델이 없다면 스프링 프레임워크나 스프링 부트가 실제로 가질 수 있는 유일한 구조적 정보이기 때문에 다시 수평 지향적입니다.</font>

761
00:27:17,600 --> 00:27:27,600
And that's why we can actually go ahead and say at application module tests that would basically from this very package would try to find the application class.

762
00:27:17,600 --> 00:27:27,600
<font color="#ffff54">그렇기 때문에 애플리케이션 모듈 테스트에서 기본적으로 바로 이 패키지에서 애플리케이션 클래스를 찾으려고 시도한다고 말할 수 있습니다.</font>

763
00:27:28,600 --> 00:27:45,600
Right. Just try to traverse them to the top find the spring boot application class build the application module model from that and then look at oh in which package is that test actually located and it would try to bootstrap only that module.

764
00:27:28,600 --> 00:27:45,600
<font color="#ffff54">맞아요. 그냥 맨 위에 있는 스프링 부트 애플리케이션 클래스를 찾아서 거기서 애플리케이션 모듈 모델을 빌드한 다음, 그 테스트가 실제로 어느 패키지에 있는지 살펴보고 해당 모듈만 부트스트랩하려고 할 것입니다.</font>

765
00:27:45,600 --> 00:27:54,600
And you can see that in the in the log output if you run this it's it basically prints out like what it's doing.

766
00:27:45,600 --> 00:27:54,600
<font color="#ffff54">그리고 이것을 실행하면 로그 출력에서 기본적으로 수행 중인 작업이 출력되는 것을 볼 수 있습니다.</font>

767
00:27:54,600 --> 00:27:57,600
So it's an application module test for the inventory in the mode standalone.

768
00:27:54,600 --> 00:27:57,600
<font color="#ffff54">독립형 모드에서 인벤토리에 대한 애플리케이션 모듈 테스트입니다.</font>

769
00:27:57,600 --> 00:28:06,600
So we try to bootstrap a single module only and it basically prints out all the stuff that that are the modules that it actually bootstraps.

770
00:27:57,600 --> 00:28:06,600
<font color="#ffff54">그래서 우리는 하나의 모듈만 부트스트랩하려고 시도하고 기본적으로 실제로 부트스트랩하는 모듈에 해당하는 모든 것을 출력합니다.</font>

771
00:28:06,600 --> 00:28:08,600
I'm going to get ahead on that in a second.

772
00:28:06,600 --> 00:28:08,600
<font color="#ffff54">잠시 후에 더 자세히 설명할게요.</font>

773
00:28:08,600 --> 00:28:13,600
Right. And the interesting the interesting output here is basically this right.

774
00:28:08,600 --> 00:28:13,600
<font color="#ffff54">그렇군요. 그리고 여기서 흥미로운 결과는 기본적으로 이 오른쪽입니다.</font>

775
00:28:13,600 --> 00:28:18,600
So we find we want this test wants to bootstrap the inventory module.

776
00:28:13,600 --> 00:28:18,600
<font color="#ffff54">이 테스트가 인벤토리 모듈을 부트스트랩하기를 원한다는 것을 알 수 있습니다.</font>

777
00:28:18,600 --> 00:28:30,600
So we tweak the spring boot startup to only apply the auto configuration and the entity scanning to the code that's located in the example of inventory module.

778
00:28:18,600 --> 00:28:30,600
<font color="#ffff54">따라서 인벤토리 모듈의 예제에 있는 코드에만 자동 구성과 엔티티 스캔을 적용하도록 스프링 부팅 시작을 조정합니다.</font>

779
00:28:30,600 --> 00:28:42,600
Right. And that's kind of it's like bootstrapping hibernate with a with a certain subset of entities and what it's a complete integration test but just like strong with strong vertical vertical slices here.

780
00:28:30,600 --> 00:28:42,600
<font color="#ffff54">맞아요. 그리고 그것은 일종의 특정 하위 집합의 엔티티와 함께 부트스트랩 동면과 완전한 통합 테스트이지만 여기에 강력한 수직 수직 슬라이스가 있는 강력한 것과 같습니다.</font>

781
00:28:43,600 --> 00:28:54,600
That's it. Let's add some that's I mean for the inventory it's kind of nice and easy because there's no outgoing dependencies to it.

782
00:28:43,600 --> 00:28:54,600
<font color="#ffff54">그게 다입니다. 인벤토리에 대한 종속성이 없기 때문에 인벤토리에 대한 몇 가지를 추가해 보겠습니다.</font>

783
00:28:54,600 --> 00:29:10,600
Right. Let's add some dependency like a valid dependency actually private final inventory because you remember we wanted to at some point we wanted to trigger the update of the inventory.

784
00:28:54,600 --> 00:29:10,600
<font color="#ffff54">그렇군요. 인벤토리 업데이트를 트리거하고 싶었던 시점을 기억하실 테니 유효한 종속성을 실제로 비공개 최종 인벤토리와 같은 종속성을 추가해 봅시다.</font>

785
00:29:10,600 --> 00:29:28,600
So we the order management obviously has or not obviously but it has to have a dependency to the inventory for now which basically changes our let me render the documentation again and refresh that which should.

786
00:29:10,600 --> 00:29:28,600
<font color="#ffff54">따라서 주문 관리에는 분명히 있든 없든 인벤토리에 대한 종속성이 있어야 하므로 기본적으로 문서를 다시 렌더링하고 새로 고쳐야 하는 것을 변경해야 합니다.</font>

787
00:29:28,600 --> 00:29:31,600
Yeah. So the order module now uses the inventory.

788
00:29:28,600 --> 00:29:31,600
<font color="#ffff54">네. 이제 주문 모듈이 인벤토리를 사용합니다.</font>

789
00:29:31,600 --> 00:29:33,600
See that up here.

790
00:29:31,600 --> 00:29:33,600
<font color="#ffff54">여기 보세요.</font>

791
00:29:33,600 --> 00:29:35,600
It uses the inventory.

792
00:29:33,600 --> 00:29:35,600
<font color="#ffff54">인벤토리를 사용합니다.</font>

793
00:29:35,600 --> 00:29:42,600
It means that we have a spring bean relationship across a module boundary going to come back to that right.

794
00:29:35,600 --> 00:29:42,600
<font color="#ffff54">이는 모듈 경계를 가로지르는 스프링 빈 관계가 다시 오른쪽으로 돌아온다는 것을 의미합니다.</font>

795
00:29:42,600 --> 00:29:44,600
Why the why this is important.

796
00:29:42,600 --> 00:29:44,600
<font color="#ffff54">이것이 중요한 이유.</font>

797
00:29:44,600 --> 00:29:48,600
And if we now start our order integration test.

798
00:29:44,600 --> 00:29:48,600
<font color="#ffff54">이제 주문 통합 테스트를 시작하겠습니다.</font>

799
00:29:48,600 --> 00:29:52,600
I guess you can follow that this would have to fail.

800
00:29:48,600 --> 00:29:52,600
<font color="#ffff54">이 테스트는 실패해야 한다는 것을 알 수 있습니다.</font>

801
00:29:52,600 --> 00:29:55,600
Right. Why would why does that have to fail.

802
00:29:52,600 --> 00:29:55,600
<font color="#ffff54">맞아요. 왜 실패해야 하죠?</font>

803
00:29:55,600 --> 00:29:58,600
It would try to bootstrap the order.

804
00:29:55,600 --> 00:29:58,600
<font color="#ffff54">주문을 부트스트랩하려고 합니다.</font>

805
00:29:58,600 --> 00:30:02,600
Package and all the spring beans located in that order package.

806
00:29:58,600 --> 00:30:02,600
<font color="#ffff54">패키지와 해당 주문 패키지에 있는 모든 스프링 빈을 가져옵니다.</font>

807
00:30:02,600 --> 00:30:09,600
And that means it would have to find and bean of type inventory to satisfy the dependency here which it shouldn't.

808
00:30:02,600 --> 00:30:09,600
<font color="#ffff54">이는 여기서 종속성을 만족시키기 위해 유형 인벤토리를 찾아서 빈을 생성해야 한다는 것을 의미하는데, 그렇게 해서는 안 됩니다.</font>

809
00:30:09,600 --> 00:30:17,600
Right. So let's run this test and see how it fails actually.

810
00:30:09,600 --> 00:30:17,600
<font color="#ffff54">맞습니다. 그럼 이 테스트를 실행해서 실제로 어떻게 실패하는지 살펴봅시다.</font>

811
00:30:17,600 --> 00:30:22,600
Yeah. As expected no such being definition qualifying being of inventory is available which is expected.

812
00:30:17,600 --> 00:30:22,600
<font color="#ffff54">그렇군요. 예상대로 인벤토리의 정의에 부합하는 존재를 찾을 수 없습니다.</font>

813
00:30:22,600 --> 00:30:24,600
But what do we do about this.

814
00:30:22,600 --> 00:30:24,600
<font color="#ffff54">이제 어떻게 해야 하죠?</font>

815
00:30:24,600 --> 00:30:29,600
There's two things you can do. One is like the standard spring boot thing that you would do in such cases.

816
00:30:24,600 --> 00:30:29,600
<font color="#ffff54">두 가지 방법이 있습니다. 하나는 이런 경우 일반적으로 하는 스프링 부팅과 같은 것입니다.</font>

817
00:30:29,600 --> 00:30:37,600
It's you would provide this thing with an mock bean inventory.

818
00:30:29,600 --> 00:30:37,600
<font color="#ffff54">모의 콩 인벤토리를 제공하는 것입니다.</font>

819
00:30:37,600 --> 00:30:46,600
And I like the stylistically quite a lot because it basically what you express here is oh to run the order the order module.

820
00:30:37,600 --> 00:30:46,600
<font color="#ffff54">그리고 기본적으로 여기서 표현하는 것은 주문 모듈을 실행하는 것이기 때문에 스타일이 상당히 마음에 듭니다.</font>

821
00:30:46,600 --> 00:30:51,600
I have to mock the dependency to that other module.

822
00:30:46,600 --> 00:30:51,600
<font color="#ffff54">다른 모듈에 대한 의존성을 조롱해야 해요.</font>

823
00:30:51,600 --> 00:30:57,600
Right. If you if you're developing microservices and you have relationships to other services then you have to wire mock those.

824
00:30:51,600 --> 00:30:57,600
<font color="#ffff54">맞아요. 마이크로서비스를 개발하면서 다른 서비스와의 관계가 있다면 와이어 모킹을 해야 합니다.</font>

825
00:30:57,600 --> 00:31:02,600
Right. It's kind of a similar idea but without all the network and all the infrastructure stuff in place here.

826
00:30:57,600 --> 00:31:02,600
<font color="#ffff54">맞아요. 비슷한 개념이지만 여기에는 네트워크와 인프라가 모두 갖춰져 있지 않죠.</font>

827
00:31:02,600 --> 00:31:08,600
Right. So you you mock the other the other component and then this this test bootstraps just fine.

828
00:31:02,600 --> 00:31:08,600
<font color="#ffff54">그렇군요. 다른 컴포넌트를 조롱한 다음 이 테스트는 잘 부트스트랩됩니다.</font>

829
00:31:08,600 --> 00:31:11,600
Right. You see it's green here. That works.

830
00:31:08,600 --> 00:31:11,600
<font color="#ffff54">그렇군요. 여기 초록색이 보이시죠? 작동합니다.</font>

831
00:31:11,600 --> 00:31:20,600
Another thing you can do and that kind of that's an interesting part and that sets apart like other module or it sets apart this stuff here from other modularity.

832
00:31:11,600 --> 00:31:20,600
<font color="#ffff54">당신이 할 수 있는 또 다른 일과 그런 종류의 흥미로운 부분이며 다른 모듈과 차별화되거나 다른 모듈과 차별화됩니다.</font>

833
00:31:20,600 --> 00:31:30,600
Approaches is that you can basically say I want to bootstrap not only the application.

834
00:31:20,600 --> 00:31:30,600
<font color="#ffff54">접근 방식은 기본적으로 애플리케이션뿐만 아니라 부트스트랩을 하고 싶다고 말할 수 있습니다.</font>

835
00:31:30,600 --> 00:31:42,600
The that individual module but from all the modules available the ones that I depend on and either in a direct step which in this case would would just work.

836
00:31:30,600 --> 00:31:42,600
<font color="#ffff54">그 개별 모듈뿐만 아니라 사용 가능한 모든 모듈 중에서 내가 의존하는 모듈과 이 경우 작동하는 직접 단계 중 하나를 선택합니다.</font>

837
00:31:43,600 --> 00:31:52,600
Or I want to select the entire subtree of modules that I need to actually bootstrap to get my module to work.

838
00:31:43,600 --> 00:31:52,600
<font color="#ffff54">또는 모듈을 작동시키기 위해 실제로 부트스트랩해야 하는 모듈의 전체 하위 트리를 선택하고 싶습니다.</font>

839
00:31:52,600 --> 00:32:00,600
It's a key differentiator to exam for example things like the Java module system right that has a very like different way of approaching integration tests.

840
00:31:52,600 --> 00:32:00,600
<font color="#ffff54">예를 들어 통합 테스트에 접근하는 방식이 매우 유사한 Java 모듈 시스템 권한과 같은 것을 검사하는 것이 핵심적인 차별화 요소입니다.</font>

841
00:32:00,600 --> 00:32:11,600
And that would actually that that different bootstrap mode is reflected in the in the log output because like with all this these customizations it's kind of OK how do I find out what's actually running here.

842
00:32:00,600 --> 00:32:11,600
<font color="#ffff54">이 모든 커스터마이징과 마찬가지로 실제로 여기서 무엇이 실행되고 있는지 어떻게 알 수 있는지 알 수 있기 때문에 실제로 다른 부트스트랩 모드가 로그 출력에 반영됩니다.</font>

843
00:32:11,600 --> 00:32:14,600
So it basically says OK mode direct dependencies.

844
00:32:11,600 --> 00:32:14,600
<font color="#ffff54">기본적으로 OK 모드의 직접 종속성을 나타냅니다.</font>

845
00:32:14,600 --> 00:32:23,600
This is the module that we were trying to bootstrap and we include transparently include for you that other module as well.

846
00:32:14,600 --> 00:32:23,600
<font color="#ffff54">이것은 우리가 부트스트랩하려고 했던 모듈이며, 다른 모듈도 투명하게 포함시킵니다.</font>

847
00:32:23,600 --> 00:32:32,600
And there's there's means for you to actually say I want this particular module to be started alongside with all the others although it's not directly related.

848
00:32:23,600 --> 00:32:32,600
<font color="#ffff54">그리고 직접 관련이 없지만 이 특정 모듈이 다른 모든 모듈과 함께 시작되기를 원한다고 실제로 말할 수 있는 수단이 있습니다.</font>

849
00:32:32,600 --> 00:32:45,600
Or you can can formulate that but that's a nice way of basically increasing gradually increasing the scope of your integration tests depending on on what you want to do with that.

850
00:32:32,600 --> 00:32:45,600
<font color="#ffff54">또는 그렇게 공식화할 수도 있지만, 기본적으로 통합 테스트의 범위를 원하는 목적에 따라 점진적으로 늘리는 것도 좋은 방법입니다.</font>

851
00:32:46,600 --> 00:32:53,600
All right. So how many minutes do I have left. Someone tell me we started at 30 15 10 minutes.

852
00:32:46,600 --> 00:32:53,600
<font color="#ffff54">좋아요. 이제 몇 분 남았죠? 30분 15초에 시작했다고 누가 그러던데?</font>

853
00:32:54,600 --> 00:33:02,600
All right. So there is that's the integration test feature. We're going to expand a bit on that in a in a bit.

854
00:32:54,600 --> 00:33:02,600
<font color="#ffff54">알았어요 통합 테스트 기능이 있습니다. 잠시 후에 조금 더 자세히 설명하겠습니다.</font>

855
00:33:02,600 --> 00:33:07,600
I have to let me go get YOLO.

856
00:33:02,600 --> 00:33:07,600
<font color="#ffff54">욜로를 즐기러 가야겠어요.</font>

857
00:33:10,600 --> 00:33:13,600
Steps I think it's zero one it's got to be.

858
00:33:10,600 --> 00:33:13,600
<font color="#ffff54">걸음 수 0이 되어야 할 것 같아요.</font>

859
00:33:15,600 --> 00:33:16,600
Yeah that's the right one.

860
00:33:15,600 --> 00:33:16,600
<font color="#ffff54">네, 맞아요.</font>

861
00:33:16,600 --> 00:33:22,600
Fast forward a couple of a couple of steps. Let's remove this.

862
00:33:16,600 --> 00:33:22,600
<font color="#ffff54">몇 단계를 빨리 감습니다. 이걸 제거해 봅시다.</font>

863
00:33:22,600 --> 00:33:31,600
What I've what I've added here in this step is just a sample for spring boot configuration properties that are just located in the inventory package.

864
00:33:22,600 --> 00:33:31,600
<font color="#ffff54">이 단계에서 추가한 것은 인벤토리 패키지에 있는 스프링 부팅 구성 속성에 대한 샘플일 뿐입니다.</font>

865
00:33:31,600 --> 00:33:39,600
And let me just run the the documentation generation for you to see a slightly slightly updated.

866
00:33:31,600 --> 00:33:39,600
<font color="#ffff54">이제 문서 생성을 실행하여 약간 업데이트된 내용을 확인해 보겠습니다.</font>

867
00:33:39,600 --> 00:33:45,600
Why is that so tiny for a for for updated document documentation.

868
00:33:39,600 --> 00:33:45,600
<font color="#ffff54">업데이트된 문서 문서에 비해 왜 이렇게 작죠?</font>

869
00:33:45,600 --> 00:33:56,600
You see that has it we have now have these these properties section in here that basically documents to like your casual reader if you have someone new coming to the team and you basically tell them all you need to work with the inventory module and they kind of

870
00:33:45,600 --> 00:33:56,600
<font color="#ffff54">이제 팀에 새로 온 사람이 있고 기본적으로 인벤토리 모듈을 사용하는 데 필요한 모든 것을 알려주면 일반 독자가 좋아할 만한 문서가 여기에 있습니다.</font>

871
00:33:56,600 --> 00:34:02,600
have to find out OK what can we actually configure about it and what kind of what are the the interesting aspects of it.

872
00:33:56,600 --> 00:34:02,600
<font color="#ffff54">실제로 무엇을 구성할 수 있는지, 어떤 점이 흥미로운지 알아내야 합니다.</font>

873
00:34:02,600 --> 00:34:06,600
There's a bit of just meta information for you to extract into the documentation.

874
00:34:02,600 --> 00:34:06,600
<font color="#ffff54">문서로 추출할 수 있는 메타 정보가 조금 있습니다.</font>

875
00:34:06,600 --> 00:34:14,600
What's also happened is we now have moved to event based communication between the user and the user.

876
00:34:06,600 --> 00:34:14,600
<font color="#ffff54">또한 이제 사용자와 사용자 간의 이벤트 기반 통신으로 전환되었습니다.</font>

877
00:34:14,599 --> 00:34:23,599
And a large part of spring module is as a whole is supporting that integration style because if you find yourself or these these functional or these business events of order completion they usually develop some kind of a

878
00:34:14,599 --> 00:34:23,599
<font color="#ffff54">그리고 스프링 모듈의 큰 부분은 전체적으로 이러한 통합 스타일을 지원하고 있습니다. 왜냐하면 여러분 자신이나 이러한 기능 또는 주문 완료의 비즈니스 이벤트를 발견하면 일반적으로 어떤 종류의</font>

879
00:34:23,599 --> 00:34:39,599
kind of a

880
00:34:23,599 --> 00:34:39,599
<font color="#ffff54">일종의</font>

881
00:34:39,599 --> 00:34:44,599
functional gravity that cause you to having to like build up a lot of dependencies for those right.

882
00:34:39,599 --> 00:34:44,599
<font color="#ffff54">기능적 중력 때문에 그 권리를 위해 많은 의존성을 구축해야 합니다.</font>

883
00:34:44,599 --> 00:34:56,599
If you want to if you complete an order you want to update the stock you want to send out emails you might have to let's say update some bonus points on some rewards program and you can have an entire team building that functionality but you will have to go back to that bloody order management

884
00:34:44,599 --> 00:34:56,599
<font color="#ffff54">주문을 완료하면 재고를 업데이트하여 이메일을 보내려면 일부 보상 프로그램에서 보너스 포인트를 업데이트해야 할 수 있으며 전체 팀이 해당 기능을 구축 할 수 있지만 그 피 묻은 주문 관리로 돌아 가야 할 것입니다.</font>

885
00:34:56,599 --> 00:35:05,599
complete order method to actually to to add the dependency to invoke that very method right.

886
00:34:56,599 --> 00:35:05,599
<font color="#ffff54">바로 그 메서드를 호출하는 종속성을 추가하기 위해 실제로 주문 메서드를 완성합니다.</font>

887
00:35:05,599 --> 00:35:14,599
And the same way you don't want your microservice to reach out to 15 different other microservices to achieve some some business result you don't actually want to do that because you don't want to have to do that.

888
00:35:05,599 --> 00:35:14,599
<font color="#ffff54">마이크로서비스가 어떤 비즈니스 결과를 얻기 위해 15개의 다른 마이크로서비스에 연락하는 것을 원하지 않는 것과 마찬가지로, 실제로는 그렇게 하고 싶지 않기 때문에 그렇게 하고 싶지 않습니다.</font>

889
00:35:14,599 --> 00:35:24,599
So the idea is that you fundamentally switch for these cross module invocations you switch to event based communication and there's a bit of spring data support for public publishing application events in the same way you want to do that.

890
00:35:14,599 --> 00:35:24,599
<font color="#ffff54">따라서 아이디어는 이러한 교차 모듈 호출을 이벤트 기반 통신으로 근본적으로 전환하고 원하는 방식으로 공개 게시 애플리케이션 이벤트에 대한 약간의 스프링 데이터 지원이 있다는 것입니다.</font>

891
00:35:24,599 --> 00:35:29,599
So you want to have a very specific approach to the application.

892
00:35:24,599 --> 00:35:29,599
<font color="#ffff54">따라서 애플리케이션에 대해 매우 구체적인 접근 방식을 원합니다.</font>

893
00:35:29,599 --> 00:35:49,599
So the idea is that you fundamentally switch for these cross module invocations you switch to event based communication and there's a bit of spring data support for public publishing application events in spring that's a feature that's built into core spring that's nothing spring module specific about.

894
00:35:29,599 --> 00:35:49,599
<font color="#ffff54">따라서 이러한 교차 모듈 호출에 대해 근본적으로 이벤트 기반 통신으로 전환하고 스프링의 공개 게시 애플리케이션 이벤트에 대한 약간의 스프링 데이터 지원이 있는데, 이는 스프링 모듈에 특정한 것이 아닌 코어 스프링에 내장된 기능입니다.</font>

895
00:35:49,599 --> 00:36:04,599
But what we what we do here is we basically just trigger a state transition on the order aggregate saying oh we registered this order completion event and that automatically gets published when we interact with the spring data repositories calling safe right because that's kind of

896
00:35:49,599 --> 00:36:04,599
<font color="#ffff54">하지만 여기서 우리가 하는 일은 기본적으로 주문 집계에서 이 주문 완료 이벤트를 등록했다는 상태 전환을 트리거하고 스프링 데이터 저장소와 상호 작용할 때 자동으로 게시되는 것입니다.</font>

897
00:36:04,599 --> 00:36:16,599
The unit of work is completed and then that triggers that event that has the nice side effect of as I usually phrase it the side effects of that invocation.

898
00:36:04,599 --> 00:36:16,599
<font color="#ffff54">작업 단위가 완료되면 해당 이벤트가 트리거되며, 이는 제가 보통 그 호출의 부작용이라고 표현하는 것처럼 좋은 부작용이 있습니다.</font>

899
00:36:16,599 --> 00:36:32,599
They end within the module right they're not like sneaking out into the other module and the order management by that gaining the task of having to know what else has to happen which is not that's not the purpose of the order management implementation here right.

900
00:36:16,599 --> 00:36:32,599
<font color="#ffff54">그것들은 모듈 내에서 끝나기 때문에 다른 모듈로 몰래 빠져나가는 것과는 다르며 주문 관리는 다른 일이 일어나야하는 것을 알아야하는 작업을 얻음으로써 여기서 주문 관리 구현의 목적이 아닌 바로 여기에 있습니다.</font>

901
00:36:32,599 --> 00:36:38,599
It's rather say okay I trigger my state transition and then I'm basically telling everyone else what I have just done.

902
00:36:32,599 --> 00:36:38,599
<font color="#ffff54">차라리 상태 전환을 트리거하고 다른 모든 사람에게 방금 한 일을 알려주는 것이 좋습니다.</font>

903
00:36:38,599 --> 00:36:43,599
I have completed the order and then everyone else is free to react on this stuff.

904
00:36:38,599 --> 00:36:43,599
<font color="#ffff54">내가 주문을 완료했으니 다른 사람들은 이 일에 대해 자유롭게 반응할 수 있습니다.</font>

905
00:36:43,599 --> 00:36:55,599
It's kind of like it's literally applying that idea that you have in let's say event based Kafka messaging driven system to the interaction with within your application as well right.

906
00:36:43,599 --> 00:36:55,599
<font color="#ffff54">이벤트 기반 카프카 메시징 기반 시스템에서 사용하는 아이디어를 애플리케이션 내 상호작용에 그대로 적용하는 것과 비슷합니다.</font>

907
00:36:55,599 --> 00:37:07,599
And so the side effect ends in the in the originating module and it could be or it would be picked up by something that's called application module listener and that's what we call it.

908
00:36:55,599 --> 00:37:07,599
<font color="#ffff54">그래서 부작용은 원래 모듈에서 끝날 수도 있고 애플리케이션 모듈 리스너라고 불리는 무언가에 의해 포착될 수도 있습니다.</font>

909
00:37:07,599 --> 00:37:17,599
That's not nothing but a bit of syntactical sugar on the combination of at async and tracks transactional event listener with requiring a new transaction.

910
00:37:07,599 --> 00:37:17,599
<font color="#ffff54">이는 비동기 및 추적 트랜잭션 이벤트 리스너와 새 트랜잭션을 요구하는 것의 조합에 약간의 구문론적 설탕을 더한 것일 뿐 아무것도 아닙니다.</font>

911
00:37:17,599 --> 00:37:32,599
So that transactional event listener causes the events to be submitted only when the transaction commits and the reason for that is that you want to make sure that the original module actually has concluded their business task.

912
00:37:17,599 --> 00:37:32,599
<font color="#ffff54">트랜잭션 이벤트 리스너는 트랜잭션이 커밋될 때만 이벤트가 제출되도록 하며, 그 이유는 원래 모듈이 실제로 비즈니스 작업을 완료했는지 확인하려는 것입니다.</font>

913
00:37:32,599 --> 00:37:39,599
You don't want to send out an email saying oh the order was completed with the chance of the transaction to still roll back right.

914
00:37:32,599 --> 00:37:39,599
<font color="#ffff54">트랜잭션이 제대로 롤백되지 않을 가능성이 있는 상태에서 주문이 완료되었다는 이메일을 보내고 싶지는 않을 것입니다.</font>

915
00:37:40,599 --> 00:37:52,599
That's kind of the idea and the reason for it for those to usually run async is that oh sending out an email for example might take a while you have to interact with some some email server.

916
00:37:40,599 --> 00:37:52,599
<font color="#ffff54">예를 들어 이메일을 보낼 때 일부 이메일 서버와 상호 작용하는 데 시간이 걸릴 수 있기 때문에 일반적으로 비동기로 실행하는 이유입니다.</font>

917
00:37:52,599 --> 00:37:59,599
So yeah you want to rather want to to take this off the actual main execution threat.

918
00:37:52,599 --> 00:37:59,599
<font color="#ffff54">그러니까 실제 메인 실행 위협에서 이걸 떼어내고 싶다는 거군요.</font>

919
00:37:59,599 --> 00:38:10,599
That's a that's a bit of a risk involved here you the application might just crash right while you while you have completed your original transaction and you in the middle of sending out an email.

920
00:37:59,599 --> 00:38:10,599
<font color="#ffff54">여기에는 약간의 위험이 수반됩니다. 원래 거래를 완료하고 이메일을 보내는 도중에 애플리케이션이 바로 충돌 할 수 있습니다.</font>

921
00:38:10,599 --> 00:38:28,599
There is support for for that scenario in spring module is called an event publication registry that would actually make sure that you're not losing the event publication right within your simple like JDBC local transaction arrangement but that's a bit too far ahead for our seven minutes left.

922
00:38:10,599 --> 00:38:28,599
<font color="#ffff54">스프링 모듈에서 이벤트 게시 레지스트리라고 하는 이 시나리오에 대한 지원이 있는데, 이는 JDBC 로컬 트랜잭션 배열과 같은 간단한 배열 내에서 이벤트 게시를 잃지 않도록 하는 것이지만 7분 남은 시간 동안 너무 앞서 나가고 있습니다.</font>

923
00:38:28,599 --> 00:38:38,599
What I would like to show you is how you actually integration test this stuff because we've like put significant effort into providing you means to to to do that.

924
00:38:28,599 --> 00:38:38,599
<font color="#ffff54">제가 보여드리고 싶은 것은 실제로 통합 테스트하는 방법을 보여드리고 싶은데, 그 방법을 제공하기 위해 상당한 노력을 기울였기 때문입니다.</font>

925
00:38:39,599 --> 00:38:54,599
And there is like there's like two ways one is the one is the let's stick with that for now one is the let's say the more bare bone way of trying that stuff which is.

926
00:38:39,599 --> 00:38:54,599
<font color="#ffff54">두 가지 방법이 있는데 하나는 당분간은 그 방법을 고수하자는 것이고, 다른 하나는 그 방법을 시도하는 데 더 많은 노력을 기울이자는 것입니다.</font>

927
00:38:54,599 --> 00:39:11,599
Which is you can have a in an abstraction called published events or in this case if you're using a search a assertable published events as a parameter to your J unit method and then you can trigger your application logic in this case the order completion and then you can expect.

928
00:38:54,599 --> 00:39:11,599
<font color="#ffff54">즉, 게시된 이벤트라는 추상화 또는 이 경우 검색을 사용하는 경우 어설 션 가능한 게시된 이벤트를 J 단위 메서드의 매개 변수로 사용하여 애플리케이션 로직(이 경우 주문 완료)을 트리거할 수 있으며 기대할 수 있습니다.</font>

929
00:39:11,599 --> 00:39:21,599
What that published events abstraction does is it's collects all events that are published in the system while that test method executes.

930
00:39:11,599 --> 00:39:21,599
<font color="#ffff54">게시된 이벤트 추상화가 하는 일은 테스트 메서드가 실행되는 동안 시스템에 게시된 모든 이벤트를 수집하는 것입니다.</font>

931
00:39:22,599 --> 00:39:32,599
Right so all the events are kind of captured and then you can basically filter and match on the events that were published so you kind of in this case you what you what you're describing here is.

932
00:39:22,599 --> 00:39:32,599
<font color="#ffff54">모든 이벤트를 캡처한 다음 기본적으로 게시된 이벤트를 필터링하고 일치시킬 수 있으므로 이 경우에는 여기서 설명하는 것과 비슷합니다.</font>

933
00:39:32,599 --> 00:39:46,599
Oh assuming I'm triggering that order completion I expect an event order completed to arrive or to be published with the ID in that event matching the order identifier that's kind of the thing here right.

934
00:39:32,599 --> 00:39:46,599
<font color="#ffff54">주문 완료를 트리거한다고 가정하면 주문이 완료된 이벤트가 도착하거나 해당 이벤트의 ID가 주문 식별자와 일치하는 이벤트가 게시될 것으로 예상됩니다.</font>

935
00:39:46,599 --> 00:40:10,599
And we've like we've had that for a while and we've basically come to the conclusion it would be nice to to actually turn this into a slightly more reasonable or more readable and more let's say high level description especially when it comes to asynchronous application invocations because then you have to you're pretty quickly at a tool called availability.

936
00:39:46,599 --> 00:40:10,599
<font color="#ffff54">그리고 우리는 한동안 이 문제를 고민해왔고, 기본적으로 이것을 좀 더 합리적이고 가독성이 높으며 특히 비동기 애플리케이션 호출에 관해서는 높은 수준의 설명으로 바꾸면 좋겠다는 결론에 도달했습니다. 왜냐하면 가용성이라는 도구에 꽤 빨리 도달해야 하기 때문입니다.</font>

937
00:40:10,599 --> 00:40:26,599
Which kind of allows you to basically say oh execute some code and then wait until something happens without having to do all this thread sleep dance yourselves and what we came up with is that we call it scenario API.

938
00:40:10,599 --> 00:40:26,599
<font color="#ffff54">이 도구를 사용하면 스레드 슬립 댄스를 할 필요 없이 기본적으로 코드를 실행한 다음 어떤 일이 발생할 때까지 기다릴 수 있으며, 우리가 생각해낸 것이 시나리오 API입니다.</font>

939
00:40:26,599 --> 00:40:49,599
Where the entire test case is kind of encapsulated in this right so we there is the notion of okay we stimulate the system or stimulate the module with some method invocation with some event publication or what have you there's I think another method called yeah publish where you can just shove in an event.

940
00:40:26,599 --> 00:40:49,599
<font color="#ffff54">전체 테스트 케이스가 이 오른쪽에 캡슐화되어 있기 때문에 시스템을 자극하거나 이벤트 게시를 통해 일부 메서드 호출로 모듈을 자극하거나 이벤트를 밀어 넣을 수 있는 예 퍼블리시라는 또 다른 메서드가 있다고 생각합니다.</font>

941
00:40:49,599 --> 00:41:18,599
And then you can basically then you describe like what you actually wait for to happen right there's like wait for event of type order completed matching mapped values so that's kind of the description of what you're waiting for and then you conclude this with to arrive and there's like additional overloads to basically say to arrive and verify so you could basically still get the actual the event that you're waiting for and then execute some other code on it to verify that you're actually waiting for.

942
00:40:49,599 --> 00:41:18,599
<font color="#ffff54">그런 다음 기본적으로 실제로 일어나기를 기다리는 것을 설명 할 수 있습니다. 매핑 된 값과 일치하는 순서 완료 유형의 이벤트를 기다리는 것과 같은 설명이 있으므로 기다리는 것에 대한 설명이 있고 도착하는 것으로 결론을 내리고 기본적으로 도착하고 확인하는 추가 오버로드가 있으므로 기본적으로 기다리는 이벤트를 실제로 가져온 다음 다른 코드를 실행하여 실제로 기다리는 것을 확인할 수 있습니다.</font>

943
00:41:18,599 --> 00:41:38,599
Or in this case you can even get for this one here you would even get the thing that you that the stimulus actually created right the result of the initial the initial operation and that's kind of it's kind of needs to to really get to to very brief descriptions of.

944
00:41:18,599 --> 00:41:38,599
<font color="#ffff54">또는 이 경우에는 여기에서 자극이 실제로 초기 작업의 결과를 올바르게 생성한 것을 얻을 수도 있고 매우 간단한 설명이 필요합니다.</font>

945
00:41:38,599 --> 00:41:44,599
Do we have that in here as well no I think I have to check out go get CEO main.

946
00:41:38,599 --> 00:41:44,599
<font color="#ffff54">여기에도 있나요? 아니요, CEO 메인에 가서 확인해야 할 것 같아요.</font>

947
00:41:44,599 --> 00:41:50,599
There should be a couple of more in there for that so there's a like.

948
00:41:44,599 --> 00:41:50,599
<font color="#ffff54">여기에도 몇 개 더 있어야 '좋아요'를 누를 수 있을 거예요.</font>

949
00:41:50,599 --> 00:42:02,599
Oh yeah that's like a slightly slightly more complex scenario we're waiting in this case I'm this is example of the event publication registry that's.

950
00:41:50,599 --> 00:42:02,599
<font color="#ffff54">네, 그건 우리가 기다리는 조금 더 복잡한 시나리오와 같습니다. 이 경우 저는 이것이 이벤트 게시 레지스트리의 예입니다.</font>

951
00:42:02,599 --> 00:42:25,599
That's in use here it's kind of the test is showcasing how it reacts to a failing event event listener and it's basically our stimulator system using order completed and then we wait until the exception actually is created in the listener and then we verify that we don't have we still have that event publication in our event publication registry technical details aside.

952
00:42:02,599 --> 00:42:25,599
<font color="#ffff54">이 테스트는 실패한 이벤트 이벤트 리스너에 어떻게 반응하는지 보여주는 일종의 테스트이며, 기본적으로 주문 완료를 사용하는 자극기 시스템이고 리스너에서 실제로 예외가 생성될 때까지 기다린 다음 이벤트 게시 레지스트리에 해당 이벤트 게시가 아직 없는지 확인하는 기술적인 세부 사항은 제쳐두고요.</font>

953
00:42:25,599 --> 00:42:45,599
I think it reads pretty pretty fluent and it's gives you a very neat API to actually describe how you want your your module to behave right in in the integration test scenario so it's like using transactions it's not like some unit testing thing going on here it's like a full integration test in this case.

954
00:42:25,599 --> 00:42:45,599
<font color="#ffff54">꽤 유창하게 읽히고 통합 테스트 시나리오에서 모듈이 어떻게 동작하기를 원하는지 실제로 설명할 수 있는 매우 깔끔한 API를 제공하므로 트랜잭션을 사용하는 것과 같은 단위 테스트가 아니라 이 경우에는 전체 통합 테스트와 같은 것입니다.</font>

955
00:42:45,599 --> 00:42:49,599
All right.

956
00:42:45,599 --> 00:42:49,599
<font color="#ffff54">알았어요.</font>

957
00:42:49,599 --> 00:43:12,599
To recap fundamental idea is we use packages as the driving factors for for our functional decomposition good fences make good neighbors right so try to keep stuff in package private if you can if you have to or want to use the say ports and adapters packages then use them below the functional decomposition right.

958
00:42:49,599 --> 00:43:12,599
<font color="#ffff54">근본적인 아이디어를 요약하자면, 우리는 기능적 분해의 원동력으로 패키지를 사용한다는 것입니다 좋은 울타리는 좋은 이웃을 만듭니다 따라서 포트와 어댑터 패키지를 사용해야하거나 사용해야하는 경우 패키지에있는 물건을 비공개로 유지하려면 기능적 분해 오른쪽 아래에서 사용하십시오.</font>

959
00:43:12,599 --> 00:43:20,599
Whether you use layering whether you use hexagonal architecture is an implementation detail to the very module.

960
00:43:12,599 --> 00:43:20,599
<font color="#ffff54">육각형 아키텍처를 사용하는지 여부에 따라 레이어링을 사용하는지 여부는 바로 모듈에 대한 구현 세부 사항입니다.</font>

961
00:43:20,599 --> 00:43:41,599
You get a simple set of access rules and API's to verify this or related project going on you're called J molecules that has a lot of the DDD abstractions within them spring modulus will actually verify that your DDD module or abstraction arrangement actually follows the rules that you for example find in one version of the module.

962
00:43:20,599 --> 00:43:41,599
<font color="#ffff54">이 프로젝트 또는 관련 프로젝트가 진행 중인지 확인하기 위한 간단한 액세스 규칙 및 API 세트가 제공됩니다. 그 안에 많은 DDD 추상화가 있는 J 분자라고 불리는 스프링 모듈은 실제로 DDD 모듈 또는 추상화 배열이 실제로 모듈의 한 버전에서 찾을 수 있는 규칙을 따르는지 확인합니다.</font>

963
00:43:41,599 --> 00:44:01,599
For example find in one version book implementing DDD it will find cyclic dependencies between modules all this kind of stuff you think of it as a pre packaged set of arc unit rules that you get out of the box if you just follow those conventions and you of course can tweak those conventions if you if you need to.

964
00:43:41,599 --> 00:44:01,599
<font color="#ffff54">예를 들어 DDD를 구현하는 한 버전 책에서 찾아보면 모듈 간의 순환 종속성을 발견할 수 있는데, 이러한 규칙을 따르기만 하면 바로 사용할 수 있는 호 단위 규칙의 사전 패키지 세트라고 생각하면 되고, 물론 필요하다면 규칙을 조정할 수도 있습니다.</font>

965
00:44:01,599 --> 00:44:08,599
Integration test support for individual modules or like multi multiple modules at once.

966
00:44:01,599 --> 00:44:08,599
<font color="#ffff54">개별 모듈에 대한 통합 테스트 지원 또는 여러 모듈을 한 번에 여러 개 테스트하는 것과 같은 기능.</font>

967
00:44:08,599 --> 00:44:25,599
And then there's the application registry registry that allows you to move your module interaction to event based interaction and not risking that that you lose events in case of the transactional arrangement kind of failing infrastructure interaction failing or what have you.

968
00:44:08,599 --> 00:44:25,599
<font color="#ffff54">그리고 모듈 상호 작용을 이벤트 기반 상호 작용으로 전환할 수 있는 애플리케이션 레지스트리 레지스트리가 있어 트랜잭션 배열이 실패하거나 인프라 상호 작용이 실패할 경우 이벤트를 잃을 위험을 감수하지 않아도 됩니다.</font>

969
00:44:25,599 --> 00:44:28,599
documentation support.

970
00:44:25,599 --> 00:44:28,599
<font color="#ffff54">문서 지원.</font>

971
00:44:28,599 --> 00:44:33,599
You've seen the diagrams you've seen the application module canvases.

972
00:44:28,599 --> 00:44:33,599
<font color="#ffff54">애플리케이션 모듈 캔버스 다이어그램을 보셨을 것입니다.</font>

973
00:44:33,599 --> 00:44:54,599
Something I didn't have the time to go into is if you have a microservices arrangement and you build your order and your inventory system as separate services you usually put something like zipkin or some tracing in between to see how the modules interact and like which which thing is causing the event here is causing that other thing to to be called.

974
00:44:33,599 --> 00:44:54,599
<font color="#ffff54">제가 미처 다루지 못한 부분은 마이크로 서비스 배열이 있고 주문과 재고 시스템을 별도의 서비스로 구축하는 경우 일반적으로 모듈이 상호 작용하는 방식과 여기에서 어떤 것이 이벤트를 유발하여 다른 것이 호출되는지 확인하기 위해 집킨이나 일부 추적을 그 사이에 넣는다는 것입니다.</font>

975
00:44:54,599 --> 00:45:12,599
We have built the same thing is that the same thing for the logical modules here so if you add the there's a couple of jars that you have to add that to your to your project it they will pull in the micrometer observation support and you will actually get the same traces showing you all there was a request entering the

976
00:44:54,599 --> 00:45:12,599
<font color="#ffff54">우리는 여기에 논리적 모듈에 대해 동일한 것을 구축했기 때문에 프로젝트에 추가해야 하는 몇 개의 항아리를 추가하면 마이크로미터 관찰 지원을 가져오고 실제로 요청이 들어오는 모든 것을 보여주는 동일한 추적을 얻을 수 있습니다.</font>

977
00:45:12,599 --> 00:45:31,599
And then you're entering the order module that has triggered an event which has triggered some functionality functionality in the inventory module in the same way you would see that if they were separate services right you get an extra layer of depth inside into your into your application interaction.

978
00:45:12,599 --> 00:45:31,599
<font color="#ffff54">그리고 인벤토리 모듈의 일부 기능을 트리거한 이벤트를 트리거한 주문 모듈을 입력하는 것과 같은 방식으로, 만약 두 서비스가 서로 다른 서비스였다면 애플리케이션 상호 작용에 대한 추가적인 깊이를 얻을 수 있는 것을 볼 수 있습니다.</font>

979
00:45:31,599 --> 00:45:32,599
That's it.

980
00:45:31,599 --> 00:45:32,599
<font color="#ffff54">여기까지입니다.</font>

981
00:45:32,599 --> 00:45:34,599
I'm on time.

982
00:45:32,599 --> 00:45:34,599
<font color="#ffff54">제시간에 왔어요.</font>

983
00:45:34,599 --> 00:45:36,599
Am I. Yeah, I think so.

984
00:45:34,599 --> 00:45:36,599
<font color="#ffff54">그래, 그런 것 같아.</font>

985
00:45:36,599 --> 00:45:39,599
If there's a question I think we can answer one.

986
00:45:36,599 --> 00:45:39,599
<font color="#ffff54">질문이 하나 있다면 대답할 수 있을 것 같아.</font>

987
00:45:39,599 --> 00:45:45,599
There are questions I can hardly see any one of you is there anyone there even you've been so silent.

988
00:45:39,599 --> 00:45:45,599
<font color="#ffff54">질문이 있는데 아무도 없는 것 같네요... 너무 조용해서요.</font>

989
00:45:45,599 --> 00:45:48,599
Oh, I hear some people have any questions.

990
00:45:45,599 --> 00:45:48,599
<font color="#ffff54">질문이 있는 사람이 있다고 들었어요.</font>

991
00:45:48,599 --> 00:45:50,599
Oh, there's one over.

992
00:45:48,599 --> 00:45:50,599
<font color="#ffff54">저기 하나 있네.</font>

993
00:45:50,599 --> 00:45:52,599
Oh, where's.

994
00:45:50,599 --> 00:45:52,599
<font color="#ffff54">오, 어디야.</font>

995
00:45:52,599 --> 00:45:57,599
Let's take this one because the microphones over there but I'm happy to talk to you later on. Go ahead.

996
00:45:52,599 --> 00:45:57,599
<font color="#ffff54">마이크는 저쪽에 있지만 나중에 얘기할 수 있으니 이걸로 하죠. 말해봐요.</font>

997
00:45:57,599 --> 00:46:06,599
This event design or event based development you have the model it I like it very much. Well done.

998
00:45:57,599 --> 00:46:06,599
<font color="#ffff54">이 이벤트 디자인이나 이벤트 기반 개발 모델이 아주 마음에 들어요. 잘했어.</font>

999
00:46:06,599 --> 00:46:25,599
The question is why do you have this coupling between modulate and event based approach I think this could be designed in the way that is fully decoupled so that anybody who is not using model it can benefit from the approach and the design you have made in the event development.

1000
00:46:06,599 --> 00:46:25,599
<font color="#ffff54">문제는 왜 모듈레이트와 이벤트 기반 접근 방식 사이에 이러한 결합을 가지고 있습니까? 모델을 사용하지 않는 모든 사람이 이벤트 개발에서 만든 접근 방식과 디자인의 이점을 누릴 수 있도록 완전히 분리 된 방식으로 설계 될 수 있다고 생각합니다.</font>

1001
00:46:25,599 --> 00:46:27,599
That's a good question.

1002
00:46:25,599 --> 00:46:27,599
<font color="#ffff54">좋은 질문이네요.</font>

1003
00:46:27,599 --> 00:46:30,599
So it's microphone it's been recorded I don't have to repeat it.

1004
00:46:27,599 --> 00:46:30,599
<font color="#ffff54">마이크가 녹음되어 있어서 반복할 필요가 없네요.</font>

1005
00:46:30,599 --> 00:46:36,599
So, of course you can you can work with spring application events.

1006
00:46:30,599 --> 00:46:36,599
<font color="#ffff54">물론 스프링 애플리케이션 이벤트로 작업할 수 있습니다.</font>

1007
00:46:36,599 --> 00:46:51,599
Without spring module is right. There's just certain error scenarios that you might want to trigger, or that you not might want to trigger that you might run into that you have to find a solution for for example, the original business method committing and the event listener, failing.

1008
00:46:36,599 --> 00:46:51,599
<font color="#ffff54">스프링 모듈이 없는 것이 맞습니다. 다만 트리거하고 싶거나 트리거하고 싶지 않은 특정 오류 시나리오가 있을 수 있는데, 예를 들어 원래 비즈니스 메서드가 커밋되고 이벤트 리스너가 실패하는 경우 해결 방법을 찾아야 합니다.</font>

1009
00:46:51,599 --> 00:47:07,599
And then you kind of what do you do about this right the order completed event is gone, but you still have to send out that email. And there's a bit of bit of glue code that kind of plugs into the spring event publication mechanism that would write like like a log entry.

1010
00:46:51,599 --> 00:47:07,599
<font color="#ffff54">그런 다음 주문 완료 이벤트가 사라졌지만 여전히 이메일을 보내야 합니다. 그리고 로그 항목처럼 작성되는 스프링 이벤트 게시 메커니즘에 연결되는 약간의 글루 코드가 있습니다.</font>

1011
00:47:07,599 --> 00:47:19,599
So you have to submit this order completion event to the event to the email sending event listener with the original business method and that entry stays there until the listener has completed successfully.

1012
00:47:07,599 --> 00:47:19,599
<font color="#ffff54">따라서 이 주문 완료 이벤트를 원래의 비즈니스 방식으로 이메일 전송 이벤트 리스너에 이벤트에 제출해야 하며 리스너가 성공적으로 완료할 때까지 해당 항목이 유지됩니다.</font>

1013
00:47:19,599 --> 00:47:34,599
So, there's just that that tiny tiny bit of glue code that you would otherwise have to come up yourself with yourself. And, like we don't feel comfortable telling everyone Oh, just go ahead and use this event based interaction.

1014
00:47:19,599 --> 00:47:34,599
<font color="#ffff54">즉, 여러분이 직접 만들어야 하는 아주 작은 접착제 코드가 있습니다. 그리고 모든 사람에게 "그냥 이 이벤트 기반 상호작용을 사용하세요"라고 말하는 것이 불편한 것처럼요.</font>

1015
00:47:34,599 --> 00:47:44,599
There are other problems that you're going to run into and now solve them. Right. We're not exchanging one problem for another. And that's kind of why is why is in there.

1016
00:47:34,599 --> 00:47:44,599
<font color="#ffff54">이제 다른 문제들을 해결해야 하잖아요. 맞아요. 우리는 한 문제를 다른 문제와 교환하는 것이 아닙니다. 그게 바로 '왜'가 저기 있는 이유입니다.</font>

1017
00:47:44,599 --> 00:47:49,599
Fundamentally, I think we could even move this to framework.

1018
00:47:44,599 --> 00:47:49,599
<font color="#ffff54">근본적으로 저는 이것을 프레임워크로 옮길 수도 있다고 생각합니다.</font>

1019
00:47:49,599 --> 00:47:53,599
At some point in time I mean right now this this project.

1020
00:47:49,599 --> 00:47:53,599
<font color="#ffff54">어느 시점에 저는 지금 이 프로젝트를 의미합니다.</font>

1021
00:47:53,599 --> 00:48:05,599
There's a predecessor of the project that's been used in production for I think a year or two already. We've just moved it to to to be an actual spring project and it's an experimental status for that reason because it's just like been moved over.

1022
00:47:53,599 --> 00:48:05,599
<font color="#ffff54">이 프로젝트의 이전 버전이 이미 1~2년 동안 프로덕션에 사용되어 왔습니다. 실제 봄 프로젝트로 옮긴 것뿐이고, 그냥 옮겨온 것 같아서 실험적인 상태입니다.</font>

1023
00:48:05,599 --> 00:48:13,599
But we are hoping to get it basically elevated to non experimental by the end of the year.

1024
00:48:05,599 --> 00:48:13,599
<font color="#ffff54">하지만 연말까지는 기본적으로 비실험 단계로 격상되기를 희망하고 있습니다.</font>

1025
00:48:13,599 --> 00:48:22,599
So yeah, fundamentally if you've asked for that, why event based in the first place. The reason is that you, you can hardly get your modules to be testable.

1026
00:48:13,599 --> 00:48:22,599
<font color="#ffff54">네, 근본적으로 왜 애초에 이벤트 기반이냐고 물으셨다면 그렇습니다. 그 이유는 모듈을 테스트할 수 없기 때문입니다.</font>

1027
00:48:22,599 --> 00:48:34,599
If they have to basically reach out to other modules all the time it's simple similar to in a distributed systems arrangement you don't want like to wire mock all the other services or run them or what have you.

1028
00:48:22,599 --> 00:48:34,599
<font color="#ffff54">기본적으로 항상 다른 모듈에 연결해야 한다면 분산 시스템 배치와 비슷하게 다른 모든 서비스를 와이어로 모의 실행하거나 실행하는 것을 원하지 않을 것입니다.</font>

1029
00:48:34,599 --> 00:48:44,599
But rather it's it's this this temporal decoupling literally right you don't have that other thing to be available for you to complete your very own business logic.

1030
00:48:34,599 --> 00:48:44,599
<font color="#ffff54">하지만 오히려 이 시간적 분리는 말 그대로 자신만의 비즈니스 로직을 완성하는 데 사용할 수 있는 다른 것이 없다는 것입니다.</font>

1031
00:48:44,599 --> 00:48:52,599
That's kind of the idea. And you don't have to actually move to a distributed systems arrangement to get that kind of programming model.

1032
00:48:44,599 --> 00:48:52,599
<font color="#ffff54">그런 생각입니다. 그리고 그런 종류의 프로그래밍 모델을 얻기 위해 실제로 분산 시스템으로 전환할 필요는 없습니다.</font>

1033
00:48:52,599 --> 00:48:55,599
That's that's kind of the thing. And it's not that I'm saying the other thing is wrong.

1034
00:48:52,599 --> 00:48:55,599
<font color="#ffff54">그게 바로 그거죠. 그리고 다른 것이 잘못되었다는 말은 아닙니다.</font>

1035
00:48:56,599 --> 00:49:01,599
I'm just saying it is a different trade off with different costs and it's still fine for you.

1036
00:48:56,599 --> 00:49:01,599
<font color="#ffff54">저는 단지 다른 비용에 대한 다른 트레이드 오프이며 여전히 당신에게는 괜찮다는 것을 말하는 것입니다.</font>

1037
00:49:01,599 --> 00:49:21,599
And actually that's what spring modulus helps you with is to prepare your system in a monolithic arrangement to if the point in time comes where you actually have the requirement to scale one thing in a different way, then it's much easier to basically decompose that modular system monolithic modular system and extract one thing out.

1038
00:49:01,599 --> 00:49:21,599
<font color="#ffff54">그리고 실제로 스프링 모듈러스가 도움이 되는 것은 모놀리식 배열로 시스템을 준비하여 실제로 한 가지를 다른 방식으로 확장해야하는 시점이 오면 기본적으로 그 모듈 식 시스템을 모놀리식 모듈 식 시스템을 분해하고 한 가지를 추출하는 것이 훨씬 쉽다는 것입니다.</font>

1039
00:49:21,599 --> 00:49:28,599
And then basically just put a Kafka in between if you're already using that event based interaction model in your monolithic application.

1040
00:49:21,599 --> 00:49:28,599
<font color="#ffff54">그리고 모놀리식 애플리케이션에서 이미 이벤트 기반 인터랙션 모델을 사용하고 있다면 그 사이에 카프카를 넣으면 됩니다.</font>

1041
00:49:28,599 --> 00:49:38,599
And with that, thank you very much and enjoy the rest of the conference. I'll be around for this afternoon. So I'm the short guy with the hat. So thank you.

1042
00:49:28,599 --> 00:49:38,599
<font color="#ffff54">이것으로, 정말 감사드리며 남은 컨퍼런스를 즐기시기 바랍니다. 오후에도 계속하겠습니다. 모자를 쓴 키 작은 남자입니다. 감사합니다.</font>
