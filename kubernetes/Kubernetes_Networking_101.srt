1
00:00:00,000 --> 00:00:01,280
All righty.

2
00:00:00,000 --> 00:00:01,280
<font color="#ffff54">알았어.</font>

3
00:00:01,280 --> 00:00:03,980
I believe it is time for us to kick this off.

4
00:00:01,280 --> 00:00:03,980
<font color="#ffff54">이제 시작해야 할 때인 것 같아.</font>

5
00:00:03,980 --> 00:00:06,400
So we have so much to cover.

6
00:00:03,980 --> 00:00:06,400
<font color="#ffff54">취재할 게 너무 많아요.</font>

7
00:00:06,400 --> 00:00:07,799
I'm going to go ahead and start.

8
00:00:06,400 --> 00:00:07,799
<font color="#ffff54">제가 먼저 시작하죠.</font>

9
00:00:07,799 --> 00:00:10,439
Feel free to keep on coming if you're waiting in line.

10
00:00:07,799 --> 00:00:10,439
<font color="#ffff54">줄을 서서 기다리시는 분들은 계속 오세요.</font>

11
00:00:10,439 --> 00:00:11,960
There's lots of seats up front here.

12
00:00:10,439 --> 00:00:11,960
<font color="#ffff54">앞쪽에 자리가 많이 있습니다.</font>

13
00:00:11,960 --> 00:00:14,780
So yeah, welcome, welcome.

14
00:00:11,960 --> 00:00:14,780
<font color="#ffff54">그래, 어서 오세요.</font>

15
00:00:14,780 --> 00:00:16,399
My name is Randy Abernathy.

16
00:00:14,780 --> 00:00:16,399
<font color="#ffff54">제 이름은 랜디 애버나시입니다.</font>

17
00:00:16,399 --> 00:00:17,820
I'm a managing partner at RXM.

18
00:00:16,399 --> 00:00:17,820
<font color="#ffff54">저는 RXM의 매니징 파트너입니다.</font>

19
00:00:17,820 --> 00:00:20,740
And this is Kubernetes Networking 101.

20
00:00:17,820 --> 00:00:20,740
<font color="#ffff54">그리고 이것은 쿠버네티스 네트워킹 101입니다.</font>

21
00:00:20,740 --> 00:00:24,140
So let me just see a quick show of hands.

22
00:00:20,740 --> 00:00:24,140
<font color="#ffff54">그럼 잠깐 손들어 보겠습니다.</font>

23
00:00:24,140 --> 00:00:28,240
How many people would consider themselves very savvy

24
00:00:24,140 --> 00:00:28,240
<font color="#ffff54">자신을 매우 잘 안다고 생각하는 사람은 몇 명입니까?</font>

25
00:00:28,880 --> 00:00:31,400
networking people?

26
00:00:28,880 --> 00:00:31,400
<font color="#ffff54">인맥을 쌓고 있나요?</font>

27
00:00:31,400 --> 00:00:31,880
All right.

28
00:00:31,400 --> 00:00:31,880
<font color="#ffff54">알았어요.</font>

29
00:00:31,880 --> 00:00:34,000
So everybody else, if you saw someone raise their hand,

30
00:00:31,880 --> 00:00:34,000
<font color="#ffff54">자, 다른 분들, 손 드신 분 손 들어 보세요,</font>

31
00:00:34,000 --> 00:00:34,760
you got questions.

32
00:00:34,000 --> 00:00:34,760
<font color="#ffff54">질문이 있는 거죠.</font>

33
00:00:34,760 --> 00:00:36,200
You know where to go, right?

34
00:00:34,760 --> 00:00:36,200
<font color="#ffff54">어디로 가야 할지 알지?</font>

35
00:00:36,200 --> 00:00:37,640
Those people.

36
00:00:36,200 --> 00:00:37,640
<font color="#ffff54">저 사람들.</font>

37
00:00:37,640 --> 00:00:40,679
So yeah, this is going to be a super fun tutorial.

38
00:00:37,640 --> 00:00:40,679
<font color="#ffff54">그래, 이건 정말 재미있는 튜토리얼이 될 거야.</font>

39
00:00:40,679 --> 00:00:42,400
We have 90 minutes.

40
00:00:40,679 --> 00:00:42,400
<font color="#ffff54">90분 남았어요.</font>

41
00:00:42,400 --> 00:00:44,240
We have a ton of stuff to cover.

42
00:00:42,400 --> 00:00:44,240
<font color="#ffff54">취재할 내용이 너무 많아요.</font>

43
00:00:44,240 --> 00:00:47,520
And I'll just give you a quick intro to the format.

44
00:00:44,240 --> 00:00:47,520
<font color="#ffff54">형식에 대해 간단히 소개하겠습니다.</font>

45
00:00:47,520 --> 00:00:50,900
We have stood up hundreds of machines

46
00:00:47,520 --> 00:00:50,900
<font color="#ffff54">우리는 수백 대의 기계를 세웠습니다.</font>

47
00:00:50,900 --> 00:00:54,320
in a cloud provider who shall remain nameless since they

48
00:00:50,900 --> 00:00:54,320
<font color="#ffff54">클라우드 제공 업체에서 이름을 밝히지 않을 것입니다.</font>

49
00:00:54,320 --> 00:00:56,320
wouldn't sponsor us.

50
00:00:54,320 --> 00:00:56,320
<font color="#ffff54">우리를 후원하지 않을 것입니다.</font>

51
00:00:56,320 --> 00:00:59,960
And so you guys can SSH into the box

52
00:00:56,320 --> 00:00:59,960
<font color="#ffff54">이제 여러분은 상자에 SSH로 접속할 수 있습니다.</font>

53
00:00:59,960 --> 00:01:03,939
that you were provided on this sheet.

54
00:00:59,960 --> 00:01:03,939
<font color="#ffff54">이 시트에 제공된 정보를 입력합니다.</font>

55
00:01:03,939 --> 00:01:07,200
Now, I realize that we're on conference Wi-Fi, right?

56
00:01:03,939 --> 00:01:07,200
<font color="#ffff54">지금 우리가 회의용 Wi-Fi를 사용하고 있는 건 맞죠?</font>

57
00:01:07,200 --> 00:01:08,400
We all know what that means.

58
00:01:07,200 --> 00:01:08,400
<font color="#ffff54">우리 모두 무슨 뜻인지 알죠?</font>

59
00:01:08,400 --> 00:01:11,640
It's probably really banging great Wi-Fi,

60
00:01:08,400 --> 00:01:11,640
<font color="#ffff54">아마 와이파이가 정말 잘 터지는 것 같아요,</font>

61
00:01:11,640 --> 00:01:14,560
but there's 200, 300 people trying

62
00:01:11,640 --> 00:01:14,560
<font color="#ffff54">하지만 200, 300명이 시도하고 있습니다.</font>

63
00:01:14,560 --> 00:01:16,000
to use it all at the same time.

64
00:01:14,560 --> 00:01:16,000
<font color="#ffff54">동시에 사용하려고 합니다.</font>

65
00:01:16,000 --> 00:01:18,240
So the best thing that we could do

66
00:01:16,000 --> 00:01:18,240
<font color="#ffff54">그래서 우리가 할 수 있는 최선의 방법은</font>

67
00:01:18,240 --> 00:01:21,039
is instead of you downloading all sorts of packages

68
00:01:18,240 --> 00:01:21,039
<font color="#ffff54">모든 종류의 패키지를 다운로드하는 대신에</font>

69
00:01:21,039 --> 00:01:24,319
and containers and stuff that would be really slow,

70
00:01:21,039 --> 00:01:24,319
<font color="#ffff54">정말 느릴 수 있는 컨테이너 같은 것들 말이죠,</font>

71
00:01:24,320 --> 00:01:27,240
you can just SSH to these cloud instances

72
00:01:24,320 --> 00:01:27,240
<font color="#ffff54">이 클라우드 인스턴스에 SSH로 접속할 수 있습니다.</font>

73
00:01:27,240 --> 00:01:29,420
and send a few characters back and forth every once

74
00:01:27,240 --> 00:01:29,420
<font color="#ffff54">그리고 한 번씩 몇 문자를 주고받을 수 있습니다.</font>

75
00:01:29,420 --> 00:01:30,080
in a while.

76
00:01:29,420 --> 00:01:30,080
<font color="#ffff54">잠시 후</font>

77
00:01:30,080 --> 00:01:32,240
It's the lowest bandwidth thing that we can come up

78
00:01:30,080 --> 00:01:32,240
<font color="#ffff54">우리가 올릴 수 있는 가장 낮은 대역폭입니다.</font>

79
00:01:32,240 --> 00:01:34,100
with for a session like this.

80
00:01:32,240 --> 00:01:34,100
<font color="#ffff54">으로 설정할 수 있습니다.</font>

81
00:01:34,100 --> 00:01:36,680
It's also really great because if you completely

82
00:01:34,100 --> 00:01:36,680
<font color="#ffff54">또한 다음과 같이 하면 정말 좋습니다.</font>

83
00:01:36,680 --> 00:01:39,800
thrash this computer, your laptop is still fine, right?

84
00:01:36,680 --> 00:01:39,800
<font color="#ffff54">이 컴퓨터를 박살내도 노트북은 여전히 멀쩡하죠?</font>

85
00:01:39,800 --> 00:01:41,320
So don't worry, right?

86
00:01:39,800 --> 00:01:41,320
<font color="#ffff54">그러니 걱정하지 마세요, 그렇죠?</font>

87
00:01:41,320 --> 00:01:42,280
It's a virtual machine.

88
00:01:41,320 --> 00:01:42,280
<font color="#ffff54">가상 머신이니까.</font>

89
00:01:42,280 --> 00:01:46,320
And if you do completely thrash this computer, we have spares.

90
00:01:42,280 --> 00:01:46,320
<font color="#ffff54">이 컴퓨터를 완전히 부숴버려도 여분이 있습니다.</font>

91
00:01:46,320 --> 00:01:51,840
So I have three folks helping me today, Chris, Ilian,

92
00:01:46,320 --> 00:01:51,840
<font color="#ffff54">오늘은 크리스, 일리언, 세 사람이 도와줄 거예요,</font>

93
00:01:51,840 --> 00:01:53,000
and Valentin.

94
00:01:51,840 --> 00:01:53,000
<font color="#ffff54">그리고 발렌틴.</font>

95
00:01:53,000 --> 00:01:55,879
And Chris is, by the way, doing a talk at 1600,

96
00:01:53,000 --> 00:01:55,879
<font color="#ffff54">그리고 크리스는 1600시에 강연을 합니다,</font>

97
00:01:55,879 --> 00:01:58,359
Koop Koodle Said What, which is going to be super awesome.

98
00:01:55,879 --> 00:01:58,359
<font color="#ffff54">쿠프 쿠들이 무슨 말을 했더라, 정말 멋질 거야.</font>

99
00:01:58,359 --> 00:02:00,879
So I would go to that if I were you.

100
00:01:58,359 --> 00:02:00,879
<font color="#ffff54">나 같으면 저기로 갈 거야.</font>

101
00:02:00,879 --> 00:02:03,960
But those guys are going to come around and help with questions.

102
00:02:00,879 --> 00:02:03,960
<font color="#ffff54">하지만 저 사람들이 와서 질문을 도와줄 거예요.</font>

103
00:02:03,960 --> 00:02:05,799
So if you have a question, raise your hand.

104
00:02:03,960 --> 00:02:05,799
<font color="#ffff54">질문이 있으시면 손을 들어주세요.</font>

105
00:02:05,799 --> 00:02:07,519
Those guys will be scanning the room.

106
00:02:05,799 --> 00:02:07,519
<font color="#ffff54">저 사람들이 방을 스캔할 겁니다.</font>

107
00:02:07,519 --> 00:02:08,599
They'll come to you.

108
00:02:07,519 --> 00:02:08,599
<font color="#ffff54">그들이 당신에게 올 겁니다.</font>

109
00:02:08,599 --> 00:02:10,479
They can give you a new machine if you need it.

110
00:02:08,599 --> 00:02:10,479
<font color="#ffff54">필요하면 새 기계를 줄 수 있습니다.</font>

111
00:02:10,479 --> 00:02:11,520
We got spares.

112
00:02:10,479 --> 00:02:11,520
<font color="#ffff54">여분이 있습니다.</font>

113
00:02:11,520 --> 00:02:13,159
They can help you get unstuck if you're

114
00:02:11,520 --> 00:02:13,159
<font color="#ffff54">다음과 같은 경우에 도움이 될 수 있습니다.</font>

115
00:02:13,159 --> 00:02:16,199
working on a part of the tutorial that isn't working.

116
00:02:13,159 --> 00:02:16,199
<font color="#ffff54">튜토리얼의 작동하지 않는 부분을 작업 중입니다.</font>

117
00:02:16,199 --> 00:02:17,580
We've tested it a bunch of times,

118
00:02:16,199 --> 00:02:17,580
<font color="#ffff54">여러 번 테스트했습니다,</font>

119
00:02:17,580 --> 00:02:20,960
so I feel pretty good about if you read the tutorial steps

120
00:02:17,580 --> 00:02:20,960
<font color="#ffff54">그래서 튜토리얼 단계를 읽으면 꽤 괜찮을 것 같습니다.</font>

121
00:02:20,960 --> 00:02:23,260
carefully and do them the way that they say,

122
00:02:20,960 --> 00:02:23,260
<font color="#ffff54">주의 깊게 살펴보고 시키는 대로 하세요,</font>

123
00:02:23,260 --> 00:02:24,520
it's going to work.

124
00:02:23,260 --> 00:02:24,520
<font color="#ffff54">잘 될 거야.</font>

125
00:02:24,520 --> 00:02:27,879
So hopefully, we won't have too many problems.

126
00:02:24,520 --> 00:02:27,879
<font color="#ffff54">큰 문제는 없겠지?</font>

127
00:02:27,879 --> 00:02:29,200
But we're here to help.

128
00:02:27,879 --> 00:02:29,200
<font color="#ffff54">하지만 우리가 도와줄게요.</font>

129
00:02:29,200 --> 00:02:32,159
If you have any questions at all, feel free to ask.

130
00:02:29,200 --> 00:02:32,159
<font color="#ffff54">궁금한 점이 있으면 언제든지 문의하세요.</font>

131
00:02:32,159 --> 00:02:33,280
Yeah, question?

132
00:02:32,159 --> 00:02:33,280
<font color="#ffff54">네, 질문 있으세요?</font>

133
00:02:33,280 --> 00:02:35,740
Is it possible to get a phone for a laptop?

134
00:02:33,280 --> 00:02:35,740
<font color="#ffff54">노트북용 전화기를 구할 수 있나요?</font>

135
00:02:35,740 --> 00:02:39,840
Is it possible to get a phone for a laptop?

136
00:02:35,740 --> 00:02:39,840
<font color="#ffff54">노트북용 휴대폰을 구할 수 있나요?</font>

137
00:02:39,840 --> 00:02:41,000
Ah, great question.

138
00:02:39,840 --> 00:02:41,000
<font color="#ffff54">아, 좋은 질문이네요.</font>

139
00:02:41,000 --> 00:02:43,400
So when we get to the first lab break,

140
00:02:41,000 --> 00:02:43,400
<font color="#ffff54">이제 첫 번째 실험실 쉬는 시간에 도착했습니다,</font>

141
00:02:43,400 --> 00:02:45,020
I'll go into this in some more detail.

142
00:02:43,400 --> 00:02:45,020
<font color="#ffff54">좀 더 자세히 설명하겠습니다.</font>

143
00:02:45,020 --> 00:02:48,159
But the question was, hey, I don't have my laptop,

144
00:02:45,020 --> 00:02:48,159
<font color="#ffff54">그런데 문제는 제 노트북이 없다는 거죠,</font>

145
00:02:48,159 --> 00:02:49,920
or my laptop's locked down, or something,

146
00:02:48,159 --> 00:02:49,920
<font color="#ffff54">아니면 노트북이 잠겼거나 뭐 그런 거죠,</font>

147
00:02:49,960 --> 00:02:51,600
and I can't get to these boxes.

148
00:02:49,960 --> 00:02:51,600
<font color="#ffff54">이 상자에 접근할 수 없어요.</font>

149
00:02:51,600 --> 00:02:52,320
What do I do?

150
00:02:51,600 --> 00:02:52,320
<font color="#ffff54">어떻게 해야 하나요?</font>

151
00:02:52,320 --> 00:02:55,400
Well, we're going to have some slides and presentation.

152
00:02:52,320 --> 00:02:55,400
<font color="#ffff54">슬라이드와 프레젠테이션을 준비할게요.</font>

153
00:02:55,400 --> 00:02:57,480
And I'll probably do a lot of the steps

154
00:02:55,400 --> 00:02:57,480
<font color="#ffff54">그리고 아마 많은 단계를 할 거예요.</font>

155
00:02:57,480 --> 00:03:00,100
if I have time while I'm running around, so you get to see that.

156
00:02:57,480 --> 00:03:00,100
<font color="#ffff54">제가 뛰어다니는 동안 시간이 나면요, 보실 수 있습니다.</font>

157
00:03:00,100 --> 00:03:02,680
But also, there's instructions in the lab

158
00:03:00,100 --> 00:03:02,680
<font color="#ffff54">실험실에는 다음과 같은 지침도 있습니다.</font>

159
00:03:02,680 --> 00:03:06,520
as to how to stand up a plain vanilla Ubuntu 2004 server

160
00:03:02,680 --> 00:03:06,520
<font color="#ffff54">일반 바닐라 우분투 2004 서버를 세우는 방법에 대한 설명입니다.</font>

161
00:03:06,520 --> 00:03:08,160
that you can do the labs on.

162
00:03:06,520 --> 00:03:08,160
<font color="#ffff54">실험을 할 수 있습니다.</font>

163
00:03:08,160 --> 00:03:10,120
There's nothing special about these labs.

164
00:03:08,160 --> 00:03:10,120
<font color="#ffff54">이 실험실에는 특별한 것이 없습니다.</font>

165
00:03:10,120 --> 00:03:13,520
They're just running on a plain vanilla Ubuntu 2004 server.

166
00:03:10,120 --> 00:03:13,520
<font color="#ffff54">그냥 평범한 바닐라 우분투 2004 서버에서 실행 중입니다.</font>

167
00:03:13,520 --> 00:03:16,360
We literally start from the absolute start,

168
00:03:13,520 --> 00:03:16,360
<font color="#ffff54">말 그대로 절대적인 시작에서 시작합니다,</font>

169
00:03:16,360 --> 00:03:19,440
install Kubernetes, set up CNI, start

170
00:03:16,360 --> 00:03:19,440
<font color="#ffff54">쿠버네티스를 설치하고, CNI를 설정하고, 시작한다.</font>

171
00:03:19,479 --> 00:03:21,639
creating services, install the service mesh,

172
00:03:19,479 --> 00:03:21,639
<font color="#ffff54">서비스를 생성하고, 서비스 메시를 설치한다,</font>

173
00:03:21,639 --> 00:03:23,479
install the ingress.

174
00:03:21,639 --> 00:03:23,479
<font color="#ffff54">인그레스를 설치합니다.</font>

175
00:03:23,479 --> 00:03:25,359
Everything is right in that lab.

176
00:03:23,479 --> 00:03:25,359
<font color="#ffff54">실험실에 모든 것이 정상입니다.</font>

177
00:03:25,359 --> 00:03:28,000
So it'll be really easy to redo later.

178
00:03:25,359 --> 00:03:28,000
<font color="#ffff54">나중에 다시 하기가 정말 쉬울 거야.</font>

179
00:03:28,000 --> 00:03:30,039
Also, and I appreciate that question,

180
00:03:28,000 --> 00:03:30,039
<font color="#ffff54">그리고 질문 고마워요,</font>

181
00:03:30,039 --> 00:03:31,719
because hello, virtual people.

182
00:03:30,039 --> 00:03:31,719
<font color="#ffff54">안녕, 가상의 사람들아.</font>

183
00:03:31,719 --> 00:03:35,579
All the people who are over here, hello, virtual people.

184
00:03:31,719 --> 00:03:35,579
<font color="#ffff54">여기 있는 모든 사람들아, 안녕, 가상의 사람들아.</font>

185
00:03:35,579 --> 00:03:38,759
All the people who are online, obviously, you

186
00:03:35,579 --> 00:03:38,759
<font color="#ffff54">온라인에 있는 모든 사람들, 당연히 여러분.</font>

187
00:03:38,759 --> 00:03:41,120
didn't get one of these sheets with an IP.

188
00:03:38,759 --> 00:03:41,120
<font color="#ffff54">이 시트에 IP가 있는 사람은 없습니다.</font>

189
00:03:41,120 --> 00:03:43,680
We just, there's like 800 people or something signed up,

190
00:03:41,120 --> 00:03:43,680
<font color="#ffff54">800명 정도 가입한 것 같아요,</font>

191
00:03:43,680 --> 00:03:45,139
so we couldn't do it for everybody.

192
00:03:43,680 --> 00:03:45,139
<font color="#ffff54">그래서 모두를 위해 해줄 수는 없었어요.</font>

193
00:03:45,139 --> 00:03:47,180
But if you've got a box that you can use that's

194
00:03:45,139 --> 00:03:47,180
<font color="#ffff54">하지만 사용할 수 있는 상자가 있으면</font>

195
00:03:47,180 --> 00:03:49,620
a plain vanilla Ubuntu box, a VM,

196
00:03:47,180 --> 00:03:49,620
<font color="#ffff54">일반 바닐라 우분투 박스, 가상머신,</font>

197
00:03:49,620 --> 00:03:51,860
you can just either SSH into that.

198
00:03:49,620 --> 00:03:51,860
<font color="#ffff54">그냥 SSH로 접속하면 됩니다.</font>

199
00:03:51,860 --> 00:03:54,060
If it's in a data center, it's on your laptop.

200
00:03:51,860 --> 00:03:54,060
<font color="#ffff54">데이터 센터에 있다면 노트북에 있는 것입니다.</font>

201
00:03:54,060 --> 00:03:57,300
If it's in a cloud somewhere, that's going to work fine.

202
00:03:54,060 --> 00:03:57,300
<font color="#ffff54">클라우드 어딘가에 있다면 정상적으로 작동할 것입니다.</font>

203
00:03:57,300 --> 00:04:00,620
And there are instructions for doing exactly that in the lab.

204
00:03:57,300 --> 00:04:00,620
<font color="#ffff54">실험실에 정확히 그렇게 하는 방법이 있습니다.</font>

205
00:04:00,620 --> 00:04:04,180
The lab points you to a virtual machine setup

206
00:04:00,620 --> 00:04:04,180
<font color="#ffff54">실습에서 가상 머신 설정으로 이동합니다.</font>

207
00:04:04,180 --> 00:04:06,060
doc, which is a markdown on GitHub.

208
00:04:04,180 --> 00:04:06,060
<font color="#ffff54">문서로 이동합니다.</font>

209
00:04:06,060 --> 00:04:07,740
And you can follow the instructions there

210
00:04:06,060 --> 00:04:07,740
<font color="#ffff54">그리고 거기에 있는 지침을 따를 수 있습니다.</font>

211
00:04:07,740 --> 00:04:10,900
to run a basic VM that we already provided for you.

212
00:04:07,740 --> 00:04:10,900
<font color="#ffff54">이미 제공한 기본 가상 머신을 실행할 수 있습니다.</font>

213
00:04:10,900 --> 00:04:13,140
It's just a plain vanilla Ubuntu box again.

214
00:04:10,900 --> 00:04:13,140
<font color="#ffff54">다시 평범한 바닐라 우분투 박스입니다.</font>

215
00:04:13,140 --> 00:04:15,340
But you can stand that up and do the labs.

216
00:04:13,140 --> 00:04:15,340
<font color="#ffff54">그래도 견디고 실험을 할 수 있겠지.</font>

217
00:04:15,340 --> 00:04:16,740
So yeah, great questions.

218
00:04:15,340 --> 00:04:16,740
<font color="#ffff54">그래, 좋은 질문이네.</font>

219
00:04:16,819 --> 00:04:19,500
And I'll continue to give you more information about the lab

220
00:04:16,819 --> 00:04:19,500
<font color="#ffff54">그리고 실험실에 대한 자세한 정보를 계속 알려드리겠습니다.</font>

221
00:04:19,500 --> 00:04:22,379
as we close in on getting started on the first step.

222
00:04:19,500 --> 00:04:22,379
<font color="#ffff54">첫 번째 단계의 시작이 가까워지고 있습니다.</font>

223
00:04:22,379 --> 00:04:25,540
This session is organized into five parts.

224
00:04:22,379 --> 00:04:25,540
<font color="#ffff54">이 세션은 다섯 부분으로 구성되어 있습니다.</font>

225
00:04:25,540 --> 00:04:27,780
We're going to take about 15 minutes for each part.

226
00:04:25,540 --> 00:04:27,780
<font color="#ffff54">각 파트당 약 15분 정도 소요됩니다.</font>

227
00:04:27,780 --> 00:04:30,420
And then I've got a very tight budget here to get started.

228
00:04:27,780 --> 00:04:30,420
<font color="#ffff54">예산이 매우 빠듯해서 시작하기가 어렵네요.</font>

229
00:04:30,420 --> 00:04:34,259
So we're going to do maybe five minutes of discussion

230
00:04:30,420 --> 00:04:34,259
<font color="#ffff54">그럼 5분 정도 토론을 해보겠습니다.</font>

231
00:04:34,259 --> 00:04:36,860
and then 10 minutes of lab work, five minutes of discussion,

232
00:04:34,259 --> 00:04:36,860
<font color="#ffff54">10분간 실험하고 5분간 토론하는 거죠,</font>

233
00:04:36,860 --> 00:04:37,819
10 minutes of lab work.

234
00:04:36,860 --> 00:04:37,819
<font color="#ffff54">10분간 실험실 작업.</font>

235
00:04:37,819 --> 00:04:39,180
This is a hands-on session.

236
00:04:37,819 --> 00:04:39,180
<font color="#ffff54">실습 세션입니다.</font>

237
00:04:39,180 --> 00:04:39,980
This is a tutorial.

238
00:04:39,180 --> 00:04:39,980
<font color="#ffff54">튜토리얼입니다.</font>

239
00:04:39,980 --> 00:04:42,920
So you're going to be doing all of this stuff.

240
00:04:39,980 --> 00:04:42,920
<font color="#ffff54">이 모든 것을 해보겠습니다.</font>

241
00:04:42,920 --> 00:04:44,660
And I'm only going to give you the overview

242
00:04:42,920 --> 00:04:44,660
<font color="#ffff54">개요만 알려드리겠습니다.</font>

243
00:04:44,660 --> 00:04:45,980
because you're going to do it.

244
00:04:44,660 --> 00:04:45,980
<font color="#ffff54">네가 할 거니까.</font>

245
00:04:46,020 --> 00:04:47,020
Why should I tell you the commands

246
00:04:46,020 --> 00:04:47,020
<font color="#ffff54">명령을 알려줘야 하는 이유</font>

247
00:04:47,020 --> 00:04:48,379
when you're going to type them yourself?

248
00:04:47,020 --> 00:04:48,379
<font color="#ffff54">직접 입력할 건데?</font>

249
00:04:48,379 --> 00:04:50,819
So all right, so that's it.

250
00:04:48,379 --> 00:04:50,819
<font color="#ffff54">자, 이제 끝났습니다.</font>

251
00:04:50,819 --> 00:04:53,660
So these three guys are out there ready to help.

252
00:04:50,819 --> 00:04:53,660
<font color="#ffff54">이 세 사람이 도와줄 준비가 됐군요.</font>

253
00:04:53,660 --> 00:04:57,420
Also, you'll see that there is a tutorial lab doc

254
00:04:53,660 --> 00:04:57,420
<font color="#ffff54">또한 튜토리얼 랩 문서가 있습니다.</font>

255
00:04:57,420 --> 00:04:59,319
in the slide deck here.

256
00:04:57,420 --> 00:04:59,319
<font color="#ffff54">가 있습니다.</font>

257
00:04:59,319 --> 00:05:01,660
It's also on your sheet.

258
00:04:59,319 --> 00:05:01,660
<font color="#ffff54">시트에도 있습니다.</font>

259
00:05:01,660 --> 00:05:04,960
So for the virtual people, you can get this deck off Skedge.

260
00:05:01,660 --> 00:05:04,960
<font color="#ffff54">가상의 사람들을 위해, 이 덱을 스케지에서 가져올 수 있습니다.</font>

261
00:05:04,960 --> 00:05:06,620
So these slides are on Skedge already.

262
00:05:04,960 --> 00:05:06,620
<font color="#ffff54">이 슬라이드는 이미 스케지에 있습니다.</font>

263
00:05:06,620 --> 00:05:08,580
So if you go to the talk, you see the schedule,

264
00:05:06,620 --> 00:05:08,580
<font color="#ffff54">강연으로 이동하면 일정이 표시됩니다,</font>

265
00:05:08,580 --> 00:05:10,860
you know, the slide link, click that, you'll get this doc.

266
00:05:08,580 --> 00:05:10,860
<font color="#ffff54">슬라이드 링크를 클릭하시면 이 문서를 보실 수 있습니다.</font>

267
00:05:10,860 --> 00:05:13,720
And then that link will take you to the markdown.

268
00:05:10,860 --> 00:05:13,720
<font color="#ffff54">그리고 그 링크를 클릭하면 마크다운으로 이동합니다.</font>

269
00:05:13,720 --> 00:05:16,480
So let me just preview that markdown for you real quick,

270
00:05:13,720 --> 00:05:16,480
<font color="#ffff54">이제 마크다운을 빠르게 미리 보여드리겠습니다,</font>

271
00:05:16,480 --> 00:05:19,160
make sure everybody is able to find it.

272
00:05:16,480 --> 00:05:19,160
<font color="#ffff54">모든 사람이 찾을 수 있는지 확인합니다.</font>

273
00:05:22,340 --> 00:05:24,260
It looks like this.

274
00:05:22,340 --> 00:05:24,260
<font color="#ffff54">이렇게 보입니다.</font>

275
00:05:25,580 --> 00:05:27,940
All right, so if you follow this GitHub link,

276
00:05:25,580 --> 00:05:27,940
<font color="#ffff54">자, 이 깃허브 링크를 따라가면,</font>

277
00:05:27,940 --> 00:05:29,920
it takes you to KubeCon EU 2022.

278
00:05:27,940 --> 00:05:29,920
<font color="#ffff54">KubeCon EU 2022로 이동합니다.</font>

279
00:05:29,920 --> 00:05:34,840
So the full URL is github.com slash RX dash M

280
00:05:29,920 --> 00:05:34,840
<font color="#ffff54">따라서 전체 URL은 github.com 슬래시 RX 대시 M입니다.</font>

281
00:05:34,840 --> 00:05:39,840
slash KubeCon dash EU dash 2022 slash tree slash main,

282
00:05:34,840 --> 00:05:39,840
<font color="#ffff54">슬래시 큐브콘 대시 EU 대시 2022 슬래시 트리 슬래시 메인,</font>

283
00:05:41,380 --> 00:05:42,520
obviously.

284
00:05:41,380 --> 00:05:42,520
<font color="#ffff54">분명히.</font>

285
00:05:42,519 --> 00:05:44,159
And then if you click on the markdown,

286
00:05:42,519 --> 00:05:44,159
<font color="#ffff54">그리고 마크다운을 클릭합니다,</font>

287
00:05:44,159 --> 00:05:45,439
it's just gonna open right up.

288
00:05:44,159 --> 00:05:45,439
<font color="#ffff54">바로 열립니다.</font>

289
00:05:45,439 --> 00:05:47,299
That's the lab, right?

290
00:05:45,439 --> 00:05:47,299
<font color="#ffff54">저기가 실험실 맞죠?</font>

291
00:05:47,299 --> 00:05:49,359
And you'll notice that it's broken up into steps.

292
00:05:47,299 --> 00:05:49,359
<font color="#ffff54">단계별로 나뉘어져 있는 것을 볼 수 있습니다.</font>

293
00:05:49,359 --> 00:05:51,299
So step one, our first lab session

294
00:05:49,359 --> 00:05:51,299
<font color="#ffff54">1단계, 첫 번째 실습 세션</font>

295
00:05:51,299 --> 00:05:53,000
is gonna be pod networking.

296
00:05:51,299 --> 00:05:53,000
<font color="#ffff54">포드 네트워킹입니다.</font>

297
00:05:53,000 --> 00:05:54,740
And that doc's not going anywhere.

298
00:05:53,000 --> 00:05:54,740
<font color="#ffff54">그리고 그 문서는 아무데도 가지 않을 겁니다.</font>

299
00:05:54,740 --> 00:05:55,680
That'll be there forever.

300
00:05:54,740 --> 00:05:55,680
<font color="#ffff54">저건 영원히 저기 있을 거야.</font>

301
00:05:55,680 --> 00:05:57,759
So you can look at that in three years if you want to.

302
00:05:55,680 --> 00:05:57,759
<font color="#ffff54">원한다면 3년 후에도 볼 수 있어요.</font>

303
00:05:57,759 --> 00:06:00,519
Nothing will work, I'm sure, but you can try it.

304
00:05:57,759 --> 00:06:00,519
<font color="#ffff54">효과가 있을지는 모르겠지만 시도해 볼 수는 있겠지.</font>

305
00:06:00,519 --> 00:06:04,120
Okay, so that's a bit of the startup.

306
00:06:00,519 --> 00:06:04,120
<font color="#ffff54">좋아, 이제 시작이네요.</font>

307
00:06:04,120 --> 00:06:07,639
Hopefully now everybody's got a sheet with the IP.

308
00:06:04,120 --> 00:06:07,639
<font color="#ffff54">이제 모두들 IP가 적힌 시트를 받았겠지?</font>

309
00:06:07,639 --> 00:06:10,279
The other thing you're gonna need to log into the lab system

310
00:06:07,639 --> 00:06:10,279
<font color="#ffff54">실험실 시스템에 로그인하려면 또 하나 필요한 게 있습니다.</font>

311
00:06:10,280 --> 00:06:12,740
you need an IP address to reach the host,

312
00:06:10,280 --> 00:06:12,740
<font color="#ffff54">호스트에 접속하려면 IP 주소가 필요합니다,</font>

313
00:06:12,740 --> 00:06:14,480
and then you need to prove your identity.

314
00:06:12,740 --> 00:06:14,480
<font color="#ffff54">그리고 신원을 증명해야 합니다.</font>

315
00:06:14,480 --> 00:06:16,740
And so you're gonna be Ubuntu, big surprise, right?

316
00:06:14,480 --> 00:06:16,740
<font color="#ffff54">그래서 당신은 우분투가 되는 거군요, 놀랍지 않나요?</font>

317
00:06:16,740 --> 00:06:17,920
That's your user ID.

318
00:06:16,740 --> 00:06:17,920
<font color="#ffff54">그게 네 사용자 아이디야.</font>

319
00:06:17,920 --> 00:06:20,220
And then you're gonna need a key.

320
00:06:17,920 --> 00:06:20,220
<font color="#ffff54">그리고 키가 필요합니다.</font>

321
00:06:20,220 --> 00:06:23,480
And that key, the link for the key is on here too.

322
00:06:20,220 --> 00:06:23,480
<font color="#ffff54">그 열쇠, 열쇠 링크도 여기 있습니다.</font>

323
00:06:23,480 --> 00:06:28,480
So here's a hint also, it's the same key.

324
00:06:23,480 --> 00:06:28,480
<font color="#ffff54">여기에도 같은 키가 있다는 힌트가 있습니다.</font>

325
00:06:29,360 --> 00:06:30,600
So if somebody needs help,

326
00:06:29,360 --> 00:06:30,600
<font color="#ffff54">누군가 도움이 필요하다면</font>

327
00:06:30,600 --> 00:06:32,080
you can log into their machine, right?

328
00:06:30,600 --> 00:06:32,080
<font color="#ffff54">그들의 컴퓨터에 로그인할 수 있죠?</font>

329
00:06:32,080 --> 00:06:33,920
These machines are all going away in about two hours.

330
00:06:32,080 --> 00:06:33,920
<font color="#ffff54">이 기계들은 약 2시간 후에 모두 사라질 거예요.</font>

331
00:06:33,920 --> 00:06:37,520
So, all right, that's enough of the logistics.

332
00:06:33,920 --> 00:06:37,520
<font color="#ffff54">자, 물류는 여기까지입니다.</font>

333
00:06:37,520 --> 00:06:39,280
Let's talk about the talk.

334
00:06:37,520 --> 00:06:39,280
<font color="#ffff54">대화에 대해 얘기해보죠.</font>

335
00:06:39,280 --> 00:06:42,880
So our goal is to introduce the world of Kubernetes

336
00:06:39,280 --> 00:06:42,880
<font color="#ffff54">우리의 목표는 쿠버네티스의 세계를 소개하는 것이다.</font>

337
00:06:42,880 --> 00:06:46,240
network communications in a high level but practical way.

338
00:06:42,880 --> 00:06:46,240
<font color="#ffff54">네트워크 통신을 높은 수준이지만 실용적인 방식으로 소개하는 것이다.</font>

339
00:06:46,240 --> 00:06:48,760
The idea of each of these little thought experiments,

340
00:06:46,240 --> 00:06:48,760
<font color="#ffff54">이 작은 사고 실험의 아이디어들,</font>

341
00:06:48,760 --> 00:06:52,360
these little labs is to show you how a part

342
00:06:48,760 --> 00:06:52,360
<font color="#ffff54">이 작은 실험들은 부품이 어떻게 작동하는지 보여주기 위한 것입니다.</font>

343
00:06:52,360 --> 00:06:55,640
of the Kubernetes networking world works in enough depth

344
00:06:52,360 --> 00:06:55,640
<font color="#ffff54">쿠버네티스 네트워킹 세계의 일부가 어떻게 작동하는지 충분히 깊이 있게 보여준다.</font>

345
00:06:55,640 --> 00:06:58,440
that you understand it and you could walk away and go, cool.

346
00:06:55,640 --> 00:06:58,440
<font color="#ffff54">이해했으니 이제 그만 가도 된다.</font>

347
00:06:58,440 --> 00:07:00,400
I'm not a networking person, but now I get it.

348
00:06:58,440 --> 00:07:00,400
<font color="#ffff54">저는 인맥을 쌓는 사람은 아니지만 이제 알겠어요.</font>

349
00:07:00,400 --> 00:07:02,280
And everything's gonna be a lot easier for me

350
00:07:00,400 --> 00:07:02,280
<font color="#ffff54">이제 모든 게 훨씬 쉬워질 거예요.</font>

351
00:07:02,280 --> 00:07:04,240
because I understand all these little parts.

352
00:07:02,280 --> 00:07:04,240
<font color="#ffff54">이 모든 작은 부분들을 이해하니까요.</font>

353
00:07:04,240 --> 00:07:06,560
Or if you are interested in digging deeper,

354
00:07:04,240 --> 00:07:06,560
<font color="#ffff54">또는 더 깊이 파고들고 싶다면,</font>

355
00:07:06,560 --> 00:07:08,080
you have a beginning point, right?

356
00:07:06,560 --> 00:07:08,080
<font color="#ffff54">시작점이 있죠?</font>

357
00:07:08,079 --> 00:07:10,680
We've installed all the stuff, everything works together.

358
00:07:08,079 --> 00:07:10,680
<font color="#ffff54">모든 것을 설치했고, 모든 것이 함께 작동합니다.</font>

359
00:07:10,680 --> 00:07:13,159
That's a lot of the times, you know, the big time waster.

360
00:07:10,680 --> 00:07:13,159
<font color="#ffff54">시간 낭비인 경우가 많아요.</font>

361
00:07:13,159 --> 00:07:15,439
Now you can get down to the business of playing with it

362
00:07:13,159 --> 00:07:15,439
<font color="#ffff54">이제 본업으로 돌아가서 놀아도 돼요.</font>

363
00:07:15,439 --> 00:07:17,959
and experimenting and taking your journey further.

364
00:07:15,439 --> 00:07:17,959
<font color="#ffff54">실험하고 더 멀리 나아갈 수 있습니다.</font>

365
00:07:17,959 --> 00:07:19,919
So that's the idea behind this session.

366
00:07:17,959 --> 00:07:19,919
<font color="#ffff54">이것이 이번 세션의 주제입니다.</font>

367
00:07:19,919 --> 00:07:22,159
Concepts and projects that we're gonna explore,

368
00:07:19,919 --> 00:07:22,159
<font color="#ffff54">우리가 탐구할 개념과 프로젝트,</font>

369
00:07:22,159 --> 00:07:23,839
we're gonna begin with container networking

370
00:07:22,159 --> 00:07:23,839
<font color="#ffff54">컨테이너 네트워킹부터 시작하겠습니다.</font>

371
00:07:23,839 --> 00:07:25,919
and talk about pods and how they talk together.

372
00:07:23,839 --> 00:07:25,919
<font color="#ffff54">그리고 파드와 파드가 함께 대화하는 방법에 대해 이야기하겠습니다.</font>

373
00:07:25,919 --> 00:07:29,680
And that is gonna involve a CNI plugin.

374
00:07:25,919 --> 00:07:29,680
<font color="#ffff54">그리고 여기에는 CNI 플러그인이 포함될 것이다.</font>

375
00:07:29,680 --> 00:07:31,740
Kubernetes doesn't, it's not opinionated, right?

376
00:07:29,680 --> 00:07:31,740
<font color="#ffff54">쿠버네티스는 그렇지 않죠?</font>

377
00:07:31,740 --> 00:07:34,459
It doesn't come with a networking solution.

378
00:07:31,740 --> 00:07:34,459
<font color="#ffff54">네트워킹 솔루션이 제공되지 않습니다.</font>

379
00:07:34,459 --> 00:07:37,120
It doesn't come with a container runtime.

380
00:07:34,459 --> 00:07:37,120
<font color="#ffff54">컨테이너 런타임이 제공되지 않습니다.</font>

381
00:07:37,120 --> 00:07:39,920
It doesn't come with storage drivers, right?

382
00:07:37,120 --> 00:07:39,920
<font color="#ffff54">스토리지 드라이버가 제공되지 않나요?</font>

383
00:07:39,920 --> 00:07:41,160
You have to add all those in

384
00:07:39,920 --> 00:07:41,160
<font color="#ffff54">여기에 모두 추가해야 합니다.</font>

385
00:07:41,160 --> 00:07:43,139
through the container network interface,

386
00:07:41,160 --> 00:07:43,139
<font color="#ffff54">를 추가해야 합니다,</font>

387
00:07:43,139 --> 00:07:44,920
the container runtime interface

388
00:07:43,139 --> 00:07:44,920
<font color="#ffff54">컨테이너 런타임 인터페이스</font>

389
00:07:44,920 --> 00:07:46,660
and the container storage interface, right?

390
00:07:44,920 --> 00:07:46,660
<font color="#ffff54">그리고 컨테이너 스토리지 인터페이스, 맞죠?</font>

391
00:07:46,660 --> 00:07:49,620
Those are the three big legs of the Kubernetes stool.

392
00:07:46,660 --> 00:07:49,620
<font color="#ffff54">이것이 쿠버네티스 스툴의 세 개의 큰 다리이다.</font>

393
00:07:49,620 --> 00:07:51,399
It's very rare to find a Kubernetes cluster

394
00:07:49,620 --> 00:07:51,399
<font color="#ffff54">쿠버네티스 클러스터를 찾는 것은 매우 드물다.</font>

395
00:07:51,399 --> 00:07:53,240
that doesn't have plugins for all three of those

396
00:07:51,399 --> 00:07:53,240
<font color="#ffff54">이 세 가지 모두에 대한 플러그인이 없는 쿠버네티스 클러스터는 거의 없다.</font>

397
00:07:53,240 --> 00:07:56,060
and sometimes multiple plugins for some of them.

398
00:07:53,240 --> 00:07:56,060
<font color="#ffff54">그리고 때로는 일부에 대해 여러 개의 플러그인이 있습니다.</font>

399
00:07:56,060 --> 00:07:58,319
But to just get up and running,

400
00:07:56,060 --> 00:07:58,319
<font color="#ffff54">하지만 일단 시작하고 실행해 보세요,</font>

401
00:07:58,319 --> 00:08:00,000
after you've installed Kubernetes,

402
00:07:58,319 --> 00:08:00,000
<font color="#ffff54">쿠버네티스를 설치한 후,</font>

403
00:08:00,000 --> 00:08:03,560
you're gonna need a container network interface plugin

404
00:08:00,000 --> 00:08:03,560
<font color="#ffff54">컨테이너 네트워크 인터페이스 플러그인이 필요하다.</font>

405
00:08:03,560 --> 00:08:04,399
and we're gonna use Cilium.

406
00:08:03,560 --> 00:08:04,399
<font color="#ffff54">그리고 실리움을 사용하겠습니다.</font>

407
00:08:04,400 --> 00:08:07,160
Cilium is a project at the CNCF,

408
00:08:04,400 --> 00:08:07,160
<font color="#ffff54">실리움은 CNCF의 프로젝트입니다,</font>

409
00:08:07,160 --> 00:08:10,200
really cool solution for networking.

410
00:08:07,160 --> 00:08:10,200
<font color="#ffff54">네트워킹을 위한 정말 멋진 솔루션입니다.</font>

411
00:08:10,200 --> 00:08:11,660
We'll talk about that briefly.

412
00:08:10,200 --> 00:08:11,660
<font color="#ffff54">잠시만요.</font>

413
00:08:11,660 --> 00:08:13,320
Then we're gonna get into step two,

414
00:08:11,660 --> 00:08:13,320
<font color="#ffff54">그럼 2단계로 넘어가겠습니다,</font>

415
00:08:13,320 --> 00:08:14,920
which is Kubernetes services.

416
00:08:13,320 --> 00:08:14,920
<font color="#ffff54">쿠버네티스 서비스입니다.</font>

417
00:08:14,920 --> 00:08:16,960
So once we've got our cluster running

418
00:08:14,920 --> 00:08:16,960
<font color="#ffff54">클러스터가 실행되고 나면</font>

419
00:08:16,960 --> 00:08:18,840
and we've got the network in place

420
00:08:16,960 --> 00:08:18,840
<font color="#ffff54">네트워크가 준비되면</font>

421
00:08:18,840 --> 00:08:20,180
and we've seen how it works

422
00:08:18,840 --> 00:08:20,180
<font color="#ffff54">어떻게 작동하는지 확인했습니다.</font>

423
00:08:20,180 --> 00:08:22,200
and understand the absolute basics,

424
00:08:20,180 --> 00:08:22,200
<font color="#ffff54">그리고 절대적인 기본을 이해합니다,</font>

425
00:08:22,200 --> 00:08:24,360
we're gonna dig into services

426
00:08:22,200 --> 00:08:24,360
<font color="#ffff54">서비스를 파헤치겠습니다.</font>

427
00:08:24,360 --> 00:08:27,040
and we're gonna see how services give us a front end

428
00:08:24,360 --> 00:08:27,040
<font color="#ffff54">서비스가 어떻게 우리에게 프런트엔드를 제공하는지 살펴볼 것입니다.</font>

429
00:08:27,040 --> 00:08:30,620
for a set of dynamically changing pods.

430
00:08:27,040 --> 00:08:30,620
<font color="#ffff54">동적으로 변경되는 파드 집합에 대해.</font>

431
00:08:30,620 --> 00:08:32,360
Clients don't want the heartburn

432
00:08:30,620 --> 00:08:32,360
<font color="#ffff54">클라이언트는 속쓰림을 원하지 않습니다.</font>

433
00:08:32,360 --> 00:08:34,360
of figuring out who to connect to.

434
00:08:32,360 --> 00:08:34,360
<font color="#ffff54">누구와 연결할지 고민하고 있습니다.</font>

435
00:08:34,360 --> 00:08:36,120
They want a virtual IP address

436
00:08:34,360 --> 00:08:36,120
<font color="#ffff54">가상 IP 주소를 원합니다.</font>

437
00:08:36,120 --> 00:08:37,600
that they can look up by name,

438
00:08:36,120 --> 00:08:37,600
<font color="#ffff54">이름으로 조회할 수 있는 가상 IP 주소를 원합니다,</font>

439
00:08:37,600 --> 00:08:39,639
that they just connect to and then the magic happens

440
00:08:37,600 --> 00:08:39,639
<font color="#ffff54">연결하기만 하면 마법이 일어납니다.</font>

441
00:08:39,639 --> 00:08:41,320
and they get to one of the pods, right?

442
00:08:39,639 --> 00:08:41,320
<font color="#ffff54">포드 중 하나에 도착하는 거죠?</font>

443
00:08:41,320 --> 00:08:42,919
So that's what services are all about.

444
00:08:41,320 --> 00:08:42,919
<font color="#ffff54">이것이 바로 서비스입니다.</font>

445
00:08:42,919 --> 00:08:44,919
We're gonna look at how Kubernetes does that,

446
00:08:42,919 --> 00:08:44,919
<font color="#ffff54">쿠버네티스가 이를 어떻게 수행하는지 살펴보겠습니다,</font>

447
00:08:44,919 --> 00:08:46,700
at least one of the ways that it does it.

448
00:08:44,919 --> 00:08:46,700
<font color="#ffff54">적어도 한 가지 방법을 살펴보자.</font>

449
00:08:46,700 --> 00:08:49,039
And then we're gonna take a look at DNS.

450
00:08:46,700 --> 00:08:49,039
<font color="#ffff54">그리고 DNS를 살펴보겠습니다.</font>

451
00:08:50,120 --> 00:08:52,600
Humans don't like to remember IP addresses.

452
00:08:50,120 --> 00:08:52,600
<font color="#ffff54">사람은 IP 주소를 기억하는 것을 좋아하지 않습니다.</font>

453
00:08:52,600 --> 00:08:56,120
Also, IP addresses tend to change a lot more than concepts.

454
00:08:52,600 --> 00:08:56,120
<font color="#ffff54">또한 IP 주소는 개념보다 훨씬 더 많이 바뀌는 경향이 있습니다.</font>

455
00:08:56,120 --> 00:08:57,960
A service name is a concept.

456
00:08:56,120 --> 00:08:57,960
<font color="#ffff54">서비스 이름은 개념입니다.</font>

457
00:08:57,960 --> 00:09:02,960
If you have a CFO reporting service,

458
00:08:57,960 --> 00:09:02,960
<font color="#ffff54">CFO 보고 서비스가 있는 경우,</font>

459
00:09:03,000 --> 00:09:06,240
it's probably gonna be called CFO reporting forever

460
00:09:03,000 --> 00:09:06,240
<font color="#ffff54">아마 영원히 CFO 리포팅이라고 불릴 겁니다.</font>

461
00:09:06,240 --> 00:09:09,440
or for a very long time and anywhere you put it.

462
00:09:06,240 --> 00:09:09,440
<font color="#ffff54">아니면 아주 오랫동안, 어디에 두든.</font>

463
00:09:09,440 --> 00:09:10,840
But if you deploy that in Singapore,

464
00:09:09,440 --> 00:09:10,840
<font color="#ffff54">하지만 싱가포르에 배포한다면,</font>

465
00:09:10,840 --> 00:09:11,680
it's gonna have one IP.

466
00:09:10,840 --> 00:09:11,680
<font color="#ffff54">하나의 IP를 갖게 됩니다.</font>

467
00:09:11,680 --> 00:09:14,280
If you deploy that in London, it's gonna have another IP.

468
00:09:11,680 --> 00:09:14,280
<font color="#ffff54">런던에 배포하면 다른 IP를 갖게 됩니다.</font>

469
00:09:14,280 --> 00:09:18,519
So services use these names to create an abstraction,

470
00:09:14,280 --> 00:09:18,519
<font color="#ffff54">따라서 서비스는 이러한 이름을 사용하여 추상화를 생성합니다,</font>

471
00:09:18,519 --> 00:09:20,720
again, another level of abstraction

472
00:09:18,519 --> 00:09:20,720
<font color="#ffff54">다시, 또 다른 수준의 추상화</font>

473
00:09:20,720 --> 00:09:22,040
on top of that virtual IP

474
00:09:20,720 --> 00:09:22,040
<font color="#ffff54">그 가상 IP 위에</font>

475
00:09:22,040 --> 00:09:24,639
and we're gonna see how Kubernetes implements DNS

476
00:09:22,040 --> 00:09:24,639
<font color="#ffff54">그리고 쿠버네티스가 DNS를 구현하는 방법을 살펴보자.</font>

477
00:09:24,639 --> 00:09:27,120
and it does it in some interesting and creative ways.

478
00:09:24,639 --> 00:09:27,120
<font color="#ffff54">그리고 몇 가지 흥미롭고 창의적인 방식으로 이를 수행한다.</font>

479
00:09:27,120 --> 00:09:28,519
One thing that's fundamental

480
00:09:27,120 --> 00:09:28,519
<font color="#ffff54">기본이 되는 한 가지</font>

481
00:09:28,519 --> 00:09:30,120
that we're gonna hammer on a little bit

482
00:09:28,519 --> 00:09:30,120
<font color="#ffff54">우리가 조금 망치질 거라는 것.</font>

483
00:09:30,120 --> 00:09:31,919
are concepts around Kubernetes.

484
00:09:30,120 --> 00:09:31,919
<font color="#ffff54">는 쿠버네티스를 둘러싼 개념이다.</font>

485
00:09:31,919 --> 00:09:34,440
You'll never understand Kubernetes networking

486
00:09:31,919 --> 00:09:34,440
<font color="#ffff54">쿠버네티스 네트워킹을 절대 이해하지 못할 것이다.</font>

487
00:09:35,360 --> 00:09:38,039
if you don't understand Kubernetes.

488
00:09:35,360 --> 00:09:38,039
<font color="#ffff54">쿠버네티스를 이해하지 못한다면.</font>

489
00:09:38,039 --> 00:09:41,120
Kubernetes thinks about the world a certain way.

490
00:09:38,039 --> 00:09:41,120
<font color="#ffff54">쿠버네티스는 세상을 특정한 방식으로 생각한다.</font>

491
00:09:41,120 --> 00:09:44,139
You don't have to deploy applications that way.

492
00:09:41,120 --> 00:09:44,139
<font color="#ffff54">애플리케이션을 그런 식으로 배포할 필요는 없다.</font>

493
00:09:44,139 --> 00:09:45,820
But if you don't understand it,

494
00:09:44,139 --> 00:09:45,820
<font color="#ffff54">하지만 이해하지 못한다면,</font>

495
00:09:45,820 --> 00:09:48,080
you're gonna keep stepping into potholes.

496
00:09:45,820 --> 00:09:48,080
<font color="#ffff54">계속 움푹 파인 곳을 밟게 될 거야.</font>

497
00:09:48,080 --> 00:09:50,279
If you understand it, you can protect yourself and say,

498
00:09:48,080 --> 00:09:50,279
<font color="#ffff54">만약 당신이 그것을 이해한다면, 당신은 자신을 보호하고 말할 수 있습니다,</font>

499
00:09:50,279 --> 00:09:52,120
well, Kubernetes wants this to be this way,

500
00:09:50,279 --> 00:09:52,120
<font color="#ffff54">쿠버네티스는 이렇게 되기를 원한다,</font>

501
00:09:52,120 --> 00:09:53,279
but we're gonna change it a little bit

502
00:09:52,120 --> 00:09:53,279
<font color="#ffff54">하지만 우리는 그것을 조금 변경할 것이다.</font>

503
00:09:53,279 --> 00:09:55,360
and we're gonna make sure we've done the correct things

504
00:09:53,279 --> 00:09:55,360
<font color="#ffff54">그리고 우리가 올바른 일을 했는지 확인할 거야.</font>

505
00:09:55,399 --> 00:09:58,600
to keep Kubernetes happy when we do it slightly differently

506
00:09:55,399 --> 00:09:58,600
<font color="#ffff54">약간 다르게 할 때 쿠버네티스를 만족시킬 수 있다.</font>

507
00:09:58,600 --> 00:10:00,279
from how Kubernetes expects.

508
00:09:58,600 --> 00:10:00,279
<font color="#ffff54">쿠버네티스가 기대하는 방식과 다르다.</font>

509
00:10:00,279 --> 00:10:02,300
And this really applies to networking

510
00:10:00,279 --> 00:10:02,300
<font color="#ffff54">그리고 이것은 네트워킹에 실제로 적용된다.</font>

511
00:10:02,300 --> 00:10:05,039
and we're gonna see some of this in the DNS section.

512
00:10:02,300 --> 00:10:05,039
<font color="#ffff54">그리고 DNS 섹션에서 이 중 일부를 볼 수 있습니다.</font>

513
00:10:05,039 --> 00:10:08,159
Next, we're gonna do step four, which is outside access.

514
00:10:05,039 --> 00:10:08,159
<font color="#ffff54">다음으로 4단계인 외부 액세스를 수행합니다.</font>

515
00:10:08,159 --> 00:10:09,980
We're gonna see how from a cluster

516
00:10:08,159 --> 00:10:09,980
<font color="#ffff54">클러스터에서 어떻게 하는지 보겠습니다.</font>

517
00:10:09,980 --> 00:10:11,879
where you've got all your cool services running,

518
00:10:09,980 --> 00:10:11,879
<font color="#ffff54">모든 멋진 서비스가 실행되는 곳입니다,</font>

519
00:10:11,879 --> 00:10:14,399
you can get from the outside in

520
00:10:11,879 --> 00:10:14,399
<font color="#ffff54">외부에서 들어올 수 있는</font>

521
00:10:14,399 --> 00:10:16,600
and there's a lot of ways to do that,

522
00:10:14,399 --> 00:10:16,600
<font color="#ffff54">그리고 그 방법에는 여러 가지가 있습니다,</font>

523
00:10:16,600 --> 00:10:20,000
but fundamentally, there's two simple paths

524
00:10:16,600 --> 00:10:20,000
<font color="#ffff54">하지만 근본적으로 두 가지 간단한 경로가 있습니다.</font>

525
00:10:20,000 --> 00:10:21,639
and there's lots of other crazy stuff

526
00:10:20,000 --> 00:10:21,639
<font color="#ffff54">그리고 다른 많은 미친 것들이 있습니다.</font>

527
00:10:21,639 --> 00:10:23,399
that people are marketing and trying to tell you,

528
00:10:21,639 --> 00:10:23,399
<font color="#ffff54">사람들이 마케팅하고 당신에게 말하려고 하는 것들,</font>

529
00:10:23,959 --> 00:10:25,600
there's two paths.

530
00:10:23,959 --> 00:10:25,600
<font color="#ffff54">두 가지 경로가 있습니다.</font>

531
00:10:25,600 --> 00:10:28,720
Under the covers of all these things, there's two ways in.

532
00:10:25,600 --> 00:10:28,720
<font color="#ffff54">이 모든 것의 이면에는 두 가지 길이 있습니다.</font>

533
00:10:28,720 --> 00:10:29,720
And so we're gonna look at that

534
00:10:28,720 --> 00:10:29,720
<font color="#ffff54">그래서 우리는 그것을 살펴볼 것입니다.</font>

535
00:10:29,720 --> 00:10:32,480
and we're gonna talk about some of the cool projects

536
00:10:29,720 --> 00:10:32,480
<font color="#ffff54">그리고 몇 가지 멋진 프로젝트에 대해 이야기해 보겠습니다.</font>

537
00:10:32,480 --> 00:10:33,559
that fit in there.

538
00:10:32,480 --> 00:10:33,559
<font color="#ffff54">저기에 들어갈 수 있을 것 같네요.</font>

539
00:10:33,559 --> 00:10:35,319
In addition to core DNS on the DNS side,

540
00:10:33,559 --> 00:10:35,319
<font color="#ffff54">DNS 측의 코어 DNS에 추가됩니다,</font>

541
00:10:35,319 --> 00:10:37,360
we're gonna look at emissary for ingress

542
00:10:35,319 --> 00:10:37,360
<font color="#ffff54">우리는 침입을 위해 엠시저를 살펴볼 것입니다.</font>

543
00:10:37,360 --> 00:10:39,279
and gateway kinds of functions.

544
00:10:37,360 --> 00:10:39,279
<font color="#ffff54">그리고 게이트웨이 종류의 기능들을 살펴보겠습니다.</font>

545
00:10:39,279 --> 00:10:42,360
Envoy is a proxy that emissary uses under the covers.

546
00:10:39,279 --> 00:10:42,360
<font color="#ffff54">Envoy는 사절이 은밀하게 사용하는 프록시입니다.</font>

547
00:10:42,360 --> 00:10:43,879
And then we're gonna look at,

548
00:10:42,360 --> 00:10:43,879
<font color="#ffff54">그리고 나서 살펴볼게요,</font>

549
00:10:43,879 --> 00:10:45,779
well, we're gonna talk about Metal LB.

550
00:10:43,879 --> 00:10:45,779
<font color="#ffff54">메탈 LB에 대해 얘기해볼게요.</font>

551
00:10:47,220 --> 00:10:49,319
Sometimes when we do this talk, we run Metal LB,

552
00:10:47,220 --> 00:10:49,319
<font color="#ffff54">가끔 이 강연을 할 때 메탈 LB를 실행합니다,</font>

553
00:10:49,319 --> 00:10:51,879
but with this many people, it would be crazy.

554
00:10:49,319 --> 00:10:51,879
<font color="#ffff54">하지만 이렇게 많은 사람이 모이면 미친 짓이죠.</font>

555
00:10:51,879 --> 00:10:52,879
So we're not gonna do that.

556
00:10:51,879 --> 00:10:52,879
<font color="#ffff54">그러니 안 할 거야.</font>

557
00:10:53,759 --> 00:10:54,600
But we'll talk about it a little bit.

558
00:10:53,759 --> 00:10:54,600
<font color="#ffff54">하지만 조금 후에 얘기하자.</font>

559
00:10:54,600 --> 00:10:57,240
And then finally, we're gonna get into service mesh,

560
00:10:54,600 --> 00:10:57,240
<font color="#ffff54">그리고 마지막으로 서비스 메시를 살펴보겠습니다,</font>

561
00:10:57,240 --> 00:10:59,399
step five, this is sort of the pinnacle, right?

562
00:10:57,240 --> 00:10:59,399
<font color="#ffff54">5단계, 이게 정점이죠?</font>

563
00:10:59,399 --> 00:11:02,019
After you've got everything else working perfectly,

564
00:10:59,399 --> 00:11:02,019
<font color="#ffff54">다른 모든 것이 완벽하게 작동하면,</font>

565
00:11:02,019 --> 00:11:03,639
that's when you might wanna start thinking

566
00:11:02,019 --> 00:11:03,639
<font color="#ffff54">그때부터 생각하기 시작할 수 있습니다.</font>

567
00:11:03,639 --> 00:11:04,840
about service mesh.

568
00:11:03,639 --> 00:11:04,840
<font color="#ffff54">서비스 메시입니다.</font>

569
00:11:04,840 --> 00:11:07,080
Not everybody needs a service mesh.

570
00:11:04,840 --> 00:11:07,080
<font color="#ffff54">모든 사람에게 서비스 메시가 필요한 것은 아닙니다.</font>

571
00:11:07,080 --> 00:11:08,080
I don't buy that.

572
00:11:07,080 --> 00:11:08,080
<font color="#ffff54">난 안 믿어.</font>

573
00:11:08,080 --> 00:11:09,679
Not everybody needs a service mesh.

574
00:11:08,080 --> 00:11:09,679
<font color="#ffff54">모든 사람에게 서비스 메시가 필요한 것은 아닙니다.</font>

575
00:11:09,679 --> 00:11:13,600
However, a service mesh is an incredibly powerful

576
00:11:09,679 --> 00:11:13,600
<font color="#ffff54">하지만 서비스 메시가 매우 강력하다면</font>

577
00:11:13,600 --> 00:11:16,220
and valuable thing and so you might need it,

578
00:11:13,600 --> 00:11:16,220
<font color="#ffff54">가치 있는 것이므로 필요할 수도 있습니다,</font>

579
00:11:16,220 --> 00:11:17,059
you might want it.

580
00:11:16,220 --> 00:11:17,059
<font color="#ffff54">당신이 원할지도 모릅니다.</font>

581
00:11:17,059 --> 00:11:19,000
It can be an incredibly valuable tool.

582
00:11:17,059 --> 00:11:19,000
<font color="#ffff54">엄청나게 가치 있는 도구가 될 수 있습니다.</font>

583
00:11:19,000 --> 00:11:20,600
We're gonna talk about what service meshes do

584
00:11:19,000 --> 00:11:20,600
<font color="#ffff54">서비스 메시가 하는 일에 대해 이야기해 보겠습니다.</font>

585
00:11:20,600 --> 00:11:24,320
and we're gonna use the only graduated project

586
00:11:20,600 --> 00:11:24,320
<font color="#ffff54">그리고 유일하게 눈금이 매겨진 프로젝트를 사용하겠습니다.</font>

587
00:11:24,320 --> 00:11:27,519
in the CNCF ecosystem that is a service mesh, LinkerD.

588
00:11:24,320 --> 00:11:27,519
<font color="#ffff54">서비스 메시인 링커D를 사용할 것입니다.</font>

589
00:11:27,519 --> 00:11:29,759
And it's a super cool project,

590
00:11:27,519 --> 00:11:29,759
<font color="#ffff54">정말 멋진 프로젝트입니다,</font>

591
00:11:29,759 --> 00:11:31,420
has a ton of amazing features

592
00:11:29,759 --> 00:11:31,420
<font color="#ffff54">놀라운 기능들이 많아요</font>

593
00:11:31,420 --> 00:11:35,159
and we'll just scratch the surface in this session.

594
00:11:31,420 --> 00:11:35,159
<font color="#ffff54">이번 세션에서는 그 중 일부만 살펴보겠습니다.</font>

595
00:11:35,159 --> 00:11:37,019
But you'll have it installed,

596
00:11:35,159 --> 00:11:37,019
<font color="#ffff54">하지만 설치는 할 수 있을 겁니다,</font>

597
00:11:37,019 --> 00:11:38,840
you'll see how easy it is to fire up

598
00:11:37,019 --> 00:11:38,840
<font color="#ffff54">부팅이 얼마나 쉬운지 알 수 있습니다.</font>

599
00:11:38,840 --> 00:11:40,960
and you'll know the basics so you can, again,

600
00:11:38,840 --> 00:11:40,960
<font color="#ffff54">그리고 기본을 알게 되므로 다시 할 수 있습니다,</font>

601
00:11:40,960 --> 00:11:43,240
carry on your journey and explore LinkerD all you want

602
00:11:40,960 --> 00:11:43,240
<font color="#ffff54">여정을 계속하고 원하는 대로 LinkerD를 탐색하세요.</font>

603
00:11:43,240 --> 00:11:44,480
after the fact.

604
00:11:43,240 --> 00:11:44,480
<font color="#ffff54">애프터 더 팩트.</font>

605
00:11:44,480 --> 00:11:47,759
Okay, so that is our plan.

606
00:11:44,480 --> 00:11:47,759
<font color="#ffff54">좋아, 이게 우리 계획이야.</font>

607
00:11:47,759 --> 00:11:49,480
Now let's see how we do.

608
00:11:47,759 --> 00:11:49,480
<font color="#ffff54">이제 어떻게 되는지 봅시다.</font>

609
00:11:49,519 --> 00:11:51,639
I'm gonna quickly switch over here.

610
00:11:49,519 --> 00:11:51,639
<font color="#ffff54">여기로 빨리 전환할게요.</font>

611
00:11:51,639 --> 00:11:53,000
We have burned 10 minutes.

612
00:11:51,639 --> 00:11:53,000
<font color="#ffff54">10분이 소모되었습니다.</font>

613
00:11:53,000 --> 00:11:54,399
Yikes, okay, we gotta get going.

614
00:11:53,000 --> 00:11:54,399
<font color="#ffff54">이런, 이제 가야겠어.</font>

615
00:11:54,399 --> 00:11:55,820
All right, so step one.

616
00:11:54,399 --> 00:11:55,820
<font color="#ffff54">좋아, 1단계.</font>

617
00:11:55,820 --> 00:11:57,600
And remember, if you've got questions,

618
00:11:55,820 --> 00:11:57,600
<font color="#ffff54">그리고 궁금한 게 있으면 물어보세요,</font>

619
00:11:57,600 --> 00:11:59,159
there's three guys, right?

620
00:11:57,600 --> 00:11:59,159
<font color="#ffff54">남자가 세 명이지?</font>

621
00:11:59,159 --> 00:12:02,159
Chris, Ilian, and Valentin out here that will help you out.

622
00:11:59,159 --> 00:12:02,159
<font color="#ffff54">크리스, 일리안, 발렌틴이 당신을 도와줄 거예요.</font>

623
00:12:02,159 --> 00:12:03,700
So just raise your hand and they'll come

624
00:12:02,159 --> 00:12:03,700
<font color="#ffff54">손만 들면 그들이 올 거야.</font>

625
00:12:03,700 --> 00:12:05,399
and answer your questions while I keep going

626
00:12:03,700 --> 00:12:05,399
<font color="#ffff54">제가 계속 진행하는 동안 질문에 대답해 주세요</font>

627
00:12:05,399 --> 00:12:06,840
to keep us on track.

628
00:12:05,399 --> 00:12:06,840
<font color="#ffff54">계속 진행합니다.</font>

629
00:12:06,840 --> 00:12:08,519
All right, so container networking concepts.

630
00:12:06,840 --> 00:12:08,519
<font color="#ffff54">자, 컨테이너 네트워킹 개념입니다.</font>

631
00:12:08,519 --> 00:12:10,240
Let's talk about this just briefly.

632
00:12:08,519 --> 00:12:10,240
<font color="#ffff54">잠깐만 얘기해보죠.</font>

633
00:12:12,080 --> 00:12:15,279
The first thing I wanna say is there's no such thing

634
00:12:12,080 --> 00:12:15,279
<font color="#ffff54">먼저 말씀드리고 싶은 건, 그런 건 없다는 겁니다.</font>

635
00:12:15,279 --> 00:12:16,180
as a container.

636
00:12:15,279 --> 00:12:16,180
<font color="#ffff54">컨테이너로.</font>

637
00:12:17,220 --> 00:12:18,279
Maybe that's a little shocking

638
00:12:17,220 --> 00:12:18,279
<font color="#ffff54">조금 충격적일 수도 있겠네요.</font>

639
00:12:18,279 --> 00:12:19,919
in a container-based convention,

640
00:12:18,279 --> 00:12:19,919
<font color="#ffff54">컨테이너 기반 컨벤션에서,</font>

641
00:12:19,919 --> 00:12:21,579
but there really isn't, right?

642
00:12:19,919 --> 00:12:21,579
<font color="#ffff54">하지만 실제로는 없지 않나요?</font>

643
00:12:21,579 --> 00:12:23,919
The Linux kernel has C groups.

644
00:12:21,579 --> 00:12:23,919
<font color="#ffff54">리눅스 커널에는 C 그룹이 있습니다.</font>

645
00:12:23,919 --> 00:12:24,919
What do they do?

646
00:12:23,919 --> 00:12:24,919
<font color="#ffff54">무엇을 할까요?</font>

647
00:12:24,919 --> 00:12:26,120
They are control groups.

648
00:12:24,919 --> 00:12:26,120
<font color="#ffff54">그들은 대조군입니다.</font>

649
00:12:26,120 --> 00:12:28,839
They control how much memory or CPU you can use.

650
00:12:26,120 --> 00:12:28,839
<font color="#ffff54">사용할 수 있는 메모리 또는 CPU의 양을 제어합니다.</font>

651
00:12:28,839 --> 00:12:31,039
The Linux kernel has namespaces.

652
00:12:28,839 --> 00:12:31,039
<font color="#ffff54">리눅스 커널에는 네임스페이스가 있습니다.</font>

653
00:12:31,039 --> 00:12:31,879
What do they do?

654
00:12:31,039 --> 00:12:31,879
<font color="#ffff54">무엇을 할까요?</font>

655
00:12:31,879 --> 00:12:35,039
They isolate what your process can see.

656
00:12:31,879 --> 00:12:35,039
<font color="#ffff54">프로세스가 볼 수 있는 것을 격리합니다.</font>

657
00:12:35,039 --> 00:12:37,279
Can your process only see itself and its children

658
00:12:35,039 --> 00:12:37,279
<font color="#ffff54">프로세스가 자신과 그 자식만 볼 수 있는지</font>

659
00:12:37,279 --> 00:12:39,319
or can it see the PIDs of other processes?

660
00:12:37,279 --> 00:12:39,319
<font color="#ffff54">아니면 다른 프로세스의 PID를 볼 수 있습니까?</font>

661
00:12:39,319 --> 00:12:40,899
That's the PID namespace.

662
00:12:39,319 --> 00:12:40,899
<font color="#ffff54">이것이 PID 네임스페이스입니다.</font>

663
00:12:40,899 --> 00:12:43,559
But what we care about is the network namespace.

664
00:12:40,899 --> 00:12:43,559
<font color="#ffff54">하지만 우리가 신경 쓰는 것은 네트워크 네임스페이스입니다.</font>

665
00:12:43,559 --> 00:12:46,679
A network namespace makes it so that a process

666
00:12:43,559 --> 00:12:46,679
<font color="#ffff54">네트워크 네임스페이스는 프로세스가 다음과 같이 되도록 합니다.</font>

667
00:12:46,680 --> 00:12:50,980
can have its own virtual copy of the IP stack.

668
00:12:46,680 --> 00:12:50,980
<font color="#ffff54">프로세스가 IP 스택의 자체 가상 복사본을 가질 수 있도록 합니다.</font>

669
00:12:50,980 --> 00:12:54,040
Inside what we think of as a container,

670
00:12:50,980 --> 00:12:54,040
<font color="#ffff54">우리가 컨테이너라고 생각하는 것의 내부,</font>

671
00:12:54,040 --> 00:12:57,660
you have your own route table, your own IP tables,

672
00:12:54,040 --> 00:12:57,660
<font color="#ffff54">자체 경로 테이블과 자체 IP 테이블이 있습니다,</font>

673
00:12:57,660 --> 00:13:01,360
your own interfaces, loopback and things like that.

674
00:12:57,660 --> 00:13:01,360
<font color="#ffff54">자체 인터페이스, 루프백 등이 있습니다.</font>

675
00:13:01,360 --> 00:13:05,520
So that's really useful because now we can reliably deploy

676
00:13:01,360 --> 00:13:05,520
<font color="#ffff54">이제 안정적으로 배포할 수 있기 때문에 정말 유용합니다.</font>

677
00:13:05,520 --> 00:13:08,180
things that listen on port 80 many, many times

678
00:13:05,520 --> 00:13:08,180
<font color="#ffff54">포트 80에서 여러 번 수신 대기하는 것들을</font>

679
00:13:08,180 --> 00:13:10,120
on the same computer because they all have

680
00:13:08,180 --> 00:13:10,120
<font color="#ffff54">모두 같은 컴퓨터에서</font>

681
00:13:10,120 --> 00:13:10,940
their own interfaces.

682
00:13:10,120 --> 00:13:10,940
<font color="#ffff54">인터페이스를 가지고 있기 때문입니다.</font>

683
00:13:10,940 --> 00:13:11,840
So this is magic, right?

684
00:13:10,940 --> 00:13:11,840
<font color="#ffff54">이게 바로 마법이지?</font>

685
00:13:11,840 --> 00:13:13,560
If we had a big cluster of machines and we wanted

686
00:13:11,840 --> 00:13:13,560
<font color="#ffff54">만약 우리가 큰 기계 클러스터를 가지고 있고, 우리가 원한다면</font>

687
00:13:13,560 --> 00:13:15,720
to dynamically roll out applications,

688
00:13:13,560 --> 00:13:15,720
<font color="#ffff54">를 사용하여 애플리케이션을 동적으로 롤아웃할 수 있습니다,</font>

689
00:13:15,720 --> 00:13:18,240
they're all fighting for ports and craziness like that,

690
00:13:15,720 --> 00:13:18,240
<font color="#ffff54">다들 포트와 그런 미친 짓을 위해 싸우고 있죠,</font>

691
00:13:18,240 --> 00:13:19,440
that would be pretty tough.

692
00:13:18,240 --> 00:13:19,440
<font color="#ffff54">꽤나 힘들겠지.</font>

693
00:13:19,440 --> 00:13:22,560
So what ends up happening with container tech is

694
00:13:19,440 --> 00:13:22,560
<font color="#ffff54">컨테이너 기술에서 결국 일어나는 일은</font>

695
00:13:22,560 --> 00:13:24,480
you get reliable deployment.

696
00:13:22,560 --> 00:13:24,480
<font color="#ffff54">안정적인 배포가 가능합니다.</font>

697
00:13:24,480 --> 00:13:25,980
That's a really huge thing.

698
00:13:24,480 --> 00:13:25,980
<font color="#ffff54">정말 대단한 일이죠.</font>

699
00:13:25,980 --> 00:13:29,440
But we need something to sort of do the deployment, right?

700
00:13:25,980 --> 00:13:29,440
<font color="#ffff54">하지만 배포를 하려면 뭔가가 필요하겠죠?</font>

701
00:13:29,440 --> 00:13:31,399
To make the deployment work

702
00:13:29,440 --> 00:13:31,399
<font color="#ffff54">배포를 하려면</font>

703
00:13:31,399 --> 00:13:33,519
and that's where Kubernetes comes in.

704
00:13:31,399 --> 00:13:33,519
<font color="#ffff54">이것이 바로 쿠버네티스가 필요한 이유입니다.</font>

705
00:13:33,519 --> 00:13:38,519
And Kubernetes, there's no such thing as a container.

706
00:13:33,519 --> 00:13:38,519
<font color="#ffff54">그리고 쿠버네티스에는 컨테이너라는 것이 없습니다.</font>

707
00:13:38,519 --> 00:13:42,180
What Kubernetes does is it takes container images,

708
00:13:38,519 --> 00:13:42,180
<font color="#ffff54">쿠버네티스가 하는 일은 컨테이너 이미지를 가져오는 것이다,</font>

709
00:13:42,180 --> 00:13:45,680
which are just little tarballs with root file systems in them

710
00:13:42,180 --> 00:13:45,680
<font color="#ffff54">루트 파일 시스템이 들어있는 작은 타르볼에 불과하다.</font>

711
00:13:46,520 --> 00:13:50,880
and it runs several of them in the same network namespace.

712
00:13:46,520 --> 00:13:50,880
<font color="#ffff54">그리고 동일한 네트워크 네임스페이스에서 여러 개를 실행합니다.</font>

713
00:13:50,880 --> 00:13:53,520
That bundle is called a pod, right?

714
00:13:50,880 --> 00:13:53,520
<font color="#ffff54">이 번들을 파드라고 하지?</font>

715
00:13:53,520 --> 00:13:55,620
They share the network namespace.

716
00:13:53,520 --> 00:13:55,620
<font color="#ffff54">이들은 네트워크 네임스페이스를 공유한다.</font>

717
00:13:55,620 --> 00:13:58,560
They also share the interprocess communications namespace.

718
00:13:55,620 --> 00:13:58,560
<font color="#ffff54">프로세스 간 통신 네임스페이스도 공유합니다.</font>

719
00:13:58,560 --> 00:14:01,280
We want it to be cheap for them to talk to each other, right?

720
00:13:58,560 --> 00:14:01,280
<font color="#ffff54">서로 대화하는 데 비용이 적게 들었으면 좋겠지?</font>

721
00:14:01,280 --> 00:14:04,720
So if you're using MQs or shared memory, stuff like that,

722
00:14:01,280 --> 00:14:04,720
<font color="#ffff54">그래서 MQ나 공유 메모리 같은 걸 사용한다면요,</font>

723
00:14:04,720 --> 00:14:06,160
those are in the IPC namespace.

724
00:14:04,720 --> 00:14:06,160
<font color="#ffff54">이 IPC 네임스페이스에 있습니다.</font>

725
00:14:06,160 --> 00:14:08,580
And if you're using the local loopback and stuff like that,

726
00:14:06,160 --> 00:14:08,580
<font color="#ffff54">로컬 루프백 등을 사용하는 경우,</font>

727
00:14:08,580 --> 00:14:10,080
that's in the network namespace.

728
00:14:08,580 --> 00:14:10,080
<font color="#ffff54">이 네트워크 네임스페이스에 있습니다.</font>

729
00:14:10,080 --> 00:14:14,320
So pods are collections of container images

730
00:14:10,080 --> 00:14:14,320
<font color="#ffff54">따라서 파드는 컨테이너 이미지의 모음이다.</font>

731
00:14:14,360 --> 00:14:17,000
that are all running in shared network namespaces.

732
00:14:14,360 --> 00:14:17,000
<font color="#ffff54">모두 공유 네트워크 네임스페이스에서 실행되고 있다.</font>

733
00:14:17,000 --> 00:14:18,840
So in Kubernetes, interestingly,

734
00:14:17,000 --> 00:14:18,840
<font color="#ffff54">쿠버네티스에서는 흥미롭게도,</font>

735
00:14:18,840 --> 00:14:20,960
the pod is the unit of distribution.

736
00:14:18,840 --> 00:14:20,960
<font color="#ffff54">파드는 배포 단위이다.</font>

737
00:14:20,960 --> 00:14:23,360
It's the smallest thing you can schedule.

738
00:14:20,960 --> 00:14:23,360
<font color="#ffff54">스케줄링할 수 있는 가장 작은 단위입니다.</font>

739
00:14:23,360 --> 00:14:25,720
It's the smallest thing that you can scale

740
00:14:23,360 --> 00:14:25,720
<font color="#ffff54">확장할 수 있는 가장 작은 단위입니다.</font>

741
00:14:25,720 --> 00:14:26,560
and they're atomic.

742
00:14:25,720 --> 00:14:26,560
<font color="#ffff54">그리고 원자 단위입니다.</font>

743
00:14:26,560 --> 00:14:28,000
You can't run part of it on one machine

744
00:14:26,560 --> 00:14:28,000
<font color="#ffff54">한 컴퓨터에서 일부를 실행할 수 없습니다.</font>

745
00:14:28,000 --> 00:14:29,500
and part of it on another, right?

746
00:14:28,000 --> 00:14:29,500
<font color="#ffff54">일부는 다른 컴퓨터에서 실행할 수 없죠?</font>

747
00:14:29,500 --> 00:14:31,360
So really what we're thinking about

748
00:14:29,500 --> 00:14:31,360
<font color="#ffff54">그래서 정말 우리가 생각하는 것은</font>

749
00:14:31,360 --> 00:14:34,720
when we move to Kubernetes is not container networking,

750
00:14:31,360 --> 00:14:34,720
<font color="#ffff54">쿠버네티스로 이동할 때 컨테이너 네트워킹이 아니다,</font>

751
00:14:34,720 --> 00:14:36,400
it's pod networking.

752
00:14:34,720 --> 00:14:36,400
<font color="#ffff54">파드 네트워킹이다.</font>

753
00:14:36,400 --> 00:14:40,000
And so pod networking works like this.

754
00:14:36,400 --> 00:14:40,000
<font color="#ffff54">파드 네트워킹은 이렇게 작동한다.</font>

755
00:14:40,000 --> 00:14:41,920
You have an interface in one pod

756
00:14:40,000 --> 00:14:41,920
<font color="#ffff54">하나의 파드에 인터페이스가 있다.</font>

757
00:14:41,920 --> 00:14:43,780
and an interface in another pod.

758
00:14:41,920 --> 00:14:43,780
<font color="#ffff54">다른 파드에 인터페이스가 있다.</font>

759
00:14:44,259 --> 00:14:47,980
They both have IP addresses and now you can talk, right?

760
00:14:44,259 --> 00:14:47,980
<font color="#ffff54">둘 다 IP 주소가 있고 이제 대화가 가능하죠?</font>

761
00:14:47,980 --> 00:14:49,699
These two guys can communicate with each other

762
00:14:47,980 --> 00:14:49,699
<font color="#ffff54">이 두 사람은 서로 통신할 수 있습니다.</font>

763
00:14:49,699 --> 00:14:51,500
and you can have as many containers as you like

764
00:14:49,699 --> 00:14:51,500
<font color="#ffff54">컨테이너를 원하는 만큼 가질 수 있습니다.</font>

765
00:14:51,500 --> 00:14:53,699
in the first pod and as many containers as you like

766
00:14:51,500 --> 00:14:53,699
<font color="#ffff54">첫 번째 파드에서 원하는 만큼의 컨테이너를 가질 수 있다.</font>

767
00:14:53,699 --> 00:14:55,899
in the second pod or as few as you like.

768
00:14:53,699 --> 00:14:55,899
<font color="#ffff54">두 번째 파드에 또는 원하는 만큼의 컨테이너.</font>

769
00:14:55,899 --> 00:14:59,339
So pods are the unit of distribution

770
00:14:55,899 --> 00:14:59,339
<font color="#ffff54">따라서 파드는 배포 단위입니다.</font>

771
00:14:59,339 --> 00:15:01,699
and also the unit of network identity, right?

772
00:14:59,339 --> 00:15:01,699
<font color="#ffff54">그리고 네트워크 아이덴티티의 단위이기도 하죠?</font>

773
00:15:01,699 --> 00:15:04,059
The unit of networking, they have an IP address.

774
00:15:01,699 --> 00:15:04,059
<font color="#ffff54">네트워크의 단위인 IP 주소가 있습니다.</font>

775
00:15:04,059 --> 00:15:06,899
Interestingly enough, the pods need to be able

776
00:15:04,059 --> 00:15:06,899
<font color="#ffff54">흥미롭게도, 파드는 다음을 수행할 수 있어야 한다.</font>

777
00:15:06,899 --> 00:15:07,939
to communicate with each other.

778
00:15:06,899 --> 00:15:07,939
<font color="#ffff54">서로 통신할 수 있어야 한다.</font>

779
00:15:07,939 --> 00:15:09,019
That's what Kubernetes says.

780
00:15:07,939 --> 00:15:09,019
<font color="#ffff54">이것이 쿠버네티스가 말하는 것이다.</font>

781
00:15:09,019 --> 00:15:11,339
All pods in a Kubernetes cluster

782
00:15:09,019 --> 00:15:11,339
<font color="#ffff54">쿠버네티스 클러스터의 모든 파드</font>

783
00:15:11,339 --> 00:15:13,659
must be able to communicate with each other, right?

784
00:15:11,339 --> 00:15:13,659
<font color="#ffff54">서로 통신할 수 있어야 하지 않나?</font>

785
00:15:14,500 --> 00:15:15,339
Now the world's changing.

786
00:15:14,500 --> 00:15:15,339
<font color="#ffff54">이제 세상은 변하고 있어요.</font>

787
00:15:15,339 --> 00:15:16,459
There's lots of exceptions to the rule,

788
00:15:15,339 --> 00:15:16,459
<font color="#ffff54">규칙에는 많은 예외가 있습니다,</font>

789
00:15:16,459 --> 00:15:20,039
but as far as your basic network requirements

790
00:15:16,459 --> 00:15:20,039
<font color="#ffff54">하지만 기본적인 네트워크 요구 사항은</font>

791
00:15:20,039 --> 00:15:23,000
for Kubernetes to function the way that it's supposed to,

792
00:15:20,039 --> 00:15:23,000
<font color="#ffff54">이 되어야 쿠버네티스가 정상적으로 작동한다,</font>

793
00:15:23,000 --> 00:15:24,980
all the pods have to be able to talk to each other.

794
00:15:23,000 --> 00:15:24,980
<font color="#ffff54">모든 파드가 서로 통신할 수 있어야 한다.</font>

795
00:15:24,980 --> 00:15:26,659
Now what if I want to put some pods

796
00:15:24,980 --> 00:15:26,659
<font color="#ffff54">이제 파드를 몇 개 넣으려면 어떻게 해야 하나요?</font>

797
00:15:26,659 --> 00:15:29,939
in the staging namespace and I don't want them

798
00:15:26,659 --> 00:15:29,939
<font color="#ffff54">스테이징 네임스페이스에 넣고 싶지 않은데</font>

799
00:15:29,939 --> 00:15:32,399
talking to pods in the production namespace?

800
00:15:29,939 --> 00:15:32,399
<font color="#ffff54">프로덕션 네임스페이스에서 파드와 대화하고 있는가?</font>

801
00:15:32,399 --> 00:15:33,980
Well, you can create network policies

802
00:15:32,399 --> 00:15:33,980
<font color="#ffff54">네트워크 정책을 만들 수 있다.</font>

803
00:15:33,980 --> 00:15:35,860
that change the rules up and stuff,

804
00:15:33,980 --> 00:15:35,860
<font color="#ffff54">규칙을 변경할 수 있습니다,</font>

805
00:15:35,860 --> 00:15:37,980
but it has to be possible for every pod

806
00:15:35,860 --> 00:15:37,980
<font color="#ffff54">하지만 모든 파드에서 가능해야 한다.</font>

807
00:15:37,980 --> 00:15:39,379
to talk to every other pod.

808
00:15:37,980 --> 00:15:39,379
<font color="#ffff54">다른 모든 파드와 대화할 수 있어야 한다.</font>

809
00:15:39,379 --> 00:15:41,839
What that means is that pods need to be able

810
00:15:39,379 --> 00:15:41,839
<font color="#ffff54">이는 파드가 다음을 수행할 수 있어야 한다는 것을 의미한다.</font>

811
00:15:41,839 --> 00:15:42,860
to communicate with each other

812
00:15:41,839 --> 00:15:42,860
<font color="#ffff54">서로 통신할 수 있어야 한다.</font>

813
00:15:42,899 --> 00:15:44,460
when they're on different machines.

814
00:15:42,899 --> 00:15:44,460
<font color="#ffff54">서로 다른 컴퓨터에 있을 때.</font>

815
00:15:44,460 --> 00:15:47,100
Linux has stuff built into it, like Linux Bridge

816
00:15:44,460 --> 00:15:47,100
<font color="#ffff54">리눅스에는 리눅스 브리지와 같은 기능이 내장되어 있습니다.</font>

817
00:15:47,100 --> 00:15:49,899
and things like that, that acts like a virtual switch

818
00:15:47,100 --> 00:15:49,899
<font color="#ffff54">가상 스위치처럼 작동하는 것들이 있습니다.</font>

819
00:15:49,899 --> 00:15:51,820
where all the pods can talk to each other

820
00:15:49,899 --> 00:15:51,820
<font color="#ffff54">모든 파드가 서로 대화할 수 있다.</font>

821
00:15:51,820 --> 00:15:53,820
and you don't really need any extra software.

822
00:15:51,820 --> 00:15:53,820
<font color="#ffff54">추가 소프트웨어가 필요하지 않습니다.</font>

823
00:15:53,820 --> 00:15:55,300
But as soon as you start communicating

824
00:15:53,820 --> 00:15:55,300
<font color="#ffff54">하지만 통신을 시작하자마자</font>

825
00:15:55,300 --> 00:15:58,840
outside of the computer to another computer,

826
00:15:55,300 --> 00:15:58,840
<font color="#ffff54">컴퓨터 외부에서 다른 컴퓨터와 통신합니다,</font>

827
00:15:58,840 --> 00:16:00,860
something's gotta happen, right?

828
00:15:58,840 --> 00:16:00,860
<font color="#ffff54">무슨 일이 일어나겠지?</font>

829
00:16:00,860 --> 00:16:03,200
Because these pods, in the old days,

830
00:16:00,860 --> 00:16:03,200
<font color="#ffff54">왜냐면 이 포드들은, 옛날에,</font>

831
00:16:03,200 --> 00:16:04,740
we might put a piece of software on there

832
00:16:03,200 --> 00:16:04,740
<font color="#ffff54">소프트웨어 조각을 넣을 수 있다.</font>

833
00:16:04,740 --> 00:16:07,700
and then we might go and program the network awhile

834
00:16:04,740 --> 00:16:07,700
<font color="#ffff54">그리고 나서 네트워크를 잠시 프로그래밍할 수도 있습니다.</font>

835
00:16:07,700 --> 00:16:09,620
and now everybody knows where it is.

836
00:16:07,700 --> 00:16:09,620
<font color="#ffff54">이제 다들 어디 있는지 알겠지.</font>

837
00:16:09,620 --> 00:16:11,500
That's not gonna fly in Kubernetes, right,

838
00:16:09,620 --> 00:16:11,500
<font color="#ffff54">쿠버네티스에서는 안 되겠지?</font>

839
00:16:11,500 --> 00:16:14,419
where we're deploying nine times a day, 10 times a day,

840
00:16:11,500 --> 00:16:14,419
<font color="#ffff54">하루에 9번, 하루에 10번씩 배포하는 곳입니다,</font>

841
00:16:14,419 --> 00:16:17,019
pods are scaling up and scaling down all day long.

842
00:16:14,419 --> 00:16:17,019
<font color="#ffff54">파드가 하루 종일 스케일업 및 스케일다운되고 있다.</font>

843
00:16:17,019 --> 00:16:19,379
That's not gonna fly, it's gotta be automated.

844
00:16:17,019 --> 00:16:19,379
<font color="#ffff54">저건 날아가지 않을 거야, 자동화해야 해.</font>

845
00:16:19,379 --> 00:16:22,220
So we need software to find networking.

846
00:16:19,379 --> 00:16:22,220
<font color="#ffff54">네트워킹을 찾으려면 소프트웨어가 필요해.</font>

847
00:16:22,220 --> 00:16:23,700
But the problem is if Kubernetes just said,

848
00:16:22,220 --> 00:16:23,700
<font color="#ffff54">하지만 문제는 쿠버네티스가 방금 말한 것처럼,</font>

849
00:16:23,700 --> 00:16:26,860
yeah, supply some software to find networking thing,

850
00:16:23,700 --> 00:16:26,860
<font color="#ffff54">네, 네트워킹을 찾을 수 있는 소프트웨어를 제공하세요,</font>

851
00:16:26,860 --> 00:16:29,740
it wouldn't work because Kubernetes would be integrating

852
00:16:26,860 --> 00:16:29,740
<font color="#ffff54">쿠버네티스가 통합할 것이기 때문에 작동하지 않을 것이다.</font>

853
00:16:29,740 --> 00:16:31,700
with 50,000 different things.

854
00:16:29,740 --> 00:16:31,700
<font color="#ffff54">을 50,000개의 다른 것들과 통합할 것이기 때문이다.</font>

855
00:16:31,700 --> 00:16:35,639
And so the CNI is a standard that makes it possible

856
00:16:31,700 --> 00:16:35,639
<font color="#ffff54">그래서 CNI는 이를 가능하게 하는 표준입니다.</font>

857
00:16:35,639 --> 00:16:38,340
for Kubernetes to make the requests that it wants to make,

858
00:16:35,639 --> 00:16:38,340
<font color="#ffff54">쿠버네티스가 원하는 요청을 할 수 있도록 하는 표준이다,</font>

859
00:16:38,340 --> 00:16:40,740
like, hey, I've started up a pod

860
00:16:38,340 --> 00:16:40,740
<font color="#ffff54">예를 들어, 내가 파드를 시작했어.</font>

861
00:16:41,620 --> 00:16:43,899
and I created a network namespace for it,

862
00:16:41,620 --> 00:16:43,899
<font color="#ffff54">그리고 이를 위한 네트워크 네임스페이스를 생성했다,</font>

863
00:16:43,899 --> 00:16:45,580
but it's plain vanilla.

864
00:16:43,899 --> 00:16:45,580
<font color="#ffff54">하지만 평범한 바닐라입니다.</font>

865
00:16:45,580 --> 00:16:47,899
There's no interfaces, there's no rules,

866
00:16:45,580 --> 00:16:47,899
<font color="#ffff54">인터페이스도 없고, 규칙도 없어요,</font>

867
00:16:47,899 --> 00:16:50,220
there's no routes, there's nothing in there.

868
00:16:47,899 --> 00:16:50,220
<font color="#ffff54">경로도 없고, 아무것도 없어요.</font>

869
00:16:50,220 --> 00:16:53,899
So hey, Mr. Software-Defined Networking thing,

870
00:16:50,220 --> 00:16:53,899
<font color="#ffff54">이봐요, 소프트웨어 정의 네트워킹 씨,</font>

871
00:16:53,899 --> 00:16:56,899
please wire this pod up so that it can talk

872
00:16:53,899 --> 00:16:56,899
<font color="#ffff54">이 포드가 대화할 수 있도록 연결해 주세요.</font>

873
00:16:56,899 --> 00:16:58,379
to other pods on this computer

874
00:16:56,899 --> 00:16:58,379
<font color="#ffff54">이 컴퓨터의 다른 파드에</font>

875
00:16:58,379 --> 00:17:01,620
and any pod in the entire cluster.

876
00:16:58,379 --> 00:17:01,620
<font color="#ffff54">그리고 전체 클러스터의 모든 파드에.</font>

877
00:17:01,620 --> 00:17:06,620
So the CNI solutions generally have at least one

878
00:17:01,620 --> 00:17:06,620
<font color="#ffff54">따라서 CNI 솔루션은 일반적으로 적어도 하나 이상의</font>

879
00:17:06,620 --> 00:17:08,420
and sometimes two components.

880
00:17:06,620 --> 00:17:08,420
<font color="#ffff54">그리고 때로는 두 개의 구성 요소가 있습니다.</font>

881
00:17:08,420 --> 00:17:10,300
The first component is a DaemonSet pod

882
00:17:08,420 --> 00:17:10,300
<font color="#ffff54">첫 번째 컴포넌트는 데몬셋 파드이다.</font>

883
00:17:10,300 --> 00:17:11,980
that runs on every node in the cluster

884
00:17:10,300 --> 00:17:11,980
<font color="#ffff54">클러스터의 모든 노드에서 실행된다.</font>

885
00:17:11,980 --> 00:17:15,380
and handles the organization of all the pods

886
00:17:11,980 --> 00:17:15,380
<font color="#ffff54">모든 파드의 구성을 처리한다.</font>

887
00:17:15,380 --> 00:17:16,420
on that cluster.

888
00:17:15,380 --> 00:17:16,420
<font color="#ffff54">해당 클러스터에서.</font>

889
00:17:16,420 --> 00:17:18,540
And then sometimes there's a control plane too.

890
00:17:16,420 --> 00:17:18,540
<font color="#ffff54">그리고 때때로 컨트롤 플레인도 있습니다.</font>

891
00:17:18,540 --> 00:17:21,780
But those CNI components make it possible for pods

892
00:17:18,540 --> 00:17:21,780
<font color="#ffff54">하지만 이러한 CNI 컴포넌트는 파드가</font>

893
00:17:21,780 --> 00:17:23,700
to reach each other when they're on different hosts.

894
00:17:21,780 --> 00:17:23,700
<font color="#ffff54">이 서로 다른 호스트에 있을 때 서로 연결할 수 있다.</font>

895
00:17:23,700 --> 00:17:25,100
And they can do that in lots of different ways.

896
00:17:23,700 --> 00:17:25,100
<font color="#ffff54">그리고 다양한 방법으로 이를 수행할 수 있습니다.</font>

897
00:17:25,100 --> 00:17:26,740
They can just use routes, right?

898
00:17:25,100 --> 00:17:26,740
<font color="#ffff54">그냥 경로를 이용하면 되죠?</font>

899
00:17:26,740 --> 00:17:28,500
You can give every host a subnet,

900
00:17:26,740 --> 00:17:28,500
<font color="#ffff54">모든 호스트에 서브넷을 부여할 수 있습니다,</font>

901
00:17:28,500 --> 00:17:32,260
and then the plugins can discover each other's subnets

902
00:17:28,500 --> 00:17:32,260
<font color="#ffff54">그러면 플러그인이 서로의 서브넷을 발견할 수 있습니다.</font>

903
00:17:32,260 --> 00:17:34,760
through lots of ways, gossip, or they could use that CD

904
00:17:32,260 --> 00:17:34,760
<font color="#ffff54">여러 가지 방법을 통해, 가십을 통해, 또는 그 CD를 사용할 수 있습니다.</font>

905
00:17:34,760 --> 00:17:35,980
to save all that information.

906
00:17:34,760 --> 00:17:35,980
<font color="#ffff54">모든 정보를 저장할 수 있습니다.</font>

907
00:17:36,180 --> 00:17:39,220
And then once they get an outbound connection,

908
00:17:36,180 --> 00:17:39,220
<font color="#ffff54">그리고 아웃바운드 연결을 받으면,</font>

909
00:17:39,220 --> 00:17:41,500
they can say, oh yeah, that IP address I know

910
00:17:39,220 --> 00:17:41,500
<font color="#ffff54">내가 아는 IP 주소라고 말할 수 있습니다.</font>

911
00:17:41,500 --> 00:17:44,019
is on that host, so I'll just route the traffic.

912
00:17:41,500 --> 00:17:44,019
<font color="#ffff54">이 해당 호스트에 있으므로 트래픽을 라우팅하면 됩니다.</font>

913
00:17:44,019 --> 00:17:46,779
They don't have to encapsulate it or do anything like that.

914
00:17:44,019 --> 00:17:46,779
<font color="#ffff54">캡슐화하거나 그런 작업을 할 필요가 없습니다.</font>

915
00:17:46,779 --> 00:17:49,420
On the other hand, it's nice sometimes

916
00:17:46,779 --> 00:17:49,420
<font color="#ffff54">반면에, 가끔은 좋죠.</font>

917
00:17:49,420 --> 00:17:52,299
to encapsulate the traffic because if you do,

918
00:17:49,420 --> 00:17:52,299
<font color="#ffff54">를 사용하여 트래픽을 캡슐화할 수 있습니다,</font>

919
00:17:52,299 --> 00:17:54,860
then you can do things like encrypt it on the wire,

920
00:17:52,299 --> 00:17:54,860
<font color="#ffff54">이면 유선에서 암호화하는 등의 작업을 수행할 수 있습니다,</font>

921
00:17:54,860 --> 00:17:59,500
you can do things like make sure that the underlying network

922
00:17:54,860 --> 00:17:59,500
<font color="#ffff54">기본 네트워크에서 암호화하는 등의 작업을 수행할 수 있습니다.</font>

923
00:17:59,500 --> 00:18:02,500
doesn't know that there are pods, right?

924
00:17:59,500 --> 00:18:02,500
<font color="#ffff54">파드가 있다는 것을 알지 못하죠?</font>

925
00:18:02,500 --> 00:18:04,500
It just sees two hosts talking to each other

926
00:18:02,500 --> 00:18:04,500
<font color="#ffff54">두 호스트가 서로 대화하는 것만 본다.</font>

927
00:18:04,539 --> 00:18:07,059
instead of a bunch of, 20 different IP addresses

928
00:18:04,539 --> 00:18:07,059
<font color="#ffff54">20개의 서로 다른 IP 주소가 아니라</font>

929
00:18:07,059 --> 00:18:08,339
from one computer.

930
00:18:07,059 --> 00:18:08,339
<font color="#ffff54">한 컴퓨터에서.</font>

931
00:18:08,339 --> 00:18:10,420
If you try that on a cloud provider,

932
00:18:08,339 --> 00:18:10,420
<font color="#ffff54">클라우드 제공업체에서 시도하는 경우,</font>

933
00:18:10,420 --> 00:18:12,000
they're probably gonna kill your traffic.

934
00:18:10,420 --> 00:18:12,000
<font color="#ffff54">아마 트래픽을 죽일 것입니다.</font>

935
00:18:12,000 --> 00:18:14,039
They're gonna go, hey, that machine,

936
00:18:12,000 --> 00:18:14,039
<font color="#ffff54">저기, 저 기계 말이야,</font>

937
00:18:14,039 --> 00:18:15,740
I know its IP address is .7,

938
00:18:14,039 --> 00:18:15,740
<font color="#ffff54">IP 주소가 .7인 거 알아,</font>

939
00:18:15,740 --> 00:18:18,859
and I see all these crazy source IPs coming out of that box.

940
00:18:15,740 --> 00:18:18,859
<font color="#ffff54">그리고 그 상자에서 나오는 모든 미친 소스 IP가 보입니다.</font>

941
00:18:18,859 --> 00:18:21,420
There's an attacker in there trying to spoof, right?

942
00:18:18,859 --> 00:18:21,420
<font color="#ffff54">공격자가 스푸핑을 시도하고 있는 거죠?</font>

943
00:18:21,420 --> 00:18:23,380
And so of course you have to go to the cloud provider

944
00:18:21,420 --> 00:18:23,380
<font color="#ffff54">그러니 당연히 클라우드 제공업체로 가서</font>

945
00:18:23,380 --> 00:18:25,140
and change settings to make all this stuff work.

946
00:18:23,380 --> 00:18:25,140
<font color="#ffff54">이 모든 것이 작동하도록 설정을 변경해야 합니다.</font>

947
00:18:25,140 --> 00:18:26,900
If you just don't wanna have to worry about that,

948
00:18:25,140 --> 00:18:26,900
<font color="#ffff54">그런 걱정을 하고 싶지 않으시다면요,</font>

949
00:18:26,900 --> 00:18:28,500
you want something that's totally portable

950
00:18:26,900 --> 00:18:28,500
<font color="#ffff54">완전히 휴대 가능한 것을 원한다면</font>

951
00:18:28,500 --> 00:18:30,700
and goes from your bare metal environment to your cloud

952
00:18:28,500 --> 00:18:30,700
<font color="#ffff54">베어메탈 환경에서 클라우드로 이동하는 경우</font>

953
00:18:30,700 --> 00:18:34,019
to somewhere else, then an overlay could be better, right?

954
00:18:30,700 --> 00:18:34,019
<font color="#ffff54">다른 곳으로 이동한다면 오버레이가 더 낫겠죠?</font>

955
00:18:34,379 --> 00:18:35,420
So there's pros and cons to everything.

956
00:18:34,379 --> 00:18:35,420
<font color="#ffff54">모든 일에는 장단점이 있는 법이죠.</font>

957
00:18:35,420 --> 00:18:37,240
There's no one right answer.

958
00:18:35,420 --> 00:18:37,240
<font color="#ffff54">정답은 하나도 없어요.</font>

959
00:18:37,240 --> 00:18:40,019
But in the case of a lot of these plugins, you have choice.

960
00:18:37,240 --> 00:18:40,019
<font color="#ffff54">하지만 많은 플러그인의 경우 선택의 여지가 있습니다.</font>

961
00:18:40,019 --> 00:18:42,099
So we're gonna talk about Cilium for just a second.

962
00:18:40,019 --> 00:18:42,099
<font color="#ffff54">그럼 실리움에 대해 잠깐 이야기해보겠습니다.</font>

963
00:18:42,099 --> 00:18:43,500
We're gonna use it in the first lab.

964
00:18:42,099 --> 00:18:43,500
<font color="#ffff54">첫 번째 실험실에서 사용할 거야.</font>

965
00:18:43,500 --> 00:18:46,859
Cilium is a CNI plugin that gives us options.

966
00:18:43,500 --> 00:18:46,859
<font color="#ffff54">실리움은 우리에게 옵션을 제공하는 CNI 플러그인입니다.</font>

967
00:18:46,859 --> 00:18:51,859
And it is kind of in the new generation of CNIs

968
00:18:46,859 --> 00:18:51,859
<font color="#ffff54">그리고 그것은 새로운 세대의 CNI에 속합니다.</font>

969
00:18:52,619 --> 00:18:54,980
that are trying to leverage eBPF.

970
00:18:52,619 --> 00:18:54,980
<font color="#ffff54">eBPF를 활용하려고 합니다.</font>

971
00:18:54,980 --> 00:18:57,420
So there's a way to tell the Linux kernel

972
00:18:54,980 --> 00:18:57,420
<font color="#ffff54">리눅스 커널에 다음과 같이 알릴 수 있는 방법이 있습니다.</font>

973
00:18:57,420 --> 00:19:00,839
to run little programs, and therefore it's very fast

974
00:18:57,420 --> 00:19:00,839
<font color="#ffff54">작은 프로그램을 실행할 수 있으므로 매우 빠릅니다.</font>

975
00:19:00,839 --> 00:19:02,960
because you don't have a user mode component

976
00:19:00,839 --> 00:19:02,960
<font color="#ffff54">사용자 모드 컴포넌트가 없기 때문입니다.</font>

977
00:19:02,960 --> 00:19:05,360
constantly messing around with the network traffic.

978
00:19:02,960 --> 00:19:05,360
<font color="#ffff54">네트워크 트래픽을 계속 엉망으로 만들고 있습니다.</font>

979
00:19:05,360 --> 00:19:07,460
And so that's exactly how Cilium works.

980
00:19:05,360 --> 00:19:07,460
<font color="#ffff54">이것이 바로 실리움이 작동하는 방식입니다.</font>

981
00:19:07,460 --> 00:19:09,400
It uses eBPF, leverages that,

982
00:19:07,460 --> 00:19:09,400
<font color="#ffff54">실리움은 eBPF를 사용하고, 이를 활용합니다,</font>

983
00:19:09,400 --> 00:19:12,840
and Cilium gives you the ability to use an overlay network.

984
00:19:09,400 --> 00:19:12,840
<font color="#ffff54">그리고 실리움은 오버레이 네트워크를 사용할 수 있는 기능을 제공합니다.</font>

985
00:19:12,840 --> 00:19:15,039
So you can tunnel the traffic between the hosts

986
00:19:12,840 --> 00:19:15,039
<font color="#ffff54">따라서 호스트 간 트래픽을 터널링할 수 있습니다.</font>

987
00:19:15,039 --> 00:19:18,319
where the network underneath doesn't see the pod traffic.

988
00:19:15,039 --> 00:19:18,319
<font color="#ffff54">아래 네트워크는 파드 트래픽을 볼 수 없다.</font>

989
00:19:18,319 --> 00:19:19,559
It just sees hosts talking.

990
00:19:18,319 --> 00:19:19,559
<font color="#ffff54">호스트가 말하는 것만 본다.</font>

991
00:19:19,559 --> 00:19:21,400
Or you can route the traffic.

992
00:19:19,559 --> 00:19:21,400
<font color="#ffff54">또는 트래픽을 라우팅할 수 있습니다.</font>

993
00:19:21,400 --> 00:19:22,240
It's up to you.

994
00:19:21,400 --> 00:19:22,240
<font color="#ffff54">당신에게 달렸습니다.</font>

995
00:19:22,240 --> 00:19:23,799
Cilium gives you some flexibility

996
00:19:22,240 --> 00:19:23,799
<font color="#ffff54">실리움은 유연성을 제공합니다</font>

997
00:19:23,799 --> 00:19:26,039
and it is a really cool CNCF project

998
00:19:23,799 --> 00:19:26,039
<font color="#ffff54">정말 멋진 CNCF 프로젝트입니다</font>

999
00:19:26,039 --> 00:19:27,079
with a bunch of neat features.

1000
00:19:26,039 --> 00:19:27,079
<font color="#ffff54">깔끔한 기능들이 많아요.</font>

1001
00:19:27,079 --> 00:19:29,039
So we're gonna use that as our CNI plugin,

1002
00:19:27,079 --> 00:19:29,039
<font color="#ffff54">그래서 우리는 그것을 CNI 플러그인으로 사용할 것입니다,</font>

1003
00:19:29,039 --> 00:19:30,759
and that's gonna give us this.

1004
00:19:29,039 --> 00:19:30,759
<font color="#ffff54">그러면 이렇게 됩니다.</font>

1005
00:19:30,759 --> 00:19:33,859
Now, you all have one node, right?

1006
00:19:30,759 --> 00:19:33,859
<font color="#ffff54">이제 모두 노드가 하나씩 있죠?</font>

1007
00:19:33,859 --> 00:19:35,839
We already have like 400 computers stood up,

1008
00:19:33,859 --> 00:19:35,839
<font color="#ffff54">이미 400대의 컴퓨터가 일어섰어요,</font>

1009
00:19:35,839 --> 00:19:37,119
so it would have been 800,

1010
00:19:35,839 --> 00:19:37,119
<font color="#ffff54">그래서 800대였을 겁니다,</font>

1011
00:19:37,119 --> 00:19:38,240
and it just keeps going from there.

1012
00:19:37,119 --> 00:19:38,240
<font color="#ffff54">그리고 거기서부터 계속 진행됩니다.</font>

1013
00:19:38,240 --> 00:19:39,319
So we're gonna do everything

1014
00:19:38,240 --> 00:19:39,319
<font color="#ffff54">그래서 우리는 모든 것을 할 거야</font>

1015
00:19:39,319 --> 00:19:40,839
on a single node Kubernetes cluster,

1016
00:19:39,319 --> 00:19:40,839
<font color="#ffff54">단일 노드 쿠버네티스 클러스터에서,</font>

1017
00:19:40,839 --> 00:19:42,440
but it's gonna work exactly the same

1018
00:19:40,839 --> 00:19:42,440
<font color="#ffff54">하지만 정확히 동일하게 작동한다.</font>

1019
00:19:42,440 --> 00:19:44,920
as if you had 100 nodes, and that's the important thing,

1020
00:19:42,440 --> 00:19:44,920
<font color="#ffff54">마치 100개의 노드가 있는 것처럼, 그게 중요한 거죠,</font>

1021
00:19:44,920 --> 00:19:46,519
and that's what Kubernetes and CNI

1022
00:19:44,920 --> 00:19:46,519
<font color="#ffff54">이것이 바로 쿠버네티스와 CNI의</font>

1023
00:19:46,519 --> 00:19:48,000
brings to the table anyway.

1024
00:19:46,519 --> 00:19:48,000
<font color="#ffff54">의 차이점이다.</font>

1025
00:19:48,000 --> 00:19:50,119
So if you had two hosts, for example,

1026
00:19:48,000 --> 00:19:50,119
<font color="#ffff54">예를 들어 호스트가 두 개라고 가정해봅시다,</font>

1027
00:19:50,119 --> 00:19:52,640
the hosts have interfaces and the pods have interfaces,

1028
00:19:50,119 --> 00:19:52,640
<font color="#ffff54">호스트에는 인터페이스가 있고 파드에는 인터페이스가 있다,</font>

1029
00:19:52,640 --> 00:19:54,720
and the CNI is the thing that takes care

1030
00:19:52,640 --> 00:19:54,720
<font color="#ffff54">그리고 CNI는 관리한다.</font>

1031
00:19:54,720 --> 00:19:57,400
of making sure the traffic can get back and forth.

1032
00:19:54,720 --> 00:19:57,400
<font color="#ffff54">트래픽이 오갈 수 있도록 하는 것입니다.</font>

1033
00:19:57,400 --> 00:19:58,240
All right, cool.

1034
00:19:57,400 --> 00:19:58,240
<font color="#ffff54">알았어요.</font>

1035
00:19:58,240 --> 00:20:01,359
So we've sort of disambiguated CNI.

1036
00:19:58,240 --> 00:20:01,359
<font color="#ffff54">이제 CNI를 어느 정도 정리했네요.</font>

1037
00:20:01,359 --> 00:20:03,180
We've talked about some of the solutions.

1038
00:20:01,359 --> 00:20:03,180
<font color="#ffff54">우리는 몇 가지 해결책에 대해 이야기했습니다.</font>

1039
00:20:03,180 --> 00:20:06,160
There's lots of other really cool CNI plugins, by the way.

1040
00:20:03,180 --> 00:20:06,160
<font color="#ffff54">그나저나 정말 멋진 CNI 플러그인이 많이 있습니다.</font>

1041
00:20:06,160 --> 00:20:08,640
Weave is another one that we use a lot at RXM

1042
00:20:06,160 --> 00:20:08,640
<font color="#ffff54">Weave는 RXM에서 많이 사용하는 또 다른 플러그인입니다.</font>

1043
00:20:08,640 --> 00:20:10,680
because it's just super easy to install.

1044
00:20:08,640 --> 00:20:10,680
<font color="#ffff54">설치가 매우 쉽기 때문입니다.</font>

1045
00:20:11,599 --> 00:20:14,000
Calico is probably one of the most popular ones out there

1046
00:20:11,599 --> 00:20:14,000
<font color="#ffff54">Calico는 아마도 가장 인기있는 것 중 하나 일 것입니다.</font>

1047
00:20:14,000 --> 00:20:16,680
that a lot of people use as well, and the list goes on.

1048
00:20:14,000 --> 00:20:16,680
<font color="#ffff54">많은 사람들이 사용하고 있으며 목록은 계속됩니다.</font>

1049
00:20:16,680 --> 00:20:18,400
So there's many, many options,

1050
00:20:16,680 --> 00:20:18,400
<font color="#ffff54">선택지가 정말 많습니다,</font>

1051
00:20:18,400 --> 00:20:20,259
and they all have different pros and cons.

1052
00:20:18,400 --> 00:20:20,259
<font color="#ffff54">모두 다른 장단점을 가지고 있습니다.</font>

1053
00:20:20,259 --> 00:20:22,000
But what we're gonna do now

1054
00:20:20,259 --> 00:20:22,000
<font color="#ffff54">하지만 이제 우리가 할 일은</font>

1055
00:20:22,000 --> 00:20:24,480
is we are going to switch to lab mode,

1056
00:20:22,000 --> 00:20:24,480
<font color="#ffff54">실험실 모드로 전환하겠습니다,</font>

1057
00:20:24,480 --> 00:20:27,160
and that link I put in the presentation, again, up here.

1058
00:20:24,480 --> 00:20:27,160
<font color="#ffff54">그리고 제가 프레젠테이션에 넣은 링크는 여기 위에 있습니다.</font>

1059
00:20:27,160 --> 00:20:28,560
So you have it on your sheet.

1060
00:20:27,160 --> 00:20:28,560
<font color="#ffff54">이제 시트에 있습니다.</font>

1061
00:20:28,560 --> 00:20:30,160
You also have it up there, right?

1062
00:20:28,560 --> 00:20:30,160
<font color="#ffff54">당신도 그 위에 있죠?</font>

1063
00:20:30,160 --> 00:20:33,720
And there's a backup link too,

1064
00:20:30,160 --> 00:20:33,720
<font color="#ffff54">백업 링크도 있어요,</font>

1065
00:20:33,720 --> 00:20:35,960
if you, for some reason, can't get to GitHub.

1066
00:20:33,720 --> 00:20:35,960
<font color="#ffff54">어떤 이유로든 깃허브에 접속할 수 없는 경우.</font>

1067
00:20:35,960 --> 00:20:37,340
The reason we did the backup link

1068
00:20:35,960 --> 00:20:37,340
<font color="#ffff54">백업 링크를 만든 이유</font>

1069
00:20:37,340 --> 00:20:40,180
is GitHub got flaky for me this morning.

1070
00:20:37,340 --> 00:20:40,180
<font color="#ffff54">오늘 아침에 깃허브에 문제가 생겼기 때문입니다.</font>

1071
00:20:40,180 --> 00:20:42,360
I was like, whoa, somebody attacking GitHub?

1072
00:20:40,180 --> 00:20:42,360
<font color="#ffff54">누가 깃허브를 공격하는 거야?</font>

1073
00:20:42,360 --> 00:20:43,279
That would be terrible.

1074
00:20:42,360 --> 00:20:43,279
<font color="#ffff54">끔찍하겠네.</font>

1075
00:20:43,279 --> 00:20:44,740
And so we put a backup link.

1076
00:20:43,279 --> 00:20:44,740
<font color="#ffff54">그래서 백업 링크를 넣었습니다.</font>

1077
00:20:44,740 --> 00:20:46,800
But I would just use the GitHub link

1078
00:20:44,740 --> 00:20:46,800
<font color="#ffff54">하지만 저는 그냥 GitHub 링크를 사용합니다.</font>

1079
00:20:46,800 --> 00:20:49,240
because if you do, you're gonna get a nice,

1080
00:20:46,800 --> 00:20:49,240
<font color="#ffff54">그렇게 하면 멋진 걸 얻을 수 있으니까,</font>

1081
00:20:49,240 --> 00:20:51,860
formatted webpage that you can just follow

1082
00:20:49,240 --> 00:20:51,860
<font color="#ffff54">형식의 웹페이지를 얻을 수 있으니까요.</font>

1083
00:20:51,860 --> 00:20:53,640
and copy and paste from.

1084
00:20:51,860 --> 00:20:53,640
<font color="#ffff54">에서 복사하여 붙여넣을 수 있습니다.</font>

1085
00:20:53,640 --> 00:20:56,840
Now, one thing I wanna mention is in the instructions,

1086
00:20:53,640 --> 00:20:56,840
<font color="#ffff54">이제 한 가지 언급하고 싶은 것은 지침에 있습니다,</font>

1087
00:20:57,359 --> 00:20:59,059
it's walking you through all the steps.

1088
00:20:57,359 --> 00:20:59,059
<font color="#ffff54">모든 단계를 안내하고 있습니다.</font>

1089
00:20:59,059 --> 00:21:01,500
So it says, hey, do this.

1090
00:20:59,059 --> 00:21:01,500
<font color="#ffff54">이걸 하라고 하네요.</font>

1091
00:21:01,500 --> 00:21:03,859
And then it says, hey, do this.

1092
00:21:01,500 --> 00:21:03,859
<font color="#ffff54">그리고 이렇게 말하네요.</font>

1093
00:21:03,859 --> 00:21:06,740
But some of these things say, hey, do this.

1094
00:21:03,859 --> 00:21:06,740
<font color="#ffff54">하지만 이런 것들 중 일부는 이렇게 말하죠.</font>

1095
00:21:06,740 --> 00:21:10,439
And it's specific to your computer.

1096
00:21:06,740 --> 00:21:10,439
<font color="#ffff54">그리고 그것은 당신의 컴퓨터에만 해당됩니다.</font>

1097
00:21:10,439 --> 00:21:14,599
For example, if you create a pod through a deployment,

1098
00:21:10,439 --> 00:21:14,599
<font color="#ffff54">예를 들어, 디플로이먼트를 통해 파드를 생성하는 경우,</font>

1099
00:21:14,599 --> 00:21:17,279
that pod is gonna have an IP address

1100
00:21:14,599 --> 00:21:17,279
<font color="#ffff54">해당 파드는 IP 주소</font>

1101
00:21:17,279 --> 00:21:21,079
that is unique to your setup.

1102
00:21:17,279 --> 00:21:21,079
<font color="#ffff54">설정에 고유한 IP 주소를 갖게 된다.</font>

1103
00:21:21,079 --> 00:21:23,559
And another example here, pinging an IP.

1104
00:21:21,079 --> 00:21:23,559
<font color="#ffff54">또 다른 예는 IP를 핑하는 경우입니다.</font>

1105
00:21:23,559 --> 00:21:25,919
Anytime you see an IP, you gotta ask yourself the question,

1106
00:21:23,559 --> 00:21:25,919
<font color="#ffff54">IP를 볼 때마다 스스로에게 질문을 던져야 합니다,</font>

1107
00:21:25,920 --> 00:21:27,460
what IP should I be putting in there?

1108
00:21:25,920 --> 00:21:27,460
<font color="#ffff54">어떤 IP를 넣어야 할까?</font>

1109
00:21:27,460 --> 00:21:29,360
Because it's not the one in the sheet.

1110
00:21:27,460 --> 00:21:29,360
<font color="#ffff54">시트에 있는 것이 아니니까요.</font>

1111
00:21:29,360 --> 00:21:32,039
The lab is an example, and then you're gonna have

1112
00:21:29,360 --> 00:21:32,039
<font color="#ffff54">실험실은 예시일 뿐이고, 그 다음에는 다음과 같습니다.</font>

1113
00:21:32,039 --> 00:21:33,560
to make some interpolations.

1114
00:21:32,039 --> 00:21:33,560
<font color="#ffff54">를 사용하여 보간을 합니다.</font>

1115
00:21:33,560 --> 00:21:34,820
Usually it'll tell you.

1116
00:21:33,560 --> 00:21:34,820
<font color="#ffff54">보통은 이렇게 알려줍니다.</font>

1117
00:21:34,820 --> 00:21:38,480
It says right here, note, there are lots

1118
00:21:34,820 --> 00:21:38,480
<font color="#ffff54">바로 여기에 이렇게 표시됩니다.</font>

1119
00:21:38,480 --> 00:21:40,680
of different machines, use your IP address,

1120
00:21:38,480 --> 00:21:40,680
<font color="#ffff54">다른 컴퓨터의 IP 주소를 사용하세요,</font>

1121
00:21:40,680 --> 00:21:41,680
that sort of thing.

1122
00:21:40,680 --> 00:21:41,680
<font color="#ffff54">그런 식으로요.</font>

1123
00:21:41,680 --> 00:21:44,880
All right, so yeah, so that's lab step one.

1124
00:21:41,680 --> 00:21:44,880
<font color="#ffff54">좋아요, 이게 실험실 1단계입니다.</font>

1125
00:21:44,880 --> 00:21:47,920
It's gonna have you, let me just kind of walk

1126
00:21:44,880 --> 00:21:47,920
<font color="#ffff54">널 잡을 거야, 그냥 걸어갈게.</font>

1127
00:21:47,920 --> 00:21:48,759
through it real quick.

1128
00:21:47,920 --> 00:21:48,759
<font color="#ffff54">빨리 지나갈게요.</font>

1129
00:21:48,759 --> 00:21:51,080
You can start right now if you want.

1130
00:21:48,759 --> 00:21:51,080
<font color="#ffff54">원하시면 지금 시작하셔도 됩니다.</font>

1131
00:21:51,080 --> 00:21:52,920
So open this document up.

1132
00:21:51,080 --> 00:21:52,920
<font color="#ffff54">그럼 이 문서를 열어보세요.</font>

1133
00:21:52,920 --> 00:21:54,680
You can read this little top section,

1134
00:21:52,920 --> 00:21:54,680
<font color="#ffff54">이 작은 상단 섹션을 읽을 수 있습니다,</font>

1135
00:21:54,680 --> 00:21:58,560
and then it walks you through SSHing into the lab system.

1136
00:21:54,680 --> 00:21:58,560
<font color="#ffff54">그리고 나서 SSH를 통해 실험실 시스템에 접속하는 방법을 안내합니다.</font>

1137
00:21:58,560 --> 00:22:01,799
It literally explains how to log in to the lab system

1138
00:21:58,560 --> 00:22:01,799
<font color="#ffff54">말 그대로 랩 시스템에 로그인하는 방법을 설명합니다.</font>

1139
00:22:01,799 --> 00:22:03,640
with SSH if you've never done that before.

1140
00:22:01,799 --> 00:22:03,640
<font color="#ffff54">한 번도 해본 적이 없다면 SSH로 로그인하는 방법을 설명합니다.</font>

1141
00:22:03,640 --> 00:22:05,240
Here's the link that I was mentioning

1142
00:22:03,640 --> 00:22:05,240
<font color="#ffff54">제가 언급했던 링크는 다음과 같습니다.</font>

1143
00:22:05,240 --> 00:22:07,880
that can give you SSH help if you need that.

1144
00:22:05,240 --> 00:22:07,880
<font color="#ffff54">필요한 경우 SSH 도움말을 받을 수 있습니다.</font>

1145
00:22:07,880 --> 00:22:10,560
And here's the link that shows you how to stand up

1146
00:22:07,880 --> 00:22:10,560
<font color="#ffff54">다음은 일어서는 방법을 알려주는 링크입니다.</font>

1147
00:22:10,560 --> 00:22:13,240
one of these Ubuntu boxes on your own laptop

1148
00:22:10,560 --> 00:22:13,240
<font color="#ffff54">노트북에 이 우분투 박스 중 하나를 설치하세요.</font>

1149
00:22:13,240 --> 00:22:15,960
so you can run the labs later if you wanna do that.

1150
00:22:13,240 --> 00:22:15,960
<font color="#ffff54">나중에 원하면 실험을 할 수 있게요.</font>

1151
00:22:15,960 --> 00:22:18,500
So once you've done this, it has you install Kubernetes.

1152
00:22:15,960 --> 00:22:18,500
<font color="#ffff54">이 작업을 완료하면 쿠버네티스를 설치하게 됩니다.</font>

1153
00:22:18,500 --> 00:22:20,480
We built a really cool little script

1154
00:22:18,500 --> 00:22:20,480
<font color="#ffff54">정말 멋진 작은 스크립트를 만들었습니다.</font>

1155
00:22:20,480 --> 00:22:23,240
that does everything except set up the CNI plugin.

1156
00:22:20,480 --> 00:22:23,240
<font color="#ffff54">CNI 플러그인 설정을 제외한 모든 작업을 수행합니다.</font>

1157
00:22:23,240 --> 00:22:24,279
So we're just gonna run that.

1158
00:22:23,240 --> 00:22:24,279
<font color="#ffff54">그럼 그냥 실행하겠습니다.</font>

1159
00:22:24,879 --> 00:22:25,720
That's gonna take a minute or two,

1160
00:22:24,879 --> 00:22:25,720
<font color="#ffff54">1, 2분 정도 걸릴 거야,</font>

1161
00:22:25,720 --> 00:22:27,559
so start that now if you can.

1162
00:22:25,720 --> 00:22:27,559
<font color="#ffff54">가능하면 지금 시작하세요.</font>

1163
00:22:27,559 --> 00:22:30,879
And then you're gonna see the status of your nodes.

1164
00:22:27,559 --> 00:22:30,879
<font color="#ffff54">그러면 노드 상태를 확인할 수 있습니다.</font>

1165
00:22:30,879 --> 00:22:32,819
You're gonna realize you need a CNI plugin.

1166
00:22:30,879 --> 00:22:32,819
<font color="#ffff54">CNI 플러그인이 필요하다는 것을 알게 될 것입니다.</font>

1167
00:22:32,819 --> 00:22:34,440
We're gonna add Cilium.

1168
00:22:32,819 --> 00:22:34,440
<font color="#ffff54">실리움을 추가하겠습니다.</font>

1169
00:22:34,440 --> 00:22:36,559
We're gonna play around with it a little bit.

1170
00:22:34,440 --> 00:22:36,559
<font color="#ffff54">이걸로 좀 놀아보자.</font>

1171
00:22:36,559 --> 00:22:38,160
Then we're gonna poke around under the covers

1172
00:22:36,559 --> 00:22:38,160
<font color="#ffff54">그리고 이불 속을 뒤져볼게요.</font>

1173
00:22:38,160 --> 00:22:39,480
and see how our pods work

1174
00:22:38,160 --> 00:22:39,480
<font color="#ffff54">우리 포드가 어떻게 작동하는지 보죠.</font>

1175
00:22:39,480 --> 00:22:41,519
and how the IP addresses are getting assigned

1176
00:22:39,480 --> 00:22:41,519
<font color="#ffff54">IP 주소가 어떻게 할당되는지 확인한다.</font>

1177
00:22:41,519 --> 00:22:45,119
and really just look at the whole IP space,

1178
00:22:41,519 --> 00:22:45,119
<font color="#ffff54">전체 IP 공간을 살펴볼 수 있습니다,</font>

1179
00:22:45,119 --> 00:22:46,399
and then we'll clean up at the end.

1180
00:22:45,119 --> 00:22:46,399
<font color="#ffff54">그리고 마지막에 정리하겠습니다.</font>

1181
00:22:46,399 --> 00:22:49,960
And so step two is services.

1182
00:22:46,399 --> 00:22:49,960
<font color="#ffff54">두 번째 단계는 서비스입니다.</font>

1183
00:22:49,960 --> 00:22:53,859
I will indeed be breaking again for services

1184
00:22:49,960 --> 00:22:53,859
<font color="#ffff54">정말 서비스를 위해 다시 휴식을 취하겠습니다.</font>

1185
00:22:54,420 --> 00:22:57,980
in a little bit, but if you get to the end of this lab

1186
00:22:54,420 --> 00:22:57,980
<font color="#ffff54">조금 있다가 이 실험이 끝나면</font>

1187
00:22:57,980 --> 00:23:01,580
and we're not back into the discussion, keep going.

1188
00:22:57,980 --> 00:23:01,580
<font color="#ffff54">다시 논의하지 말고 계속 진행하세요.</font>

1189
00:23:01,580 --> 00:23:02,740
Drill into the services.

1190
00:23:01,580 --> 00:23:02,740
<font color="#ffff54">서비스에 대해 자세히 알아보세요.</font>

1191
00:23:02,740 --> 00:23:05,220
It's okay to get ahead because I'm pretty sure

1192
00:23:02,740 --> 00:23:05,220
<font color="#ffff54">앞서 나가도 괜찮아요.</font>

1193
00:23:05,220 --> 00:23:07,860
you're gonna be behind at some point in this session.

1194
00:23:05,220 --> 00:23:07,860
<font color="#ffff54">이 세션의 어느 시점에서는 뒤처질 테니까요.</font>

1195
00:23:07,860 --> 00:23:12,220
So yeah, SSH into your lab instance, install Kubernetes,

1196
00:23:07,860 --> 00:23:12,220
<font color="#ffff54">네, 랩 인스턴스에 SSH로 접속해서 쿠버네티스를 설치하세요,</font>

1197
00:23:12,220 --> 00:23:15,500
set up CNI, and then explore the pod network.

1198
00:23:12,220 --> 00:23:15,500
<font color="#ffff54">CNI를 설정한 다음, 파드 네트워크를 탐색한다.</font>

1199
00:23:15,500 --> 00:23:17,780
Have fun, holler if you have questions,

1200
00:23:15,500 --> 00:23:17,780
<font color="#ffff54">재미있게 사용하시고, 궁금한 점이 있으면 소리쳐주세요,</font>

1201
00:23:17,780 --> 00:23:20,120
and I am, for the people who are virtual

1202
00:23:17,780 --> 00:23:20,120
<font color="#ffff54">그리고 나는, 가상의 사람들을 위해</font>

1203
00:23:20,120 --> 00:23:21,340
and who don't have laptops,

1204
00:23:20,120 --> 00:23:21,340
<font color="#ffff54">노트북이 없는 사람들을 위해,</font>

1205
00:23:21,339 --> 00:23:24,059
I'm gonna probably do these steps real quickly

1206
00:23:21,339 --> 00:23:24,059
<font color="#ffff54">이 단계는 정말 빨리 끝내야 할 것 같습니다.</font>

1207
00:23:24,059 --> 00:23:26,220
on the overhead so you can just see them.

1208
00:23:24,059 --> 00:23:26,220
<font color="#ffff54">그냥 볼 수 있게 머리 위에 띄울게요.</font>

1209
00:23:27,459 --> 00:23:30,259
All right, let me look at the time too.

1210
00:23:27,459 --> 00:23:30,259
<font color="#ffff54">좋아요, 시간도 볼게요.</font>

1211
00:23:30,259 --> 00:23:32,319
Okay, what are we talking about here?

1212
00:23:30,259 --> 00:23:32,319
<font color="#ffff54">좋아, 이게 무슨 소리야?</font>

1213
00:23:32,319 --> 00:23:35,419
So it is 11.23.

1214
00:23:32,319 --> 00:23:35,419
<font color="#ffff54">그래서 11.23입니다.</font>

1215
00:23:35,419 --> 00:23:38,179
So this one might take a little bit of time.

1216
00:23:35,419 --> 00:23:38,179
<font color="#ffff54">시간이 좀 걸릴 수 있습니다.</font>

1217
00:23:38,179 --> 00:23:40,740
I'm gonna give everybody till, say, 11.30,

1218
00:23:38,179 --> 00:23:40,740
<font color="#ffff54">모두에게 11시 30분까지 시간을 줄게요,</font>

1219
00:23:40,740 --> 00:23:42,779
and then we'll do a check-in.

1220
00:23:40,740 --> 00:23:42,779
<font color="#ffff54">그리고 나서 체크인을 할게요.</font>

1221
00:23:42,779 --> 00:23:43,599
All right.

1222
00:23:42,779 --> 00:23:43,599
<font color="#ffff54">알았어요.</font>

1223
00:23:51,339 --> 00:23:52,179
Okay.

1224
00:23:51,339 --> 00:23:52,179
<font color="#ffff54">알았어.</font>

1225
00:24:21,339 --> 00:24:22,179
All right.

1226
00:24:21,339 --> 00:24:22,179
<font color="#ffff54">알았어요.</font>

1227
00:24:38,299 --> 00:24:42,139
Obviously you can use any SSH client you like.

1228
00:24:38,299 --> 00:24:42,139
<font color="#ffff54">물론 원하는 SSH 클라이언트를 사용할 수 있습니다.</font>

1229
00:24:42,139 --> 00:24:43,819
I'm using Mobac's term, which I love,

1230
00:24:42,139 --> 00:24:43,819
<font color="#ffff54">제가 좋아하는 모박의 용어를 사용하고 있습니다,</font>

1231
00:24:43,819 --> 00:24:47,519
and if you wanna use PuTTY, there's a PPK up there as well

1232
00:24:43,819 --> 00:24:47,519
<font color="#ffff54">PuTTY를 사용하고 싶으면 저기 PPK도 있어요.</font>

1233
00:24:47,519 --> 00:24:50,379
in the keys, and I think it's on the sheet if you need it.

1234
00:24:47,519 --> 00:24:50,379
<font color="#ffff54">키에 있고, 필요하면 시트에 있을 거예요.</font>

1235
00:24:51,339 --> 00:24:52,179
Okay.

1236
00:24:51,339 --> 00:24:52,179
<font color="#ffff54">알았어.</font>

1237
00:25:12,779 --> 00:25:14,019
Hey, Valentin.

1238
00:25:12,779 --> 00:25:14,019
<font color="#ffff54">안녕, 발렌틴.</font>

1239
00:25:14,019 --> 00:25:15,419
Hey, Valentin.

1240
00:25:14,019 --> 00:25:15,419
<font color="#ffff54">안녕, 발렌틴.</font>

1241
00:25:15,419 --> 00:25:17,500
How many do we have left?

1242
00:25:15,419 --> 00:25:17,500
<font color="#ffff54">얼마나 남았어?</font>

1243
00:25:17,500 --> 00:25:18,459
Do we have a lot left?

1244
00:25:17,500 --> 00:25:18,459
<font color="#ffff54">많이 남았나요?</font>

1245
00:25:18,459 --> 00:25:19,299
Yeah.

1246
00:25:18,459 --> 00:25:19,299
<font color="#ffff54">그래.</font>

1247
00:25:19,299 --> 00:25:20,119
Oh, cool, all right.

1248
00:25:19,299 --> 00:25:20,119
<font color="#ffff54">좋아, 알았어.</font>

1249
00:25:21,339 --> 00:25:22,179
All right.

1250
00:25:21,339 --> 00:25:22,179
<font color="#ffff54">알았어.</font>

1251
00:25:27,299 --> 00:25:29,699
All right, I just started the Kubernetes install on my,

1252
00:25:27,299 --> 00:25:29,699
<font color="#ffff54">좋아, 방금 쿠버네티스 설치를 시작했다,</font>

1253
00:25:29,699 --> 00:25:31,539
well, I just grabbed a sheet just like you guys,

1254
00:25:29,699 --> 00:25:31,539
<font color="#ffff54">나도 방금 너희들처럼 시트를 가져왔어,</font>

1255
00:25:31,539 --> 00:25:33,899
so I'm SSHed in.

1256
00:25:31,539 --> 00:25:33,899
<font color="#ffff54">SSH로 접속했어.</font>

1257
00:25:35,059 --> 00:25:36,939
I'm running the Kubernetes install.

1258
00:25:35,059 --> 00:25:36,939
<font color="#ffff54">쿠버네티스 설치를 실행 중입니다.</font>

1259
00:25:36,939 --> 00:25:38,019
It's installing Docker first.

1260
00:25:36,939 --> 00:25:38,019
<font color="#ffff54">도커를 먼저 설치하고 있습니다.</font>

1261
00:25:38,019 --> 00:25:39,079
We're using Docker.

1262
00:25:38,019 --> 00:25:39,079
<font color="#ffff54">도커를 사용하고 있습니다.</font>

1263
00:25:39,079 --> 00:25:40,399
That's the runtime.

1264
00:25:39,079 --> 00:25:40,399
<font color="#ffff54">런타임입니다.</font>

1265
00:25:41,579 --> 00:25:42,419
Why Docker?

1266
00:25:41,579 --> 00:25:42,419
<font color="#ffff54">왜 도커일까요?</font>

1267
00:25:42,419 --> 00:25:45,179
Docker's a poor choice for production,

1268
00:25:42,419 --> 00:25:45,179
<font color="#ffff54">도커는 프로덕션에 적합하지 않습니다,</font>

1269
00:25:45,179 --> 00:25:46,459
not because Docker isn't amazing.

1270
00:25:45,179 --> 00:25:46,459
<font color="#ffff54">도커가 훌륭하지 않아서가 아닙니다.</font>

1271
00:25:46,459 --> 00:25:47,459
Docker is amazing.

1272
00:25:46,459 --> 00:25:47,459
<font color="#ffff54">도커는 놀라워요.</font>

1273
00:25:47,459 --> 00:25:49,579
It's just giant, and it has all sorts of stuff in it

1274
00:25:47,459 --> 00:25:49,579
<font color="#ffff54">그냥 거대하고, 모든 종류의 물건이 들어있어요.</font>

1275
00:25:49,579 --> 00:25:51,339
that you don't want in your production environment.

1276
00:25:49,579 --> 00:25:51,339
<font color="#ffff54">프로덕션 환경에서는 원하지 않는 것들이죠.</font>

1277
00:25:51,339 --> 00:25:53,699
If you're a developer or if you're experimenting,

1278
00:25:51,339 --> 00:25:53,699
<font color="#ffff54">개발자이거나 실험 중인 경우,</font>

1279
00:25:53,699 --> 00:25:55,480
you want Docker, because it's awesome.

1280
00:25:53,699 --> 00:25:55,480
<font color="#ffff54">도커가 멋지니까요.</font>

1281
00:25:55,480 --> 00:25:58,500
It has all sorts of cool tools and features and techniques

1282
00:25:55,480 --> 00:25:58,500
<font color="#ffff54">모든 종류의 멋진 도구와 기능, 기술이 있습니다.</font>

1283
00:25:58,500 --> 00:26:00,779
that you can use for debugging and experimenting

1284
00:25:58,500 --> 00:26:00,779
<font color="#ffff54">디버깅과 실험에 사용할 수 있습니다.</font>

1285
00:26:00,779 --> 00:26:03,919
and exploring, so that's why we use Docker here.

1286
00:26:00,779 --> 00:26:03,919
<font color="#ffff54">탐색을 위해 Docker를 사용하는 이유입니다.</font>

1287
00:26:03,919 --> 00:26:06,699
We just install Docker, and then we install the Docker shim,

1288
00:26:03,919 --> 00:26:06,699
<font color="#ffff54">도커를 설치한 다음 도커 심을 설치합니다,</font>

1289
00:26:06,699 --> 00:26:08,299
which no longer comes with Kubernetes,

1290
00:26:06,699 --> 00:26:08,299
<font color="#ffff54">더 이상 쿠버네티스와 함께 제공되지 않는다,</font>

1291
00:26:08,299 --> 00:26:09,899
so you have to do both steps.

1292
00:26:08,299 --> 00:26:09,899
<font color="#ffff54">따라서 두 단계를 모두 수행해야 한다.</font>

1293
00:26:09,899 --> 00:26:11,359
Docker's getting installed,

1294
00:26:09,899 --> 00:26:11,359
<font color="#ffff54">도커가 설치 중입니다,</font>

1295
00:26:11,359 --> 00:26:13,500
then the Docker shim's getting installed,

1296
00:26:11,359 --> 00:26:13,500
<font color="#ffff54">도커 심이 설치되고 있습니다,</font>

1297
00:26:13,500 --> 00:26:16,399
then we're gonna install Kubernetes latest, which is 1.23.

1298
00:26:13,500 --> 00:26:16,399
<font color="#ffff54">그러면 쿠버네티스 최신 버전인 1.23을 설치합니다.</font>

1299
00:27:19,579 --> 00:27:24,579
You might also ask, what distribution of Kubernetes

1300
00:27:19,579 --> 00:27:24,579
<font color="#ffff54">쿠버네티스의 어떤 배포판인지 물어볼 수도 있다.</font>

1301
00:27:27,259 --> 00:27:29,500
are we using, and the answer is none.

1302
00:27:27,259 --> 00:27:29,500
<font color="#ffff54">를 사용하고 있는지 물어볼 수 있는데, 대답은 '없음'이다.</font>

1303
00:27:29,500 --> 00:27:31,720
We're just using upstream Kubernetes.

1304
00:27:29,500 --> 00:27:31,720
<font color="#ffff54">우리는 그냥 업스트림 쿠버네티스를 사용하고 있다.</font>

1305
00:27:31,720 --> 00:27:36,480
Plain vanilla, 100%, completely compatible, the Kubernetes,

1306
00:27:31,720 --> 00:27:36,480
<font color="#ffff54">플레인 바닐라, 100%, 완벽하게 호환되는 쿠버네티스,</font>

1307
00:27:36,480 --> 00:27:38,299
and we're using kubeadm to install it,

1308
00:27:36,480 --> 00:27:38,299
<font color="#ffff54">그리고 kubeadm을 사용하여 설치하고 있습니다,</font>

1309
00:27:38,299 --> 00:27:40,779
which is the reference installer.

1310
00:27:38,299 --> 00:27:40,779
<font color="#ffff54">를 참조 인스톨러로 사용한다.</font>

1311
00:27:40,779 --> 00:27:44,179
It's the node installer that runs underneath like kubespray

1312
00:27:40,779 --> 00:27:44,179
<font color="#ffff54">kubespray와 같이 아래에서 실행되는 노드 인스톨러이다.</font>

1313
00:27:44,179 --> 00:27:49,179
and stuff like that, so no special gimmicks

1314
00:27:44,179 --> 00:27:49,179
<font color="#ffff54">같은 것들, 그래서 특별한 기믹은 없다.</font>

1315
00:27:49,440 --> 00:27:52,620
in our clusters, just the basics,

1316
00:27:49,440 --> 00:27:52,620
<font color="#ffff54">우리 클러스터에서는 그냥 기본적인 것들입니다,</font>

1317
00:27:52,620 --> 00:27:54,860
and the stuff we add, which is gonna be a lot.

1318
00:27:52,620 --> 00:27:54,860
<font color="#ffff54">그리고 우리가 추가하는 것들, 엄청나게 많을 겁니다.</font>

1319
00:28:11,180 --> 00:28:13,660
Running this script is the thing that takes the longest,

1320
00:28:11,180 --> 00:28:13,660
<font color="#ffff54">이 스크립트를 실행하는 것이 가장 오래 걸리는 작업입니다,</font>

1321
00:28:13,660 --> 00:28:16,660
so everything else is a lot shorter after this,

1322
00:28:13,660 --> 00:28:16,660
<font color="#ffff54">그 이후에는 다른 모든 것이 훨씬 짧아집니다,</font>

1323
00:28:16,660 --> 00:28:18,420
and if you think about it, you're installing

1324
00:28:16,660 --> 00:28:18,420
<font color="#ffff54">그리고 생각해 보면, 여러분은</font>

1325
00:28:18,500 --> 00:28:20,380
an entire Kubernetes cluster from nothing,

1326
00:28:18,500 --> 00:28:20,380
<font color="#ffff54">전체 쿠버네티스 클러스터를 무에서 유를 창조하는 것이다,</font>

1327
00:28:20,380 --> 00:28:23,420
so that's not bad, just a minute or two there.

1328
00:28:20,380 --> 00:28:23,420
<font color="#ffff54">1, 2분 정도면 나쁘지 않습니다.</font>

1329
00:28:26,320 --> 00:28:28,180
Just look at my node, it's not ready.

1330
00:28:26,320 --> 00:28:28,180
<font color="#ffff54">내 노드 좀 봐, 아직 준비 안 됐어.</font>

1331
00:28:28,180 --> 00:28:30,740
It's not ready, because I don't have a CNI solution,

1332
00:28:28,180 --> 00:28:30,740
<font color="#ffff54">CNI 솔루션이 없어서 준비되지 않았습니다,</font>

1333
00:28:31,620 --> 00:28:33,600
so I'm gonna read on in the lab.

1334
00:28:31,620 --> 00:28:33,600
<font color="#ffff54">실험실에서 계속 읽어볼게요.</font>

1335
00:28:33,600 --> 00:28:36,060
Lab tells me your node's not ready.

1336
00:28:33,600 --> 00:28:36,060
<font color="#ffff54">실험실에서 노드가 준비되지 않았다고 합니다.</font>

1337
00:28:36,060 --> 00:28:37,700
Now we're gonna install psyllium.

1338
00:28:36,060 --> 00:28:37,700
<font color="#ffff54">이제 실리움을 설치하겠습니다.</font>

1339
00:28:39,620 --> 00:28:41,580
This is gonna make our node ready,

1340
00:28:39,620 --> 00:28:41,580
<font color="#ffff54">이제 노드가 준비됩니다,</font>

1341
00:28:41,580 --> 00:28:43,400
and there's three steps here, which is, you know,

1342
00:28:41,580 --> 00:28:43,400
<font color="#ffff54">여기에는 세 단계가 있습니다,</font>

1343
00:28:43,400 --> 00:28:45,220
I like to do everything kind of old school,

1344
00:28:43,400 --> 00:28:45,220
<font color="#ffff54">전 모든 걸 옛날 방식으로 하는 걸 좋아해요,</font>

1345
00:28:45,220 --> 00:28:46,220
so you can see what's happening.

1346
00:28:45,220 --> 00:28:46,220
<font color="#ffff54">무슨 일이 일어나고 있는지 볼 수 있어요.</font>

1347
00:28:46,220 --> 00:28:48,819
We're downloading a tarball, right?

1348
00:28:46,220 --> 00:28:48,819
<font color="#ffff54">타르볼을 다운로드하고 있죠?</font>

1349
00:28:48,819 --> 00:28:51,980
That's the first piece, and then once we've got

1350
00:28:48,819 --> 00:28:51,980
<font color="#ffff54">그게 첫 번째 조각이고, 그 다음에는</font>

1351
00:28:51,980 --> 00:28:54,720
the tarball downloaded, we have to extract it,

1352
00:28:51,980 --> 00:28:54,720
<font color="#ffff54">다운로드한 타르볼을 추출해야 합니다,</font>

1353
00:28:55,680 --> 00:28:58,500
and that's gonna give us the psyllium CLI,

1354
00:28:55,680 --> 00:28:58,500
<font color="#ffff54">그러면 실리움 CLI를 얻을 수 있습니다,</font>

1355
00:28:58,500 --> 00:29:03,500
so a lot of these kind of modern projects for Kubernetes

1356
00:28:58,500 --> 00:29:03,500
<font color="#ffff54">따라서 쿠버네티스를 위한 이러한 종류의 최신 프로젝트의 대부분은</font>

1357
00:29:04,059 --> 00:29:06,620
use the operator pattern, where they actually have

1358
00:29:04,059 --> 00:29:06,620
<font color="#ffff54">연산자 패턴을 사용하는데, 실제로는</font>

1359
00:29:07,779 --> 00:29:11,200
maybe a command line tool, and then they run a service

1360
00:29:07,779 --> 00:29:11,200
<font color="#ffff54">명령줄 도구를 사용하여 서비스를 실행합니다.</font>

1361
00:29:11,200 --> 00:29:13,120
in Kubernetes that you can interact with,

1362
00:29:11,200 --> 00:29:13,120
<font color="#ffff54">쿠버네티스에서 상호 작용할 수 있다,</font>

1363
00:29:13,120 --> 00:29:15,579
which is nice, because you can get data and things from it,

1364
00:29:13,120 --> 00:29:15,579
<font color="#ffff54">데이터와 물건을 가져올 수 있기 때문에 좋습니다,</font>

1365
00:29:16,419 --> 00:29:18,019
and then that service is responsible for actually deploying

1366
00:29:16,419 --> 00:29:18,019
<font color="#ffff54">그리고 그 서비스가 실제로 배포를 담당한다.</font>

1367
00:29:18,019 --> 00:29:20,299
the pods that are doing the thing you're trying to do,

1368
00:29:18,019 --> 00:29:20,299
<font color="#ffff54">하고자 하는 작업을 수행하는 파드를 배포한다,</font>

1369
00:29:20,299 --> 00:29:23,099
so I have the psyllium CLI installed now.

1370
00:29:20,299 --> 00:29:23,099
<font color="#ffff54">그래서 이제 실리움 CLI를 설치했다.</font>

1371
00:29:23,099 --> 00:29:25,579
I got my version information, but there's no psyllium

1372
00:29:23,099 --> 00:29:25,579
<font color="#ffff54">버전 정보를 얻었지만 실리움이 없습니다.</font>

1373
00:29:25,579 --> 00:29:26,419
on my cluster.

1374
00:29:25,579 --> 00:29:26,419
<font color="#ffff54">내 클러스터에.</font>

1375
00:29:26,419 --> 00:29:28,379
If I go back and do a get node, you know,

1376
00:29:26,419 --> 00:29:28,379
<font color="#ffff54">다시 돌아가서 get 노드를 수행하면,</font>

1377
00:29:28,379 --> 00:29:30,379
still not ready, so I have to tell psyllium

1378
00:29:28,379 --> 00:29:30,379
<font color="#ffff54">아직 준비가 안됐으니 실리움에게 말해야겠어.</font>

1379
00:29:30,379 --> 00:29:35,259
to install the CNI plugin, and that's the last step here

1380
00:29:30,379 --> 00:29:35,259
<font color="#ffff54">에 CNI 플러그인을 설치하라고 알려줘야 하고, 이것이 마지막 단계입니다.</font>

1381
00:29:35,259 --> 00:29:37,159
before we are up and running.

1382
00:29:35,259 --> 00:29:37,159
<font color="#ffff54">실행하기 전에.</font>

1383
00:29:39,500 --> 00:29:42,159
These guys, of course, have all sorts of crazy icons

1384
00:29:39,500 --> 00:29:42,159
<font color="#ffff54">물론 이 친구들은 온갖 종류의 미친 아이콘을 가지고 있습니다.</font>

1385
00:29:42,159 --> 00:29:44,039
in their output, which is cute.

1386
00:29:42,159 --> 00:29:44,039
<font color="#ffff54">귀여운 아이콘을 가지고 있습니다.</font>

1387
00:29:45,579 --> 00:29:50,579
And of course, every time you do one of these things,

1388
00:29:45,579 --> 00:29:50,579
<font color="#ffff54">그리고 물론, 이런 일을 할 때마다,</font>

1389
00:29:55,119 --> 00:29:57,019
containers are being downloaded, right,

1390
00:29:55,119 --> 00:29:57,019
<font color="#ffff54">컨테이너가 다운로드되고 있습니다,</font>

1391
00:29:57,019 --> 00:29:59,139
because everything runs in containers.

1392
00:29:57,019 --> 00:29:59,139
<font color="#ffff54">모든 것이 컨테이너에서 실행되기 때문입니다.</font>

1393
00:29:59,139 --> 00:30:01,139
Kubernetes eats its own dog food.

1394
00:29:59,139 --> 00:30:01,139
<font color="#ffff54">쿠버네티스는 자신의 개밥을 먹는다.</font>

1395
00:30:01,139 --> 00:30:04,039
Insofar as it's possible, when kube-adm installs things,

1396
00:30:01,139 --> 00:30:04,039
<font color="#ffff54">가능한 한, kube-adm이 무언가를 설치할 때,</font>

1397
00:30:04,039 --> 00:30:07,279
anyway, the control plane runs in containers, in pods,

1398
00:30:04,039 --> 00:30:07,279
<font color="#ffff54">어쨌든, 컨트롤 플레인은 컨테이너, 파드에서 실행된다,</font>

1399
00:30:07,279 --> 00:30:09,279
so you have the scheduler in a pod,

1400
00:30:07,279 --> 00:30:09,279
<font color="#ffff54">그래서 스케줄러가 파드에 있다,</font>

1401
00:30:09,279 --> 00:30:11,179
you have the controller manager in a pod,

1402
00:30:09,279 --> 00:30:11,179
<font color="#ffff54">컨트롤러 매니저가 파드에 있다,</font>

1403
00:30:11,179 --> 00:30:13,659
you have the kube-proxy in a prod,

1404
00:30:11,179 --> 00:30:13,659
<font color="#ffff54">프로드에 큐브-프록시가 있다,</font>

1405
00:30:13,680 --> 00:30:16,180
the node agent, the kubelet, can't run in a pod

1406
00:30:13,680 --> 00:30:16,180
<font color="#ffff54">노드 에이전트인 kubelet이 파드에서 실행될 수 없다.</font>

1407
00:30:16,180 --> 00:30:17,840
because it's the thing that creates the pods,

1408
00:30:16,180 --> 00:30:17,840
<font color="#ffff54">왜냐하면 그것이 파드를 생성하기 때문이다,</font>

1409
00:30:17,840 --> 00:30:20,440
but beyond that, everything's in a pod.

1410
00:30:17,840 --> 00:30:20,440
<font color="#ffff54">하지만 그 너머에는 모든 것이 포드 안에 있습니다.</font>

1411
00:30:20,440 --> 00:30:23,259
So now that we've got psyllium up and running,

1412
00:30:20,440 --> 00:30:23,259
<font color="#ffff54">이제 차전자피가 실행되고 있습니다,</font>

1413
00:30:24,400 --> 00:30:27,380
we can do some things like ask it status.

1414
00:30:24,400 --> 00:30:27,380
<font color="#ffff54">상태를 물어보는 등의 작업을 할 수 있습니다.</font>

1415
00:30:28,880 --> 00:30:30,560
All right, this is the nice thing about having a CLI

1416
00:30:28,880 --> 00:30:30,560
<font color="#ffff54">CLI를 사용하면 좋은 점은 다음과 같습니다.</font>

1417
00:30:30,560 --> 00:30:31,400
and a control plane.

1418
00:30:30,560 --> 00:30:31,400
<font color="#ffff54">그리고 제어 평면.</font>

1419
00:30:31,400 --> 00:30:32,779
We get all sorts of pretty colors,

1420
00:30:31,400 --> 00:30:32,779
<font color="#ffff54">온갖 예쁜 색을 얻습니다,</font>

1421
00:30:32,779 --> 00:30:34,759
and so it looks good, right?

1422
00:30:32,779 --> 00:30:34,759
<font color="#ffff54">보기 좋죠?</font>

1423
00:30:34,759 --> 00:30:37,360
We have the operator running, and we have a single node,

1424
00:30:34,759 --> 00:30:37,360
<font color="#ffff54">오퍼레이터가 실행 중이고 노드가 하나 있습니다,</font>

1425
00:30:37,360 --> 00:30:40,700
so we have a single psyllium agent running.

1426
00:30:37,360 --> 00:30:40,700
<font color="#ffff54">따라서 하나의 실리움 에이전트가 실행 중입니다.</font>

1427
00:30:40,700 --> 00:30:43,240
If we were running, you know, 40 nodes

1428
00:30:40,700 --> 00:30:43,240
<font color="#ffff54">만약 우리가 40개의 노드를 실행 중이라면</font>

1429
00:30:43,779 --> 00:30:44,859
because it's a daemon set,

1430
00:30:43,779 --> 00:30:44,859
<font color="#ffff54">데몬 세트이기 때문입니다,</font>

1431
00:30:44,859 --> 00:30:46,099
it would run on every single node,

1432
00:30:44,859 --> 00:30:46,099
<font color="#ffff54">모든 단일 노드에서 실행됩니다,</font>

1433
00:30:46,099 --> 00:30:47,859
and there'd be 40 of them.

1434
00:30:46,099 --> 00:30:47,859
<font color="#ffff54">그리고 그 중 40개가 있을 것입니다.</font>

1435
00:30:47,859 --> 00:30:48,700
We only have one node,

1436
00:30:47,859 --> 00:30:48,700
<font color="#ffff54">노드가 하나뿐입니다,</font>

1437
00:30:48,700 --> 00:30:50,960
so we only have one of the psyllium plugins.

1438
00:30:48,700 --> 00:30:50,960
<font color="#ffff54">따라서 우리는 실리움 플러그인 중 하나만 가지고 있습니다.</font>

1439
00:30:51,960 --> 00:30:52,799
All right?

1440
00:30:51,960 --> 00:30:52,799
<font color="#ffff54">알겠지?</font>

1441
00:30:55,940 --> 00:30:57,279
And then it just has you look around

1442
00:30:55,940 --> 00:30:57,279
<font color="#ffff54">그리고 주위를 둘러보게 합니다.</font>

1443
00:30:57,279 --> 00:30:59,079
and explore the network a little bit.

1444
00:30:57,279 --> 00:30:59,079
<font color="#ffff54">그리고 네트워크를 조금 탐색합니다.</font>

1445
00:31:02,539 --> 00:31:04,940
Make sure traffic is going back and forth.

1446
00:31:02,539 --> 00:31:04,940
<font color="#ffff54">트래픽이 오가는지 확인합니다.</font>

1447
00:31:08,680 --> 00:31:11,160
Has us run a little pod and verify that we can get to it,

1448
00:31:08,680 --> 00:31:11,160
<font color="#ffff54">작은 파드를 실행하고 접속할 수 있는지 확인합니다,</font>

1449
00:31:11,160 --> 00:31:12,620
and we'll do that real quick.

1450
00:31:11,160 --> 00:31:12,620
<font color="#ffff54">아주 빨리 할게요.</font>

1451
00:31:13,240 --> 00:31:16,660
We'll use the kubectl run command,

1452
00:31:13,240 --> 00:31:16,660
<font color="#ffff54">kubectl 실행 명령을 사용한다,</font>

1453
00:31:16,660 --> 00:31:20,240
which essentially creates a manifest behind the scenes

1454
00:31:16,660 --> 00:31:20,240
<font color="#ffff54">이는 기본적으로 백그라운드에서 매니페스트를 생성한다.</font>

1455
00:31:20,240 --> 00:31:21,839
and applies it to the cluster.

1456
00:31:20,240 --> 00:31:21,839
<font color="#ffff54">클러스터에 적용합니다.</font>

1457
00:31:21,839 --> 00:31:24,799
So this one's gonna create a pod called web

1458
00:31:21,839 --> 00:31:24,799
<font color="#ffff54">이것은 웹이라는 파드를 생성한다.</font>

1459
00:31:24,799 --> 00:31:28,039
with the image HTTPD and defaults for everything else.

1460
00:31:24,799 --> 00:31:28,039
<font color="#ffff54">라는 파드를 생성하고 다른 모든 것은 기본값을 사용합니다.</font>

1461
00:31:31,700 --> 00:31:35,019
And then we can take a look at this guy.

1462
00:31:31,700 --> 00:31:35,019
<font color="#ffff54">이제 이 친구를 살펴볼 수 있습니다.</font>

1463
00:31:35,019 --> 00:31:37,660
Output wide, and kubectl get pod

1464
00:31:35,019 --> 00:31:37,660
<font color="#ffff54">와이드 출력, 그리고 kubectl이 파드를 가져온다.</font>

1465
00:31:37,660 --> 00:31:40,940
is gonna show us the IP of the pod,

1466
00:31:37,660 --> 00:31:40,940
<font color="#ffff54">는 파드의 IP를 보여준다,</font>

1467
00:31:41,940 --> 00:31:43,900
and that way we can test it.

1468
00:31:41,940 --> 00:31:43,900
<font color="#ffff54">그러면 테스트할 수 있습니다.</font>

1469
00:31:48,019 --> 00:31:49,940
All right, Apache up and running.

1470
00:31:48,019 --> 00:31:49,940
<font color="#ffff54">좋아, 아파치를 실행한다.</font>

1471
00:31:52,980 --> 00:31:53,820
Thank you.

1472
00:31:52,980 --> 00:31:53,820
<font color="#ffff54">고마워요.</font>

1473
00:32:04,700 --> 00:32:06,740
As more exploration goes on,

1474
00:32:04,700 --> 00:32:06,740
<font color="#ffff54">더 많은 탐사가 진행 중입니다,</font>

1475
00:32:06,740 --> 00:32:11,200
we get a chance to take a look at the psyllium config,

1476
00:32:06,740 --> 00:32:11,200
<font color="#ffff54">차전자피의 구성을 살펴볼 기회를 얻습니다,</font>

1477
00:32:11,200 --> 00:32:15,079
and I'll just run a couple more of these commands.

1478
00:32:11,200 --> 00:32:15,079
<font color="#ffff54">그리고 이 명령어들을 몇 개 더 실행해 보겠습니다.</font>

1479
00:32:21,420 --> 00:32:24,000
All right, so this is the pool of IP addresses

1480
00:32:21,420 --> 00:32:24,000
<font color="#ffff54">자, 다음은 IP 주소 풀입니다.</font>

1481
00:32:24,000 --> 00:32:26,380
that's gonna be handed out to our pods.

1482
00:32:24,000 --> 00:32:26,380
<font color="#ffff54">우리 파드에 나눠줄 주소입니다.</font>

1483
00:32:26,380 --> 00:32:28,279
The lab kind of walks you through the different pools.

1484
00:32:26,380 --> 00:32:28,279
<font color="#ffff54">실험실에서 여러 풀을 안내해 주네요.</font>

1485
00:32:28,279 --> 00:32:29,799
Right, we have the internet,

1486
00:32:28,279 --> 00:32:29,799
<font color="#ffff54">그래, 인터넷이 있네,</font>

1487
00:32:29,799 --> 00:32:32,900
where everything goes except some reserved address ranges.

1488
00:32:29,799 --> 00:32:32,900
<font color="#ffff54">일부 예약된 주소 범위를 제외한 모든 것이 이동합니다.</font>

1489
00:32:32,900 --> 00:32:35,660
Then you have your cloud host machines,

1490
00:32:32,900 --> 00:32:35,660
<font color="#ffff54">그러면 클라우드 호스트 머신이 있습니다,</font>

1491
00:32:35,660 --> 00:32:38,860
which are probably using one of those reserved ranges.

1492
00:32:35,660 --> 00:32:38,860
<font color="#ffff54">이 예약된 범위 중 하나를 사용하고 있을 것입니다.</font>

1493
00:32:38,860 --> 00:32:40,279
And then you have the pod network,

1494
00:32:38,860 --> 00:32:40,279
<font color="#ffff54">그리고 파드 네트워크가 있습니다,</font>

1495
00:32:40,279 --> 00:32:41,620
which is inside that cloud.

1496
00:32:40,279 --> 00:32:41,620
<font color="#ffff54">이 클라우드 안에 있다.</font>

1497
00:32:41,620 --> 00:32:44,920
And so these things all need to not conflict, right?

1498
00:32:41,620 --> 00:32:44,920
<font color="#ffff54">그래서 이 모든 것들이 충돌하지 않아야 하죠?</font>

1499
00:32:44,920 --> 00:32:46,680
You don't wanna conflict with the public IP address

1500
00:32:44,920 --> 00:32:46,680
<font color="#ffff54">공인 IP 주소와 충돌하고 싶지 않으시겠죠?</font>

1501
00:32:46,680 --> 00:32:48,900
because they might need to reach you or vice versa.

1502
00:32:46,680 --> 00:32:48,900
<font color="#ffff54">상대방이 나에게 연락해야 할 수도 있고 그 반대일 수도 있기 때문입니다.</font>

1503
00:32:48,900 --> 00:32:49,740
You could proxy them,

1504
00:32:48,900 --> 00:32:49,740
<font color="#ffff54">프록시할 수 있습니다,</font>

1505
00:32:49,740 --> 00:32:52,700
but and you don't wanna conflict with the host IPs.

1506
00:32:49,740 --> 00:32:52,700
<font color="#ffff54">하지만 호스트 IP와 충돌하고 싶지 않을 것입니다.</font>

1507
00:32:52,700 --> 00:32:54,040
That would be confusing.

1508
00:32:52,700 --> 00:32:54,040
<font color="#ffff54">혼란스러울 수 있습니다.</font>

1509
00:32:54,040 --> 00:32:56,900
And then the pod IP space is also gonna need to be unique.

1510
00:32:54,040 --> 00:32:56,900
<font color="#ffff54">그리고 파드 IP 공간도 고유해야 한다.</font>

1511
00:33:00,440 --> 00:33:02,420
When you set up your cluster,

1512
00:33:00,440 --> 00:33:02,420
<font color="#ffff54">클러스터를 설정할 때,</font>

1513
00:33:02,420 --> 00:33:05,779
you can specify the IP range for services,

1514
00:33:02,420 --> 00:33:05,779
<font color="#ffff54">서비스에 대한 IP 범위를 지정할 수 있습니다,</font>

1515
00:33:05,779 --> 00:33:07,400
as we'll see in a minute,

1516
00:33:05,779 --> 00:33:07,400
<font color="#ffff54">잠시 후에 살펴보겠습니다,</font>

1517
00:33:07,400 --> 00:33:10,640
but it's the CNI that decides what IP address your pod gets.

1518
00:33:07,400 --> 00:33:10,640
<font color="#ffff54">하지만 파드가 어떤 IP 주소를 갖게 될지는 CNI가 결정한다.</font>

1519
00:33:10,640 --> 00:33:13,060
That's why it's set up here in the CNI function.

1520
00:33:10,640 --> 00:33:13,060
<font color="#ffff54">이것이 바로 여기 CNI 함수에서 설정하는 이유이다.</font>

1521
00:33:13,060 --> 00:33:15,140
So if you wanted a different range,

1522
00:33:13,060 --> 00:33:15,140
<font color="#ffff54">다른 범위를 원한다면</font>

1523
00:33:15,140 --> 00:33:17,019
you'd have to tell psyllium when you installed it.

1524
00:33:15,140 --> 00:33:17,019
<font color="#ffff54">설치했을 때 실리움에게 알려줘야 합니다.</font>

1525
00:33:17,019 --> 00:33:19,200
And if you do a psyllium install minus minus help,

1526
00:33:17,019 --> 00:33:19,200
<font color="#ffff54">그리고 실리움 설치 마이너스 마이너스 도움말을 수행하면,</font>

1527
00:33:19,200 --> 00:33:21,340
it'll dump out a gazillion options that you can use.

1528
00:33:19,200 --> 00:33:21,340
<font color="#ffff54">사용할 수 있는 수많은 옵션을 덤프합니다.</font>

1529
00:33:21,340 --> 00:33:24,940
And there's also a config that you can set and apply

1530
00:33:21,340 --> 00:33:24,940
<font color="#ffff54">그리고 설정하고 적용할 수 있는 구성도 있습니다.</font>

1531
00:33:24,940 --> 00:33:28,180
in kind of a more infrastructure as code approach.

1532
00:33:24,940 --> 00:33:28,180
<font color="#ffff54">을 설정하여 적용할 수 있습니다.</font>

1533
00:33:32,420 --> 00:33:36,820
All right, and so we test the pod network out,

1534
00:33:32,420 --> 00:33:36,820
<font color="#ffff54">자, 이제 파드 네트워크를 테스트합니다,</font>

1535
00:33:36,820 --> 00:33:37,880
do a couple more things.

1536
00:33:36,820 --> 00:33:37,880
<font color="#ffff54">몇 가지 작업을 더 한다.</font>

1537
00:33:37,880 --> 00:33:40,920
And then finally we clean up at the end.

1538
00:33:37,880 --> 00:33:40,920
<font color="#ffff54">그리고 마지막에 청소를 합니다.</font>

1539
00:33:41,820 --> 00:33:44,320
Didn't actually create the client,

1540
00:33:41,820 --> 00:33:44,320
<font color="#ffff54">실제로 클라이언트를 생성하지 않았습니다,</font>

1541
00:33:44,320 --> 00:33:46,259
but I'm gonna go ahead and just delete the web guy

1542
00:33:44,320 --> 00:33:46,259
<font color="#ffff54">그냥 웹 녀석을 삭제할게요.</font>

1543
00:33:46,259 --> 00:33:48,300
and call it a day here.

1544
00:33:46,259 --> 00:33:48,300
<font color="#ffff54">여기까지 하겠습니다.</font>

1545
00:33:48,300 --> 00:33:51,180
Step one done for me.

1546
00:33:48,300 --> 00:33:51,180
<font color="#ffff54">1단계는 끝났습니다.</font>

1547
00:33:52,779 --> 00:33:55,140
You just do a quick show of hands.

1548
00:33:52,779 --> 00:33:55,140
<font color="#ffff54">손만 빨리 내밀면 됩니다.</font>

1549
00:33:55,140 --> 00:33:56,820
If you're still working, great.

1550
00:33:55,140 --> 00:33:56,820
<font color="#ffff54">아직 일하고 있다면 다행이네요.</font>

1551
00:33:56,820 --> 00:33:59,340
How many people have finished with step one though?

1552
00:33:56,820 --> 00:33:59,340
<font color="#ffff54">1단계를 완료한 사람은 몇 명인가요?</font>

1553
00:34:00,259 --> 00:34:01,100
Okay, great.

1554
00:34:00,259 --> 00:34:01,100
<font color="#ffff54">좋아요.</font>

1555
00:34:01,100 --> 00:34:02,120
Let's move on.

1556
00:34:01,100 --> 00:34:02,120
<font color="#ffff54">계속 진행하죠.</font>

1557
00:34:02,680 --> 00:34:04,000
If you're still working, that's great.

1558
00:34:02,680 --> 00:34:04,000
<font color="#ffff54">아직 일하고 있다면 다행이네요.</font>

1559
00:34:04,000 --> 00:34:04,840
Don't feel slow.

1560
00:34:04,000 --> 00:34:04,840
<font color="#ffff54">느리다고 느끼지 마세요.</font>

1561
00:34:04,840 --> 00:34:07,600
You're probably going really fast actually,

1562
00:34:04,840 --> 00:34:07,600
<font color="#ffff54">실제로는 정말 빨리 가고 있을 거예요,</font>

1563
00:34:07,600 --> 00:34:11,079
but we're gonna try to keep on the clock here.

1564
00:34:07,600 --> 00:34:11,079
<font color="#ffff54">하지만 여기서 계속 시간을 맞추도록 노력할게요.</font>

1565
00:34:11,079 --> 00:34:13,640
So give me half an ear while you're keep working

1566
00:34:11,079 --> 00:34:13,640
<font color="#ffff54">그러니 계속 작업하는 동안 내 귀를 반쯤 열어줘.</font>

1567
00:34:13,640 --> 00:34:14,760
if you want to.

1568
00:34:13,640 --> 00:34:14,760
<font color="#ffff54">원한다면.</font>

1569
00:34:14,760 --> 00:34:15,579
This is a tutorial.

1570
00:34:14,760 --> 00:34:15,579
<font color="#ffff54">튜토리얼입니다.</font>

1571
00:34:15,579 --> 00:34:16,840
It's all about the hands-on.

1572
00:34:15,579 --> 00:34:16,840
<font color="#ffff54">실습에 관한 모든 것.</font>

1573
00:34:16,840 --> 00:34:19,280
So if you have a choice between ignoring me

1574
00:34:16,840 --> 00:34:19,280
<font color="#ffff54">날 무시할지, 아니면</font>

1575
00:34:19,280 --> 00:34:23,619
and doing the lab and not ignoring me, I would ignore me.

1576
00:34:19,280 --> 00:34:23,619
<font color="#ffff54">날 무시하고 실험을 하는 것과 날 무시하지 않고 실험을 하는 것 중 하나를 선택할 수 있다면 난 날 무시할 거야.</font>

1577
00:34:24,619 --> 00:34:26,559
So Kubernetes Service Communications.

1578
00:34:24,619 --> 00:34:26,559
<font color="#ffff54">그래서 쿠버네티스 서비스 커뮤니케이션.</font>

1579
00:34:26,559 --> 00:34:30,240
Let's take a look at how Kubernetes thinks about services.

1580
00:34:26,559 --> 00:34:30,240
<font color="#ffff54">쿠버네티스가 서비스에 대해 어떻게 생각하는지 살펴보자.</font>

1581
00:34:30,240 --> 00:34:32,720
When you are running pods,

1582
00:34:30,240 --> 00:34:32,720
<font color="#ffff54">파드를 실행할 때,</font>

1583
00:34:32,720 --> 00:34:34,440
let's think about Kubernetes 1.0.

1584
00:34:32,720 --> 00:34:34,440
<font color="#ffff54">쿠버네티스 1.0에 대해 생각해 보자.</font>

1585
00:34:34,440 --> 00:34:38,160
Kubernetes 1.0 was for microservices, period.

1586
00:34:34,440 --> 00:34:38,160
<font color="#ffff54">쿠버네티스 1.0은 마이크로서비스를 위한 것이었다.</font>

1587
00:34:38,160 --> 00:34:39,320
End of story.

1588
00:34:38,160 --> 00:34:39,320
<font color="#ffff54">이야기 끝.</font>

1589
00:34:39,320 --> 00:34:42,700
There were no real provisions

1590
00:34:39,320 --> 00:34:42,700
<font color="#ffff54">실제 조항은 없었습니다.</font>

1591
00:34:42,700 --> 00:34:44,920
for any kind of stateful workloads.

1592
00:34:42,700 --> 00:34:44,920
<font color="#ffff54">모든 종류의 스테이트풀 워크로드에 대해.</font>

1593
00:34:44,920 --> 00:34:48,680
Cassandra is not a microservice, right?

1594
00:34:44,920 --> 00:34:48,680
<font color="#ffff54">카산드라는 마이크로서비스가 아니죠?</font>

1595
00:34:48,680 --> 00:34:51,160
It is a clustered storage engine

1596
00:34:48,680 --> 00:34:51,160
<font color="#ffff54">클러스터형 스토리지 엔진입니다.</font>

1597
00:34:51,160 --> 00:34:52,520
where you run many, many nodes

1598
00:34:51,160 --> 00:34:52,520
<font color="#ffff54">많은 노드를 실행하는 곳</font>

1599
00:34:52,520 --> 00:34:54,440
and it's horizontally scalable

1600
00:34:52,520 --> 00:34:54,440
<font color="#ffff54">그리고 수평적으로 확장 가능합니다.</font>

1601
00:34:54,440 --> 00:34:59,440
and it's absolutely a cloud-friendly kind of data store,

1602
00:34:54,440 --> 00:34:59,440
<font color="#ffff54">그리고 클라우드 친화적인 데이터 저장소입니다,</font>

1603
00:34:59,440 --> 00:35:00,400
but it's not a microservice.

1604
00:34:59,440 --> 00:35:00,400
<font color="#ffff54">하지만 마이크로서비스는 아닙니다.</font>

1605
00:35:00,400 --> 00:35:02,119
Microservices are stateless.

1606
00:35:00,400 --> 00:35:02,119
<font color="#ffff54">마이크로서비스는 상태가 없습니다.</font>

1607
00:35:02,119 --> 00:35:03,480
State is hard.

1608
00:35:02,119 --> 00:35:03,480
<font color="#ffff54">상태가 어렵습니다.</font>

1609
00:35:03,480 --> 00:35:06,159
Scaling your Cassandra cluster, sizing it,

1610
00:35:03,480 --> 00:35:06,159
<font color="#ffff54">카산드라 클러스터를 확장하고 크기를 조정하는 중입니다,</font>

1611
00:35:06,159 --> 00:35:08,240
doing all those things is hard,

1612
00:35:06,159 --> 00:35:08,240
<font color="#ffff54">그 모든 일을 하는 것은 어렵습니다,</font>

1613
00:35:08,240 --> 00:35:10,780
but running a microservice is easy

1614
00:35:08,240 --> 00:35:10,780
<font color="#ffff54">하지만 마이크로서비스를 실행하는 것은 쉽습니다.</font>

1615
00:35:10,780 --> 00:35:13,720
and destroying it when you have seven others

1616
00:35:10,780 --> 00:35:13,720
<font color="#ffff54">다른 7개가 있을 때 파괴합니다.</font>

1617
00:35:13,720 --> 00:35:15,800
shouldn't ripple the waters at all.

1618
00:35:13,720 --> 00:35:15,800
<font color="#ffff54">물결이 전혀 일어나지 않아야 합니다.</font>

1619
00:35:15,800 --> 00:35:16,639
Nobody should care.

1620
00:35:15,800 --> 00:35:16,639
<font color="#ffff54">아무도 신경 쓸 필요 없어.</font>

1621
00:35:16,639 --> 00:35:17,880
You get disconnected, you reconnect,

1622
00:35:16,639 --> 00:35:17,880
<font color="#ffff54">연결이 끊어졌다가 다시 연결됩니다,</font>

1623
00:35:17,880 --> 00:35:19,139
and you end up with one of the other guys

1624
00:35:17,880 --> 00:35:19,139
<font color="#ffff54">그리고 다른 남자 중 한 명과 만나게 된다.</font>

1625
00:35:19,139 --> 00:35:20,679
and they're all the same.

1626
00:35:19,139 --> 00:35:20,679
<font color="#ffff54">모두 똑같아.</font>

1627
00:35:20,679 --> 00:35:22,559
That's what microservices are all about.

1628
00:35:20,679 --> 00:35:22,559
<font color="#ffff54">이것이 바로 마이크로서비스의 핵심입니다.</font>

1629
00:35:22,559 --> 00:35:25,440
And so Kubernetes embraces this.

1630
00:35:22,559 --> 00:35:25,440
<font color="#ffff54">그래서 쿠버네티스는 이를 수용합니다.</font>

1631
00:35:25,440 --> 00:35:28,639
And so we can run a whole bunch of copies of our service

1632
00:35:25,440 --> 00:35:28,639
<font color="#ffff54">그래서 우리는 우리 서비스의 전체 사본을 실행할 수 있습니다.</font>

1633
00:35:28,679 --> 00:35:31,079
under a deployment in Kubernetes.

1634
00:35:28,679 --> 00:35:31,079
<font color="#ffff54">를 실행할 수 있습니다.</font>

1635
00:35:31,079 --> 00:35:34,079
And then to avoid customers

1636
00:35:31,079 --> 00:35:34,079
<font color="#ffff54">그리고 고객을 피하기 위해</font>

1637
00:35:34,079 --> 00:35:36,940
having to worry about the mayhem of pods scaling up and down

1638
00:35:34,079 --> 00:35:36,940
<font color="#ffff54">파드의 확장 및 축소로 인한 대혼란을 걱정해야 한다.</font>

1639
00:35:36,940 --> 00:35:38,839
and getting deleted because a node is overloaded

1640
00:35:36,940 --> 00:35:38,839
<font color="#ffff54">노드에 과부하가 걸려서 삭제될 수 있다.</font>

1641
00:35:38,839 --> 00:35:41,119
or whatever, we put a service in front of it.

1642
00:35:38,839 --> 00:35:41,119
<font color="#ffff54">또는 그 앞에 서비스를 넣습니다.</font>

1643
00:35:41,119 --> 00:35:44,679
And that service has a head, a cluster IP,

1644
00:35:41,119 --> 00:35:44,679
<font color="#ffff54">그리고 그 서비스에는 헤드, 즉 클러스터 IP가 있습니다,</font>

1645
00:35:44,679 --> 00:35:46,179
a virtual IP address.

1646
00:35:44,679 --> 00:35:46,179
<font color="#ffff54">가상 IP 주소가 있습니다.</font>

1647
00:35:46,179 --> 00:35:48,639
It's not associated with any interface.

1648
00:35:46,179 --> 00:35:48,639
<font color="#ffff54">어떤 인터페이스와도 연결되어 있지 않습니다.</font>

1649
00:35:48,639 --> 00:35:50,119
It's just an IP.

1650
00:35:48,639 --> 00:35:50,119
<font color="#ffff54">그냥 IP입니다.</font>

1651
00:35:50,119 --> 00:35:52,400
And when you try to connect to it,

1652
00:35:50,119 --> 00:35:52,400
<font color="#ffff54">그리고 접속을 시도하면,</font>

1653
00:35:52,400 --> 00:35:55,199
the Linux kernel has to figure out what to do

1654
00:35:52,400 --> 00:35:55,199
<font color="#ffff54">리눅스 커널은 무엇을 해야할지 알아내야 합니다.</font>

1655
00:35:55,199 --> 00:35:57,559
because that address isn't associated with anything.

1656
00:35:55,199 --> 00:35:57,559
<font color="#ffff54">해당 주소는 아무 것도 연결되어 있지 않기 때문입니다.</font>

1657
00:35:57,559 --> 00:35:59,079
There's nowhere to send the packets, right?

1658
00:35:57,559 --> 00:35:59,079
<font color="#ffff54">패킷을 보낼 곳이 없죠?</font>

1659
00:35:59,079 --> 00:36:04,079
And so Kubernetes implements the routing functionality,

1660
00:35:59,079 --> 00:36:04,079
<font color="#ffff54">그래서 쿠버네티스는 라우팅 기능을 구현한다,</font>

1661
00:36:04,219 --> 00:36:06,960
the forwarding functionality that makes that all work.

1662
00:36:04,219 --> 00:36:06,960
<font color="#ffff54">이 모든 것을 작동하게 하는 포워딩 기능을 구현한다.</font>

1663
00:36:06,960 --> 00:36:09,239
When you create a service, you get a cluster IP

1664
00:36:06,960 --> 00:36:09,239
<font color="#ffff54">서비스를 생성하면 클러스터 IP를 얻습니다.</font>

1665
00:36:09,239 --> 00:36:12,000
and you get the wiring that delivers your connection

1666
00:36:09,239 --> 00:36:12,000
<font color="#ffff54">그리고 연결을 제공하는 배선을 얻는다.</font>

1667
00:36:12,000 --> 00:36:13,880
to one of those backend pods.

1668
00:36:12,000 --> 00:36:13,880
<font color="#ffff54">백엔드 파드 중 하나에 연결됩니다.</font>

1669
00:36:13,880 --> 00:36:16,019
So how do we make that go?

1670
00:36:13,880 --> 00:36:16,019
<font color="#ffff54">어떻게 하면 될까요?</font>

1671
00:36:16,019 --> 00:36:18,559
Well, there's a thing called the kube-proxy.

1672
00:36:16,019 --> 00:36:18,559
<font color="#ffff54">큐브 프록시라는 것이 있습니다.</font>

1673
00:36:18,559 --> 00:36:21,279
It runs in a pod as a daemon set

1674
00:36:18,559 --> 00:36:21,279
<font color="#ffff54">이것은 파드에서 데몬 세트로 실행된다.</font>

1675
00:36:21,279 --> 00:36:22,880
on every node in the cluster.

1676
00:36:21,279 --> 00:36:22,880
<font color="#ffff54">클러스터의 모든 노드에서 실행된다.</font>

1677
00:36:22,880 --> 00:36:25,719
And it's doing that stuff.

1678
00:36:22,880 --> 00:36:25,719
<font color="#ffff54">그리고 그 일을 하고 있습니다.</font>

1679
00:36:25,720 --> 00:36:28,160
Its job is every time a service is created,

1680
00:36:25,720 --> 00:36:28,160
<font color="#ffff54">서비스가 생성될 때마다 그 일을 합니다,</font>

1681
00:36:28,160 --> 00:36:29,680
so it's watching the API server saying,

1682
00:36:28,160 --> 00:36:29,680
<font color="#ffff54">이므로 API 서버를 감시하고 있습니다,</font>

1683
00:36:29,680 --> 00:36:31,600
hey, tell me about any services.

1684
00:36:29,680 --> 00:36:31,600
<font color="#ffff54">어떤 서비스가 있는지 알려주세요.</font>

1685
00:36:31,600 --> 00:36:32,840
And when a service gets created,

1686
00:36:31,600 --> 00:36:32,840
<font color="#ffff54">그리고 서비스가 생성되면,</font>

1687
00:36:32,840 --> 00:36:34,640
it immediately goes and tells the Linux kernel

1688
00:36:32,840 --> 00:36:34,640
<font color="#ffff54">즉시 리눅스 커널에 알린다.</font>

1689
00:36:34,640 --> 00:36:36,560
do all this stuff, right?

1690
00:36:34,640 --> 00:36:36,560
<font color="#ffff54">이 모든 작업을 수행합니다.</font>

1691
00:36:36,560 --> 00:36:37,920
And now all of a sudden,

1692
00:36:36,560 --> 00:36:37,920
<font color="#ffff54">그리고 이제 갑자기,</font>

1693
00:36:37,920 --> 00:36:40,860
people can reach those pods through those services.

1694
00:36:37,920 --> 00:36:40,860
<font color="#ffff54">사람들이 해당 서비스를 통해 해당 파드에 도달할 수 있습니다.</font>

1695
00:36:40,860 --> 00:36:43,840
And when pods come and go,

1696
00:36:40,860 --> 00:36:43,840
<font color="#ffff54">그리고 파드가 왔다 갔다 할 때,</font>

1697
00:36:43,840 --> 00:36:46,120
the kube-proxy is watching that too.

1698
00:36:43,840 --> 00:36:46,120
<font color="#ffff54">큐브-프록시는 그것도 보고 있다.</font>

1699
00:36:46,120 --> 00:36:48,920
If a pod goes away, he takes that pod out of the mesh.

1700
00:36:46,120 --> 00:36:48,920
<font color="#ffff54">파드가 사라지면, 그 파드를 메시에서 제거한다.</font>

1701
00:36:48,920 --> 00:36:51,680
If a pod shows up and has the right label,

1702
00:36:48,920 --> 00:36:51,680
<font color="#ffff54">파드가 나타나고 올바른 레이블을 가진 경우,</font>

1703
00:36:51,680 --> 00:36:53,460
he adds that pod into the mesh.

1704
00:36:51,680 --> 00:36:53,460
<font color="#ffff54">해당 파드를 메시에 추가한다.</font>

1705
00:36:53,460 --> 00:36:55,699
So the kube-proxy is the magic.

1706
00:36:53,460 --> 00:36:55,699
<font color="#ffff54">큐브-프록시는 마법과도 같다.</font>

1707
00:36:55,699 --> 00:36:58,320
Now, how does the kube-proxy make this work?

1708
00:36:55,699 --> 00:36:58,320
<font color="#ffff54">이제, kube-proxy는 어떻게 작동할까요?</font>

1709
00:36:58,320 --> 00:37:01,659
Well, the slowest way is it can do user mode.

1710
00:36:58,320 --> 00:37:01,659
<font color="#ffff54">가장 느린 방법은 사용자 모드를 사용하는 것이다.</font>

1711
00:37:01,659 --> 00:37:03,940
But this is deprecated and, you know,

1712
00:37:01,659 --> 00:37:03,940
<font color="#ffff54">하지만 이것은 더 이상 사용되지 않습니다,</font>

1713
00:37:03,940 --> 00:37:06,079
this was used in the early beta days of Kubernetes

1714
00:37:03,940 --> 00:37:06,079
<font color="#ffff54">이것은 쿠버네티스 초기 베타 시절에 사용되었다.</font>

1715
00:37:06,079 --> 00:37:08,780
where the traffic would literally connect to the proxy

1716
00:37:06,079 --> 00:37:08,780
<font color="#ffff54">트래픽이 말 그대로 프록시에 연결되는 위치.</font>

1717
00:37:08,780 --> 00:37:10,260
and then the proxy would make the connection

1718
00:37:08,780 --> 00:37:10,260
<font color="#ffff54">그리고 나서 프록시가 연결합니다.</font>

1719
00:37:10,260 --> 00:37:11,139
outbound for you.

1720
00:37:10,260 --> 00:37:11,139
<font color="#ffff54">아웃바운드합니다.</font>

1721
00:37:11,139 --> 00:37:13,300
So that's no good because now you've got a user mode process

1722
00:37:11,139 --> 00:37:13,300
<font color="#ffff54">이제 사용자 모드 프로세스가 있으므로 좋지 않습니다.</font>

1723
00:37:13,300 --> 00:37:15,079
and your data path's gonna be slow.

1724
00:37:13,300 --> 00:37:15,079
<font color="#ffff54">데이터 경로가 느려질 테니까요.</font>

1725
00:37:15,079 --> 00:37:17,460
So the next thing we can do is use IP tables.

1726
00:37:15,079 --> 00:37:17,460
<font color="#ffff54">다음으로 할 수 있는 일은 IP 테이블을 사용하는 것입니다.</font>

1727
00:37:17,460 --> 00:37:18,800
We just tell the kernel, hey,

1728
00:37:17,460 --> 00:37:18,800
<font color="#ffff54">커널에 이렇게 말하면 됩니다,</font>

1729
00:37:18,800 --> 00:37:20,380
when somebody connects to this IP address,

1730
00:37:18,800 --> 00:37:20,380
<font color="#ffff54">라고 알려주면 됩니다,</font>

1731
00:37:20,380 --> 00:37:22,500
use a destination network address translation

1732
00:37:20,380 --> 00:37:22,500
<font color="#ffff54">대상 네트워크 주소 변환 사용</font>

1733
00:37:22,539 --> 00:37:24,980
to one of these pods.

1734
00:37:22,539 --> 00:37:24,980
<font color="#ffff54">이 파드 중 하나로.</font>

1735
00:37:24,980 --> 00:37:26,639
A lot of people don't know it,

1736
00:37:24,980 --> 00:37:26,639
<font color="#ffff54">많은 사람들이 모릅니다,</font>

1737
00:37:26,639 --> 00:37:30,940
but you can randomly select a rule in a chain of rules

1738
00:37:26,639 --> 00:37:30,940
<font color="#ffff54">하지만 규칙 체인에서 규칙을 임의로 선택할 수 있습니다.</font>

1739
00:37:30,940 --> 00:37:32,920
in IP tables and that's what's happening, right?

1740
00:37:30,940 --> 00:37:32,920
<font color="#ffff54">를 선택할 수 있습니다.</font>

1741
00:37:32,920 --> 00:37:35,300
So if there's 20 services back there,

1742
00:37:32,920 --> 00:37:35,300
<font color="#ffff54">뒤에 20개의 서비스가 있다면,</font>

1743
00:37:35,300 --> 00:37:37,340
it's just gonna randomly select one of them

1744
00:37:35,300 --> 00:37:37,340
<font color="#ffff54">그 중 하나를 무작위로 선택합니다.</font>

1745
00:37:37,340 --> 00:37:38,840
and then send you to that guy.

1746
00:37:37,340 --> 00:37:38,840
<font color="#ffff54">그 남자에게 널 보낼 거야</font>

1747
00:37:38,840 --> 00:37:40,500
So it's load balancing, right?

1748
00:37:38,840 --> 00:37:40,500
<font color="#ffff54">로드 밸런싱이 되는 거죠?</font>

1749
00:37:40,500 --> 00:37:42,820
It's random, but it's load balancing.

1750
00:37:40,500 --> 00:37:42,820
<font color="#ffff54">무작위이긴 하지만 로드 밸런싱을 하는 거죠.</font>

1751
00:37:42,820 --> 00:37:45,500
And if pods are coming and going like crazy

1752
00:37:42,820 --> 00:37:45,500
<font color="#ffff54">그리고 파드가 미친 듯이 왔다 갔다 한다면</font>

1753
00:37:45,500 --> 00:37:47,659
and one of the pods gets overloaded,

1754
00:37:45,500 --> 00:37:47,659
<font color="#ffff54">그리고 파드 중 하나에 과부하가 걸린다,</font>

1755
00:37:47,659 --> 00:37:49,380
that pod's likely to be evicted

1756
00:37:47,659 --> 00:37:49,380
<font color="#ffff54">해당 파드가 퇴거될 가능성이 있다.</font>

1757
00:37:49,380 --> 00:37:50,900
and all those connections are gonna break

1758
00:37:49,380 --> 00:37:50,900
<font color="#ffff54">모든 연결이 끊어질 거야</font>

1759
00:37:50,900 --> 00:37:53,000
and they're gonna redistribute immediately

1760
00:37:50,900 --> 00:37:53,000
<font color="#ffff54">즉시 재분배됩니다.</font>

1761
00:37:53,000 --> 00:37:55,139
because the clients are gonna reconnect.

1762
00:37:53,000 --> 00:37:55,139
<font color="#ffff54">클라이언트가 다시 연결할 것이기 때문입니다.</font>

1763
00:37:55,139 --> 00:37:56,440
If you're talking to a microservice,

1764
00:37:55,139 --> 00:37:56,440
<font color="#ffff54">마이크로서비스와 대화하는 경우,</font>

1765
00:37:56,440 --> 00:37:59,539
you should expect it to be ephemeral, right?

1766
00:37:56,440 --> 00:37:59,539
<font color="#ffff54">일시적일 거라고 예상해야 하죠?</font>

1767
00:37:59,539 --> 00:38:01,780
Note to people writing client code,

1768
00:37:59,539 --> 00:38:01,780
<font color="#ffff54">클라이언트 코드를 작성하는 사람들에게 참고하세요,</font>

1769
00:38:01,780 --> 00:38:03,700
expect that connection to break.

1770
00:38:01,780 --> 00:38:03,700
<font color="#ffff54">연결이 끊어질 것을 예상하세요.</font>

1771
00:38:03,700 --> 00:38:05,180
Don't be surprised by it.

1772
00:38:03,700 --> 00:38:05,180
<font color="#ffff54">놀라지 마세요.</font>

1773
00:38:05,180 --> 00:38:07,300
When it does, you just reconnect

1774
00:38:05,180 --> 00:38:07,300
<font color="#ffff54">다시 연결하면 됩니다.</font>

1775
00:38:07,300 --> 00:38:09,200
and you're gonna get distributed to somebody else.

1776
00:38:07,300 --> 00:38:09,200
<font color="#ffff54">다른 사람에게 배포됩니다.</font>

1777
00:38:09,200 --> 00:38:12,119
So the entropy of the cluster naturally distributes the load

1778
00:38:09,200 --> 00:38:12,119
<font color="#ffff54">따라서 클러스터의 엔트로피는 자연스럽게 부하를 분산시킵니다.</font>

1779
00:38:12,119 --> 00:38:12,960
pretty darn well.

1780
00:38:12,119 --> 00:38:12,960
<font color="#ffff54">꽤나 잘 됩니다.</font>

1781
00:38:12,960 --> 00:38:13,780
A lot of people are like,

1782
00:38:12,960 --> 00:38:13,780
<font color="#ffff54">많은 사람들이 좋아합니다,</font>

1783
00:38:13,780 --> 00:38:17,500
let's use some sophisticated global rate limit,

1784
00:38:13,780 --> 00:38:17,500
<font color="#ffff54">좀 더 정교한 글로벌 속도 제한을 사용해 봅시다,</font>

1785
00:38:17,500 --> 00:38:18,340
blah, blah, blah.

1786
00:38:17,500 --> 00:38:18,340
<font color="#ffff54">어쩌고저쩌고.</font>

1787
00:38:18,340 --> 00:38:20,119
And at the end of the day, try it.

1788
00:38:18,340 --> 00:38:20,119
<font color="#ffff54">그리고 하루가 끝나면 해보세요.</font>

1789
00:38:20,119 --> 00:38:21,440
Try the simple stuff first.

1790
00:38:20,119 --> 00:38:21,440
<font color="#ffff54">간단한 것부터 해보세요.</font>

1791
00:38:21,440 --> 00:38:23,480
It's often fastest, right?

1792
00:38:21,440 --> 00:38:23,480
<font color="#ffff54">그게 가장 빠를 때가 많죠?</font>

1793
00:38:23,480 --> 00:38:25,960
But if that doesn't work for you, there's other options.

1794
00:38:23,480 --> 00:38:25,960
<font color="#ffff54">하지만 그래도 안 된다면 다른 방법이 있습니다.</font>

1795
00:38:25,960 --> 00:38:29,239
Now, one thing that probably is an upgrade is IPVS.

1796
00:38:25,960 --> 00:38:29,239
<font color="#ffff54">업그레이드할 수 있는 한 가지 방법은 IPVS입니다.</font>

1797
00:38:29,239 --> 00:38:31,639
So the kernel has also another mechanism,

1798
00:38:29,239 --> 00:38:31,639
<font color="#ffff54">커널에는 또 다른 메커니즘이 있습니다,</font>

1799
00:38:31,639 --> 00:38:33,239
IP virtual services,

1800
00:38:31,639 --> 00:38:33,239
<font color="#ffff54">IP 가상 서비스,</font>

1801
00:38:33,239 --> 00:38:38,119
and it's a little bit, a teeny bit faster than IP tables

1802
00:38:33,239 --> 00:38:38,119
<font color="#ffff54">IP 테이블보다 약간, 아주 약간 빠릅니다.</font>

1803
00:38:38,119 --> 00:38:40,920
in some situations and a lot faster in some others

1804
00:38:38,119 --> 00:38:40,920
<font color="#ffff54">어떤 상황에서는 더 빠르고 어떤 상황에서는 훨씬 빠릅니다.</font>

1805
00:38:40,920 --> 00:38:42,779
because it uses a lot less resources.

1806
00:38:40,920 --> 00:38:42,779
<font color="#ffff54">훨씬 적은 리소스를 사용하기 때문입니다.</font>

1807
00:38:42,779 --> 00:38:44,079
That's the main thing.

1808
00:38:42,779 --> 00:38:44,079
<font color="#ffff54">그게 중요한 거죠.</font>

1809
00:38:44,079 --> 00:38:46,980
IP tables were never meant to be distributing traffic.

1810
00:38:44,079 --> 00:38:46,980
<font color="#ffff54">IP 테이블은 트래픽을 분산시키려는 의도가 아니었습니다.</font>

1811
00:38:46,980 --> 00:38:48,859
So IPVS is probably the better option.

1812
00:38:46,980 --> 00:38:48,859
<font color="#ffff54">따라서 IPVS가 더 나은 옵션일 것입니다.</font>

1813
00:38:48,860 --> 00:38:51,940
You can tell kube-proxy which of these modes you wanna use,

1814
00:38:48,860 --> 00:38:51,940
<font color="#ffff54">이 모드 중 어떤 모드를 사용할지 kube-proxy에게 알려주면 된다,</font>

1815
00:38:51,940 --> 00:38:54,140
and the default is IP tables.

1816
00:38:51,940 --> 00:38:54,140
<font color="#ffff54">기본값은 IP 테이블이다.</font>

1817
00:38:54,140 --> 00:38:55,980
So that's the one that we're using in our lab

1818
00:38:54,140 --> 00:38:55,980
<font color="#ffff54">이것이 저희 연구실에서 사용하는 주소입니다.</font>

1819
00:38:55,980 --> 00:38:58,740
because we didn't tell it to do anything else, right?

1820
00:38:55,980 --> 00:38:58,740
<font color="#ffff54">우리가 다른 걸 시키지 않았으니까요, 그렇죠?</font>

1821
00:38:58,740 --> 00:39:02,740
There are also CNI plugins that have fancy features too

1822
00:38:58,740 --> 00:39:02,740
<font color="#ffff54">멋진 기능을 가진 CNI 플러그인도 있습니다.</font>

1823
00:39:02,740 --> 00:39:05,099
because EVPF, hey, programming the kernel

1824
00:39:02,740 --> 00:39:05,099
<font color="#ffff54">왜냐하면 EVPF는 커널을 프로그래밍하기 때문이다.</font>

1825
00:39:05,099 --> 00:39:06,180
sounds like that would be a way

1826
00:39:05,099 --> 00:39:06,180
<font color="#ffff54">그게 방법인 것 같네요</font>

1827
00:39:06,180 --> 00:39:08,019
to handle these services too, right?

1828
00:39:06,180 --> 00:39:08,019
<font color="#ffff54">이런 서비스도 처리할 수 있겠죠?</font>

1829
00:39:08,019 --> 00:39:10,640
Well, it is, and it has some benefits.

1830
00:39:08,019 --> 00:39:10,640
<font color="#ffff54">네, 그리고 몇 가지 장점이 있습니다.</font>

1831
00:39:10,640 --> 00:39:12,680
So some of the plugins let you do that.

1832
00:39:10,640 --> 00:39:12,680
<font color="#ffff54">그래서 몇몇 플러그인은 그렇게 할 수 있게 해줍니다.</font>

1833
00:39:12,680 --> 00:39:16,260
You could replace the kube-proxy with Cilium

1834
00:39:12,680 --> 00:39:16,260
<font color="#ffff54">큐브-프록시를 실리움으로 대체할 수 있다.</font>

1835
00:39:16,260 --> 00:39:19,260
if you wanted to and let it do all that stuff.

1836
00:39:16,260 --> 00:39:19,260
<font color="#ffff54">로 대체할 수 있다.</font>

1837
00:39:19,260 --> 00:39:22,140
We didn't tell it to do that again, so it didn't,

1838
00:39:19,260 --> 00:39:22,140
<font color="#ffff54">다시 하라고 하지 않았기 때문에 그렇게 하지 않았어요,</font>

1839
00:39:22,140 --> 00:39:24,620
but that's an option that's on the table.

1840
00:39:22,140 --> 00:39:24,620
<font color="#ffff54">하지만 그것은 테이블 위에 있는 옵션입니다.</font>

1841
00:39:24,620 --> 00:39:27,260
Now remember that all of the hosts

1842
00:39:24,620 --> 00:39:27,260
<font color="#ffff54">이제 모든 호스트가</font>

1843
00:39:27,260 --> 00:39:30,420
in your cloud, virtual private cloud, right,

1844
00:39:27,260 --> 00:39:30,420
<font color="#ffff54">클라우드, 가상 사설 클라우드에 있습니다,</font>

1845
00:39:30,420 --> 00:39:31,500
have to have unique addresses

1846
00:39:30,420 --> 00:39:31,500
<font color="#ffff54">고유한 주소가 있어야 합니다.</font>

1847
00:39:31,500 --> 00:39:32,500
if they're gonna talk to each other.

1848
00:39:31,500 --> 00:39:32,500
<font color="#ffff54">서로 대화하려면 말이죠.</font>

1849
00:39:32,500 --> 00:39:34,180
So all your Kubernetes cluster nodes

1850
00:39:32,500 --> 00:39:34,180
<font color="#ffff54">따라서 모든 쿠버네티스 클러스터 노드는</font>

1851
00:39:34,180 --> 00:39:35,720
have to have unique addresses.

1852
00:39:34,180 --> 00:39:35,720
<font color="#ffff54">는 고유한 주소를 가져야 한다.</font>

1853
00:39:35,720 --> 00:39:38,820
And then all of the pods that run in them

1854
00:39:35,720 --> 00:39:38,820
<font color="#ffff54">그리고 그 안에서 실행되는 모든 파드들은</font>

1855
00:39:38,820 --> 00:39:40,420
have to have unique addresses.

1856
00:39:38,820 --> 00:39:40,420
<font color="#ffff54">고유한 주소를 가져야 한다.</font>

1857
00:39:40,420 --> 00:39:42,200
And since you need to be able to get to the pods

1858
00:39:40,420 --> 00:39:42,200
<font color="#ffff54">그리고 파드에 도달할 수 있어야 하므로</font>

1859
00:39:42,200 --> 00:39:44,280
from the host in order to do things

1860
00:39:42,200 --> 00:39:44,280
<font color="#ffff54">작업을 수행하려면 호스트에서</font>

1861
00:39:44,280 --> 00:39:45,940
like check their health and stuff,

1862
00:39:44,280 --> 00:39:45,940
<font color="#ffff54">건강 체크 같은 거요,</font>

1863
00:39:46,460 --> 00:39:48,900
those addresses have to be unique, right, non-overlapping.

1864
00:39:46,460 --> 00:39:48,900
<font color="#ffff54">이 주소들은 고유하고, 맞고, 겹치지 않아야 합니다.</font>

1865
00:39:48,900 --> 00:39:51,440
And then the last thing is the service IPs

1866
00:39:48,900 --> 00:39:51,440
<font color="#ffff54">그리고 마지막은 서비스 IP입니다.</font>

1867
00:39:51,440 --> 00:39:53,559
need to be unique and non-overlapping.

1868
00:39:51,440 --> 00:39:53,559
<font color="#ffff54">는 고유하고 겹치지 않아야 합니다.</font>

1869
00:39:53,559 --> 00:39:55,619
So we have three address spaces we gotta think about

1870
00:39:53,559 --> 00:39:55,619
<font color="#ffff54">따라서 고려해야 할 세 가지 주소 공간이 있습니다.</font>

1871
00:39:55,619 --> 00:39:56,700
when we're setting up Kubernetes.

1872
00:39:55,619 --> 00:39:56,700
<font color="#ffff54">쿠버네티스를 설정할 때.</font>

1873
00:39:56,700 --> 00:39:59,500
This is part of the architecting a cluster process, right?

1874
00:39:56,700 --> 00:39:59,500
<font color="#ffff54">이것은 클러스터를 설계하는 과정의 일부죠?</font>

1875
00:39:59,500 --> 00:40:01,139
What are the address ranges we're gonna use

1876
00:39:59,500 --> 00:40:01,139
<font color="#ffff54">사용할 주소 범위는 무엇인가요?</font>

1877
00:40:01,139 --> 00:40:03,019
for these things?

1878
00:40:01,139 --> 00:40:03,019
<font color="#ffff54">이런 것들은?</font>

1879
00:40:03,019 --> 00:40:04,380
And another interesting thing

1880
00:40:03,019 --> 00:40:04,380
<font color="#ffff54">그리고 또 다른 흥미로운 것</font>

1881
00:40:04,380 --> 00:40:06,740
is the support for IPv4 and IPv6.

1882
00:40:04,380 --> 00:40:06,740
<font color="#ffff54">는 IPv4와 IPv6를 지원한다는 점입니다.</font>

1883
00:40:06,740 --> 00:40:10,179
We're doing everything in IPv4 for no reason.

1884
00:40:06,740 --> 00:40:10,179
<font color="#ffff54">이유 없이 모든 것을 IPv4로 하고 있습니다.</font>

1885
00:40:10,179 --> 00:40:12,099
It's just what happens by default, right?

1886
00:40:10,179 --> 00:40:12,099
<font color="#ffff54">원래 이렇게 되는 거잖아요?</font>

1887
00:40:12,099 --> 00:40:14,039
This is the way things work by default.

1888
00:40:12,099 --> 00:40:14,039
<font color="#ffff54">이게 기본적으로 작동하는 방식입니다.</font>

1889
00:40:14,039 --> 00:40:15,019
But out there on the internet,

1890
00:40:14,039 --> 00:40:15,019
<font color="#ffff54">하지만 인터넷에서는,</font>

1891
00:40:15,059 --> 00:40:17,179
IPv6 continues to gain steam.

1892
00:40:15,059 --> 00:40:17,179
<font color="#ffff54">IPv6는 계속해서 힘을 얻고 있습니다.</font>

1893
00:40:17,179 --> 00:40:18,980
A lot of companies, especially telcos,

1894
00:40:17,179 --> 00:40:18,980
<font color="#ffff54">많은 기업, 특히 통신사들,</font>

1895
00:40:18,980 --> 00:40:20,539
are IPv6 internally everywhere.

1896
00:40:18,980 --> 00:40:20,539
<font color="#ffff54">내부적으로 모든 곳에서 IPv6를 사용합니다.</font>

1897
00:40:20,539 --> 00:40:24,179
And so there's a good momentum towards IPv6.

1898
00:40:20,539 --> 00:40:24,179
<font color="#ffff54">따라서 IPv6를 향한 좋은 모멘텀이 있습니다.</font>

1899
00:40:24,179 --> 00:40:26,820
In Kubernetes 1.0, it was IPv4.

1900
00:40:24,179 --> 00:40:26,820
<font color="#ffff54">쿠버네티스 1.0에서는 IPv4였다.</font>

1901
00:40:26,820 --> 00:40:28,340
That was the end of the story.

1902
00:40:26,820 --> 00:40:28,340
<font color="#ffff54">이것이 이야기의 끝이었다.</font>

1903
00:40:28,340 --> 00:40:33,340
Next, IPv6 only went GA in 1.18, right?

1904
00:40:28,340 --> 00:40:33,340
<font color="#ffff54">다음으로, IPv6는 1.18에서야 정식 버전으로 전환되었죠?</font>

1905
00:40:34,179 --> 00:40:36,139
That was a long time later.

1906
00:40:34,179 --> 00:40:36,139
<font color="#ffff54">그건 한참 후의 일이었죠.</font>

1907
00:40:36,139 --> 00:40:38,780
And you had one or the other, right?

1908
00:40:36,139 --> 00:40:38,780
<font color="#ffff54">둘 중 하나는 가지고 있었죠?</font>

1909
00:40:38,780 --> 00:40:39,599
Not both.

1910
00:40:38,780 --> 00:40:39,599
<font color="#ffff54">둘 다 아니야.</font>

1911
00:40:39,599 --> 00:40:40,579
You could pick one, right?

1912
00:40:39,599 --> 00:40:40,579
<font color="#ffff54">하나만 고르면 되죠?</font>

1913
00:40:40,579 --> 00:40:43,699
And this is as far as what Kubernetes is responsible for.

1914
00:40:40,579 --> 00:40:43,699
<font color="#ffff54">쿠버네티스가 담당하는 것은 여기까지다.</font>

1915
00:40:43,700 --> 00:40:45,580
So the cluster IPs, right?

1916
00:40:43,700 --> 00:40:45,580
<font color="#ffff54">클러스터 IP 맞죠?</font>

1917
00:40:45,580 --> 00:40:47,940
If you had a CNI plugin that knew how to do IPv6,

1918
00:40:45,580 --> 00:40:47,940
<font color="#ffff54">IPv6를 수행하는 방법을 알고 있는 CNI 플러그인이 있다면,</font>

1919
00:40:47,940 --> 00:40:49,180
well, knock yourself out.

1920
00:40:47,940 --> 00:40:49,180
<font color="#ffff54">뭐, 마음껏 해보세요.</font>

1921
00:40:49,180 --> 00:40:50,000
That's fine.

1922
00:40:49,180 --> 00:40:50,000
<font color="#ffff54">괜찮아.</font>

1923
00:40:50,000 --> 00:40:53,260
But the services are always gonna be IPv4 or IPv6

1924
00:40:50,000 --> 00:40:53,260
<font color="#ffff54">하지만 서비스는 항상 IPv4 또는 IPv6입니다.</font>

1925
00:40:53,260 --> 00:40:56,740
until 1.20,

1926
00:40:53,260 --> 00:40:56,740
<font color="#ffff54">1.20까지</font>

1927
00:40:56,740 --> 00:41:01,180
where we got either IPv4 or IPv6 in the same cluster, right?

1928
00:40:56,740 --> 00:41:01,180
<font color="#ffff54">같은 클러스터에서 IPv4 또는 IPv6를 사용하는 경우 맞죠?</font>

1929
00:41:01,180 --> 00:41:02,000
Now you could pick.

1930
00:41:01,180 --> 00:41:02,000
<font color="#ffff54">이제 선택할 수 있습니다.</font>

1931
00:41:02,000 --> 00:41:03,580
You could have an IPv4 service over here

1932
00:41:02,000 --> 00:41:03,580
<font color="#ffff54">여기에 IPv4 서비스가 있을 수 있습니다.</font>

1933
00:41:03,580 --> 00:41:05,380
and an IPv6 over here.

1934
00:41:03,580 --> 00:41:05,380
<font color="#ffff54">그리고 여기는 IPv6.</font>

1935
00:41:05,380 --> 00:41:06,400
Pretty cool.

1936
00:41:05,380 --> 00:41:06,400
<font color="#ffff54">꽤 멋지네요.</font>

1937
00:41:06,400 --> 00:41:09,100
But you still couldn't have a dual stack service, right?

1938
00:41:06,400 --> 00:41:09,100
<font color="#ffff54">하지만 여전히 듀얼 스택 서비스를 할 수는 없죠?</font>

1939
00:41:09,100 --> 00:41:10,220
That was out of bounds.

1940
00:41:09,100 --> 00:41:10,220
<font color="#ffff54">그건 한계를 벗어났어요.</font>

1941
00:41:10,220 --> 00:41:12,620
Until, da-na, one, two, three.

1942
00:41:10,220 --> 00:41:12,620
<font color="#ffff54">다-나, 하나, 둘, 셋까지.</font>

1943
00:41:12,619 --> 00:41:14,299
Three weeks ago or whatever it was,

1944
00:41:12,619 --> 00:41:14,299
<font color="#ffff54">3주 전인지 뭔지 모르겠지만,</font>

1945
00:41:14,299 --> 00:41:17,420
we now have GA, IPv4, IPv6 dual stack.

1946
00:41:14,299 --> 00:41:17,420
<font color="#ffff54">이제 GA, IPv4, IPv6 듀얼 스택이 생겼습니다.</font>

1947
00:41:17,420 --> 00:41:22,420
So you can pick on a cluster to make a service single stack.

1948
00:41:17,420 --> 00:41:22,420
<font color="#ffff54">이제 클러스터를 선택해서 서비스 싱글 스택을 만들 수 있습니다.</font>

1949
00:41:23,059 --> 00:41:24,900
You can make it prefer dual stack.

1950
00:41:23,059 --> 00:41:24,900
<font color="#ffff54">듀얼 스택을 선호하도록 만들 수 있습니다.</font>

1951
00:41:24,900 --> 00:41:27,460
And then you can require dual stack.

1952
00:41:24,900 --> 00:41:27,460
<font color="#ffff54">그리고 듀얼 스택을 요구할 수 있습니다.</font>

1953
00:41:27,460 --> 00:41:31,339
And that means that the users got to have both, right?

1954
00:41:27,460 --> 00:41:31,339
<font color="#ffff54">사용자가 두 가지를 모두 가지고 있어야 한다는 뜻이죠?</font>

1955
00:41:31,339 --> 00:41:35,579
So those are pretty cool features.

1956
00:41:31,339 --> 00:41:35,579
<font color="#ffff54">꽤 멋진 기능들이네요.</font>

1957
00:41:35,579 --> 00:41:37,920
The Kubernetes project is really stunning,

1958
00:41:35,579 --> 00:41:37,920
<font color="#ffff54">쿠버네티스 프로젝트는 정말 놀랍습니다,</font>

1959
00:41:37,920 --> 00:41:40,480
how fast it moves and how much tech is in it

1960
00:41:37,920 --> 00:41:40,480
<font color="#ffff54">얼마나 빠르게 움직이고 얼마나 많은 기술이 들어있는지</font>

1961
00:41:40,480 --> 00:41:42,099
when you look at all the different places

1962
00:41:40,480 --> 00:41:42,099
<font color="#ffff54">모든 다른 장소를 볼 때</font>

1963
00:41:42,539 --> 00:41:43,460
and how advanced it is.

1964
00:41:42,539 --> 00:41:43,460
<font color="#ffff54">그리고 그것이 얼마나 발전했는지.</font>

1965
00:41:43,460 --> 00:41:45,019
So some things are a long time coming.

1966
00:41:43,460 --> 00:41:45,019
<font color="#ffff54">그래서 어떤 것들은 오래 걸립니다.</font>

1967
00:41:45,019 --> 00:41:47,460
That maybe was, but hey, it's here now.

1968
00:41:45,019 --> 00:41:47,460
<font color="#ffff54">그랬을지도 모르지만 지금은 여기 있잖아.</font>

1969
00:41:47,460 --> 00:41:49,599
Services, how do we create one?

1970
00:41:47,460 --> 00:41:49,599
<font color="#ffff54">서비스, 어떻게 만들 수 있나요?</font>

1971
00:41:49,599 --> 00:41:51,940
Well, in Kubernetes, you pretty much create everything

1972
00:41:49,599 --> 00:41:51,940
<font color="#ffff54">쿠버네티스에서는 거의 모든 것을 생성할 수 있다.</font>

1973
00:41:51,940 --> 00:41:56,339
by specifying it and giving the specification to Kubernetes.

1974
00:41:51,940 --> 00:41:56,339
<font color="#ffff54">지정하고 쿠버네티스에 사양을 제공함으로써.</font>

1975
00:41:56,339 --> 00:41:58,139
And then Kubernetes just spends the rest of its life

1976
00:41:56,339 --> 00:41:58,139
<font color="#ffff54">그리고 쿠버네티스는 남은 수명을 보낸다.</font>

1977
00:41:58,139 --> 00:42:00,339
trying to make the status of the cluster

1978
00:41:58,139 --> 00:42:00,339
<font color="#ffff54">클러스터의 상태를 확인하려고 한다.</font>

1979
00:42:00,339 --> 00:42:03,139
the same as your specifications.

1980
00:42:00,339 --> 00:42:03,139
<font color="#ffff54">사양과 동일하게 만들려고 합니다.</font>

1981
00:42:03,139 --> 00:42:05,039
That's what Kubernetes does.

1982
00:42:03,139 --> 00:42:05,039
<font color="#ffff54">이것이 쿠버네티스가 하는 일이다.</font>

1983
00:42:05,039 --> 00:42:07,259
It makes the status of the cluster

1984
00:42:05,039 --> 00:42:07,259
<font color="#ffff54">클러스터의 상태를 만든다.</font>

1985
00:42:07,259 --> 00:42:08,940
the same as your specifications.

1986
00:42:07,259 --> 00:42:08,940
<font color="#ffff54">으로 변경합니다.</font>

1987
00:42:08,940 --> 00:42:11,639
That way, you don't have to constantly get up

1988
00:42:08,940 --> 00:42:11,639
<font color="#ffff54">이렇게 하면 계속 일어날 필요가 없습니다.</font>

1989
00:42:12,199 --> 00:42:13,019
in the middle of the night and say,

1990
00:42:12,199 --> 00:42:13,019
<font color="#ffff54">한밤중에 일어나서</font>

1991
00:42:13,019 --> 00:42:14,359
oh, that pod stopped, let me restart it.

1992
00:42:13,019 --> 00:42:14,359
<font color="#ffff54">아, 그 포드가 멈췄어요. 다시 시작하겠습니다.</font>

1993
00:42:14,359 --> 00:42:16,480
No, you said I want a pod running,

1994
00:42:14,359 --> 00:42:16,480
<font color="#ffff54">아니, 파드를 실행하라고 했잖아,</font>

1995
00:42:16,480 --> 00:42:19,000
and if it stops, Kubernetes restarts it.

1996
00:42:16,480 --> 00:42:19,000
<font color="#ffff54">그리고 멈추면 쿠버네티스가 다시 시작한다.</font>

1997
00:42:19,000 --> 00:42:22,079
Self-healing, all these types of automate the toil,

1998
00:42:19,000 --> 00:42:22,079
<font color="#ffff54">자가 치유, 이 모든 유형의 수고를 자동화합니다,</font>

1999
00:42:22,079 --> 00:42:23,079
SRE stuff.

2000
00:42:22,079 --> 00:42:23,079
<font color="#ffff54">SRE 물건들.</font>

2001
00:42:23,079 --> 00:42:24,719
So this is a service.

2002
00:42:23,079 --> 00:42:24,719
<font color="#ffff54">이것은 서비스입니다.</font>

2003
00:42:24,719 --> 00:42:25,639
It's a very simple one.

2004
00:42:24,719 --> 00:42:25,639
<font color="#ffff54">아주 간단한 서비스입니다.</font>

2005
00:42:25,639 --> 00:42:27,119
It has a name, web.

2006
00:42:25,639 --> 00:42:27,119
<font color="#ffff54">웹이라는 이름이 있습니다.</font>

2007
00:42:27,119 --> 00:42:29,039
It has a port, 80.

2008
00:42:27,119 --> 00:42:29,039
<font color="#ffff54">포트가 80입니다.</font>

2009
00:42:29,039 --> 00:42:30,319
The port has a name, too.

2010
00:42:29,039 --> 00:42:30,319
<font color="#ffff54">포트에 이름도 있습니다.</font>

2011
00:42:30,319 --> 00:42:32,099
And in case you have multiple ports,

2012
00:42:30,319 --> 00:42:32,099
<font color="#ffff54">포트가 여러 개인 경우</font>

2013
00:42:32,099 --> 00:42:34,000
you can use SRV records and DNS

2014
00:42:32,099 --> 00:42:34,000
<font color="#ffff54">SRV 레코드와 DNS를 사용할 수 있습니다.</font>

2015
00:42:34,000 --> 00:42:36,199
to discover which ones are which and stuff.

2016
00:42:34,000 --> 00:42:36,199
<font color="#ffff54">를 사용하여 어떤 것이 어떤 것인지 알아낼 수 있습니다.</font>

2017
00:42:36,199 --> 00:42:38,039
And then we have a selector that says,

2018
00:42:36,199 --> 00:42:38,039
<font color="#ffff54">그리고 다음과 같은 선택기가 있습니다,</font>

2019
00:42:38,039 --> 00:42:43,039
hey, any pod that has the label key app value web

2020
00:42:38,039 --> 00:42:43,039
<font color="#ffff54">이봐, 레이블 키 앱 값 웹이 있는 모든 파드는</font>

2021
00:42:44,480 --> 00:42:46,719
gets this traffic.

2022
00:42:44,480 --> 00:42:46,719
<font color="#ffff54">이 트래픽을 받는다.</font>

2023
00:42:46,719 --> 00:42:47,699
So if there's 100 of them,

2024
00:42:46,719 --> 00:42:47,699
<font color="#ffff54">만약 100개라면</font>

2025
00:42:47,699 --> 00:42:50,559
you'll have 100 of those pods getting connections

2026
00:42:47,699 --> 00:42:50,559
<font color="#ffff54">100개의 파드가 연결을 받게 된다.</font>

2027
00:42:50,559 --> 00:42:51,820
when this service is hit.

2028
00:42:50,559 --> 00:42:51,820
<font color="#ffff54">이 서비스가 히트될 때.</font>

2029
00:42:51,820 --> 00:42:54,179
If there's one of them, then that one will get it.

2030
00:42:51,820 --> 00:42:54,179
<font color="#ffff54">둘 중 하나가 있으면 그 하나가 가져갑니다.</font>

2031
00:42:54,179 --> 00:42:57,679
If there's none, then you can't connect.

2032
00:42:54,179 --> 00:42:57,679
<font color="#ffff54">아무도 없으면 연결할 수 없습니다.</font>

2033
00:42:57,679 --> 00:42:59,900
There's no such thing as a virtual IP.

2034
00:42:57,679 --> 00:42:59,900
<font color="#ffff54">가상 IP 같은 것은 없습니다.</font>

2035
00:42:59,900 --> 00:43:00,840
It's a virtual.

2036
00:42:59,900 --> 00:43:00,840
<font color="#ffff54">가상이에요.</font>

2037
00:43:00,840 --> 00:43:03,099
It's just rules in a table or something like that.

2038
00:43:00,840 --> 00:43:03,099
<font color="#ffff54">그냥 테이블에 있는 규칙 같은 거야.</font>

2039
00:43:03,099 --> 00:43:04,279
So if there aren't any pods,

2040
00:43:03,099 --> 00:43:04,279
<font color="#ffff54">그래서 만약 파드가 없다면,</font>

2041
00:43:04,279 --> 00:43:06,400
you're not gonna go any further.

2042
00:43:04,279 --> 00:43:06,400
<font color="#ffff54">더 이상 진행하지 않습니다.</font>

2043
00:43:06,440 --> 00:43:08,519
So that's the idea behind a service.

2044
00:43:06,440 --> 00:43:08,519
<font color="#ffff54">이것이 바로 서비스의 개념입니다.</font>

2045
00:43:08,519 --> 00:43:12,480
Now, all of the pods that match that selector

2046
00:43:08,519 --> 00:43:12,480
<font color="#ffff54">이제, 해당 셀렉터와 일치하는 모든 파드들은</font>

2047
00:43:12,480 --> 00:43:15,000
create something called an endpoint.

2048
00:43:12,480 --> 00:43:15,000
<font color="#ffff54">엔드포인트라는 것을 생성한다.</font>

2049
00:43:15,000 --> 00:43:19,480
The service could push all the pod information

2050
00:43:15,000 --> 00:43:19,480
<font color="#ffff54">서비스가 모든 파드 정보를 푸시할 수 있다.</font>

2051
00:43:19,480 --> 00:43:22,440
that match the service down to all the queue proxies.

2052
00:43:19,480 --> 00:43:22,440
<font color="#ffff54">모든 큐 프록시로 푸시할 수 있다.</font>

2053
00:43:22,440 --> 00:43:23,480
But that'd be very expensive

2054
00:43:22,440 --> 00:43:23,480
<font color="#ffff54">하지만 비용이 많이 듭니다.</font>

2055
00:43:23,480 --> 00:43:24,420
because you can have clusters

2056
00:43:23,480 --> 00:43:24,420
<font color="#ffff54">클러스터를 가질 수 있기 때문입니다.</font>

2057
00:43:24,420 --> 00:43:26,800
with thousands and thousands of pods.

2058
00:43:24,420 --> 00:43:26,800
<font color="#ffff54">수천, 수만 개의 파드를 가질 수 있기 때문입니다.</font>

2059
00:43:26,800 --> 00:43:30,039
And so what's better is to just create a little thing

2060
00:43:26,800 --> 00:43:30,039
<font color="#ffff54">그래서 더 좋은 것은 그냥 작은 것을 만드는 것이다.</font>

2061
00:43:30,039 --> 00:43:32,920
that has the IP address, and that's about it,

2062
00:43:30,039 --> 00:43:32,920
<font color="#ffff54">를 생성하는 것입니다,</font>

2063
00:43:32,920 --> 00:43:36,280
an endpoint that identifies the targets that you want

2064
00:43:32,920 --> 00:43:36,280
<font color="#ffff54">원하는 대상을 식별하는 엔드포인트입니다.</font>

2065
00:43:37,120 --> 00:43:38,440
and then you send those down to the queue proxy.

2066
00:43:37,120 --> 00:43:38,440
<font color="#ffff54">그런 다음 이를 큐 프록시로 보냅니다.</font>

2067
00:43:38,440 --> 00:43:41,660
So earlier I said, hey, the queue proxy's watching the pods.

2068
00:43:38,440 --> 00:43:41,660
<font color="#ffff54">앞서 큐 프록시가 파드를 보고 있다고 말씀드렸습니다.</font>

2069
00:43:41,660 --> 00:43:44,060
It's actually looking for endpoints, right?

2070
00:43:41,660 --> 00:43:44,060
<font color="#ffff54">실제로 엔드포인트를 찾고 있는 거죠?</font>

2071
00:43:44,060 --> 00:43:47,120
And so the service controller is creating the endpoints

2072
00:43:44,060 --> 00:43:47,120
<font color="#ffff54">그래서 서비스 컨트롤러가 엔드포인트를 생성하고 있습니다.</font>

2073
00:43:47,120 --> 00:43:49,160
and then the queue proxy is getting those.

2074
00:43:47,120 --> 00:43:49,160
<font color="#ffff54">그리고 큐 프록시가 이를 받습니다.</font>

2075
00:43:49,160 --> 00:43:51,640
So an endpoint looks like this up here.

2076
00:43:49,160 --> 00:43:51,640
<font color="#ffff54">여기서 엔드포인트는 다음과 같이 보입니다.</font>

2077
00:43:52,680 --> 00:43:55,880
What happens if you create a service that has no selector?

2078
00:43:52,680 --> 00:43:55,880
<font color="#ffff54">선택기가 없는 서비스를 만들면 어떻게 될까요?</font>

2079
00:43:57,040 --> 00:44:01,000
That service will never ever identify any pods

2080
00:43:57,040 --> 00:44:01,000
<font color="#ffff54">이 서비스는 어떤 파드도 식별하지 못한다.</font>

2081
00:44:01,000 --> 00:44:02,460
to send traffic to.

2082
00:44:01,000 --> 00:44:02,460
<font color="#ffff54">트래픽을 보낼 수 있다.</font>

2083
00:44:02,460 --> 00:44:04,200
So you're gonna have to do it.

2084
00:44:02,460 --> 00:44:04,200
<font color="#ffff54">그러니 당신이 해야 합니다.</font>

2085
00:44:04,200 --> 00:44:05,860
And this is something that you might do

2086
00:44:04,200 --> 00:44:05,860
<font color="#ffff54">그리고 이것은 당신이 할 수 있는 일입니다.</font>

2087
00:44:06,400 --> 00:44:09,300
in a scenario where those pods aren't pods.

2088
00:44:06,400 --> 00:44:09,300
<font color="#ffff54">해당 파드가 파드가 아닌 시나리오에서.</font>

2089
00:44:09,300 --> 00:44:11,900
What if you have 16 VMs?

2090
00:44:09,300 --> 00:44:11,900
<font color="#ffff54">VM이 16개라면?</font>

2091
00:44:11,900 --> 00:44:14,440
And every once in a while, some of them shut down

2092
00:44:11,900 --> 00:44:14,440
<font color="#ffff54">그리고 가끔씩 그 중 일부가 종료됩니다.</font>

2093
00:44:14,440 --> 00:44:16,160
and some new ones stand up.

2094
00:44:14,440 --> 00:44:16,160
<font color="#ffff54">그리고 새로운 것들이 일어납니다.</font>

2095
00:44:16,160 --> 00:44:19,700
You could create your own glue to create these endpoints.

2096
00:44:16,160 --> 00:44:19,700
<font color="#ffff54">이러한 엔드포인트를 만들기 위해 자신만의 글루를 만들 수 있습니다.</font>

2097
00:44:19,700 --> 00:44:23,539
And because the endpoint is named website,

2098
00:44:19,700 --> 00:44:23,539
<font color="#ffff54">그리고 엔드포인트의 이름이 웹사이트이기 때문에,</font>

2099
00:44:23,539 --> 00:44:26,079
we know it's a sub-resource of the service website.

2100
00:44:23,539 --> 00:44:26,079
<font color="#ffff54">서비스 웹사이트의 하위 리소스임을 알 수 있습니다.</font>

2101
00:44:26,079 --> 00:44:28,380
And then it's got an address and the ports,

2102
00:44:26,079 --> 00:44:28,380
<font color="#ffff54">그리고 주소와 포트가 있습니다,</font>

2103
00:44:28,380 --> 00:44:31,980
just like we had before defined on the service side.

2104
00:44:28,380 --> 00:44:31,980
<font color="#ffff54">앞서 서비스 측에서 정의한 것과 같습니다.</font>

2105
00:44:31,980 --> 00:44:33,920
And then next thing you know,

2106
00:44:31,980 --> 00:44:33,920
<font color="#ffff54">그리고 그 다음에는</font>

2107
00:44:33,920 --> 00:44:35,740
you look at the endpoints for your service

2108
00:44:33,920 --> 00:44:35,740
<font color="#ffff54">서비스의 엔드포인트를 확인합니다.</font>

2109
00:44:36,560 --> 00:44:38,300
and this guy shows up if you apply that endpoint.

2110
00:44:36,560 --> 00:44:38,300
<font color="#ffff54">해당 엔드포인트를 적용하면 이 녀석이 나타납니다.</font>

2111
00:44:38,300 --> 00:44:39,420
So you can create your own endpoints.

2112
00:44:38,300 --> 00:44:39,420
<font color="#ffff54">따라서 여러분만의 엔드포인트를 만들 수 있습니다.</font>

2113
00:44:39,420 --> 00:44:42,260
You can have them produced dynamically by Kubernetes.

2114
00:44:39,420 --> 00:44:42,260
<font color="#ffff54">쿠버네티스가 동적으로 생성하도록 할 수 있다.</font>

2115
00:44:42,260 --> 00:44:45,060
So in general, if you're routing the pods,

2116
00:44:42,260 --> 00:44:45,060
<font color="#ffff54">따라서 일반적으로 파드를 라우팅하는 경우,</font>

2117
00:44:45,060 --> 00:44:47,020
you would want them dynamically created.

2118
00:44:45,060 --> 00:44:47,020
<font color="#ffff54">동적으로 생성되기를 원할 것이다.</font>

2119
00:44:47,020 --> 00:44:49,340
Now, what kinds of services do we have to work with?

2120
00:44:47,020 --> 00:44:49,340
<font color="#ffff54">이제 어떤 종류의 서비스와 함께 작업해야 할까요?</font>

2121
00:44:49,340 --> 00:44:50,860
There's a bunch.

2122
00:44:49,340 --> 00:44:50,860
<font color="#ffff54">많아요.</font>

2123
00:44:50,860 --> 00:44:52,680
The first kind is a headless service.

2124
00:44:50,860 --> 00:44:52,680
<font color="#ffff54">첫 번째 종류는 헤드리스 서비스입니다.</font>

2125
00:44:52,680 --> 00:44:56,600
A headless service has no cluster IP.

2126
00:44:52,680 --> 00:44:56,600
<font color="#ffff54">헤드리스 서비스에는 클러스터 IP가 없습니다.</font>

2127
00:44:56,600 --> 00:44:58,820
You literally say cluster IP none.

2128
00:44:56,600 --> 00:44:58,820
<font color="#ffff54">말 그대로 클러스터 IP가 없습니다.</font>

2129
00:44:58,820 --> 00:45:01,620
It actually turns out it's a cluster IP type of service

2130
00:44:58,820 --> 00:45:01,620
<font color="#ffff54">실제로는 클러스터 IP 유형의 서비스인 것으로 밝혀졌습니다.</font>

2131
00:45:01,620 --> 00:45:03,240
with no cluster IP.

2132
00:45:01,620 --> 00:45:03,240
<font color="#ffff54">클러스터 IP가 없습니다.</font>

2133
00:45:03,240 --> 00:45:05,580
I don't know how that works, but anyway.

2134
00:45:03,240 --> 00:45:05,580
<font color="#ffff54">어떻게 작동하는지 모르겠지만 어쨌든.</font>

2135
00:45:06,420 --> 00:45:07,699
You define a headless service by creating

2136
00:45:06,420 --> 00:45:07,699
<font color="#ffff54">헤드리스 서비스를 정의하려면</font>

2137
00:45:07,699 --> 00:45:10,299
a cluster IP service with no cluster IP.

2138
00:45:07,699 --> 00:45:10,299
<font color="#ffff54">클러스터 IP가 없는 클러스터 IP 서비스.</font>

2139
00:45:10,299 --> 00:45:11,860
What is that good for?

2140
00:45:10,299 --> 00:45:11,860
<font color="#ffff54">이게 무슨 의미일까요?</font>

2141
00:45:11,860 --> 00:45:16,199
It's good for situations where the pods aren't the same.

2142
00:45:11,860 --> 00:45:16,199
<font color="#ffff54">포드가 동일하지 않은 상황에 유용합니다.</font>

2143
00:45:17,119 --> 00:45:19,900
What if one of your pods is a Kafka pod

2144
00:45:17,119 --> 00:45:19,900
<font color="#ffff54">파드 중 하나가 카프카 파드라면?</font>

2145
00:45:19,900 --> 00:45:22,900
and it has the topic NASDAQ?

2146
00:45:19,900 --> 00:45:22,900
<font color="#ffff54">토픽이 NASDAQ이고?</font>

2147
00:45:22,900 --> 00:45:27,219
And what if the other of your pods is a Kafka pod

2148
00:45:22,900 --> 00:45:27,219
<font color="#ffff54">다른 파드가 카프카 파드라면 어떨까?</font>

2149
00:45:27,219 --> 00:45:30,519
and it has on it the topic New York Stock Exchange?

2150
00:45:27,219 --> 00:45:30,519
<font color="#ffff54">뉴욕 증권 거래소라는 주제를 가지고 있다면?</font>

2151
00:45:30,519 --> 00:45:34,559
And another pod has life and so on, right?

2152
00:45:30,519 --> 00:45:34,559
<font color="#ffff54">그리고 다른 포드에는 생명 등이 있죠?</font>

2153
00:45:34,559 --> 00:45:37,759
Well, you can't connect to the life pod

2154
00:45:34,559 --> 00:45:37,759
<font color="#ffff54">생명체 포드에 연결할 수 없습니다.</font>

2155
00:45:37,759 --> 00:45:39,960
if you want to get the New York Stock Exchange data.

2156
00:45:37,759 --> 00:45:39,960
<font color="#ffff54">뉴욕 증권 거래소 데이터를 얻고 싶다면.</font>

2157
00:45:39,960 --> 00:45:42,119
They have identity, these pods.

2158
00:45:39,960 --> 00:45:42,119
<font color="#ffff54">이 포드들은 정체성이 있어요.</font>

2159
00:45:42,119 --> 00:45:44,759
They're not microservices.

2160
00:45:42,119 --> 00:45:44,759
<font color="#ffff54">마이크로서비스가 아니다.</font>

2161
00:45:44,759 --> 00:45:45,960
So anytime you have a situation

2162
00:45:44,759 --> 00:45:45,960
<font color="#ffff54">따라서 어떤 상황이 발생하면</font>

2163
00:45:45,960 --> 00:45:47,539
where they're not microservices,

2164
00:45:45,960 --> 00:45:47,539
<font color="#ffff54">마이크로서비스가 아닌 경우,</font>

2165
00:45:47,539 --> 00:45:50,079
but you want DNS resolution and stuff like that,

2166
00:45:47,539 --> 00:45:50,079
<font color="#ffff54">하지만 DNS 확인과 같은 것을 원합니다,</font>

2167
00:45:50,079 --> 00:45:51,960
this is the kind of service you want.

2168
00:45:50,079 --> 00:45:51,960
<font color="#ffff54">이런 종류의 서비스를 원합니다.</font>

2169
00:45:51,960 --> 00:45:53,699
Next, cluster IP.

2170
00:45:51,960 --> 00:45:53,699
<font color="#ffff54">다음은 클러스터 IP입니다.</font>

2171
00:45:53,699 --> 00:45:56,239
Cluster IP is for microservices, right?

2172
00:45:53,699 --> 00:45:56,239
<font color="#ffff54">클러스터 IP는 마이크로서비스용이죠?</font>

2173
00:45:56,239 --> 00:45:57,599
Where it just sends the traffic.

2174
00:45:56,239 --> 00:45:57,599
<font color="#ffff54">트래픽을 보내는 곳입니다.</font>

2175
00:45:57,599 --> 00:46:00,079
That's the first example we looked at.

2176
00:45:57,599 --> 00:46:00,079
<font color="#ffff54">이것이 우리가 살펴본 첫 번째 예제입니다.</font>

2177
00:46:00,079 --> 00:46:03,759
Node port is another one where if packets are coming in

2178
00:46:00,079 --> 00:46:03,759
<font color="#ffff54">노드 포트는 패킷이 들어올 경우</font>

2179
00:46:03,800 --> 00:46:05,120
from the outside world

2180
00:46:03,800 --> 00:46:05,120
<font color="#ffff54">외부 세계로부터</font>

2181
00:46:05,120 --> 00:46:07,520
and we want them to be delivered to our service,

2182
00:46:05,120 --> 00:46:07,520
<font color="#ffff54">우리 서비스로 전달되기를 원합니다,</font>

2183
00:46:07,520 --> 00:46:09,960
we can use a port on every node,

2184
00:46:07,520 --> 00:46:09,960
<font color="#ffff54">모든 노드에서 포트를 사용할 수 있습니다,</font>

2185
00:46:09,960 --> 00:46:12,160
on every host in the cluster

2186
00:46:09,960 --> 00:46:12,160
<font color="#ffff54">클러스터의 모든 호스트에서</font>

2187
00:46:12,160 --> 00:46:15,080
and have that port forward to our service.

2188
00:46:12,160 --> 00:46:15,080
<font color="#ffff54">해당 포트를 우리 서비스로 전달합니다.</font>

2189
00:46:15,080 --> 00:46:19,120
So that port is reserved for us in the entire cluster.

2190
00:46:15,080 --> 00:46:19,120
<font color="#ffff54">따라서 해당 포트는 전체 클러스터에서 우리를 위해 예약됩니다.</font>

2191
00:46:19,120 --> 00:46:21,960
So obviously the control plane needs to know

2192
00:46:19,120 --> 00:46:21,960
<font color="#ffff54">따라서 당연히 컨트롤 플레인은 다음을 알아야 합니다.</font>

2193
00:46:21,960 --> 00:46:23,680
what port range you want to use

2194
00:46:21,960 --> 00:46:23,680
<font color="#ffff54">어떤 포트 범위를 사용할지</font>

2195
00:46:23,680 --> 00:46:25,000
and it needs to be in control

2196
00:46:23,680 --> 00:46:25,000
<font color="#ffff54">그리고 제어해야 합니다.</font>

2197
00:46:25,000 --> 00:46:26,840
of which ports are handed out and so on.

2198
00:46:25,000 --> 00:46:26,840
<font color="#ffff54">어떤 포트가 분배되는지 등등.</font>

2199
00:46:26,840 --> 00:46:29,120
So we'll look at node port a little bit more later.

2200
00:46:26,840 --> 00:46:29,120
<font color="#ffff54">노드 포트는 나중에 조금 더 살펴보겠습니다.</font>

2201
00:46:29,120 --> 00:46:31,360
Load balancer is like node port,

2202
00:46:29,120 --> 00:46:31,360
<font color="#ffff54">로드밸런서는 노드 포트와 같습니다,</font>

2203
00:46:31,400 --> 00:46:34,840
except it also stands up an external load balancer.

2204
00:46:31,400 --> 00:46:34,840
<font color="#ffff54">외부 로드밸런서를 세운다는 점만 다릅니다.</font>

2205
00:46:34,840 --> 00:46:36,420
This requires a plugin, right?

2206
00:46:34,840 --> 00:46:36,420
<font color="#ffff54">이거 플러그인이 필요한 거죠?</font>

2207
00:46:36,420 --> 00:46:38,079
We have to have some sort of external thing

2208
00:46:36,420 --> 00:46:38,079
<font color="#ffff54">뭔가 외부적인 것이 있어야 합니다.</font>

2209
00:46:38,079 --> 00:46:40,599
like an Azure load balancer

2210
00:46:38,079 --> 00:46:40,599
<font color="#ffff54">Azure 로드 밸런서 같은 것</font>

2211
00:46:40,599 --> 00:46:42,640
or a Google Cloud network load balancer

2212
00:46:40,599 --> 00:46:42,640
<font color="#ffff54">또는 구글 클라우드 네트워크 로드 밸런서</font>

2213
00:46:42,640 --> 00:46:44,460
or something to interact with

2214
00:46:42,640 --> 00:46:44,460
<font color="#ffff54">또는 상호 작용할 무언가</font>

2215
00:46:44,460 --> 00:46:46,960
or a Metal LB as we were looking at earlier.

2216
00:46:44,460 --> 00:46:46,960
<font color="#ffff54">또는 앞서 살펴본 메탈 LB입니다.</font>

2217
00:46:46,960 --> 00:46:49,340
And then lastly, we have external name.

2218
00:46:46,960 --> 00:46:49,340
<font color="#ffff54">마지막으로 외부 이름이 있습니다.</font>

2219
00:46:49,340 --> 00:46:52,120
This is for scenarios where you have a service name

2220
00:46:49,340 --> 00:46:52,120
<font color="#ffff54">이것은 서비스 이름이 있는 시나리오를 위한 것입니다.</font>

2221
00:46:52,120 --> 00:46:54,720
that you want to be resolvable inside your cluster.

2222
00:46:52,120 --> 00:46:54,720
<font color="#ffff54">클러스터 내에서 확인할 수 있는 서비스 이름이 있는 경우입니다.</font>

2223
00:46:54,720 --> 00:46:56,880
We're gonna look at DNS more in the next module,

2224
00:46:54,720 --> 00:46:56,880
<font color="#ffff54">다음 모듈에서 DNS에 대해 자세히 살펴보겠습니다,</font>

2225
00:46:56,880 --> 00:47:00,680
but you actually want it to look for some name

2226
00:46:56,880 --> 00:47:00,680
<font color="#ffff54">하지만 실제로는 어떤 이름을 찾기를 원합니다.</font>

2227
00:47:00,839 --> 00:47:02,039
that's outside your cluster, right?

2228
00:47:00,839 --> 00:47:02,039
<font color="#ffff54">클러스터 밖에 있는 거 맞죠?</font>

2229
00:47:02,039 --> 00:47:03,519
So you're gonna make a name mapping

2230
00:47:02,039 --> 00:47:03,519
<font color="#ffff54">그래서 네임 매핑을 만들 거야.</font>

2231
00:47:03,519 --> 00:47:05,359
and you can do that with external name.

2232
00:47:03,519 --> 00:47:05,359
<font color="#ffff54">외부 이름을 사용하면 됩니다.</font>

2233
00:47:05,359 --> 00:47:07,319
All right, so lab step two.

2234
00:47:05,359 --> 00:47:07,319
<font color="#ffff54">자, 실험실 2단계입니다.</font>

2235
00:47:07,319 --> 00:47:08,839
We're going to create a deployment,

2236
00:47:07,319 --> 00:47:08,839
<font color="#ffff54">배포를 생성하겠습니다,</font>

2237
00:47:08,839 --> 00:47:10,279
which is gonna have several pods.

2238
00:47:08,839 --> 00:47:10,279
<font color="#ffff54">여러 개의 파드가 있을 것이다.</font>

2239
00:47:10,279 --> 00:47:12,679
We're gonna create a cluster IP service.

2240
00:47:10,279 --> 00:47:12,679
<font color="#ffff54">클러스터 IP 서비스를 생성한다.</font>

2241
00:47:12,679 --> 00:47:13,919
We're gonna connect to the service,

2242
00:47:12,679 --> 00:47:13,919
<font color="#ffff54">서비스에 연결하겠습니다,</font>

2243
00:47:13,919 --> 00:47:16,239
see the traffic, reach the deployment and come back.

2244
00:47:13,919 --> 00:47:16,239
<font color="#ffff54">트래픽을 확인하고 배포에 도달한 후 다시 돌아옵니다.</font>

2245
00:47:16,239 --> 00:47:18,519
And then we're gonna figure out how it works.

2246
00:47:16,239 --> 00:47:18,519
<font color="#ffff54">그리고 나서 어떻게 작동하는지 알아볼 겁니다.</font>

2247
00:47:18,519 --> 00:47:21,199
We're gonna get under the covers, look at the IP tables,

2248
00:47:18,519 --> 00:47:21,199
<font color="#ffff54">이불 속으로 들어가서 IP 테이블을 살펴볼게요,</font>

2249
00:47:21,199 --> 00:47:23,759
poke around a little bit and see how things are happening.

2250
00:47:21,199 --> 00:47:23,759
<font color="#ffff54">좀 더 들여다보고 상황을 살펴볼게요.</font>

2251
00:47:23,759 --> 00:47:28,759
Okay, so we are looking at 1147.

2252
00:47:23,759 --> 00:47:28,759
<font color="#ffff54">자, 1147을 보고 있습니다.</font>

2253
00:47:28,760 --> 00:47:31,160
1147, how is that possible?

2254
00:47:28,760 --> 00:47:31,160
<font color="#ffff54">1147, 이게 어떻게 가능하지?</font>

2255
00:47:31,160 --> 00:47:35,560
Okay, let's give everybody say eight minutes.

2256
00:47:31,160 --> 00:47:35,560
<font color="#ffff54">자, 모두에게 8분을 주자.</font>

2257
00:47:35,560 --> 00:47:37,600
We'll come back at 55 minutes after.

2258
00:47:35,560 --> 00:47:37,600
<font color="#ffff54">55분 후에 다시 오겠습니다.</font>

2259
00:47:39,480 --> 00:47:41,440
Nothing to install in this session, so.

2260
00:47:39,480 --> 00:47:41,440
<font color="#ffff54">이 세션에는 설치할 것이 없습니다.</font>

2261
00:47:42,700 --> 00:47:44,480
But there is a lot of stuff to look at.

2262
00:47:42,700 --> 00:47:44,480
<font color="#ffff54">하지만 볼 것이 많습니다.</font>

2263
00:47:44,480 --> 00:47:47,920
So 1155 and we will be coming back.

2264
00:47:44,480 --> 00:47:47,920
<font color="#ffff54">1155, 다시 돌아올게요.</font>

2265
00:47:50,800 --> 00:47:54,440
Okay, so I'm gonna go ahead and do this second step

2266
00:47:50,800 --> 00:47:54,440
<font color="#ffff54">자, 이제 두 번째 단계를 수행하겠습니다.</font>

2267
00:47:54,440 --> 00:47:56,280
for people virtual, just so you can get an idea

2268
00:47:54,440 --> 00:47:56,280
<font color="#ffff54">가상의 사람들을 위해, 그냥 아이디어를 얻을 수 있도록.</font>

2269
00:47:56,280 --> 00:47:58,960
of what's happening here and I'll talk through it.

2270
00:47:56,280 --> 00:47:58,960
<font color="#ffff54">여기서 무슨 일이 일어나고 있는지 설명해줄게요.</font>

2271
00:47:58,960 --> 00:48:00,519
But for the people locally, you can just ignore me

2272
00:47:58,960 --> 00:48:00,519
<font color="#ffff54">하지만 현지 사람들은 그냥 무시해도 돼요.</font>

2273
00:48:00,519 --> 00:48:02,000
and work on the lab yourself.

2274
00:48:00,519 --> 00:48:02,000
<font color="#ffff54">직접 실험실에서 일해.</font>

2275
00:48:02,880 --> 00:48:05,800
So first thing we're gonna do is we need some pods

2276
00:48:02,880 --> 00:48:05,800
<font color="#ffff54">가장 먼저 할 일은 포드 몇 개가 필요해요.</font>

2277
00:48:05,800 --> 00:48:07,519
to connect to, so we're gonna create a deployment

2278
00:48:05,800 --> 00:48:07,519
<font color="#ffff54">연결할 파드가 필요하므로, 디플로이먼트를 생성한다.</font>

2279
00:48:07,519 --> 00:48:09,840
with three replicas and it's just gonna run

2280
00:48:07,519 --> 00:48:09,840
<font color="#ffff54">세 개의 복제본과 함께 실행합니다.</font>

2281
00:48:09,840 --> 00:48:11,519
the Apache web server.

2282
00:48:09,840 --> 00:48:11,519
<font color="#ffff54">아파치 웹 서버를 실행합니다.</font>

2283
00:48:11,519 --> 00:48:13,080
So we do that.

2284
00:48:11,519 --> 00:48:13,080
<font color="#ffff54">그렇게 합니다.</font>

2285
00:48:13,080 --> 00:48:13,920
Okay, cool.

2286
00:48:13,080 --> 00:48:13,920
<font color="#ffff54">좋아, 멋지네.</font>

2287
00:48:17,920 --> 00:48:19,240
I can type.

2288
00:48:17,920 --> 00:48:19,240
<font color="#ffff54">타이핑할 수 있어요.</font>

2289
00:48:19,240 --> 00:48:21,360
All right, good, we got our three pods up and running.

2290
00:48:19,240 --> 00:48:21,360
<font color="#ffff54">좋아, 세 개의 포드가 작동합니다.</font>

2291
00:48:21,360 --> 00:48:26,360
Now we're going to go ahead and show the labels

2292
00:48:21,360 --> 00:48:26,360
<font color="#ffff54">이제 레이블을 표시해 보겠습니다.</font>

2293
00:48:27,000 --> 00:48:28,160
on these pods.

2294
00:48:27,000 --> 00:48:28,160
<font color="#ffff54">이 포드에.</font>

2295
00:48:31,960 --> 00:48:36,280
And when you create a deployment using that imperative

2296
00:48:31,960 --> 00:48:36,280
<font color="#ffff54">그리고 이 임퍼러티를 사용하여 디플로이먼트를 생성할 때</font>

2297
00:48:36,280 --> 00:48:38,519
technique, which is that's just quick and dirty, right?

2298
00:48:36,280 --> 00:48:38,519
<font color="#ffff54">기법을 사용하면 빠르고 더럽지 않나요?</font>

2299
00:48:38,519 --> 00:48:40,880
Normally you'd create a manifest, but when you use

2300
00:48:38,519 --> 00:48:40,880
<font color="#ffff54">보통은 매니페스트를 생성하지만, 다음과 같은 경우</font>

2301
00:48:40,880 --> 00:48:44,800
that technique, you're gonna get a label, key, app

2302
00:48:40,880 --> 00:48:44,800
<font color="#ffff54">이 기법을 사용하면 레이블, 키, 앱을 얻게 됩니다.</font>

2303
00:48:44,800 --> 00:48:47,000
and a value, which is the name of the deployment.

2304
00:48:44,800 --> 00:48:47,000
<font color="#ffff54">그리고 배포의 이름인 값을 얻게 됩니다.</font>

2305
00:48:47,000 --> 00:48:48,500
So I can predict that, right?

2306
00:48:47,000 --> 00:48:48,500
<font color="#ffff54">이제 예측할 수 있겠죠?</font>

2307
00:48:48,500 --> 00:48:50,160
I know I'm gonna have this app website label.

2308
00:48:48,500 --> 00:48:50,160
<font color="#ffff54">이 앱 웹사이트 라벨이 붙을 거라는 걸 알아요.</font>

2309
00:48:50,159 --> 00:48:51,719
I don't know what the name of the pod's gonna be

2310
00:48:50,159 --> 00:48:51,719
<font color="#ffff54">포드 이름이 어떻게 될지 모르겠어요.</font>

2311
00:48:51,719 --> 00:48:52,639
because they're ephemeral.

2312
00:48:51,719 --> 00:48:52,639
<font color="#ffff54">임시적이니까.</font>

2313
00:48:52,639 --> 00:48:55,359
They come and go and they're identity lists, right?

2314
00:48:52,639 --> 00:48:55,359
<font color="#ffff54">그것들은 왔다가 사라지는 신원 목록이잖아요, 그렇죠?</font>

2315
00:48:55,359 --> 00:48:57,839
I shouldn't care about the name, but I know that they're

2316
00:48:55,359 --> 00:48:57,839
<font color="#ffff54">이름은 신경 안 써도 되지만, 난 그들이</font>

2317
00:48:57,839 --> 00:49:01,159
part of this website package.

2318
00:48:57,839 --> 00:49:01,159
<font color="#ffff54">이 웹사이트 패키지의 일부입니다.</font>

2319
00:49:01,159 --> 00:49:03,119
All right, so the next thing I wanna do is I wanna create

2320
00:49:01,159 --> 00:49:03,119
<font color="#ffff54">좋아, 이제 다음으로 할 일은</font>

2321
00:49:03,119 --> 00:49:05,799
a cluster IP service and we're gonna do this.

2322
00:49:03,119 --> 00:49:05,799
<font color="#ffff54">클러스터 IP 서비스를 만들어서 이렇게 하겠습니다.</font>

2323
00:49:07,679 --> 00:49:09,960
This is basically the exact same service we just looked at

2324
00:49:07,679 --> 00:49:09,960
<font color="#ffff54">이것은 기본적으로 방금 살펴본 것과 똑같은 서비스입니다.</font>

2325
00:49:09,960 --> 00:49:10,960
in the slides.

2326
00:49:09,960 --> 00:49:10,960
<font color="#ffff54">슬라이드에서.</font>

2327
00:49:17,079 --> 00:49:19,000
All right, drop that in there.

2328
00:49:17,079 --> 00:49:19,000
<font color="#ffff54">좋아, 저기 넣어</font>

2329
00:49:20,159 --> 00:49:21,000
All right.

2330
00:49:20,159 --> 00:49:21,000
<font color="#ffff54">됐어</font>

2331
00:49:31,480 --> 00:49:34,199
kubectl get all, doesn't get everything, but it gets most

2332
00:49:31,480 --> 00:49:34,199
<font color="#ffff54">모든 것을 얻지는 못하지만 대부분을 얻는다.</font>

2333
00:49:34,199 --> 00:49:35,079
of the stuff you care about.

2334
00:49:34,199 --> 00:49:35,079
<font color="#ffff54">관심 있는 것들만 가져온다.</font>

2335
00:49:35,079 --> 00:49:36,519
So I got my three pods.

2336
00:49:35,079 --> 00:49:36,519
<font color="#ffff54">포드 세 개를 가져왔어요.</font>

2337
00:49:36,519 --> 00:49:38,839
I have the replica set under the deployment.

2338
00:49:36,519 --> 00:49:38,839
<font color="#ffff54">디플로이먼트 아래에 레플리카 세트가 있다.</font>

2339
00:49:38,839 --> 00:49:41,079
So the deployment created the replica set for me.

2340
00:49:38,839 --> 00:49:41,079
<font color="#ffff54">그래서 배포가 저를 위해 복제본 세트를 만들었습니다.</font>

2341
00:49:41,079 --> 00:49:44,879
And then I've got my service website and it has a cluster IP

2342
00:49:41,079 --> 00:49:44,879
<font color="#ffff54">그리고 내 서비스 웹사이트에 클러스터 IP가 있습니다.</font>

2343
00:49:44,879 --> 00:49:47,659
so that was handed to me by Kubernetes.

2344
00:49:44,879 --> 00:49:47,659
<font color="#ffff54">그래서 쿠버네티스가 저에게 전달한 것입니다.</font>

2345
00:49:47,659 --> 00:49:49,759
Kubernetes decides what that's gonna be

2346
00:49:47,659 --> 00:49:49,759
<font color="#ffff54">쿠버네티스가 그 결과를 결정한다.</font>

2347
00:49:50,320 --> 00:49:51,920
because Kubernetes has the service controller

2348
00:49:50,320 --> 00:49:51,920
<font color="#ffff54">쿠버네티스는 서비스 컨트롤러를 가지고 있기 때문이다.</font>

2349
00:49:51,920 --> 00:49:56,060
and it also knows what the range of addresses

2350
00:49:51,920 --> 00:49:56,060
<font color="#ffff54">그리고 주소의 범위가 무엇인지도 알고 있다.</font>

2351
00:49:56,060 --> 00:49:57,360
that you wanna use are.

2352
00:49:56,060 --> 00:49:57,360
<font color="#ffff54">가 무엇인지도 알고 있습니다.</font>

2353
00:49:57,360 --> 00:50:00,400
Now, if we had used kubeadm with the config file

2354
00:49:57,360 --> 00:50:00,400
<font color="#ffff54">이제, 만약 우리가 구성 파일과 함께 kubeadm을 사용했다면</font>

2355
00:50:00,400 --> 00:50:02,480
or given it the right command line parameters,

2356
00:50:00,400 --> 00:50:02,480
<font color="#ffff54">또는 올바른 커맨드 라인 파라미터를 제공했다면,</font>

2357
00:50:02,480 --> 00:50:05,480
we get to change that to use something else if we wanted to.

2358
00:50:02,480 --> 00:50:05,480
<font color="#ffff54">원한다면 다른 것을 사용하도록 변경할 수 있습니다.</font>

2359
00:50:05,480 --> 00:50:09,580
All right, so I'm gonna curl that and it works,

2360
00:50:05,480 --> 00:50:09,580
<font color="#ffff54">좋아, 이제 컬을 넣으면 작동합니다,</font>

2361
00:50:09,580 --> 00:50:13,120
but I have no idea which pod I hit and I don't care.

2362
00:50:09,580 --> 00:50:13,120
<font color="#ffff54">하지만 어느 포드를 쳤는지도 모르겠고 신경도 안 써요.</font>

2363
00:50:13,120 --> 00:50:13,940
They're all the same.

2364
00:50:13,120 --> 00:50:13,940
<font color="#ffff54">다 똑같아요.</font>

2365
00:50:13,940 --> 00:50:15,120
They're replicas.

2366
00:50:13,940 --> 00:50:15,120
<font color="#ffff54">복제품입니다.</font>

2367
00:50:15,120 --> 00:50:15,960
That's the point.

2368
00:50:15,120 --> 00:50:15,960
<font color="#ffff54">그게 요점입니다.</font>

2369
00:50:17,160 --> 00:50:19,420
All right, so there's some other good stuff in here.

2370
00:50:17,160 --> 00:50:19,420
<font color="#ffff54">좋아, 여기 다른 좋은 것들이 있어.</font>

2371
00:50:19,940 --> 00:50:22,300
And then the next thing that we're gonna do

2372
00:50:19,940 --> 00:50:22,300
<font color="#ffff54">그리고 다음에 우리가 할 일은</font>

2373
00:50:22,300 --> 00:50:27,300
is we're gonna look for the range that Kubernetes is using.

2374
00:50:22,300 --> 00:50:27,300
<font color="#ffff54">쿠버네티스가 사용하는 범위를 찾을 것입니다.</font>

2375
00:50:28,059 --> 00:50:30,300
So this is that service controller IP range, right?

2376
00:50:28,059 --> 00:50:30,300
<font color="#ffff54">이게 서비스 컨트롤러의 IP 범위 맞죠?</font>

2377
00:50:30,300 --> 00:50:34,460
That's where the IP addresses are coming from

2378
00:50:30,300 --> 00:50:34,460
<font color="#ffff54">이것이 IP 주소가 오는 곳입니다.</font>

2379
00:50:34,460 --> 00:50:35,300
for these services.

2380
00:50:34,460 --> 00:50:35,300
<font color="#ffff54">이 서비스를 위해.</font>

2381
00:50:35,300 --> 00:50:38,059
So it's a 1096 stroke 12 is what the default is.

2382
00:50:35,300 --> 00:50:38,059
<font color="#ffff54">따라서 1096 스트로크 12가 기본값입니다.</font>

2383
00:50:38,059 --> 00:50:39,059
You could change it.

2384
00:50:38,059 --> 00:50:39,059
<font color="#ffff54">변경할 수 있습니다.</font>

2385
00:50:39,920 --> 00:50:42,680
Okay, a little bit more poking around

2386
00:50:39,920 --> 00:50:42,680
<font color="#ffff54">좋아, 조금만 더 들여다보자.</font>

2387
00:50:42,680 --> 00:50:44,119
and now we're gonna look at some endpoints.

2388
00:50:42,680 --> 00:50:44,119
<font color="#ffff54">이제 몇 가지 엔드포인트를 살펴보겠습니다.</font>

2389
00:50:44,119 --> 00:50:46,820
So let's take a look at the endpoints for the website.

2390
00:50:44,119 --> 00:50:46,820
<font color="#ffff54">이제 웹사이트의 엔드포인트를 살펴봅시다.</font>

2391
00:50:47,820 --> 00:50:50,780
And we can see there's three of them, right?

2392
00:50:47,820 --> 00:50:50,780
<font color="#ffff54">세 개의 엔드포인트가 있는 것을 볼 수 있죠?</font>

2393
00:50:50,780 --> 00:50:54,980
1015, 10154 and 1054.

2394
00:50:50,780 --> 00:50:54,980
<font color="#ffff54">1015, 10154, 1054.</font>

2395
00:50:54,980 --> 00:50:57,059
And remember, they're always gonna have the same

2396
00:50:54,980 --> 00:50:57,059
<font color="#ffff54">그리고 기억하세요.</font>

2397
00:50:57,059 --> 00:50:59,600
first three octets because the hosts are subnetted

2398
00:50:57,059 --> 00:50:59,600
<font color="#ffff54">호스트가 서브넷화되어 있기 때문에 처음 세 옥텟은</font>

2399
00:50:59,600 --> 00:51:03,100
at 24 bits and then the overall space is eight bits.

2400
00:50:59,600 --> 00:51:03,100
<font color="#ffff54">24비트이고 전체 공간은 8비트입니다.</font>

2401
00:51:03,100 --> 00:51:04,380
We saw that in CNI.

2402
00:51:03,100 --> 00:51:04,380
<font color="#ffff54">CNI에서 이를 확인했습니다.</font>

2403
00:51:04,380 --> 00:51:07,080
So these are CNI controlled by Cilium

2404
00:51:04,380 --> 00:51:07,080
<font color="#ffff54">이것들은 실리움에 의해 제어되는 CNI입니다.</font>

2405
00:51:07,080 --> 00:51:09,660
and then the service IP, the cluster IP

2406
00:51:07,080 --> 00:51:09,660
<font color="#ffff54">그리고 서비스 IP, 클러스터 IP인</font>

2407
00:51:09,660 --> 00:51:10,940
is controlled by Kubernetes

2408
00:51:09,660 --> 00:51:10,940
<font color="#ffff54">은 쿠버네티스에 의해 제어된다.</font>

2409
00:51:10,940 --> 00:51:13,420
because it's the service controller piece.

2410
00:51:10,940 --> 00:51:13,420
<font color="#ffff54">서비스 컨트롤러 부분이기 때문이다.</font>

2411
00:51:13,420 --> 00:51:14,260
All right, good.

2412
00:51:13,420 --> 00:51:14,260
<font color="#ffff54">좋아요.</font>

2413
00:51:15,260 --> 00:51:16,940
Let's see what else we got here.

2414
00:51:15,260 --> 00:51:16,940
<font color="#ffff54">또 뭐가 있는지 봅시다.</font>

2415
00:51:16,940 --> 00:51:17,940
So the next thing we're gonna do

2416
00:51:16,940 --> 00:51:17,940
<font color="#ffff54">다음으로 할 일은 다음과 같습니다.</font>

2417
00:51:17,940 --> 00:51:20,020
is try to figure out how this all works.

2418
00:51:17,940 --> 00:51:20,020
<font color="#ffff54">이 모든 것이 어떻게 작동하는지 알아내는 것입니다.</font>

2419
00:51:20,020 --> 00:51:22,760
So we're gonna look into the IP tables

2420
00:51:20,020 --> 00:51:22,760
<font color="#ffff54">이제 IP 테이블을 살펴보겠습니다.</font>

2421
00:51:22,760 --> 00:51:26,460
and we're gonna look for the cluster IP.

2422
00:51:22,760 --> 00:51:26,460
<font color="#ffff54">그리고 클러스터 IP를 찾겠습니다.</font>

2423
00:51:26,460 --> 00:51:28,380
Obviously I can't use the one from the lab.

2424
00:51:26,460 --> 00:51:28,380
<font color="#ffff54">분명히 실험실의 것을 사용할 수 없습니다.</font>

2425
00:51:28,380 --> 00:51:29,660
I have to use the one that I got

2426
00:51:28,380 --> 00:51:29,660
<font color="#ffff54">내가 가진 걸 써야겠어</font>

2427
00:51:29,660 --> 00:51:32,120
which is potentially very different.

2428
00:51:29,660 --> 00:51:32,120
<font color="#ffff54">이는 잠재적으로 매우 다를 수 있습니다.</font>

2429
00:51:36,860 --> 00:51:38,720
Service IPs aren't doled out sequentially

2430
00:51:36,860 --> 00:51:38,720
<font color="#ffff54">서비스 IP가 순차적으로 분배되지 않음</font>

2431
00:51:38,720 --> 00:51:40,840
because then you could predict what the next one would be

2432
00:51:38,720 --> 00:51:40,840
<font color="#ffff54">다음 IP가 무엇인지 예측할 수 있기 때문입니다.</font>

2433
00:51:40,840 --> 00:51:42,740
and that leaves you open to some security issues.

2434
00:51:40,840 --> 00:51:42,740
<font color="#ffff54">보안 문제가 발생할 수 있습니다.</font>

2435
00:51:42,780 --> 00:51:45,460
So they're randomly selected from the range.

2436
00:51:42,780 --> 00:51:45,460
<font color="#ffff54">그래서 범위에서 무작위로 선택됩니다.</font>

2437
00:51:45,460 --> 00:51:48,820
All right, so I can see that there's an IP tables rule

2438
00:51:45,460 --> 00:51:48,820
<font color="#ffff54">좋아, IP 테이블 규칙이 있음을 알 수 있습니다.</font>

2439
00:51:48,820 --> 00:51:51,440
that says if TCP traffic comes from anywhere

2440
00:51:48,820 --> 00:51:51,440
<font color="#ffff54">TCP 트래픽이 어디에서 오든</font>

2441
00:51:51,440 --> 00:51:56,440
and goes to that address on TCP port 80,

2442
00:51:51,440 --> 00:51:56,440
<font color="#ffff54">TCP 포트 80의 해당 주소로 이동합니다,</font>

2443
00:51:57,980 --> 00:52:01,500
use that chain to figure out what happens.

2444
00:51:57,980 --> 00:52:01,500
<font color="#ffff54">이 체인을 사용하여 무슨 일이 일어나는지 알아보세요.</font>

2445
00:52:01,500 --> 00:52:03,600
So the next thing I need to do

2446
00:52:01,500 --> 00:52:03,600
<font color="#ffff54">다음으로 해야 할 일은</font>

2447
00:52:03,600 --> 00:52:05,700
is I need to update my grep

2448
00:52:03,600 --> 00:52:05,700
<font color="#ffff54">내 grep을 업데이트해야 합니다.</font>

2449
00:52:07,480 --> 00:52:09,980
to look at the chain called this.

2450
00:52:07,480 --> 00:52:09,980
<font color="#ffff54">라는 체인을 살펴봅니다.</font>

2451
00:52:13,260 --> 00:52:14,300
And...

2452
00:52:13,260 --> 00:52:14,300
<font color="#ffff54">그리고...</font>

2453
00:52:19,820 --> 00:52:20,660
Let me actually...

2454
00:52:19,820 --> 00:52:20,660
<font color="#ffff54">내가 실제로...</font>

2455
00:52:29,660 --> 00:52:31,060
Ah, yeah, there we go.

2456
00:52:29,660 --> 00:52:31,060
<font color="#ffff54">아, 그렇지.</font>

2457
00:52:31,060 --> 00:52:35,740
And so that is pointing us at our service.

2458
00:52:31,060 --> 00:52:35,740
<font color="#ffff54">이제 우리 서비스를 가리키고 있습니다.</font>

2459
00:52:35,740 --> 00:52:38,420
And you can see here, this guy says, all right,

2460
00:52:35,740 --> 00:52:38,420
<font color="#ffff54">여기 보시면, 이 남자가 이렇게 말합니다,</font>

2461
00:52:38,500 --> 00:52:42,740
um, destination IP 80.

2462
00:52:38,500 --> 00:52:42,740
<font color="#ffff54">음, 목적지 IP 80.</font>

2463
00:52:50,059 --> 00:52:51,559
Let's run this guy here.

2464
00:52:50,059 --> 00:52:51,559
<font color="#ffff54">이 녀석을 실행해 봅시다.</font>

2465
00:53:08,420 --> 00:53:09,260
There we go.

2466
00:53:08,420 --> 00:53:09,260
<font color="#ffff54">됐어요.</font>

2467
00:53:09,260 --> 00:53:10,980
And so those are the three pods

2468
00:53:09,260 --> 00:53:10,980
<font color="#ffff54">이렇게 세 개의 파드가 있습니다.</font>

2469
00:53:10,980 --> 00:53:14,019
that we saw in our deployment.

2470
00:53:10,980 --> 00:53:14,019
<font color="#ffff54">배포에서 확인했습니다.</font>

2471
00:53:14,019 --> 00:53:16,700
And you can see if you look at the packet counts,

2472
00:53:14,019 --> 00:53:16,700
<font color="#ffff54">패킷 수를 보면 알 수 있습니다,</font>

2473
00:53:16,700 --> 00:53:19,019
you can of course tell which one you hit

2474
00:53:16,700 --> 00:53:19,019
<font color="#ffff54">물론 어느 쪽을 공격했는지 알 수 있습니다.</font>

2475
00:53:19,019 --> 00:53:20,300
when you did your curl, right?

2476
00:53:19,019 --> 00:53:20,300
<font color="#ffff54">컬을 했을 때 말이죠?</font>

2477
00:53:20,300 --> 00:53:21,860
It's this bottom guy as it turns out.

2478
00:53:20,300 --> 00:53:21,860
<font color="#ffff54">알고 보니 이 아랫사람이네.</font>

2479
00:53:21,860 --> 00:53:23,340
So it's just a random probability,

2480
00:53:21,860 --> 00:53:23,340
<font color="#ffff54">그냥 무작위 확률입니다,</font>

2481
00:53:23,340 --> 00:53:24,980
33% when there's three of them,

2482
00:53:23,340 --> 00:53:24,980
<font color="#ffff54">세 개가 있을 때 33%,</font>

2483
00:53:24,980 --> 00:53:26,420
50% when there's two of them,

2484
00:53:24,980 --> 00:53:26,420
<font color="#ffff54">두 개일 때는 50%,</font>

2485
00:53:26,420 --> 00:53:28,340
and then the last one's the default.

2486
00:53:26,420 --> 00:53:28,340
<font color="#ffff54">마지막 하나가 기본값이 됩니다.</font>

2487
00:53:28,340 --> 00:53:30,740
And so this is the guy that got hit.

2488
00:53:28,340 --> 00:53:30,740
<font color="#ffff54">이 사람이 공격당한 사람입니다.</font>

2489
00:53:30,740 --> 00:53:35,740
And so if I look for the pod that's 10.0.0.54,

2490
00:53:30,740 --> 00:53:35,740
<font color="#ffff54">그래서 파드를 찾으면 10.0.0.54입니다,</font>

2491
00:53:35,740 --> 00:53:37,860
10.0.0.54,

2492
00:53:35,740 --> 00:53:37,860
<font color="#ffff54">10.0.0.54,</font>

2493
00:53:45,220 --> 00:53:47,340
and I look at that guy's logs, right?

2494
00:53:45,220 --> 00:53:47,340
<font color="#ffff54">저 남자의 로그를 보면, 그렇지?</font>

2495
00:53:47,340 --> 00:53:49,340
So this is 54 down here.

2496
00:53:47,340 --> 00:53:49,340
<font color="#ffff54">여기가 54번지네요.</font>

2497
00:53:50,440 --> 00:53:52,380
So let's look at the logs of this guy.

2498
00:53:50,440 --> 00:53:52,380
<font color="#ffff54">그럼 이 녀석의 로그를 살펴봅시다.</font>

2499
00:53:52,380 --> 00:53:56,420
We'll see a bunch of stuff, but there's the hit, right?

2500
00:53:52,380 --> 00:53:56,420
<font color="#ffff54">여러 가지가 나오겠지만, 히트작이 있죠?</font>

2501
00:53:56,420 --> 00:53:57,940
That was our curl.

2502
00:53:56,420 --> 00:53:57,940
<font color="#ffff54">저게 우리 컬이었어.</font>

2503
00:53:57,940 --> 00:54:01,780
And then if we do this same thing and look at logs

2504
00:53:57,940 --> 00:54:01,780
<font color="#ffff54">그리고 동일한 작업을 수행하고 로그를 살펴보면 다음과 같습니다.</font>

2505
00:54:02,780 --> 00:54:06,780
for anybody with the label app website, oh wow.

2506
00:54:02,780 --> 00:54:06,780
<font color="#ffff54">레이블 앱 웹사이트를 가진 사람이라면 누구나 알 수 있죠.</font>

2507
00:54:17,700 --> 00:54:18,540
There we go.

2508
00:54:17,700 --> 00:54:18,540
<font color="#ffff54">됐어요.</font>

2509
00:54:18,540 --> 00:54:21,220
We can see that there are no hits anywhere in here

2510
00:54:18,540 --> 00:54:21,220
<font color="#ffff54">여기 어디에도 히트가 없는 것을 볼 수 있습니다.</font>

2511
00:54:21,220 --> 00:54:23,019
except this one from our curl.

2512
00:54:21,220 --> 00:54:23,019
<font color="#ffff54">이 컬에서 나온 것만 빼고요.</font>

2513
00:54:23,019 --> 00:54:24,900
So all three of the other pods, right?

2514
00:54:23,019 --> 00:54:24,900
<font color="#ffff54">그럼 다른 세 개의 파드도 모두 포함되는 거죠?</font>

2515
00:54:24,900 --> 00:54:26,620
This guy, no hits.

2516
00:54:24,900 --> 00:54:26,620
<font color="#ffff54">이 녀석, 안 맞았어.</font>

2517
00:54:26,620 --> 00:54:27,700
This guy, no hits.

2518
00:54:26,620 --> 00:54:27,700
<font color="#ffff54">이 녀석, 적중 없음.</font>

2519
00:54:27,700 --> 00:54:29,140
This guy got a hit.

2520
00:54:27,700 --> 00:54:29,140
<font color="#ffff54">이 녀석은 적중했습니다.</font>

2521
00:54:29,140 --> 00:54:31,080
So the service is working, right?

2522
00:54:29,140 --> 00:54:31,080
<font color="#ffff54">서비스가 작동하는 거죠?</font>

2523
00:54:31,119 --> 00:54:33,199
Our IP tables are solving the problem

2524
00:54:31,119 --> 00:54:33,199
<font color="#ffff54">IP 테이블이 문제를 해결하고 있습니다.</font>

2525
00:54:33,199 --> 00:54:36,519
of randomly distributing traffic to our pods on the backend.

2526
00:54:33,199 --> 00:54:36,519
<font color="#ffff54">백엔드의 파드에 트래픽을 무작위로 분배하고 있습니다.</font>

2527
00:54:37,880 --> 00:54:40,639
There's a little bit more exploration that goes on there.

2528
00:54:37,880 --> 00:54:40,639
<font color="#ffff54">조금 더 탐색이 진행 중입니다.</font>

2529
00:54:41,679 --> 00:54:43,480
But that brings us down to the bottom section

2530
00:54:41,679 --> 00:54:43,480
<font color="#ffff54">하지만 이제 맨 아래 섹션으로 내려갑니다.</font>

2531
00:54:43,480 --> 00:54:46,139
where we get to delete some things and see how stuff works.

2532
00:54:43,480 --> 00:54:46,139
<font color="#ffff54">여기서 몇 가지를 삭제하고 어떻게 작동하는지 확인할 수 있습니다.</font>

2533
00:54:46,139 --> 00:54:47,900
So for example,

2534
00:54:46,139 --> 00:54:47,900
<font color="#ffff54">예를 들어</font>

2535
00:54:57,039 --> 00:54:59,880
just gonna pick one of these guys at random and delete it.

2536
00:54:57,039 --> 00:54:59,880
<font color="#ffff54">이 중 하나를 무작위로 골라서 삭제합니다.</font>

2537
00:55:01,400 --> 00:55:04,039
And a bunch of things happen when you do this.

2538
00:55:01,400 --> 00:55:04,039
<font color="#ffff54">이렇게 하면 여러 가지 일이 일어납니다.</font>

2539
00:55:04,039 --> 00:55:06,440
Number one, the curl keeps working

2540
00:55:04,039 --> 00:55:06,440
<font color="#ffff54">첫째, 컬이 계속 작동합니다.</font>

2541
00:55:06,440 --> 00:55:09,239
and you never even see any hesitation.

2542
00:55:06,440 --> 00:55:09,239
<font color="#ffff54">망설임이 전혀 보이지 않습니다.</font>

2543
00:55:09,239 --> 00:55:11,480
And the reason is that the service proxy

2544
00:55:09,239 --> 00:55:11,480
<font color="#ffff54">그 이유는 서비스 프록시가</font>

2545
00:55:11,480 --> 00:55:15,019
has taken the deleted pod out of the mesh.

2546
00:55:11,480 --> 00:55:15,019
<font color="#ffff54">가 삭제된 파드를 메시에서 제거했기 때문이다.</font>

2547
00:55:15,019 --> 00:55:18,840
And of course, what also happens is that Kubernetes

2548
00:55:15,019 --> 00:55:18,840
<font color="#ffff54">물론, 쿠버네티스도 마찬가지다.</font>

2549
00:55:18,840 --> 00:55:22,440
immediately realizes that there aren't three pods anymore.

2550
00:55:18,840 --> 00:55:22,440
<font color="#ffff54">는 더 이상 세 개의 파드가 없다는 것을 즉시 인식한다.</font>

2551
00:55:22,440 --> 00:55:24,259
And since the replica set and the deployment

2552
00:55:22,440 --> 00:55:24,259
<font color="#ffff54">그리고 레플리카 세트와 디플로이먼트가 완료되었으므로</font>

2553
00:55:24,259 --> 00:55:26,219
were set to have three, it creates a brand new one.

2554
00:55:24,259 --> 00:55:26,219
<font color="#ffff54">가 3개로 설정되었으므로, 새로운 것을 생성합니다.</font>

2555
00:55:26,219 --> 00:55:28,340
It's not the same pod, right?

2556
00:55:26,219 --> 00:55:28,340
<font color="#ffff54">같은 포드가 아니죠?</font>

2557
00:55:28,340 --> 00:55:30,820
That guy, if you look at the IP,

2558
00:55:28,340 --> 00:55:30,820
<font color="#ffff54">저 남자, IP를 보면,</font>

2559
00:55:32,860 --> 00:55:35,460
right, not the same pod, right?

2560
00:55:32,860 --> 00:55:35,460
<font color="#ffff54">같은 포드 아니죠?</font>

2561
00:55:35,460 --> 00:55:40,460
This guy is 134 and he's been running for 31 seconds

2562
00:55:35,460 --> 00:55:40,460
<font color="#ffff54">이 녀석은 134번이고 31초 동안 달렸어요.</font>

2563
00:55:41,220 --> 00:55:43,579
versus the other guys, which are seven minutes.

2564
00:55:41,220 --> 00:55:43,579
<font color="#ffff54">다른 녀석들은 7분입니다.</font>

2565
00:55:43,579 --> 00:55:46,120
So the mesh is dynamic, right?

2566
00:55:43,579 --> 00:55:46,120
<font color="#ffff54">메시가 동적이지 않나요?</font>

2567
00:55:46,120 --> 00:55:49,660
It's taking advantage of this dynamic environment

2568
00:55:46,120 --> 00:55:49,660
<font color="#ffff54">이 동적인 환경을 활용하고 있습니다.</font>

2569
00:55:49,660 --> 00:55:52,460
and automatically updating all of the routing

2570
00:55:49,660 --> 00:55:52,460
<font color="#ffff54">모든 라우팅을 자동으로 업데이트합니다.</font>

2571
00:55:52,460 --> 00:55:55,200
or forwarding necessary to make things go.

2572
00:55:52,460 --> 00:55:55,200
<font color="#ffff54">또는 라우팅에 필요한 포워딩을 수행합니다.</font>

2573
00:55:56,080 --> 00:55:59,160
All right, so let's move on.

2574
00:55:56,080 --> 00:55:59,160
<font color="#ffff54">좋아, 그럼 계속 진행하자.</font>

2575
00:55:59,160 --> 00:56:03,120
And keep in mind, if you're done with two before I move on,

2576
00:55:59,160 --> 00:56:03,120
<font color="#ffff54">그리고 명심해, 내가 넘어가기 전에 두 개 다 끝내야 해,</font>

2577
00:56:03,120 --> 00:56:05,160
feel free to move on yourself.

2578
00:56:03,120 --> 00:56:05,160
<font color="#ffff54">자유롭게 계속 진행하세요.</font>

2579
00:56:05,160 --> 00:56:06,400
All right, so Kubernetes DNS.

2580
00:56:05,160 --> 00:56:06,400
<font color="#ffff54">자, 쿠버네티스 DNS.</font>

2581
00:56:06,400 --> 00:56:08,240
Let's talk about DNS briefly

2582
00:56:06,400 --> 00:56:08,240
<font color="#ffff54">DNS에 대해 간단히 이야기해보자.</font>

2583
00:56:08,240 --> 00:56:10,760
and how Kubernetes implements it.

2584
00:56:08,240 --> 00:56:10,760
<font color="#ffff54">그리고 쿠버네티스가 어떻게 구현하는지 알아보자.</font>

2585
00:56:10,760 --> 00:56:12,520
If you're still working on lab two, keep working,

2586
00:56:10,760 --> 00:56:12,520
<font color="#ffff54">아직 실습 2를 진행 중이라면 계속 진행하세요,</font>

2587
00:56:12,520 --> 00:56:13,840
just lend me half an ear.

2588
00:56:12,520 --> 00:56:13,840
<font color="#ffff54">귀를 반만 빌려줘.</font>

2589
00:56:13,840 --> 00:56:16,960
So DNS and Kubernetes, there are three files

2590
00:56:13,840 --> 00:56:16,960
<font color="#ffff54">DNS와 쿠버네티스에는 세 개의 파일이 있다.</font>

2591
00:56:16,960 --> 00:56:19,200
that your containers get

2592
00:56:16,960 --> 00:56:19,200
<font color="#ffff54">컨테이너가 받는</font>

2593
00:56:19,200 --> 00:56:21,900
that come from the container runtime,

2594
00:56:19,200 --> 00:56:21,900
<font color="#ffff54">컨테이너 런타임에서 온다,</font>

2595
00:56:21,900 --> 00:56:25,860
not from your image, your container image.

2596
00:56:21,900 --> 00:56:25,860
<font color="#ffff54">이미지가 아닌 컨테이너 이미지에서 온 것입니다.</font>

2597
00:56:25,860 --> 00:56:28,700
They're always overlaid by the container runtime.

2598
00:56:25,860 --> 00:56:28,700
<font color="#ffff54">항상 컨테이너 런타임에 의해 오버레이됩니다.</font>

2599
00:56:28,700 --> 00:56:31,579
And the reason is if you take a HTTP container

2600
00:56:28,700 --> 00:56:31,579
<font color="#ffff54">그 이유는 HTTP 컨테이너에서</font>

2601
00:56:31,579 --> 00:56:34,180
and you run it in Singapore, it's gonna get one IP.

2602
00:56:31,579 --> 00:56:34,180
<font color="#ffff54">싱가포르에서 실행하면 하나의 IP를 얻게 됩니다.</font>

2603
00:56:34,180 --> 00:56:36,680
If you run it in London, it's gonna get another IP.

2604
00:56:34,180 --> 00:56:36,680
<font color="#ffff54">런던에서 실행하면 다른 IP를 얻게 됩니다.</font>

2605
00:56:36,680 --> 00:56:40,860
So how could you possibly create an Etsy host file

2606
00:56:36,680 --> 00:56:40,860
<font color="#ffff54">그렇다면 어떻게 Etsy 호스트 파일을 만들 수 있을까요?</font>

2607
00:56:40,860 --> 00:56:42,840
with the correct information, right?

2608
00:56:40,860 --> 00:56:42,840
<font color="#ffff54">올바른 정보로 만들 수 있죠?</font>

2609
00:56:42,840 --> 00:56:45,660
Since it should have your IP and your host name in there.

2610
00:56:42,840 --> 00:56:45,660
<font color="#ffff54">내 IP와 호스트 이름이 들어가야 하니까요.</font>

2611
00:56:45,660 --> 00:56:48,380
How could you possibly create a host name file

2612
00:56:45,660 --> 00:56:48,380
<font color="#ffff54">어떻게 호스트 이름 파일을 만들 수 있죠?</font>

2613
00:56:48,380 --> 00:56:51,059
with the correct information since the name of your host

2614
00:56:48,380 --> 00:56:51,059
<font color="#ffff54">호스트 이름 이후 올바른 정보로 수정합니다.</font>

2615
00:56:51,059 --> 00:56:54,779
when you're a pod is the name of your pod?

2616
00:56:51,059 --> 00:56:54,779
<font color="#ffff54">파드라면 파드의 이름인가?</font>

2617
00:56:54,779 --> 00:56:56,679
And that's dynamically being created.

2618
00:56:54,779 --> 00:56:56,679
<font color="#ffff54">그리고 그것은 동적으로 생성되고 있다.</font>

2619
00:56:56,679 --> 00:56:58,380
So you don't even know what it's gonna be.

2620
00:56:56,679 --> 00:56:58,380
<font color="#ffff54">그래서 당신은 그것이 어떻게 될지조차 모릅니다.</font>

2621
00:56:58,380 --> 00:57:01,519
And then the final thing is resolve.conf.

2622
00:56:58,380 --> 00:57:01,519
<font color="#ffff54">그리고 마지막은 resolve.conf입니다.</font>

2623
00:57:01,519 --> 00:57:05,980
Every Kubernetes cluster runs core DNS by default.

2624
00:57:01,519 --> 00:57:05,980
<font color="#ffff54">모든 쿠버네티스 클러스터는 기본적으로 코어 DNS를 실행한다.</font>

2625
00:57:05,980 --> 00:57:08,340
Some distros change it and use something else

2626
00:57:05,980 --> 00:57:08,340
<font color="#ffff54">일부 배포판은 이를 변경하여 다른 것을 사용한다.</font>

2627
00:57:08,340 --> 00:57:11,639
and some distros configure core DNS in different ways.

2628
00:57:08,340 --> 00:57:11,639
<font color="#ffff54">일부 배포판은 코어 DNS를 다른 방식으로 구성합니다.</font>

2629
00:57:11,639 --> 00:57:14,199
But there is a DNS server built into Kubernetes.

2630
00:57:11,639 --> 00:57:14,199
<font color="#ffff54">하지만 쿠버네티스에는 DNS 서버가 내장되어 있다.</font>

2631
00:57:14,199 --> 00:57:16,360
And when you use the reference installer,

2632
00:57:14,199 --> 00:57:16,360
<font color="#ffff54">그리고 레퍼런스 인스톨러를 사용하면</font>

2633
00:57:16,360 --> 00:57:19,219
kube-adm, you get core DNS, which is another CNCF project,

2634
00:57:16,360 --> 00:57:19,219
<font color="#ffff54">kube-adm을 사용하면 또 다른 CNCF 프로젝트인 코어 DNS를 얻게 된다,</font>

2635
00:57:19,219 --> 00:57:20,259
one of the earliest ones.

2636
00:57:19,219 --> 00:57:20,259
<font color="#ffff54">가장 빠른 것 중 하나이다.</font>

2637
00:57:20,300 --> 00:57:25,300
And so core DNS will automatically resolve service names

2638
00:57:20,300 --> 00:57:25,300
<font color="#ffff54">따라서 코어 DNS는 자동으로 서비스 이름을 확인합니다.</font>

2639
00:57:25,720 --> 00:57:28,060
inside your cluster to their virtual IPs

2640
00:57:25,720 --> 00:57:28,060
<font color="#ffff54">클러스터 내부의 가상 IP로</font>

2641
00:57:28,060 --> 00:57:30,180
so that you can just use names instead of IPs,

2642
00:57:28,060 --> 00:57:30,180
<font color="#ffff54">따라서 IP 대신 이름만 사용할 수 있습니다,</font>

2643
00:57:30,180 --> 00:57:31,140
which is great.

2644
00:57:30,180 --> 00:57:31,140
<font color="#ffff54">아주 좋습니다.</font>

2645
00:57:31,140 --> 00:57:32,620
But that means those three files

2646
00:57:31,140 --> 00:57:32,620
<font color="#ffff54">하지만 이는 다음 세 파일을 의미합니다.</font>

2647
00:57:32,620 --> 00:57:35,020
have to be correctly configured.

2648
00:57:32,620 --> 00:57:35,020
<font color="#ffff54">을 올바르게 설정해야 합니다.</font>

2649
00:57:35,020 --> 00:57:36,460
And so it's the kubelet

2650
00:57:35,020 --> 00:57:36,460
<font color="#ffff54">그리고 이것이 바로 kubelet이다.</font>

2651
00:57:36,460 --> 00:57:38,700
that understands your Kubernetes environment

2652
00:57:36,460 --> 00:57:38,700
<font color="#ffff54">쿠버네티스 환경을 이해한다.</font>

2653
00:57:38,700 --> 00:57:41,580
and sets these files up so that your pod works.

2654
00:57:38,700 --> 00:57:41,580
<font color="#ffff54">파드가 작동하도록 이 파일들을 설정한다.</font>

2655
00:57:41,580 --> 00:57:46,580
And so you have core DNS running

2656
00:57:41,580 --> 00:57:46,580
<font color="#ffff54">이제 코어 DNS가 실행된다.</font>

2657
00:57:47,140 --> 00:57:49,180
in the kube system namespace.

2658
00:57:47,140 --> 00:57:49,180
<font color="#ffff54">을 실행합니다.</font>

2659
00:57:49,180 --> 00:57:51,620
As you can see up here, we have two pods, core DNS pods.

2660
00:57:49,180 --> 00:57:51,620
<font color="#ffff54">여기에서 볼 수 있듯이, 코어 DNS 파드인 두 개의 파드가 있습니다.</font>

2661
00:57:51,620 --> 00:57:53,640
So if one of them crashes, we have resilience, right?

2662
00:57:51,620 --> 00:57:53,640
<font color="#ffff54">둘 중 하나가 충돌해도 복원력이 있는 거죠?</font>

2663
00:57:53,640 --> 00:57:55,580
Kubernetes eats its own dog food.

2664
00:57:53,640 --> 00:57:55,580
<font color="#ffff54">쿠버네티스는 스스로 개밥을 먹는다.</font>

2665
00:57:55,580 --> 00:57:57,840
Core DNS runs in a deployment.

2666
00:57:55,580 --> 00:57:57,840
<font color="#ffff54">코어 DNS가 디플로이먼트에서 실행된다.</font>

2667
00:57:57,840 --> 00:58:00,240
And then there's a service also

2668
00:57:57,840 --> 00:58:00,240
<font color="#ffff54">그리고 서비스도 있습니다.</font>

2669
00:58:00,240 --> 00:58:03,780
that gives us a cluster IP for DNS inside Kubernetes.

2670
00:58:00,240 --> 00:58:03,780
<font color="#ffff54">쿠버네티스 내부의 DNS를 위한 클러스터 IP를 제공한다.</font>

2671
00:58:03,780 --> 00:58:06,320
And it's 10.96.0.10.

2672
00:58:03,780 --> 00:58:06,320
<font color="#ffff54">그리고 10.96.0.10입니다.</font>

2673
00:58:06,320 --> 00:58:08,020
That's the default IP for DNS.

2674
00:58:06,320 --> 00:58:08,020
<font color="#ffff54">이것이 DNS의 기본 IP입니다.</font>

2675
00:58:08,020 --> 00:58:10,540
And it's gonna be injected into every single pod

2676
00:58:08,020 --> 00:58:10,540
<font color="#ffff54">그리고 모든 단일 파드에 주입될 것입니다.</font>

2677
00:58:10,540 --> 00:58:12,180
in resolve.conf.

2678
00:58:10,540 --> 00:58:12,180
<font color="#ffff54">resolve.conf에.</font>

2679
00:58:12,180 --> 00:58:14,320
Because when your pod tries to look up a name,

2680
00:58:12,180 --> 00:58:14,320
<font color="#ffff54">왜냐하면 파드가 이름을 조회하려고 할 때,</font>

2681
00:58:14,320 --> 00:58:18,180
it needs to go to core DNS to find the IP of that service.

2682
00:58:14,320 --> 00:58:18,180
<font color="#ffff54">이면 코어 DNS로 이동하여 해당 서비스의 IP를 찾아야 한다.</font>

2683
00:58:18,180 --> 00:58:20,500
We don't generally look at pods, right?

2684
00:58:18,180 --> 00:58:20,500
<font color="#ffff54">우리는 일반적으로 파드를 보지 않죠?</font>

2685
00:58:20,500 --> 00:58:22,060
They're ephemeral.

2686
00:58:20,500 --> 00:58:22,060
<font color="#ffff54">일시적이잖아요.</font>

2687
00:58:22,060 --> 00:58:22,900
We don't care about them.

2688
00:58:22,060 --> 00:58:22,900
<font color="#ffff54">우리는 그들에 대해 신경 쓰지 않습니다.</font>

2689
00:58:22,900 --> 00:58:25,420
We care about the API that we're trying to consume, right?

2690
00:58:22,900 --> 00:58:25,420
<font color="#ffff54">우리는 우리가 사용하려는 API가 중요하지 않나요?</font>

2691
00:58:25,420 --> 00:58:27,620
The interface, not the implementation.

2692
00:58:25,420 --> 00:58:27,620
<font color="#ffff54">구현이 아니라 인터페이스가 중요하죠.</font>

2693
00:58:27,620 --> 00:58:30,660
And so that's a quick look at core DNS

2694
00:58:27,620 --> 00:58:30,660
<font color="#ffff54">핵심 DNS를 간략히 살펴보면 다음과 같습니다.</font>

2695
00:58:30,660 --> 00:58:32,620
and how it's set up and what it does.

2696
00:58:30,660 --> 00:58:32,620
<font color="#ffff54">그리고 설정 방법과 기능에 대해 알아보겠습니다.</font>

2697
00:58:32,620 --> 00:58:37,180
And then if you want to think about DNS inside a cluster,

2698
00:58:32,620 --> 00:58:37,180
<font color="#ffff54">그리고 클러스터 내부의 DNS에 대해 생각해 보겠습니다,</font>

2699
00:58:37,180 --> 00:58:39,080
number one, you might have many clusters.

2700
00:58:37,180 --> 00:58:39,080
<font color="#ffff54">첫째, 많은 클러스터가 있을 수 있습니다.</font>

2701
00:58:39,080 --> 00:58:41,940
So you can give every single cluster its own suffix, right?

2702
00:58:39,080 --> 00:58:41,940
<font color="#ffff54">그럼 모든 클러스터에 고유한 접미사를 부여할 수 있겠죠?</font>

2703
00:58:41,940 --> 00:58:43,620
Cluster.local is the default.

2704
00:58:41,940 --> 00:58:43,620
<font color="#ffff54">Cluster.local이 기본값입니다.</font>

2705
00:58:43,620 --> 00:58:45,020
And so you get cluster.local

2706
00:58:43,620 --> 00:58:45,020
<font color="#ffff54">그래서 클러스터.local을 얻는다.</font>

2707
00:58:45,020 --> 00:58:46,840
in the example we're gonna look at.

2708
00:58:45,020 --> 00:58:46,840
<font color="#ffff54">이 예제에서 살펴볼 것이다.</font>

2709
00:58:46,840 --> 00:58:49,480
Next, there's the service bucket where services live.

2710
00:58:46,840 --> 00:58:49,480
<font color="#ffff54">다음으로, 서비스가 있는 서비스 버킷이 있습니다.</font>

2711
00:58:49,480 --> 00:58:50,320
There's some other buckets,

2712
00:58:49,480 --> 00:58:50,320
<font color="#ffff54">다른 버킷도 있습니다,</font>

2713
00:58:50,320 --> 00:58:51,880
but this is the most important one.

2714
00:58:50,320 --> 00:58:51,880
<font color="#ffff54">하지만 이것이 가장 중요한 버킷입니다.</font>

2715
00:58:51,880 --> 00:58:55,039
And then namespaces are a thing in Kubernetes, right?

2716
00:58:51,880 --> 00:58:55,039
<font color="#ffff54">그리고 쿠버네티스에서는 네임스페이스가 중요하죠?</font>

2717
00:58:55,039 --> 00:58:56,760
If I want dev and production,

2718
00:58:55,039 --> 00:58:56,760
<font color="#ffff54">만약 내가 개발과 프로덕션을 원한다면,</font>

2719
00:58:56,760 --> 00:58:58,360
if I want team A and team B,

2720
00:58:56,760 --> 00:58:58,360
<font color="#ffff54">팀 A와 팀 B를 원한다면</font>

2721
00:58:58,360 --> 00:59:02,280
if I want blue, green, whatever,

2722
00:58:58,360 --> 00:59:02,280
<font color="#ffff54">파란색, 녹색, 뭐든 원하는 경우,</font>

2723
00:59:02,280 --> 00:59:04,600
different namespaces are isolated from each other.

2724
00:59:02,280 --> 00:59:04,600
<font color="#ffff54">서로 다른 네임스페이스가 서로 격리되어 있습니다.</font>

2725
00:59:04,600 --> 00:59:07,200
And so if you create a service called Fred

2726
00:59:04,600 --> 00:59:07,200
<font color="#ffff54">따라서 프레드라는 서비스를 만들면</font>

2727
00:59:07,200 --> 00:59:09,300
and I try to create one and I get an error,

2728
00:59:07,200 --> 00:59:09,300
<font color="#ffff54">를 만들려고 하면 오류가 발생합니다,</font>

2729
00:59:09,300 --> 00:59:11,039
that's gonna be confusing, right?

2730
00:59:09,300 --> 00:59:11,039
<font color="#ffff54">혼란스럽지 않나요?</font>

2731
00:59:11,039 --> 00:59:13,800
If we're in completely different departments and contexts

2732
00:59:11,039 --> 00:59:13,800
<font color="#ffff54">완전히 다른 부서와 상황에 있는 경우</font>

2733
00:59:13,800 --> 00:59:15,440
and we don't even normally talk to each other,

2734
00:59:13,800 --> 00:59:15,440
<font color="#ffff54">평소에는 서로 대화도 하지 않는 경우,</font>

2735
00:59:15,440 --> 00:59:16,800
that's gonna be a big problem.

2736
00:59:15,440 --> 00:59:16,800
<font color="#ffff54">큰 문제가 될 거야.</font>

2737
00:59:17,640 --> 00:59:18,460
So namespaces give you the ability

2738
00:59:17,640 --> 00:59:18,460
<font color="#ffff54">네임스페이스는 다음과 같은 기능을 제공합니다.</font>

2739
00:59:18,460 --> 00:59:19,840
to create any name you want,

2740
00:59:18,460 --> 00:59:19,840
<font color="#ffff54">원하는 이름을 만들 수 있습니다,</font>

2741
00:59:19,840 --> 00:59:22,660
which means the DNS has to be isolated.

2742
00:59:19,840 --> 00:59:22,660
<font color="#ffff54">즉, DNS를 격리해야 합니다.</font>

2743
00:59:22,660 --> 00:59:26,440
And so the namespace is in the DNS name.

2744
00:59:22,660 --> 00:59:26,440
<font color="#ffff54">따라서 네임스페이스는 DNS 이름에 있습니다.</font>

2745
00:59:26,440 --> 00:59:28,960
And then finally you have the name of the service itself.

2746
00:59:26,440 --> 00:59:28,960
<font color="#ffff54">그리고 마지막으로 서비스 자체의 이름이 있습니다.</font>

2747
00:59:28,960 --> 00:59:32,560
So an example of a realistic production DNS name

2748
00:59:28,960 --> 00:59:32,560
<font color="#ffff54">실제 프로덕션 DNS 이름의 예는 다음과 같습니다.</font>

2749
00:59:32,560 --> 00:59:35,200
for a service in Kubernetes might be web,

2750
00:59:32,560 --> 00:59:35,200
<font color="#ffff54">은 웹일 수 있다,</font>

2751
00:59:35,200 --> 00:59:37,039
if your service is called web,

2752
00:59:35,200 --> 00:59:37,039
<font color="#ffff54">이 될 수 있다,</font>

2753
00:59:37,039 --> 00:59:39,680
production, if your namespace is called production,

2754
00:59:37,039 --> 00:59:39,680
<font color="#ffff54">네임스페이스가 프로덕션인 경우 프로덕션,</font>

2755
00:59:39,680 --> 00:59:43,840
.svc and then k8s54.rx-m.com,

2756
00:59:39,680 --> 00:59:43,840
<font color="#ffff54">.svc, 그리고 k8s54.rx-m.com입니다,</font>

2757
00:59:43,840 --> 00:59:46,360
if that's the suffix you gave that cluster.

2758
00:59:43,840 --> 00:59:46,360
<font color="#ffff54">이 클러스터에 지정한 접미사인 경우.</font>

2759
00:59:46,920 --> 00:59:48,920
And so you can see with this kind of a unique name,

2760
00:59:46,920 --> 00:59:48,920
<font color="#ffff54">이런 종류의 고유 이름을 사용하면 알 수 있습니다,</font>

2761
00:59:48,920 --> 00:59:50,480
I can actually reach a service

2762
00:59:48,920 --> 00:59:50,480
<font color="#ffff54">실제로 서비스에 연결할 수 있습니다.</font>

2763
00:59:50,480 --> 00:59:53,140
in a completely different cluster, right?

2764
00:59:50,480 --> 00:59:53,140
<font color="#ffff54">완전히 다른 클러스터에 있는 거죠?</font>

2765
00:59:53,140 --> 00:59:54,440
I could give the name of the service,

2766
00:59:53,140 --> 00:59:54,440
<font color="#ffff54">서비스 이름을 알려줄 수 있어요,</font>

2767
00:59:54,440 --> 00:59:56,160
the namespace in the cluster,

2768
00:59:54,440 --> 00:59:56,160
<font color="#ffff54">클러스터의 네임스페이스,</font>

2769
00:59:56,160 --> 00:59:58,320
the SVC and then the cluster suffix.

2770
00:59:56,160 --> 00:59:58,320
<font color="#ffff54">그리고 클러스터 접미사.</font>

2771
00:59:58,320 --> 00:59:59,840
And as long as my networking,

2772
00:59:58,320 --> 00:59:59,840
<font color="#ffff54">그리고 내 네트워킹이 작동하는 한,</font>

2773
00:59:59,840 --> 01:00:02,059
normal computer networking infrastructure

2774
00:59:59,840 --> 01:00:02,059
<font color="#ffff54">일반 컴퓨터 네트워킹 인프라</font>

2775
01:00:02,059 --> 01:00:04,400
knows how to deliver that packet to that cluster,

2776
01:00:02,059 --> 01:00:04,400
<font color="#ffff54">해당 패킷을 해당 클러스터로 전달하는 방법을 알고 있습니다,</font>

2777
01:00:04,400 --> 01:00:06,640
we've got connectivity.

2778
01:00:04,400 --> 01:00:06,640
<font color="#ffff54">연결되었습니다.</font>

2779
01:00:06,640 --> 01:00:08,800
So headless services are another thing.

2780
01:00:06,640 --> 01:00:08,800
<font color="#ffff54">헤드리스 서비스는 또 다른 문제입니다.</font>

2781
01:00:08,800 --> 01:00:11,360
We mentioned if you say cluster IP none,

2782
01:00:08,800 --> 01:00:11,360
<font color="#ffff54">클러스터 IP가 없다고 하면 언급했습니다,</font>

2783
01:00:11,360 --> 01:00:12,360
you'll get a headless service.

2784
01:00:11,360 --> 01:00:12,360
<font color="#ffff54">헤드리스 서비스를 받게 됩니다.</font>

2785
01:00:12,360 --> 01:00:14,140
Well, what happens in a headless service?

2786
01:00:12,360 --> 01:00:14,140
<font color="#ffff54">헤드리스 서비스에서는 어떤 일이 일어나나요?</font>

2787
01:00:14,139 --> 01:00:16,980
In a headless service, you don't want the cluster IP,

2788
01:00:14,139 --> 01:00:16,980
<font color="#ffff54">헤드리스 서비스에서는 클러스터 IP를 원하지 않습니다,</font>

2789
01:00:16,980 --> 01:00:18,339
you don't wanna look that up,

2790
01:00:16,980 --> 01:00:18,339
<font color="#ffff54">를 조회하고 싶지 않을 것입니다,</font>

2791
01:00:18,339 --> 01:00:20,139
cause it's no good, right?

2792
01:00:18,339 --> 01:00:20,139
<font color="#ffff54">안 좋은 거니까, 그치?</font>

2793
01:00:20,139 --> 01:00:21,819
You don't wanna randomly go somewhere.

2794
01:00:20,139 --> 01:00:21,819
<font color="#ffff54">무작정 어딘가로 가고 싶지 않을 거야.</font>

2795
01:00:21,819 --> 01:00:22,980
If I want New York data,

2796
01:00:21,819 --> 01:00:22,980
<font color="#ffff54">뉴욕 데이터를 원한다면,</font>

2797
01:00:22,980 --> 01:00:24,339
I have to talk to that Kafka node.

2798
01:00:22,980 --> 01:00:24,339
<font color="#ffff54">카프카 노드와 대화해야 합니다.</font>

2799
01:00:24,339 --> 01:00:27,239
If I want life data, I gotta talk to that Kafka node.

2800
01:00:24,339 --> 01:00:27,239
<font color="#ffff54">생명 데이터를 원한다면, 저 카프카 노드와 대화해야 합니다.</font>

2801
01:00:27,239 --> 01:00:29,619
So in a headless service,

2802
01:00:27,239 --> 01:00:29,619
<font color="#ffff54">그래서 헤드리스 서비스에서,</font>

2803
01:00:29,619 --> 01:00:34,619
you get the actual IPs of all of the nodes

2804
01:00:29,619 --> 01:00:34,619
<font color="#ffff54">모든 노드의 실제 IP를 얻게 됩니다.</font>

2805
01:00:35,000 --> 01:00:38,059
or all the pods when you look up the service name.

2806
01:00:35,000 --> 01:00:38,059
<font color="#ffff54">또는 서비스 이름을 조회할 때 모든 파드의 IP를 얻을 수 있다.</font>

2807
01:00:38,059 --> 01:00:41,379
So it's not just one IP of the head of the cluster IP,

2808
01:00:38,059 --> 01:00:41,379
<font color="#ffff54">따라서 클러스터 헤드의 IP가 하나만 있는 것이 아닙니다,</font>

2809
01:00:41,380 --> 01:00:44,460
you're gonna get all the pod IPs together.

2810
01:00:41,380 --> 01:00:44,460
<font color="#ffff54">모든 파드 IP를 모을 것이다.</font>

2811
01:00:44,460 --> 01:00:46,420
The other thing that is important

2812
01:00:44,460 --> 01:00:46,420
<font color="#ffff54">또 다른 중요한 것은</font>

2813
01:00:46,420 --> 01:00:50,740
is that there's a special controller for stateful pods

2814
01:00:46,420 --> 01:00:50,740
<font color="#ffff54">스테이트풀 파드를 위한 특별한 컨트롤러가 있다는 것이다.</font>

2815
01:00:50,740 --> 01:00:52,440
called a stateful set.

2816
01:00:50,740 --> 01:00:52,440
<font color="#ffff54">스테이트풀 세트라고 한다.</font>

2817
01:00:52,440 --> 01:00:56,539
And it creates pods with deterministic names,

2818
01:00:52,440 --> 01:00:56,539
<font color="#ffff54">그리고 결정론적 이름을 가진 파드를 생성한다,</font>

2819
01:00:56,539 --> 01:00:59,820
with identity, with persistent identity.

2820
01:00:56,539 --> 01:00:59,820
<font color="#ffff54">아이덴티티를 가진, 영구적인 아이덴티티를 가진 파드를 생성한다.</font>

2821
01:00:59,820 --> 01:01:03,300
If this pod, which is let's call it web7,

2822
01:00:59,820 --> 01:01:03,300
<font color="#ffff54">이 파드를 웹7이라고 하자,</font>

2823
01:01:03,300 --> 01:01:05,460
gets evicted from a computer,

2824
01:01:03,300 --> 01:01:05,460
<font color="#ffff54">컴퓨터에서 쫓겨난다,</font>

2825
01:01:05,460 --> 01:01:07,220
we won't get web58 over here,

2826
01:01:05,460 --> 01:01:07,220
<font color="#ffff54">웹58이 여기로 들어오지 않습니다,</font>

2827
01:01:07,220 --> 01:01:09,920
we'll get web7 again over here.

2828
01:01:07,220 --> 01:01:09,920
<font color="#ffff54">웹7을 다시 가져옵니다.</font>

2829
01:01:09,920 --> 01:01:10,860
Might have a different IP,

2830
01:01:09,920 --> 01:01:10,860
<font color="#ffff54">다른 IP가 있을 수 있습니다,</font>

2831
01:01:11,360 --> 01:01:12,539
but the name will be the same.

2832
01:01:11,360 --> 01:01:12,539
<font color="#ffff54">하지만 이름은 동일합니다.</font>

2833
01:01:12,539 --> 01:01:16,460
So if you create a stateful set of Redis,

2834
01:01:12,539 --> 01:01:16,460
<font color="#ffff54">따라서 Redis의 스테이트풀 집합을 생성하면,</font>

2835
01:01:16,460 --> 01:01:19,500
the pods will be called Redis0, Redis1, Redis2,

2836
01:01:16,460 --> 01:01:19,500
<font color="#ffff54">파드는 Redis0, Redis1, Redis2라고 불릴 것이다,</font>

2837
01:01:19,500 --> 01:01:21,500
with an ordinal as they get created.

2838
01:01:19,500 --> 01:01:21,500
<font color="#ffff54">생성될 때 서수를 사용한다.</font>

2839
01:01:21,500 --> 01:01:22,900
So you can predict the name

2840
01:01:21,500 --> 01:01:22,900
<font color="#ffff54">따라서 이름을 예측할 수 있습니다.</font>

2841
01:01:22,900 --> 01:01:25,579
and that name will be persistent, it won't go away.

2842
01:01:22,900 --> 01:01:25,579
<font color="#ffff54">그리고 그 이름은 사라지지 않고 지속될 것입니다.</font>

2843
01:01:25,579 --> 01:01:26,980
In other words, the Kafka guy

2844
01:01:25,579 --> 01:01:26,980
<font color="#ffff54">다시 말해, 카프카라는 사람은</font>

2845
01:01:26,980 --> 01:01:30,720
that's servicing the NASDAQ market data,

2846
01:01:26,980 --> 01:01:30,720
<font color="#ffff54">나스닥 시장 데이터를 서비스하고 있습니다,</font>

2847
01:01:30,720 --> 01:01:33,559
when it crashes, it's gonna fire back up over here

2848
01:01:30,720 --> 01:01:33,559
<font color="#ffff54">충돌하면 이쪽에서 다시 시작됩니다.</font>

2849
01:01:33,559 --> 01:01:37,620
and it's gonna still be Kafka7 with the NASDAQ data.

2850
01:01:33,559 --> 01:01:37,620
<font color="#ffff54">여전히 나스닥 데이터와 함께 카프카7이 있을 겁니다.</font>

2851
01:01:37,620 --> 01:01:40,519
And the volume it was using is gonna chase it.

2852
01:01:37,620 --> 01:01:40,519
<font color="#ffff54">그리고 사용하던 볼륨이 그것을 쫓아갈 것입니다.</font>

2853
01:01:41,380 --> 01:01:42,539
And it's network-attachable.

2854
01:01:41,380 --> 01:01:42,539
<font color="#ffff54">그리고 네트워크에 연결할 수 있습니다.</font>

2855
01:01:42,539 --> 01:01:44,740
So that's what we want in a stateful set.

2856
01:01:42,539 --> 01:01:44,740
<font color="#ffff54">이것이 바로 우리가 스테이트풀 세트에서 원하는 것입니다.</font>

2857
01:01:44,740 --> 01:01:47,140
And so if I need to look up Kafka7,

2858
01:01:44,740 --> 01:01:47,140
<font color="#ffff54">그래서 만약 제가 카프카7을 조회해야 한다면요,</font>

2859
01:01:47,140 --> 01:01:49,660
I don't wanna fix myself on the IP.

2860
01:01:47,140 --> 01:01:49,660
<font color="#ffff54">IP에 집착하고 싶지 않아요.</font>

2861
01:01:49,660 --> 01:01:51,559
What if it gets punted to a new machine

2862
01:01:49,660 --> 01:01:51,559
<font color="#ffff54">새 컴퓨터로 전송되면 어떻게 하죠?</font>

2863
01:01:51,559 --> 01:01:53,099
and gets a different IP?

2864
01:01:51,559 --> 01:01:53,099
<font color="#ffff54">다른 IP를 얻으면?</font>

2865
01:01:53,099 --> 01:01:54,860
I wanna use the DNS name, right?

2866
01:01:53,099 --> 01:01:54,860
<font color="#ffff54">DNS 이름을 사용하고 싶지 않나요?</font>

2867
01:01:54,860 --> 01:01:57,980
I wanna be abstract from the machinery of the networking.

2868
01:01:54,860 --> 01:01:57,980
<font color="#ffff54">나는 네트워킹의 기계로부터 추상화되고 싶다.</font>

2869
01:01:57,980 --> 01:02:00,980
And so I could say, hey, Redis1.redis.datans,

2870
01:01:57,980 --> 01:02:00,980
<font color="#ffff54">그래서 저는 이렇게 말할 수 있죠, Redis1.redis.datans,</font>

2871
01:02:03,140 --> 01:02:05,860
which is my namespace, service cluster local,

2872
01:02:03,140 --> 01:02:05,860
<font color="#ffff54">내 네임스페이스, 서비스 클러스터 로컬입니다,</font>

2873
01:02:05,860 --> 01:02:07,940
let's say that's the guy who has the NASDAQ data,

2874
01:02:05,860 --> 01:02:07,940
<font color="#ffff54">이 사람이 나스닥 데이터를 가진 사람이라고 가정해 봅시다,</font>

2875
01:02:07,940 --> 01:02:09,820
then I would just connect to that guy every time.

2876
01:02:07,940 --> 01:02:09,820
<font color="#ffff54">그러면 저는 매번 그 사람에게 연결할 것입니다.</font>

2877
01:02:09,820 --> 01:02:11,880
And I would always get the NASDAQ data.

2878
01:02:09,820 --> 01:02:11,880
<font color="#ffff54">그리고 저는 항상 나스닥 데이터를 얻었습니다.</font>

2879
01:02:11,880 --> 01:02:13,660
So that's what a headless service brings to the table.

2880
01:02:11,880 --> 01:02:13,660
<font color="#ffff54">이것이 바로 헤드리스 서비스의 장점입니다.</font>

2881
01:02:13,660 --> 01:02:18,140
It creates this DNS structure for stateful pods.

2882
01:02:13,660 --> 01:02:18,140
<font color="#ffff54">스테이트풀 파드를 위한 이 DNS 구조를 생성합니다.</font>

2883
01:02:18,140 --> 01:02:20,460
And generally, that's why you use a headless service

2884
01:02:18,140 --> 01:02:20,460
<font color="#ffff54">일반적으로 헤드리스 서비스를 사용하는 이유는 다음과 같다.</font>

2885
01:02:20,460 --> 01:02:22,260
when you have stateful pods.

2886
01:02:20,460 --> 01:02:22,260
<font color="#ffff54">스테이트풀 파드가 있을 때.</font>

2887
01:02:22,260 --> 01:02:25,240
So overriding the DNS is also possible.

2888
01:02:22,260 --> 01:02:25,240
<font color="#ffff54">따라서 DNS를 재정의하는 것도 가능하다.</font>

2889
01:02:25,240 --> 01:02:27,940
What if you're an administrator and you have to run a pod

2890
01:02:25,240 --> 01:02:27,940
<font color="#ffff54">관리자가 파드를 실행해야 하는 경우 어떻게 해야 하나요?</font>

2891
01:02:27,940 --> 01:02:31,600
and that pod needs to talk to an external DNS system?

2892
01:02:27,940 --> 01:02:31,600
<font color="#ffff54">해당 파드가 외부 DNS 시스템과 통신해야 한다면?</font>

2893
01:02:31,600 --> 01:02:33,260
You don't want it going to the internal one,

2894
01:02:31,600 --> 01:02:33,260
<font color="#ffff54">내부로 가는 것을 원하지 않는다,</font>

2895
01:02:33,260 --> 01:02:34,740
you wanna go into the external one.

2896
01:02:33,260 --> 01:02:34,740
<font color="#ffff54">외부로 가고 싶어.</font>

2897
01:02:34,740 --> 01:02:38,140
You can set up your resolve.conf as custom as you like.

2898
01:02:34,740 --> 01:02:38,140
<font color="#ffff54">resolve.conf를 원하는 대로 설정할 수 있습니다.</font>

2899
01:02:38,139 --> 01:02:40,519
A resolve.conf is generally gonna have a name server

2900
01:02:38,139 --> 01:02:40,519
<font color="#ffff54">resolve.conf에는 일반적으로 다음과 같은 네임 서버가 있습니다.</font>

2901
01:02:40,519 --> 01:02:44,420
to connect to, searches, so suffixes that you would add.

2902
01:02:40,519 --> 01:02:44,420
<font color="#ffff54">연결할 네임 서버, 검색, 접미사를 추가할 수 있습니다.</font>

2903
01:02:44,420 --> 01:02:46,440
If I look for web, it's gonna work.

2904
01:02:44,420 --> 01:02:46,440
<font color="#ffff54">웹을 찾으면 작동합니다.</font>

2905
01:02:46,440 --> 01:02:47,279
Why?

2906
01:02:46,440 --> 01:02:47,279
<font color="#ffff54">왜?</font>

2907
01:02:47,279 --> 01:02:50,079
Because there's a suffix in there that is gonna specify

2908
01:02:47,279 --> 01:02:50,079
<font color="#ffff54">왜냐면 거기에 접미사가 있어서</font>

2909
01:02:50,079 --> 01:02:53,619
mynamespace.service.whatever my cluster suffix is.

2910
01:02:50,079 --> 01:02:53,619
<font color="#ffff54">내 클러스터 접미사가 뭐든간에.</font>

2911
01:02:53,619 --> 01:02:55,619
I can just look up the service and it works.

2912
01:02:53,619 --> 01:02:55,619
<font color="#ffff54">서비스를 조회하면 작동합니다.</font>

2913
01:02:55,619 --> 01:02:57,559
If I wanna look up a service in another namespace,

2914
01:02:55,619 --> 01:02:57,559
<font color="#ffff54">다른 네임스페이스에서 서비스를 조회하고 싶은 경우,</font>

2915
01:02:57,559 --> 01:03:01,299
I can just say service.othernamespace and it will work

2916
01:02:57,559 --> 01:03:01,299
<font color="#ffff54">서비스닷오너스페이스라고 하면 작동합니다.</font>

2917
01:03:01,299 --> 01:03:04,059
because there's multiple search paths

2918
01:03:01,299 --> 01:03:04,059
<font color="#ffff54">여러 검색 경로가 있기 때문입니다.</font>

2919
01:03:04,059 --> 01:03:06,900
for each piece of the DNS name.

2920
01:03:04,059 --> 01:03:06,900
<font color="#ffff54">의 각 부분에 대해</font>

2921
01:03:06,940 --> 01:03:08,800
And then finally you have options that you can set.

2922
01:03:06,940 --> 01:03:08,800
<font color="#ffff54">마지막으로 설정할 수 있는 옵션이 있습니다.</font>

2923
01:03:08,800 --> 01:03:11,440
So this is, if you're not a DNS guru, you can ignore this,

2924
01:03:08,800 --> 01:03:11,440
<font color="#ffff54">DNS 전문가가 아니라면 무시해도 됩니다,</font>

2925
01:03:11,440 --> 01:03:13,460
but basically these are the ways that you can override

2926
01:03:11,440 --> 01:03:13,460
<font color="#ffff54">하지만 기본적으로 다음과 같은 방법으로 재정의할 수 있습니다.</font>

2927
01:03:13,460 --> 01:03:14,980
what's in the resolve.conf.

2928
01:03:13,460 --> 01:03:14,980
<font color="#ffff54">resolve.conf에 있는 내용.</font>

2929
01:03:14,980 --> 01:03:17,300
So step three, playing around with DNS.

2930
01:03:14,980 --> 01:03:17,300
<font color="#ffff54">3단계, DNS를 가지고 노는 단계입니다.</font>

2931
01:03:17,300 --> 01:03:21,579
Let's give everybody, let's say until 10 after

2932
01:03:17,300 --> 01:03:21,579
<font color="#ffff54">모든 사람에게 10시 이후까지 시간을 주자.</font>

2933
01:03:21,579 --> 01:03:22,579
to work through that.

2934
01:03:21,579 --> 01:03:22,579
<font color="#ffff54">시간을 주자.</font>

2935
01:03:24,740 --> 01:03:25,720
Seven minutes.

2936
01:03:24,740 --> 01:03:25,720
<font color="#ffff54">7분 남았습니다.</font>

2937
01:03:31,420 --> 01:03:32,460
Again, go ahead and work on your own.

2938
01:03:31,420 --> 01:03:32,460
<font color="#ffff54">다시 한번, 혼자서 작업하세요.</font>

2939
01:03:32,460 --> 01:03:33,820
I'm just gonna, for the virtual folks

2940
01:03:32,460 --> 01:03:33,820
<font color="#ffff54">난 그냥 가상 사람들을 위해</font>

2941
01:03:33,820 --> 01:03:35,019
and for people who don't have a laptop,

2942
01:03:33,820 --> 01:03:35,019
<font color="#ffff54">그리고 노트북이 없는 사람들을 위해,</font>

2943
01:03:35,019 --> 01:03:36,820
I'll just give you a preview here.

2944
01:03:35,019 --> 01:03:36,820
<font color="#ffff54">여기서 미리 알려드리겠습니다.</font>

2945
01:03:37,780 --> 01:03:40,660
So let's see, did I clean up after myself last time?

2946
01:03:37,780 --> 01:03:40,660
<font color="#ffff54">어디 보자, 내가 지난번에 청소는 했나?</font>

2947
01:03:41,519 --> 01:03:42,360
I did not.

2948
01:03:41,519 --> 01:03:42,360
<font color="#ffff54">안 했어.</font>

2949
01:03:42,360 --> 01:03:43,280
Let me go ahead and do that.

2950
01:03:42,360 --> 01:03:43,280
<font color="#ffff54">내가 할게.</font>

2951
01:03:44,220 --> 01:03:47,320
So I'm gonna kudos delete some stuff real quick.

2952
01:03:44,220 --> 01:03:47,320
<font color="#ffff54">몇 개만 빨리 삭제할게요.</font>

2953
01:03:54,220 --> 01:03:56,460
All right, so on the DNS side,

2954
01:03:54,220 --> 01:03:56,460
<font color="#ffff54">좋아, 그럼 DNS 쪽에서,</font>

2955
01:03:56,460 --> 01:03:58,539
we're gonna create a deployment again.

2956
01:03:56,460 --> 01:03:58,539
<font color="#ffff54">배포를 다시 생성하겠습니다.</font>

2957
01:03:58,539 --> 01:03:59,380
So.

2958
01:03:58,539 --> 01:03:59,380
<font color="#ffff54">그럼.</font>

2959
01:04:05,300 --> 01:04:06,860
And then we're gonna expose it.

2960
01:04:05,300 --> 01:04:06,860
<font color="#ffff54">그리고 우리는 그것을 폭로할 것이다.</font>

2961
01:04:06,860 --> 01:04:09,219
This is a cheeky way to create a service.

2962
01:04:06,860 --> 01:04:09,219
<font color="#ffff54">이것은 서비스를 만드는 건방진 방법입니다.</font>

2963
01:04:10,259 --> 01:04:11,239
All right, it creates a service

2964
01:04:10,259 --> 01:04:11,239
<font color="#ffff54">좋아, 서비스를 생성합니다.</font>

2965
01:04:11,239 --> 01:04:13,059
that's wired to that deployment,

2966
01:04:11,239 --> 01:04:13,059
<font color="#ffff54">해당 배포에 연결된 서비스를 생성합니다,</font>

2967
01:04:13,059 --> 01:04:16,380
so it figures out what labels to use automatically.

2968
01:04:13,059 --> 01:04:16,380
<font color="#ffff54">그래서 어떤 레이블을 사용할지 자동으로 알아냅니다.</font>

2969
01:04:16,380 --> 01:04:20,440
And now I'm going to run a client,

2970
01:04:16,380 --> 01:04:20,440
<font color="#ffff54">이제 클라이언트를 실행해 보겠습니다,</font>

2971
01:04:20,440 --> 01:04:25,059
and we're gonna look around at how we can resolve the name

2972
01:04:20,440 --> 01:04:25,059
<font color="#ffff54">그리고 어떻게 이름을 확인할 수 있는지 살펴볼 것입니다.</font>

2973
01:04:25,059 --> 01:04:26,199
instead of the IP.

2974
01:04:25,059 --> 01:04:26,199
<font color="#ffff54">를 입력합니다.</font>

2975
01:04:27,040 --> 01:04:29,120
So BusyBox image has to download.

2976
01:04:27,040 --> 01:04:29,120
<font color="#ffff54">따라서 BusyBox 이미지를 다운로드해야 합니다.</font>

2977
01:04:29,120 --> 01:04:30,120
We'll let it do that.

2978
01:04:29,120 --> 01:04:30,120
<font color="#ffff54">그렇게 하도록 놔두겠습니다.</font>

2979
01:04:30,120 --> 01:04:33,480
And the idea is, let's just try first to W,

2980
01:04:30,120 --> 01:04:33,480
<font color="#ffff54">일단 W로 먼저 시도해 봅시다,</font>

2981
01:04:33,480 --> 01:04:36,360
there's no curl in BusyBox, so we'll W get the website.

2982
01:04:33,480 --> 01:04:36,360
<font color="#ffff54">BusyBox에 컬이 없으므로 웹사이트를 W로 가져옵니다.</font>

2983
01:04:36,360 --> 01:04:38,640
And we're gonna, this is DNS, right?

2984
01:04:36,360 --> 01:04:38,640
<font color="#ffff54">여기가 DNS 맞죠?</font>

2985
01:04:38,640 --> 01:04:41,000
I'm saying, hey, look up website.

2986
01:04:38,640 --> 01:04:41,000
<font color="#ffff54">이봐, 웹사이트를 찾아봐.</font>

2987
01:04:42,120 --> 01:04:44,080
I mean, how does that work, right?

2988
01:04:42,120 --> 01:04:44,080
<font color="#ffff54">그게 어떻게 작동하죠?</font>

2989
01:04:44,080 --> 01:04:44,980
How does that work?

2990
01:04:44,080 --> 01:04:44,980
<font color="#ffff54">어떻게 작동하죠?</font>

2991
01:04:44,980 --> 01:04:46,960
It works, but how does it work?

2992
01:04:44,980 --> 01:04:46,960
<font color="#ffff54">작동하지만 어떻게 작동하죠?</font>

2993
01:04:46,960 --> 01:04:49,800
Well, let's take a look at the DNS machinery.

2994
01:04:46,960 --> 01:04:49,800
<font color="#ffff54">그럼, DNS 메커니즘을 살펴봅시다.</font>

2995
01:04:49,800 --> 01:04:51,160
All right, the first thing that we would wanna do

2996
01:04:49,800 --> 01:04:51,160
<font color="#ffff54">좋아요, 가장 먼저 할 일은</font>

2997
01:04:51,160 --> 01:04:52,740
is look at the resolve.conf.

2998
01:04:51,160 --> 01:04:52,740
<font color="#ffff54">resolve.conf를 살펴보는 것입니다.</font>

2999
01:04:53,620 --> 01:04:56,140
Right, whenever your resolver,

3000
01:04:53,620 --> 01:04:56,140
<font color="#ffff54">네, 리졸버가</font>

3001
01:04:56,140 --> 01:04:59,080
the part of the Linux library or the, you know,

3002
01:04:56,140 --> 01:04:59,080
<font color="#ffff54">리눅스 라이브러리의 일부이거나,</font>

3003
01:04:59,080 --> 01:05:02,740
the glibc or whatever it is that's doing your resolution,

3004
01:04:59,080 --> 01:05:02,740
<font color="#ffff54">해상도를 높이는 glibc나 뭐든 간에요,</font>

3005
01:05:02,740 --> 01:05:05,380
it's probably going to a cache.

3006
01:05:02,740 --> 01:05:05,380
<font color="#ffff54">아마 캐시로 가고 있을 겁니다.</font>

3007
01:05:05,380 --> 01:05:06,820
If it doesn't see the name there,

3008
01:05:05,380 --> 01:05:06,820
<font color="#ffff54">거기에 이름이 보이지 않는다면,</font>

3009
01:05:06,820 --> 01:05:08,100
then it's looking in your atc host.

3010
01:05:06,820 --> 01:05:08,100
<font color="#ffff54">이면 atc 호스트에서 찾고 있는 것입니다.</font>

3011
01:05:08,100 --> 01:05:10,720
If it doesn't see the name there, then it's going to DNS.

3012
01:05:08,100 --> 01:05:10,720
<font color="#ffff54">이름이 표시되지 않으면 DNS로 이동하는 것입니다.</font>

3013
01:05:10,720 --> 01:05:12,440
So where does it find the DNS server?

3014
01:05:10,720 --> 01:05:12,440
<font color="#ffff54">그러면 어디에서 DNS 서버를 찾을까요?</font>

3015
01:05:12,440 --> 01:05:13,900
Well, there you go, myresolve.conf.

3016
01:05:12,440 --> 01:05:13,900
<font color="#ffff54">자, 여기 myresolve.conf가 있습니다.</font>

3017
01:05:13,900 --> 01:05:16,300
Recognize that IP?

3018
01:05:13,900 --> 01:05:16,300
<font color="#ffff54">이 IP 알아보시겠어요?</font>

3019
01:05:16,300 --> 01:05:18,260
It's 10.96.0.1.

3020
01:05:16,300 --> 01:05:18,260
<font color="#ffff54">10.96.0.1입니다.</font>

3021
01:05:18,260 --> 01:05:20,180
That's our core DNS service.

3022
01:05:18,260 --> 01:05:20,180
<font color="#ffff54">이것이 우리의 핵심 DNS 서비스입니다.</font>

3023
01:05:20,180 --> 01:05:22,820
It's the cluster IP of our core DNS.

3024
01:05:20,180 --> 01:05:22,820
<font color="#ffff54">코어 DNS의 클러스터 IP입니다.</font>

3025
01:05:22,820 --> 01:05:24,620
Kubernetes eats its own dog food.

3026
01:05:22,820 --> 01:05:24,620
<font color="#ffff54">쿠버네티스가 자신의 개밥을 먹는다.</font>

3027
01:05:24,620 --> 01:05:26,880
Then look at the search suffixes.

3028
01:05:24,620 --> 01:05:26,880
<font color="#ffff54">그런 다음 검색 접미사를 살펴본다.</font>

3029
01:05:26,880 --> 01:05:30,300
I'm in the default namespace on cluster.local.

3030
01:05:26,880 --> 01:05:30,300
<font color="#ffff54">저는 cluster.local의 기본 네임스페이스에 있습니다.</font>

3031
01:05:30,300 --> 01:05:33,940
So when you make the name, right,

3032
01:05:30,300 --> 01:05:33,940
<font color="#ffff54">그래서 이름을 만들 때, 맞습니다,</font>

3033
01:05:33,940 --> 01:05:38,940
if you fully qualify it and you say .default,

3034
01:05:33,940 --> 01:05:38,940
<font color="#ffff54">완전히 정규화하고 .default라고 하면,</font>

3035
01:05:40,180 --> 01:05:45,180
.service, .cluster, .local, right,

3036
01:05:40,180 --> 01:05:45,180
<font color="#ffff54">.service, .cluster, .local, 오른쪽,</font>

3037
01:05:47,700 --> 01:05:48,900
that's what's happening, right?

3038
01:05:47,700 --> 01:05:48,900
<font color="#ffff54">이게 무슨 일이지?</font>

3039
01:05:48,900 --> 01:05:51,019
We're just adding that search suffix

3040
01:05:48,900 --> 01:05:51,019
<font color="#ffff54">검색 접미사만 추가하면 됩니다.</font>

3041
01:05:51,019 --> 01:05:52,220
and it's a fully qualified name.

3042
01:05:51,019 --> 01:05:52,220
<font color="#ffff54">정규화된 이름입니다.</font>

3043
01:05:52,220 --> 01:05:55,260
It won't conflict with website services

3044
01:05:52,220 --> 01:05:55,260
<font color="#ffff54">웹사이트 서비스와 충돌하지 않습니다.</font>

3045
01:05:55,260 --> 01:05:56,539
and other namespaces.

3046
01:05:55,260 --> 01:05:56,539
<font color="#ffff54">및 다른 네임스페이스와 충돌하지 않습니다.</font>

3047
01:05:56,539 --> 01:05:58,860
What if I want to get to a website service

3048
01:05:56,539 --> 01:05:58,860
<font color="#ffff54">웹사이트 서비스로 이동하려면 어떻게 해야 하나요?</font>

3049
01:05:58,860 --> 01:05:59,960
in another namespace?

3050
01:05:58,860 --> 01:05:59,960
<font color="#ffff54">다른 네임스페이스에 있나요?</font>

3051
01:05:59,960 --> 01:06:01,639
Well, you can, right?

3052
01:05:59,960 --> 01:06:01,639
<font color="#ffff54">할 수 있죠?</font>

3053
01:06:01,639 --> 01:06:05,860
You can simply say website.prod, let's say.

3054
01:06:01,639 --> 01:06:05,860
<font color="#ffff54">웹사이트.prod라고 하면 됩니다.</font>

3055
01:06:05,860 --> 01:06:06,700
Now that's not going to work

3056
01:06:05,860 --> 01:06:06,700
<font color="#ffff54">이제 작동하지 않습니다.</font>

3057
01:06:06,700 --> 01:06:08,019
because I don't have a prod namespace,

3058
01:06:06,700 --> 01:06:08,019
<font color="#ffff54">프로드 네임스페이스가 없으니까요,</font>

3059
01:06:08,019 --> 01:06:09,900
but you can see it doesn't work, right?

3060
01:06:08,019 --> 01:06:09,900
<font color="#ffff54">하지만 작동하지 않는다는 것을 알 수 있죠?</font>

3061
01:06:09,900 --> 01:06:12,260
It would have worked if it was in default,

3062
01:06:09,900 --> 01:06:12,260
<font color="#ffff54">기본값이었다면 작동했을 겁니다,</font>

3063
01:06:12,260 --> 01:06:14,780
but you said go look in prod and there isn't one there.

3064
01:06:12,260 --> 01:06:14,780
<font color="#ffff54">하지만 프로드를 찾아보라고 했는데 거기에는 없습니다.</font>

3065
01:06:14,780 --> 01:06:18,420
And so notice that this guy was resolving

3066
01:06:14,780 --> 01:06:18,420
<font color="#ffff54">그래서 이 사람이 다음을 해결하고 있었음을 알 수 있습니다.</font>

3067
01:06:18,900 --> 01:06:22,019
with service.cluster.local, the second search, right,

3068
01:06:18,900 --> 01:06:22,019
<font color="#ffff54">두 번째 검색인 service.cluster.local로요,</font>

3069
01:06:22,019 --> 01:06:24,099
suffix, and then we have cluster.local

3070
01:06:22,019 --> 01:06:24,099
<font color="#ffff54">접미사를 추가하고, 그 다음에는 클러스터.local</font>

3071
01:06:24,099 --> 01:06:26,780
and then whatever gets inherited from the host machines.

3072
01:06:24,099 --> 01:06:26,780
<font color="#ffff54">그리고 호스트 머신에서 무엇이든 상속받습니다.</font>

3073
01:06:26,780 --> 01:06:27,599
All right, cool.

3074
01:06:26,780 --> 01:06:27,599
<font color="#ffff54">좋아, 멋지네.</font>

3075
01:06:27,599 --> 01:06:30,700
So we now have the idea of like how the pod side

3076
01:06:27,599 --> 01:06:30,700
<font color="#ffff54">이제 파드 측에서 다음과 같은 아이디어를 얻었습니다.</font>

3077
01:06:30,700 --> 01:06:32,099
of it's working, right?

3078
01:06:30,700 --> 01:06:32,099
<font color="#ffff54">작동하고 있는 거죠?</font>

3079
01:06:32,099 --> 01:06:35,180
And I'm just going to exit out of this guy.

3080
01:06:32,099 --> 01:06:35,180
<font color="#ffff54">이제 이 녀석에서 빠져나갈게요.</font>

3081
01:06:36,460 --> 01:06:40,700
And if we do a kubectl get all

3082
01:06:36,460 --> 01:06:40,700
<font color="#ffff54">그리고 만약 우리가 kubectl을 실행하면</font>

3083
01:06:40,700 --> 01:06:44,780
in the namespace kubecystem,

3084
01:06:40,700 --> 01:06:44,780
<font color="#ffff54">네임스페이스 kubecystem에서,</font>

3085
01:06:44,780 --> 01:06:47,099
you know, there's the machinery, right?

3086
01:06:44,780 --> 01:06:47,099
<font color="#ffff54">기계가 있잖아, 그렇지?</font>

3087
01:06:47,139 --> 01:06:51,219
In kubecystem, we have the core DNS deployment

3088
01:06:47,139 --> 01:06:51,219
<font color="#ffff54">쿠버시스템에는 핵심 DNS 배포가 있다.</font>

3089
01:06:51,219 --> 01:06:53,940
with two pods and we have our replica set

3090
01:06:51,219 --> 01:06:53,940
<font color="#ffff54">두 개의 파드가 있고 레플리카 세트가 있다.</font>

3091
01:06:53,940 --> 01:06:56,259
and we have the two pods up there.

3092
01:06:53,940 --> 01:06:56,259
<font color="#ffff54">저 위에 두 개의 파드가 있습니다.</font>

3093
01:06:56,259 --> 01:06:58,699
And then there's the core DNS service.

3094
01:06:56,259 --> 01:06:58,699
<font color="#ffff54">그리고 핵심 DNS 서비스가 있습니다.</font>

3095
01:06:58,699 --> 01:07:00,659
So those are the pieces of the puzzle.

3096
01:06:58,699 --> 01:07:00,659
<font color="#ffff54">이것이 퍼즐의 조각입니다.</font>

3097
01:07:02,099 --> 01:07:05,659
All right, and the lab goes on and it has you play

3098
01:07:02,099 --> 01:07:05,659
<font color="#ffff54">자, 이제 실험은 계속되고, 여러분은</font>

3099
01:07:05,659 --> 01:07:07,299
around a little bit with some of this stuff.

3100
01:07:05,659 --> 01:07:07,299
<font color="#ffff54">이걸로 좀 놀아보자.</font>

3101
01:07:07,299 --> 01:07:09,339
Then it has you create a headless service.

3102
01:07:07,299 --> 01:07:09,339
<font color="#ffff54">그런 다음 헤드리스 서비스를 만들게 합니다.</font>

3103
01:07:11,980 --> 01:07:13,539
Got a couple of minutes, I might do that real quick.

3104
01:07:11,980 --> 01:07:13,539
<font color="#ffff54">몇 분 남았으니 빨리 해볼게요.</font>

3105
01:07:13,539 --> 01:07:15,719
So I'm going to go ahead and create this headless service.

3106
01:07:13,539 --> 01:07:15,719
<font color="#ffff54">그럼 이제 이 헤드리스 서비스를 만들어볼게요.</font>

3107
01:07:15,720 --> 01:07:17,440
The special thing about the headless service

3108
01:07:15,720 --> 01:07:17,440
<font color="#ffff54">헤드리스 서비스의 특별한 점</font>

3109
01:07:17,440 --> 01:07:21,440
over a normal service is that it has no cluster IP.

3110
01:07:17,440 --> 01:07:21,440
<font color="#ffff54">일반 서비스에 비해 특별한 점은 클러스터 IP가 없다는 것입니다.</font>

3111
01:07:25,200 --> 01:07:29,040
And so you can see at the bottom here, cluster IP none.

3112
01:07:25,200 --> 01:07:29,040
<font color="#ffff54">그래서 여기 하단에 클러스터 IP가 없는 것을 볼 수 있습니다.</font>

3113
01:07:38,360 --> 01:07:41,920
All right, and then the lab has us take a look

3114
01:07:38,360 --> 01:07:41,920
<font color="#ffff54">자, 이제 실험실에서 다음을 살펴봅니다.</font>

3115
01:07:41,920 --> 01:07:43,100
at the cluster IP service.

3116
01:07:41,920 --> 01:07:43,100
<font color="#ffff54">클러스터 IP 서비스에서.</font>

3117
01:07:43,100 --> 01:07:45,200
We see that he's got no cluster IP.

3118
01:07:43,100 --> 01:07:45,200
<font color="#ffff54">클러스터 IP가 없음을 알 수 있습니다.</font>

3119
01:07:45,640 --> 01:07:47,560
And then we're going to jump back into that pod

3120
01:07:45,640 --> 01:07:47,560
<font color="#ffff54">그리고 다시 해당 파드로 이동합니다.</font>

3121
01:07:47,560 --> 01:07:49,680
and we're going to do some NS lookups to see

3122
01:07:47,560 --> 01:07:49,680
<font color="#ffff54">그리고 NS 조회를 수행하여 다음을 확인합니다.</font>

3123
01:07:49,680 --> 01:07:52,440
what kind of DNS trouble we can get into.

3124
01:07:49,680 --> 01:07:52,440
<font color="#ffff54">어떤 종류의 DNS 문제가 발생할 수 있는지 확인합니다.</font>

3125
01:07:52,440 --> 01:07:57,440
So I'm going to kubectl attach my input stream

3126
01:07:52,440 --> 01:07:57,440
<font color="#ffff54">그래서 나는 내 입력 스트림을 kubectl에 첨부한다.</font>

3127
01:07:58,680 --> 01:08:00,940
to what was it called, client.

3128
01:07:58,680 --> 01:08:00,940
<font color="#ffff54">클라이언트라는 이름의 스트림에 연결한다.</font>

3129
01:08:03,840 --> 01:08:05,440
Client, there we go, okay.

3130
01:08:03,840 --> 01:08:05,440
<font color="#ffff54">클라이언트, 알겠습니다.</font>

3131
01:08:05,440 --> 01:08:07,280
And so let's go ahead and try that NS lookup

3132
01:08:05,440 --> 01:08:07,280
<font color="#ffff54">이제 NS 조회를 시도해 보겠습니다.</font>

3133
01:08:07,280 --> 01:08:10,120
on headless website that we just created.

3134
01:08:07,280 --> 01:08:10,120
<font color="#ffff54">방금 만든 헤드리스 웹사이트에서요.</font>

3135
01:08:10,120 --> 01:08:12,320
And you can see, I don't get back a single IP,

3136
01:08:10,120 --> 01:08:12,320
<font color="#ffff54">보시다시피, 하나의 IP도 반환되지 않습니다,</font>

3137
01:08:12,320 --> 01:08:13,880
I get back all of them.

3138
01:08:12,320 --> 01:08:13,880
<font color="#ffff54">전부 다 돌아옵니다.</font>

3139
01:08:13,880 --> 01:08:16,600
There's three pods, I get all three of them.

3140
01:08:13,880 --> 01:08:16,600
<font color="#ffff54">세 개의 포드가 있는데, 세 개를 모두 가져옵니다.</font>

3141
01:08:16,600 --> 01:08:21,159
And some DNS errors, but you get the idea, right?

3142
01:08:16,600 --> 01:08:21,159
<font color="#ffff54">그리고 몇 가지 DNS 오류도 있지만, 무슨 말인지 아시겠죠?</font>

3143
01:08:21,159 --> 01:08:23,840
So the lookup worked, we got the three pods.

3144
01:08:21,159 --> 01:08:23,840
<font color="#ffff54">조회는 성공했고, 세 개의 파드를 얻었습니다.</font>

3145
01:08:23,840 --> 01:08:26,720
And you can see that these three pods,

3146
01:08:23,840 --> 01:08:26,720
<font color="#ffff54">그리고 이 세 개의 파드를 볼 수 있습니다,</font>

3147
01:08:26,720 --> 01:08:29,279
they don't have unique identity.

3148
01:08:26,720 --> 01:08:29,279
<font color="#ffff54">고유한 정체성을 가지고 있지 않음을 알 수 있다.</font>

3149
01:08:29,279 --> 01:08:33,000
They're created by a deployment, they have random names.

3150
01:08:29,279 --> 01:08:33,000
<font color="#ffff54">배포에 의해 생성되며 임의의 이름을 가집니다.</font>

3151
01:08:33,000 --> 01:08:34,960
And so we just, hey, here are the IP addresses,

3152
01:08:33,000 --> 01:08:34,960
<font color="#ffff54">여기 IP 주소가 있습니다,</font>

3153
01:08:34,960 --> 01:08:36,720
if you want to connect to one, you can.

3154
01:08:34,960 --> 01:08:36,720
<font color="#ffff54">이 중 하나에 연결하고 싶으면 연결할 수 있습니다.</font>

3155
01:08:36,720 --> 01:08:40,020
But the idea then is to take this to the next level

3156
01:08:36,720 --> 01:08:40,020
<font color="#ffff54">하지만 다음 단계로 넘어가야 합니다.</font>

3157
01:08:40,020 --> 01:08:45,020
where we put the headless service on top of a stateful set.

3158
01:08:40,020 --> 01:08:45,020
<font color="#ffff54">헤드리스 서비스를 스테이트풀 세트 위에 올려놓는 것입니다.</font>

3159
01:08:45,200 --> 01:08:47,140
So that's this guy down here.

3160
01:08:45,200 --> 01:08:47,140
<font color="#ffff54">여기 이 녀석입니다.</font>

3161
01:08:47,140 --> 01:08:51,240
Note that a YAML file can have multiple YAML documents.

3162
01:08:47,140 --> 01:08:51,240
<font color="#ffff54">한 개의 YAML 파일에 여러 개의 YAML 문서가 있을 수 있다는 점에 유의하세요.</font>

3163
01:08:53,240 --> 01:08:55,580
And that's exactly what's going on in here.

3164
01:08:53,240 --> 01:08:55,580
<font color="#ffff54">이것이 바로 여기서 일어나고 있는 일입니다.</font>

3165
01:08:55,580 --> 01:08:58,540
We have the first part is our service, right?

3166
01:08:55,580 --> 01:08:58,540
<font color="#ffff54">첫 번째 부분은 우리 서비스죠?</font>

3167
01:08:58,540 --> 01:09:03,540
So that's just the service without the cluster IP, right?

3168
01:08:58,540 --> 01:09:03,540
<font color="#ffff54">클러스터 IP가 없는 서비스만 있는 거죠?</font>

3169
01:09:04,340 --> 01:09:06,160
The headless service, and then this is the stateful set.

3170
01:09:04,340 --> 01:09:06,160
<font color="#ffff54">헤드리스 서비스, 그리고 이것은 스테이트풀 세트입니다.</font>

3171
01:09:06,160 --> 01:09:08,400
We're saying, hey, we're going to pretend

3172
01:09:06,160 --> 01:09:08,400
<font color="#ffff54">이봐요, 우리는 마치</font>

3173
01:09:08,559 --> 01:09:11,599
that these nginx guys are actually stateful.

3174
01:09:08,559 --> 01:09:11,599
<font color="#ffff54">이 nginx 녀석들이 실제로 상태 저장소인 것처럼 말이죠.</font>

3175
01:09:11,599 --> 01:09:13,339
They're not, but it's all right.

3176
01:09:11,599 --> 01:09:13,339
<font color="#ffff54">그렇지 않지만 괜찮아요.</font>

3177
01:09:14,259 --> 01:09:19,259
And now let's, cube CTO apply minus F, that guy.

3178
01:09:14,259 --> 01:09:19,259
<font color="#ffff54">이제 큐브 CTO가 마이너스 F를 적용해 봅시다.</font>

3179
01:09:29,639 --> 01:09:32,619
Now what we can see is we have the,

3180
01:09:29,639 --> 01:09:32,619
<font color="#ffff54">이제 우리가 볼 수 있는 것은,</font>

3181
01:09:33,739 --> 01:09:38,339
we've got this new stateful set called web state, right?

3182
01:09:33,739 --> 01:09:38,339
<font color="#ffff54">웹 상태라는 새로운 상태 저장 집합이 생겼죠?</font>

3183
01:09:39,319 --> 01:09:43,720
And that web state has created a pod, web state zero.

3184
01:09:39,319 --> 01:09:43,720
<font color="#ffff54">그리고 그 웹 스테이트가 파드인 웹 스테이트 제로를 생성했다.</font>

3185
01:09:43,720 --> 01:09:46,360
So the pod gets the name of the stateful set

3186
01:09:43,720 --> 01:09:46,360
<font color="#ffff54">그래서 파드는 스테이트풀 세트의 이름을 얻는다.</font>

3187
01:09:46,360 --> 01:09:50,980
plus an ordinal, and if I cube CTL scale,

3188
01:09:46,360 --> 01:09:50,980
<font color="#ffff54">에 서수를 더하고, CTL 스케일을 큐브화하면,</font>

3189
01:09:53,960 --> 01:09:58,960
stateful set web state to replicas equal three,

3190
01:09:53,960 --> 01:09:58,960
<font color="#ffff54">상태 저장 웹 상태를 복제본으로 설정하면 3이 됩니다,</font>

3191
01:10:08,920 --> 01:10:10,640
you got to spell it right.

3192
01:10:08,920 --> 01:10:10,640
<font color="#ffff54">철자를 제대로 써야 합니다.</font>

3193
01:10:10,640 --> 01:10:12,199
Fortunately, there's a shortcut.

3194
01:10:10,640 --> 01:10:12,199
<font color="#ffff54">다행히도 지름길이 있습니다.</font>

3195
01:10:12,199 --> 01:10:13,600
All right, so that's scaled.

3196
01:10:12,199 --> 01:10:13,600
<font color="#ffff54">자, 이제 크기가 조정되었습니다.</font>

3197
01:10:15,279 --> 01:10:17,720
Now there we go, right?

3198
01:10:15,279 --> 01:10:17,720
<font color="#ffff54">이제 됐죠?</font>

3199
01:10:17,720 --> 01:10:19,360
Zero, one and two.

3200
01:10:17,720 --> 01:10:19,360
<font color="#ffff54">0, 1, 2</font>

3201
01:10:19,360 --> 01:10:24,360
So if we go back up and attach again to our previous guy,

3202
01:10:19,360 --> 01:10:24,360
<font color="#ffff54">다시 올라가서 이전 녀석에게 다시 연결합니다,</font>

3203
01:10:24,800 --> 01:10:29,800
and then we nslookup web state,

3204
01:10:24,800 --> 01:10:29,800
<font color="#ffff54">그리고 웹 상태를 조회합니다,</font>

3205
01:10:32,319 --> 01:10:33,680
let's just do that.

3206
01:10:32,319 --> 01:10:33,680
<font color="#ffff54">그냥 해봅시다.</font>

3207
01:10:33,680 --> 01:10:38,579
You can see that we get the lookup as always, right?

3208
01:10:33,680 --> 01:10:38,579
<font color="#ffff54">언제나처럼 조회가 되는 것을 볼 수 있지요?</font>

3209
01:10:38,579 --> 01:10:40,220
Web state is in fact a service,

3210
01:10:38,579 --> 01:10:40,220
<font color="#ffff54">웹 상태는 실제로 서비스입니다,</font>

3211
01:10:40,220 --> 01:10:43,860
but now what we can do is we can ask

3212
01:10:40,220 --> 01:10:43,860
<font color="#ffff54">하지만 이제 우리가 할 수 있는 것은 다음과 같이 물어볼 수 있습니다.</font>

3213
01:10:43,860 --> 01:10:45,460
for a different kind of query.

3214
01:10:43,860 --> 01:10:45,460
<font color="#ffff54">다른 종류의 쿼리를 요청할 수 있습니다.</font>

3215
01:10:46,460 --> 01:10:48,180
You can ask for an SRV query.

3216
01:10:46,460 --> 01:10:48,180
<font color="#ffff54">SRV 쿼리를 요청할 수 있습니다.</font>

3217
01:10:54,740 --> 01:10:56,260
Is it equal?

3218
01:10:54,740 --> 01:10:56,260
<font color="#ffff54">동일합니까?</font>

3219
01:10:56,260 --> 01:10:57,100
There we go.

3220
01:10:56,260 --> 01:10:57,100
<font color="#ffff54">됐어요.</font>

3221
01:10:57,100 --> 01:10:59,800
And you can see that over here, web state zero, one and two.

3222
01:10:57,100 --> 01:10:59,800
<font color="#ffff54">여기 웹 상태 0, 1, 2를 볼 수 있습니다.</font>

3223
01:10:59,800 --> 01:11:02,740
So we can identify these guys now

3224
01:10:59,800 --> 01:11:02,740
<font color="#ffff54">이제 이 녀석들을 식별할 수 있습니다.</font>

3225
01:11:02,760 --> 01:11:04,960
by their actual names.

3226
01:11:02,760 --> 01:11:04,960
<font color="#ffff54">그들의 실제 이름으로.</font>

3227
01:11:04,960 --> 01:11:09,479
And if we try to, for example, curl a specific one of them,

3228
01:11:04,960 --> 01:11:09,479
<font color="#ffff54">예를 들어 그중 특정 하나를 컬링하려고 하면 다음과 같습니다,</font>

3229
01:11:09,479 --> 01:11:11,000
we can say web state,

3230
01:11:09,479 --> 01:11:11,000
<font color="#ffff54">웹 상태라고 할 수 있습니다,</font>

3231
01:11:11,000 --> 01:11:13,739
I want to talk to specifically the NASDAQ guy, right?

3232
01:11:11,000 --> 01:11:13,739
<font color="#ffff54">특히 나스닥 담당자와 얘기하고 싶어요, 그렇죠?</font>

3233
01:11:15,279 --> 01:11:18,000
Because I don't want the New York Stock Exchange data.

3234
01:11:15,279 --> 01:11:18,000
<font color="#ffff54">뉴욕 증권 거래소 데이터는 필요 없으니까요.</font>

3235
01:11:18,000 --> 01:11:20,479
I want the NASDAQ guy, and he's number one.

3236
01:11:18,000 --> 01:11:20,479
<font color="#ffff54">난 나스닥에 있는 사람이 필요해, 그가 1등이야.</font>

3237
01:11:22,179 --> 01:11:24,079
And curl's not found, so I'll use wget.

3238
01:11:22,179 --> 01:11:24,079
<font color="#ffff54">curl을 찾을 수 없으니 wget을 사용하겠습니다.</font>

3239
01:11:27,840 --> 01:11:28,679
And there you go, right?

3240
01:11:27,840 --> 01:11:28,679
<font color="#ffff54">이제 됐죠?</font>

3241
01:11:28,679 --> 01:11:30,139
We hit the NGINX guy there.

3242
01:11:28,679 --> 01:11:30,139
<font color="#ffff54">저기 NGINX 놈을 공격했어.</font>

3243
01:11:30,160 --> 01:11:35,160
So that's DNS in its various flavors in Kubernetes, right?

3244
01:11:30,160 --> 01:11:35,160
<font color="#ffff54">이게 바로 쿠버네티스의 다양한 버전의 DNS죠?</font>

3245
01:11:35,200 --> 01:11:36,800
And of course, I mean, as you guys know,

3246
01:11:35,200 --> 01:11:36,800
<font color="#ffff54">물론, 여러분도 아시다시피,</font>

3247
01:11:36,800 --> 01:11:38,079
there's a lot more to know,

3248
01:11:36,800 --> 01:11:38,079
<font color="#ffff54">알아야 할 게 더 많아요,</font>

3249
01:11:38,079 --> 01:11:41,200
but the lab does start you down the road,

3250
01:11:38,079 --> 01:11:41,200
<font color="#ffff54">하지만 실험실에서 출발할 수 있어요,</font>

3251
01:11:41,200 --> 01:11:43,240
hopefully is pulling away the veil

3252
01:11:41,200 --> 01:11:43,240
<font color="#ffff54">희망은 베일을 벗기고 있다</font>

3253
01:11:43,240 --> 01:11:44,800
on some of the more confusing bits

3254
01:11:43,240 --> 01:11:44,800
<font color="#ffff54">좀 더 혼란스러운 부분들</font>

3255
01:11:44,800 --> 01:11:47,920
and the things that aren't obvious when you start off.

3256
01:11:44,800 --> 01:11:47,920
<font color="#ffff54">그리고 처음 시작할 때 명확하지 않은 것들.</font>

3257
01:11:47,920 --> 01:11:50,360
All right, so let's move into our next section,

3258
01:11:47,920 --> 01:11:50,360
<font color="#ffff54">자, 이제 다음 섹션으로 넘어가죠,</font>

3259
01:11:50,360 --> 01:11:52,200
accessing services from the outside.

3260
01:11:50,360 --> 01:11:52,200
<font color="#ffff54">외부에서 서비스에 액세스합니다.</font>

3261
01:11:52,200 --> 01:11:54,000
How do we get from the outside in?

3262
01:11:52,200 --> 01:11:54,000
<font color="#ffff54">외부에서 어떻게 들어가나요?</font>

3263
01:11:54,000 --> 01:11:55,680
Keep working on the labs if you want.

3264
01:11:54,000 --> 01:11:55,680
<font color="#ffff54">원한다면 실험실에서 계속 작업하세요.</font>

3265
01:11:55,680 --> 01:11:57,100
Let me in here.

3266
01:11:55,680 --> 01:11:57,100
<font color="#ffff54">들여보내줘.</font>

3267
01:11:57,120 --> 01:12:00,240
So outside access can be performed in lots of ways.

3268
01:11:57,120 --> 01:12:00,240
<font color="#ffff54">외부 접속은 여러 가지 방법으로 할 수 있습니다.</font>

3269
01:12:00,240 --> 01:12:05,240
At the end of the day, there's host port and node port,

3270
01:12:00,240 --> 01:12:05,240
<font color="#ffff54">결국 호스트 포트와 노드 포트가 있습니다,</font>

3271
01:12:06,800 --> 01:12:08,960
and a lot of stuff on top of them.

3272
01:12:06,800 --> 01:12:08,960
<font color="#ffff54">그리고 그 위에 많은 것들이 있습니다.</font>

3273
01:12:08,960 --> 01:12:13,960
Host port and node port handle 99.99%

3274
01:12:08,960 --> 01:12:13,960
<font color="#ffff54">호스트 포트와 노드 포트가 99.99%를 처리합니다.</font>

3275
01:12:14,039 --> 01:12:16,960
of the traffic flowing into a cluster,

3276
01:12:14,039 --> 01:12:16,960
<font color="#ffff54">클러스터로 유입되는 트래픽의 비율입니다,</font>

3277
01:12:16,960 --> 01:12:18,800
one of those two techniques.

3278
01:12:16,960 --> 01:12:18,800
<font color="#ffff54">이 두 가지 기술 중 하나입니다.</font>

3279
01:12:18,800 --> 01:12:19,740
So what does a host port do?

3280
01:12:18,800 --> 01:12:19,740
<font color="#ffff54">그렇다면 호스트 포트는 무엇을 할까요?</font>

3281
01:12:19,740 --> 01:12:21,240
It's not a service.

3282
01:12:19,740 --> 01:12:21,240
<font color="#ffff54">서비스가 아닙니다.</font>

3283
01:12:21,240 --> 01:12:24,880
In a pod, you can say, take this port on the host

3284
01:12:21,240 --> 01:12:24,880
<font color="#ffff54">파드에서, 호스트에서 이 포트를 가져가라고 말할 수 있다.</font>

3285
01:12:24,900 --> 01:12:28,460
and map it to the pod's listening port, right?

3286
01:12:24,900 --> 01:12:28,460
<font color="#ffff54">를 파드의 리스닝 포트에 매핑하면 되겠죠?</font>

3287
01:12:28,460 --> 01:12:29,699
And that will work.

3288
01:12:28,460 --> 01:12:29,699
<font color="#ffff54">그러면 작동합니다.</font>

3289
01:12:29,699 --> 01:12:32,779
The problem with that is it's not very friendly

3290
01:12:29,699 --> 01:12:32,779
<font color="#ffff54">문제는 그다지 친숙하지 않다는 겁니다.</font>

3291
01:12:32,779 --> 01:12:33,980
to the cluster, right?

3292
01:12:32,779 --> 01:12:33,980
<font color="#ffff54">클러스터로 이동하는 거죠?</font>

3293
01:12:33,980 --> 01:12:37,340
If you want to map port 80 on the host, I mean, good luck.

3294
01:12:33,980 --> 01:12:37,340
<font color="#ffff54">호스트에서 포트 80을 매핑하려면 행운을 빕니다.</font>

3295
01:12:37,340 --> 01:12:39,819
What if none of the hosts have port 80 open?

3296
01:12:37,340 --> 01:12:39,819
<font color="#ffff54">포트 80이 열려있는 호스트가 하나도 없다면?</font>

3297
01:12:39,819 --> 01:12:41,579
Your pod can't run anywhere.

3298
01:12:39,819 --> 01:12:41,579
<font color="#ffff54">파드가 아무데도 실행될 수 없다.</font>

3299
01:12:41,579 --> 01:12:44,260
So it's not a great solution for your users,

3300
01:12:41,579 --> 01:12:44,260
<font color="#ffff54">따라서 사용자에게 좋은 솔루션이 아니다,</font>

3301
01:12:44,260 --> 01:12:46,739
for us developers who are trying to deploy apps, right?

3302
01:12:44,260 --> 01:12:46,739
<font color="#ffff54">앱을 배포하려는 우리 개발자들에게는요?</font>

3303
01:12:46,739 --> 01:12:48,100
You don't wanna use a host port.

3304
01:12:46,739 --> 01:12:48,100
<font color="#ffff54">호스트 포트를 사용하고 싶지 않으세요?</font>

3305
01:12:48,100 --> 01:12:49,659
It's for administrators, right?

3306
01:12:48,100 --> 01:12:49,659
<font color="#ffff54">관리자용이죠?</font>

3307
01:12:49,659 --> 01:12:53,819
If I'm running SSH in a pod, well, yeah,

3308
01:12:49,659 --> 01:12:53,819
<font color="#ffff54">만약 내가 파드에서 SSH를 실행하고 있다면, 네, 맞아요,</font>

3309
01:12:53,840 --> 01:12:55,079
I want it to listen on 22,

3310
01:12:53,840 --> 01:12:55,079
<font color="#ffff54">22에 수신하기를 원한다,</font>

3311
01:12:55,079 --> 01:12:57,479
so I might host port that or something

3312
01:12:55,079 --> 01:12:57,479
<font color="#ffff54">그래서 그 포트를 호스트할 수도 있고</font>

3313
01:12:57,479 --> 01:12:59,119
for diagnostics or testing,

3314
01:12:57,479 --> 01:12:59,119
<font color="#ffff54">진단이나 테스트를 위해,</font>

3315
01:12:59,119 --> 01:13:02,039
but it's not for general use for users, right?

3316
01:12:59,119 --> 01:13:02,039
<font color="#ffff54">하지만 사용자가 일반적으로 사용하는 것은 아니죠?</font>

3317
01:13:02,039 --> 01:13:04,199
What users should be using is a node port.

3318
01:13:02,039 --> 01:13:04,199
<font color="#ffff54">사용자가 사용해야 하는 것은 노드 포트입니다.</font>

3319
01:13:04,199 --> 01:13:08,799
A node port's a service, and it's a cluster IP.

3320
01:13:04,199 --> 01:13:08,799
<font color="#ffff54">노드 포트는 서비스이며 클러스터 IP입니다.</font>

3321
01:13:08,799 --> 01:13:10,359
You get a cluster IP, right?

3322
01:13:08,799 --> 01:13:10,359
<font color="#ffff54">클러스터 IP를 받았죠?</font>

3323
01:13:10,359 --> 01:13:12,119
It's like an inheritance hierarchy, right?

3324
01:13:10,359 --> 01:13:12,119
<font color="#ffff54">상속 계층 구조 같은 거죠?</font>

3325
01:13:12,119 --> 01:13:13,719
Cluster IP is the base class,

3326
01:13:12,119 --> 01:13:13,719
<font color="#ffff54">클러스터 IP가 베이스 클래스입니다,</font>

3327
01:13:13,719 --> 01:13:15,920
and node port is a derived class.

3328
01:13:13,719 --> 01:13:15,920
<font color="#ffff54">노드 포트는 파생 클래스입니다.</font>

3329
01:13:15,920 --> 01:13:17,599
All the cluster IP stuff you get,

3330
01:13:15,920 --> 01:13:17,599
<font color="#ffff54">모든 클러스터 IP 정보입니다,</font>

3331
01:13:17,599 --> 01:13:21,479
plus a port is selected from the node port range,

3332
01:13:17,599 --> 01:13:21,479
<font color="#ffff54">노드 포트 범위에서 포트가 선택됩니다,</font>

3333
01:13:21,500 --> 01:13:24,580
like let's say 310, right?

3334
01:13:21,500 --> 01:13:24,580
<font color="#ffff54">예를 들어 310이라고 치죠?</font>

3335
01:13:24,580 --> 01:13:27,740
Three, three zero zero one zero, so 30,010, I guess,

3336
01:13:24,580 --> 01:13:27,740
<font color="#ffff54">3, 3, 3, 0, 0, 0, 그러니까 30,010이네요,</font>

3337
01:13:27,740 --> 01:13:29,660
and that's your port,

3338
01:13:27,740 --> 01:13:29,660
<font color="#ffff54">그게 네 포트야</font>

3339
01:13:29,660 --> 01:13:32,040
and every single host computer will now take traffic

3340
01:13:29,660 --> 01:13:32,040
<font color="#ffff54">이제 모든 호스트 컴퓨터가 트래픽을 받습니다.</font>

3341
01:13:32,040 --> 01:13:34,180
on that port and forward it to your service.

3342
01:13:32,040 --> 01:13:34,180
<font color="#ffff54">의 트래픽을 받아 서비스로 전달합니다.</font>

3343
01:13:34,180 --> 01:13:38,460
So if you set up, for example, a load balancer

3344
01:13:34,180 --> 01:13:38,460
<font color="#ffff54">예를 들어 로드 밸런서를 다음과 같이 설정하면 됩니다.</font>

3345
01:13:38,460 --> 01:13:40,760
in front of all the nodes in your cluster

3346
01:13:38,460 --> 01:13:40,760
<font color="#ffff54">클러스터의 모든 노드 앞에서</font>

3347
01:13:40,760 --> 01:13:42,420
and direct traffic to that port,

3348
01:13:40,760 --> 01:13:42,420
<font color="#ffff54">해당 포트로 트래픽을 유도합니다,</font>

3349
01:13:42,420 --> 01:13:44,140
you will be reaching your service,

3350
01:13:42,420 --> 01:13:44,140
<font color="#ffff54">서비스에 도달하게 됩니다,</font>

3351
01:13:44,140 --> 01:13:46,880
and that's exactly what a load balancer service does.

3352
01:13:44,140 --> 01:13:46,880
<font color="#ffff54">이것이 바로 로드밸런서 서비스가 하는 일입니다.</font>

3353
01:13:46,880 --> 01:13:49,600
So the inheritance hierarchy continues.

3354
01:13:46,880 --> 01:13:49,600
<font color="#ffff54">상속 계층 구조가 계속 이어집니다.</font>

3355
01:13:49,620 --> 01:13:53,140
Cluster IP, node port, load balancer.

3356
01:13:49,620 --> 01:13:53,140
<font color="#ffff54">클러스터 IP, 노드 포트, 로드밸런서.</font>

3357
01:13:53,140 --> 01:13:56,280
The node balancer, load balancer is the most derived, right?

3358
01:13:53,140 --> 01:13:56,280
<font color="#ffff54">노드 밸런서, 로드 밸런서가 가장 많이 파생된 것 맞죠?</font>

3359
01:13:56,280 --> 01:13:59,140
It is a node port, and it is a cluster IP.

3360
01:13:56,280 --> 01:13:59,140
<font color="#ffff54">노드 포트이고, 클러스터 IP입니다.</font>

3361
01:13:59,140 --> 01:14:01,860
So inside the cluster, you can use the cluster IP.

3362
01:13:59,140 --> 01:14:01,860
<font color="#ffff54">따라서 클러스터 내부에서는 클러스터 IP를 사용할 수 있습니다.</font>

3363
01:14:01,860 --> 01:14:02,800
That's best.

3364
01:14:01,860 --> 01:14:02,800
<font color="#ffff54">그게 최선입니다.</font>

3365
01:14:02,800 --> 01:14:04,180
It's DNS resolvable.

3366
01:14:02,800 --> 01:14:04,180
<font color="#ffff54">DNS 확인 가능.</font>

3367
01:14:04,180 --> 01:14:05,620
It's gonna load balance you.

3368
01:14:04,180 --> 01:14:05,620
<font color="#ffff54">로드 밸런스를 맞추겠습니다.</font>

3369
01:14:05,620 --> 01:14:07,140
It's fast.

3370
01:14:05,620 --> 01:14:07,140
<font color="#ffff54">빠르네.</font>

3371
01:14:07,140 --> 01:14:09,120
Then node port, that's one hop, right?

3372
01:14:07,140 --> 01:14:09,120
<font color="#ffff54">그럼 노드 포트는 한 홉이죠?</font>

3373
01:14:09,120 --> 01:14:10,500
You go right to the pod.

3374
01:14:09,120 --> 01:14:10,500
<font color="#ffff54">바로 파드로 이동합니다.</font>

3375
01:14:10,500 --> 01:14:12,700
Node port is two hops, right?

3376
01:14:10,500 --> 01:14:12,700
<font color="#ffff54">노드 포트는 두 홉이죠?</font>

3377
01:14:12,700 --> 01:14:15,480
Because you have to first hit the port on the host,

3378
01:14:12,700 --> 01:14:15,480
<font color="#ffff54">호스트의 포트에 먼저 접속해야 하기 때문입니다,</font>

3379
01:14:15,480 --> 01:14:18,500
and somebody's got to forward your traffic

3380
01:14:15,480 --> 01:14:18,500
<font color="#ffff54">그리고 누군가는 당신의 트래픽을 전달해야 합니다.</font>

3381
01:14:18,500 --> 01:14:20,359
to the next hop, right?

3382
01:14:18,500 --> 01:14:20,359
<font color="#ffff54">다음 홉으로 전달해야 하죠?</font>

3383
01:14:20,359 --> 01:14:22,199
There are scenarios where you can have actually

3384
01:14:20,359 --> 01:14:22,199
<font color="#ffff54">실제로 다음과 같은 시나리오가 있을 수 있습니다.</font>

3385
01:14:22,199 --> 01:14:24,359
a user mode proxy, like kube-proxy,

3386
01:14:22,199 --> 01:14:24,359
<font color="#ffff54">사용자 모드 프록시를 사용할 수 있다,</font>

3387
01:14:24,359 --> 01:14:26,140
and some versions of Kubernetes will actually listen

3388
01:14:24,359 --> 01:14:26,140
<font color="#ffff54">그리고 일부 쿠버네티스 버전은 실제로 수신한다.</font>

3389
01:14:26,140 --> 01:14:28,319
on all the node ports and forward the traffic.

3390
01:14:26,140 --> 01:14:28,319
<font color="#ffff54">를 수신하고 트래픽을 전달한다.</font>

3391
01:14:28,319 --> 01:14:29,880
In other cases, it's handled by the kernel,

3392
01:14:28,319 --> 01:14:29,880
<font color="#ffff54">다른 경우에는 커널이 처리합니다,</font>

3393
01:14:29,880 --> 01:14:31,479
the eBPF and stuff like that.

3394
01:14:29,880 --> 01:14:31,479
<font color="#ffff54">에 의해 처리됩니다.</font>

3395
01:14:31,479 --> 01:14:34,199
But then ultimately, your traffic ends up being delivered

3396
01:14:31,479 --> 01:14:34,199
<font color="#ffff54">하지만 궁극적으로 트래픽이 전달됩니다.</font>

3397
01:14:34,199 --> 01:14:38,239
to the pod, and the pod's probably not on that computer,

3398
01:14:34,199 --> 01:14:38,239
<font color="#ffff54">로 전달되고 파드는 해당 컴퓨터에 없을 것입니다,</font>

3399
01:14:38,239 --> 01:14:39,840
right, unless you know specifically

3400
01:14:38,239 --> 01:14:39,840
<font color="#ffff54">그래, 네가 구체적으로 알지 못한다면</font>

3401
01:14:39,840 --> 01:14:41,920
if there's 100 computers in the cluster,

3402
01:14:39,840 --> 01:14:41,920
<font color="#ffff54">클러스터에 100대의 컴퓨터가 있는 경우,</font>

3403
01:14:41,920 --> 01:14:44,079
and you're running five pods,

3404
01:14:41,920 --> 01:14:44,079
<font color="#ffff54">그리고 5개의 파드를 실행하고 있다,</font>

3405
01:14:44,079 --> 01:14:46,239
you're only running on 5% of the nodes.

3406
01:14:44,079 --> 01:14:46,239
<font color="#ffff54">5%의 노드에서만 실행하고 있다.</font>

3407
01:14:46,239 --> 01:14:48,399
If you pick a host and hit the node port,

3408
01:14:46,239 --> 01:14:48,399
<font color="#ffff54">호스트를 선택하고 노드 포트를 누르면,</font>

3409
01:14:49,260 --> 01:14:50,660
chances are your pod's not on that node.

3410
01:14:49,260 --> 01:14:50,660
<font color="#ffff54">파드가 해당 노드에 있지 않을 가능성이 있다.</font>

3411
01:14:50,660 --> 01:14:51,760
So you're gonna have two hops, right?

3412
01:14:50,660 --> 01:14:51,760
<font color="#ffff54">그럼 두 홉이 있는 거죠?</font>

3413
01:14:51,760 --> 01:14:53,660
You're gonna hit the host, and then it's gonna have

3414
01:14:51,760 --> 01:14:53,660
<font color="#ffff54">호스트에 부딪히면, 호스트가</font>

3415
01:14:53,660 --> 01:14:55,180
to forward your traffic over to the machine

3416
01:14:53,660 --> 01:14:55,180
<font color="#ffff54">트래픽을 기계로 전달합니다.</font>

3417
01:14:55,180 --> 01:14:56,980
that has the pod, right?

3418
01:14:55,180 --> 01:14:56,980
<font color="#ffff54">파드가 있는 거 맞죠?</font>

3419
01:14:56,980 --> 01:14:59,340
And then load balancer, three hops.

3420
01:14:56,980 --> 01:14:59,340
<font color="#ffff54">그리고 로드밸런서, 세 홉.</font>

3421
01:15:00,620 --> 01:15:03,120
The load balancer, there's no load balancers

3422
01:15:00,620 --> 01:15:03,120
<font color="#ffff54">로드밸런서, 로드밸런서가 없습니다.</font>

3423
01:15:03,120 --> 01:15:04,400
built into Kubernetes.

3424
01:15:03,120 --> 01:15:04,400
<font color="#ffff54">쿠버네티스에 내장되어 있다.</font>

3425
01:15:04,400 --> 01:15:06,920
You have to have a plugin that stands one up for you.

3426
01:15:04,400 --> 01:15:06,920
<font color="#ffff54">여러분을 위한 플러그인이 있어야 합니다.</font>

3427
01:15:06,920 --> 01:15:10,820
So Metal LB can be stood up and use BGP

3428
01:15:06,920 --> 01:15:10,820
<font color="#ffff54">그래서 Metal LB를 세워서 BGP를 사용할 수 있습니다.</font>

3429
01:15:10,820 --> 01:15:13,060
to create, advertise a virtual IP

3430
01:15:10,820 --> 01:15:13,060
<font color="#ffff54">가상 IP를 생성하고 광고합니다.</font>

3431
01:15:13,060 --> 01:15:16,180
that goes to the node port or something like that.

3432
01:15:13,060 --> 01:15:16,180
<font color="#ffff54">노드 포트 등으로 이동합니다.</font>

3433
01:15:16,180 --> 01:15:20,119
You can also use things like the load balancers

3434
01:15:16,180 --> 01:15:20,119
<font color="#ffff54">로드 밸런서 같은 것을 사용할 수도 있습니다.</font>

3435
01:15:20,119 --> 01:15:22,619
for your cloud providers, and F5 has one.

3436
01:15:20,119 --> 01:15:22,619
<font color="#ffff54">클라우드 제공업체를 위한 로드 밸런서를 사용할 수도 있습니다.</font>

3437
01:15:22,619 --> 01:15:24,100
There's all sorts of load balancers out there

3438
01:15:22,619 --> 01:15:24,100
<font color="#ffff54">모든 종류의 로드 밸런서가 있습니다.</font>

3439
01:15:24,100 --> 01:15:26,520
that will plug in, but you gotta do it, right?

3440
01:15:24,100 --> 01:15:26,520
<font color="#ffff54">연결할 수 있지만, 그래도 해야죠?</font>

3441
01:15:26,520 --> 01:15:27,760
Kubernetes is not opinionated.

3442
01:15:26,520 --> 01:15:27,760
<font color="#ffff54">쿠버네티스는 독단적이지 않다.</font>

3443
01:15:27,760 --> 01:15:29,000
You pick your load balancer,

3444
01:15:27,760 --> 01:15:29,000
<font color="#ffff54">로드밸런서를 선택한다,</font>

3445
01:15:29,000 --> 01:15:30,360
and then when you set up your service,

3446
01:15:29,000 --> 01:15:30,360
<font color="#ffff54">그리고 서비스를 설정합니다,</font>

3447
01:15:30,360 --> 01:15:34,240
it creates the event, and then if somebody wants

3448
01:15:30,360 --> 01:15:34,240
<font color="#ffff54">이벤트를 생성하고, 누군가 원하면</font>

3449
01:15:34,240 --> 01:15:36,380
to do something with it, they can.

3450
01:15:34,240 --> 01:15:36,380
<font color="#ffff54">무언가를 하기를 원하면 할 수 있습니다.</font>

3451
01:15:36,380 --> 01:15:38,159
In our cluster, when you create a load balancer,

3452
01:15:36,380 --> 01:15:38,159
<font color="#ffff54">우리 클러스터에서 로드밸런서를 생성하면,</font>

3453
01:15:38,159 --> 01:15:40,039
it's gonna be pending.

3454
01:15:38,159 --> 01:15:40,039
<font color="#ffff54">보류 상태가 될 것이다.</font>

3455
01:15:40,039 --> 01:15:42,680
You're never gonna get the external IP of the load balancer

3456
01:15:40,039 --> 01:15:42,680
<font color="#ffff54">로드밸런서의 외부 IP는 절대 얻을 수 없습니다.</font>

3457
01:15:42,680 --> 01:15:44,520
because there's no plugin installed.

3458
01:15:42,680 --> 01:15:44,520
<font color="#ffff54">플러그인이 설치되지 않았기 때문입니다.</font>

3459
01:15:44,660 --> 01:15:46,780
And so load balancer is three hops.

3460
01:15:44,660 --> 01:15:46,780
<font color="#ffff54">따라서 로드 밸런서는 세 홉입니다.</font>

3461
01:15:46,780 --> 01:15:48,780
You hit the load balancer, which is a thing,

3462
01:15:46,780 --> 01:15:48,780
<font color="#ffff54">로드 밸런서를 건드렸군요,</font>

3463
01:15:48,780 --> 01:15:52,240
a real device or a logical thing, right?

3464
01:15:48,780 --> 01:15:52,240
<font color="#ffff54">실제 장치나 논리적인 거지?</font>

3465
01:15:52,240 --> 01:15:55,100
And then it hits the node port on one of the machines,

3466
01:15:52,240 --> 01:15:55,100
<font color="#ffff54">그리고 컴퓨터 중 하나의 노드 포트에 도달합니다,</font>

3467
01:15:55,100 --> 01:15:57,900
and then third hop is back to the pod.

3468
01:15:55,100 --> 01:15:57,900
<font color="#ffff54">그리고 세 번째 홉은 다시 파드로 돌아간다.</font>

3469
01:15:57,900 --> 01:16:00,120
So it's a hierarchy, and each one's more expensive.

3470
01:15:57,900 --> 01:16:00,120
<font color="#ffff54">계층 구조가 있고, 각 계층은 더 비싸다.</font>

3471
01:16:00,120 --> 01:16:02,580
So you gotta decide what you wanna do.

3472
01:16:00,120 --> 01:16:02,580
<font color="#ffff54">그러니 뭘 할지 결정해야 해요.</font>

3473
01:16:02,580 --> 01:16:05,200
Load balancers are nice because you can give them

3474
01:16:02,580 --> 01:16:05,200
<font color="#ffff54">로드밸런서가 좋은 이유는 다음과 같습니다.</font>

3475
01:16:05,200 --> 01:16:07,340
a DNS name out on the internet, for example,

3476
01:16:05,200 --> 01:16:07,340
<font color="#ffff54">예를 들어 인터넷에 DNS 이름을 보낼 수 있습니다,</font>

3477
01:16:07,340 --> 01:16:10,220
and you might have hardware replication of them.

3478
01:16:07,340 --> 01:16:10,220
<font color="#ffff54">하드웨어 복제가 있을 수 있습니다.</font>

3479
01:16:10,220 --> 01:16:11,520
There might be like seven of them,

3480
01:16:10,220 --> 01:16:11,520
<font color="#ffff54">일곱 개 정도 있을 수 있습니다,</font>

3481
01:16:11,520 --> 01:16:13,780
so if one fails, HA and all that.

3482
01:16:11,520 --> 01:16:13,780
<font color="#ffff54">그래서 하나가 실패하면, HA와 그 모든 것들.</font>

3483
01:16:13,880 --> 01:16:16,119
So load balancers are good for external access too,

3484
01:16:13,880 --> 01:16:16,119
<font color="#ffff54">따라서 로드밸런서는 외부 접속에도 좋습니다,</font>

3485
01:16:16,119 --> 01:16:18,239
but they're based on node ports, typically.

3486
01:16:16,119 --> 01:16:18,239
<font color="#ffff54">하지만 일반적으로 노드 포트를 기반으로 합니다.</font>

3487
01:16:18,239 --> 01:16:20,599
They get into the cluster through a node port.

3488
01:16:18,239 --> 01:16:20,599
<font color="#ffff54">노드 포트를 통해 클러스터로 들어갑니다.</font>

3489
01:16:20,599 --> 01:16:22,300
And then you have ingress.

3490
01:16:20,599 --> 01:16:22,300
<font color="#ffff54">그리고 침입합니다.</font>

3491
01:16:22,300 --> 01:16:25,000
An ingress is a controller that runs in your cluster,

3492
01:16:22,300 --> 01:16:25,000
<font color="#ffff54">인그레스는 클러스터에서 실행되는 컨트롤러이다,</font>

3493
01:16:25,000 --> 01:16:28,679
typically has a load balancer or a node port service

3494
01:16:25,000 --> 01:16:28,679
<font color="#ffff54">일반적으로 로드밸런서 또는 노드 포트 서비스를 가지고 있다.</font>

3495
01:16:28,679 --> 01:16:31,759
in front of it, but the thing about an ingress controller

3496
01:16:28,679 --> 01:16:31,759
<font color="#ffff54">앞에 있지만, 인그레스 컨트롤러에 대한 것은</font>

3497
01:16:31,759 --> 01:16:34,219
is what if I have five services?

3498
01:16:31,759 --> 01:16:34,219
<font color="#ffff54">다섯 개의 서비스가 있으면 어떨까요?</font>

3499
01:16:34,219 --> 01:16:36,920
Do you wanna tell your iPhone developers,

3500
01:16:34,219 --> 01:16:36,920
<font color="#ffff54">아이폰 개발자들에게 말해주고 싶어요?</font>

3501
01:16:36,920 --> 01:16:39,199
oh, if you want that, you connect over to here,

3502
01:16:36,920 --> 01:16:39,199
<font color="#ffff54">오, 그걸 원하면 여기로 접속하세요,</font>

3503
01:16:39,199 --> 01:16:40,759
and if you want that, you connect over to here,

3504
01:16:39,199 --> 01:16:40,759
<font color="#ffff54">원하시면 여기로 연결하세요,</font>

3505
01:16:40,759 --> 01:16:42,079
and then, oh, this part of the API

3506
01:16:40,759 --> 01:16:42,079
<font color="#ffff54">그리고 나서, 아, API의 이 부분입니다.</font>

3507
01:16:42,100 --> 01:16:44,059
is actually hosted over here.

3508
01:16:42,100 --> 01:16:44,059
<font color="#ffff54">는 실제로 여기서 호스팅됩니다.</font>

3509
01:16:44,059 --> 01:16:45,539
Not really, right?

3510
01:16:44,059 --> 01:16:45,539
<font color="#ffff54">그렇지 않나요?</font>

3511
01:16:45,539 --> 01:16:49,460
Microservices shouldn't be exposed outside of the context

3512
01:16:45,539 --> 01:16:49,460
<font color="#ffff54">마이크로서비스는 컨텍스트 외부에 노출되어서는 안 된다.</font>

3513
01:16:49,460 --> 01:16:51,519
within which you're developing them.

3514
01:16:49,460 --> 01:16:51,519
<font color="#ffff54">개발 중인 컨텍스트 내에서만 노출되어야 합니다.</font>

3515
01:16:51,519 --> 01:16:55,739
The external API deals with different language,

3516
01:16:51,519 --> 01:16:55,739
<font color="#ffff54">외부 API가 다른 언어를 처리합니다,</font>

3517
01:16:55,739 --> 01:17:00,739
different semantics, different bandwidths, right?

3518
01:16:55,739 --> 01:17:00,739
<font color="#ffff54">의미도 다르고, 대역폭도 다르죠?</font>

3519
01:17:00,739 --> 01:17:03,019
The internet is flaky and low bandwidth.

3520
01:17:00,739 --> 01:17:03,019
<font color="#ffff54">인터넷이 불안정하고 대역폭이 낮습니다.</font>

3521
01:17:03,019 --> 01:17:05,819
Your data center is gonna be fast and reliable.

3522
01:17:03,019 --> 01:17:05,819
<font color="#ffff54">데이터 센터는 빠르고 안정적입니다.</font>

3523
01:17:05,819 --> 01:17:07,180
They're very different worlds.

3524
01:17:05,819 --> 01:17:07,180
<font color="#ffff54">아주 다른 세상입니다.</font>

3525
01:17:07,180 --> 01:17:09,939
The ingress controller can create kind of like a firewall,

3526
01:17:07,180 --> 01:17:09,939
<font color="#ffff54">인그레스 컨트롤러는 방화벽과 같은 것을 만들 수 있습니다,</font>

3527
01:17:09,960 --> 01:17:12,640
an adapter from the outside world to the inside world.

3528
01:17:09,960 --> 01:17:12,640
<font color="#ffff54">외부 세계와 내부 세계를 연결하는 어댑터입니다.</font>

3529
01:17:12,640 --> 01:17:15,360
You could have two services or eight,

3530
01:17:12,640 --> 01:17:15,360
<font color="#ffff54">서비스가 두 개일 수도 있고 여덟 개일 수도 있습니다,</font>

3531
01:17:15,360 --> 01:17:19,040
and then you could say, hey, if somebody hits slash engine,

3532
01:17:15,360 --> 01:17:19,040
<font color="#ffff54">그리고 나서 누군가 슬래시 엔진을 누르면 이렇게 말할 수 있습니다,</font>

3533
01:17:19,040 --> 01:17:20,100
send them over here.

3534
01:17:19,040 --> 01:17:20,100
<font color="#ffff54">여기로 보내주세요.</font>

3535
01:17:20,100 --> 01:17:22,760
If they hit slash web, send them over there.

3536
01:17:20,100 --> 01:17:22,760
<font color="#ffff54">슬래시 웹에 부딪히면 저쪽으로 보내세요.</font>

3537
01:17:22,760 --> 01:17:24,560
And so an ingress controller gets rules

3538
01:17:22,760 --> 01:17:24,560
<font color="#ffff54">그래서 인그레스 컨트롤러는 규칙을 얻습니다.</font>

3539
01:17:24,560 --> 01:17:27,120
that tell it how to send the traffic inside the cluster

3540
01:17:24,560 --> 01:17:27,120
<font color="#ffff54">클러스터 내부로 트래픽을 전송하는 방법을 알려준다.</font>

3541
01:17:27,120 --> 01:17:29,180
to the different services that are on the inside.

3542
01:17:27,120 --> 01:17:29,180
<font color="#ffff54">내부에 있는 다른 서비스로 전송합니다.</font>

3543
01:17:29,180 --> 01:17:32,000
So you might have a bunch of your little microservices

3544
01:17:29,180 --> 01:17:32,000
<font color="#ffff54">따라서 작은 마이크로서비스가 여러 개 있을 수 있습니다.</font>

3545
01:17:32,000 --> 01:17:34,120
with cluster IPs only.

3546
01:17:32,000 --> 01:17:34,120
<font color="#ffff54">클러스터 IP로만.</font>

3547
01:17:34,120 --> 01:17:37,200
You don't want them accessed from the outside.

3548
01:17:34,120 --> 01:17:37,200
<font color="#ffff54">외부에서 액세스하는 것을 원하지 않습니다.</font>

3549
01:17:37,200 --> 01:17:38,480
And then you have an ingress controller

3550
01:17:37,200 --> 01:17:38,480
<font color="#ffff54">그리고 출입 컨트롤러가 있습니다.</font>

3551
01:17:38,500 --> 01:17:40,020
that provides your public interface,

3552
01:17:38,500 --> 01:17:40,020
<font color="#ffff54">퍼블릭 인터페이스를 제공합니다,</font>

3553
01:17:40,020 --> 01:17:41,140
and it sends all the traffic

3554
01:17:40,020 --> 01:17:41,140
<font color="#ffff54">그리고 모든 트래픽을 전송합니다.</font>

3555
01:17:41,140 --> 01:17:42,420
to those guys behind the scenes.

3556
01:17:41,140 --> 01:17:42,420
<font color="#ffff54">배후에 있는 사람들에게요.</font>

3557
01:17:42,420 --> 01:17:44,460
And it's the ingress controller

3558
01:17:42,420 --> 01:17:44,460
<font color="#ffff54">그리고 출입 컨트롤러입니다</font>

3559
01:17:44,460 --> 01:17:46,580
that has a load balancer service in front of it,

3560
01:17:44,460 --> 01:17:46,580
<font color="#ffff54">그 앞에 로드밸런서 서비스가 있습니다,</font>

3561
01:17:46,580 --> 01:17:48,420
and only the ingress controller.

3562
01:17:46,580 --> 01:17:48,420
<font color="#ffff54">그리고 인그레스 컨트롤러만.</font>

3563
01:17:48,420 --> 01:17:50,340
It's the one way in, right?

3564
01:17:48,420 --> 01:17:50,340
<font color="#ffff54">한 방향으로만 들어오는 거죠?</font>

3565
01:17:50,340 --> 01:17:52,380
So you might create node ports on the fly

3566
01:17:50,340 --> 01:17:52,380
<font color="#ffff54">그래서 노드 포트를 즉석에서 만들 수 있습니다.</font>

3567
01:17:52,380 --> 01:17:55,140
to test things and to experiment if you're on the inside,

3568
01:17:52,380 --> 01:17:55,140
<font color="#ffff54">테스트하고 내부에 있는지 실험할 수 있습니다,</font>

3569
01:17:55,140 --> 01:17:57,500
but the outside world never sees those.

3570
01:17:55,140 --> 01:17:57,500
<font color="#ffff54">하지만 외부 세계에서는 절대 볼 수 없다.</font>

3571
01:17:57,500 --> 01:17:59,060
What's a gateway?

3572
01:17:57,500 --> 01:17:59,060
<font color="#ffff54">게이트웨이가 뭐지?</font>

3573
01:17:59,060 --> 01:18:01,740
A gateway is a more powerful ingress controller.

3574
01:17:59,060 --> 01:18:01,740
<font color="#ffff54">게이트웨이는 더 강력한 인그레스 컨트롤러입니다.</font>

3575
01:18:01,740 --> 01:18:03,540
Ingress is a thing in Kubernetes.

3576
01:18:01,740 --> 01:18:03,540
<font color="#ffff54">쿠버네티스에서 인그레스는 존재한다.</font>

3577
01:18:03,540 --> 01:18:04,780
It's a defined framework.

3578
01:18:03,540 --> 01:18:04,780
<font color="#ffff54">정의된 프레임워크입니다.</font>

3579
01:18:04,780 --> 01:18:06,840
Again, Kubernetes doesn't provide one.

3580
01:18:04,780 --> 01:18:06,840
<font color="#ffff54">다시 말하지만, 쿠버네티스는 이를 제공하지 않는다.</font>

3581
01:18:06,840 --> 01:18:07,820
You have to install one,

3582
01:18:06,840 --> 01:18:07,820
<font color="#ffff54">하나를 설치해야 한다,</font>

3583
01:18:08,119 --> 01:18:09,079
and we're gonna use Ambassador.

3584
01:18:08,119 --> 01:18:09,079
<font color="#ffff54">앰배서더를 사용하겠습니다.</font>

3585
01:18:09,079 --> 01:18:10,159
Oops, sorry, Emissary.

3586
01:18:09,079 --> 01:18:10,159
<font color="#ffff54">죄송합니다, 사절님.</font>

3587
01:18:10,159 --> 01:18:11,920
It used to be called Ambassador.

3588
01:18:10,159 --> 01:18:11,920
<font color="#ffff54">예전에는 앰배서더라고 불렸죠.</font>

3589
01:18:11,920 --> 01:18:14,479
And so we're gonna use Emissary for that.

3590
01:18:11,920 --> 01:18:14,479
<font color="#ffff54">그래서 이젠 사절이라고 부르죠.</font>

3591
01:18:14,479 --> 01:18:15,319
Well, guess what?

3592
01:18:14,479 --> 01:18:15,319
<font color="#ffff54">그거 알아?</font>

3593
01:18:15,319 --> 01:18:17,799
Emissary does the Kubernetes ingress framework,

3594
01:18:15,319 --> 01:18:17,799
<font color="#ffff54">Emissary는 쿠버네티스 인그레스 프레임워크를 수행한다,</font>

3595
01:18:17,799 --> 01:18:20,479
but Emissary is crazy powerful

3596
01:18:17,799 --> 01:18:20,479
<font color="#ffff54">하지만 Emissary는 엄청나게 강력하다.</font>

3597
01:18:20,479 --> 01:18:22,199
and has tons of other features.

3598
01:18:20,479 --> 01:18:22,199
<font color="#ffff54">다른 기능도 많아요.</font>

3599
01:18:22,199 --> 01:18:23,239
It can inject headers.

3600
01:18:22,199 --> 01:18:23,239
<font color="#ffff54">헤더를 주입할 수 있습니다.</font>

3601
01:18:23,239 --> 01:18:28,239
It can do fault stuff for chaos operations.

3602
01:18:23,239 --> 01:18:28,239
<font color="#ffff54">카오스 연산을 위한 결함 작업을 수행할 수 있습니다.</font>

3603
01:18:28,399 --> 01:18:29,920
It could do all sorts of things.

3604
01:18:28,399 --> 01:18:29,920
<font color="#ffff54">모든 종류의 일을 할 수 있습니다.</font>

3605
01:18:29,920 --> 01:18:31,479
And so it's a gateway.

3606
01:18:29,920 --> 01:18:31,479
<font color="#ffff54">그래서 관문이죠.</font>

3607
01:18:31,479 --> 01:18:35,039
It's a super powerful way to provide a single place

3608
01:18:31,479 --> 01:18:35,039
<font color="#ffff54">한 곳에서 제공하는 매우 강력한 방법입니다.</font>

3609
01:18:35,039 --> 01:18:36,139
where all your traffic can come in.

3610
01:18:35,039 --> 01:18:36,139
<font color="#ffff54">모든 트래픽이 들어올 수 있는 곳입니다.</font>

3611
01:18:36,160 --> 01:18:38,680
It can do security stuff.

3612
01:18:36,160 --> 01:18:38,680
<font color="#ffff54">보안 작업을 할 수 있습니다.</font>

3613
01:18:38,680 --> 01:18:41,000
Obviously, TLS is even part of ingress,

3614
01:18:38,680 --> 01:18:41,000
<font color="#ffff54">분명히 TLS도 인그레스의 일부입니다,</font>

3615
01:18:41,000 --> 01:18:43,039
but it can do some more advanced security things.

3616
01:18:41,000 --> 01:18:43,039
<font color="#ffff54">하지만 좀 더 고급 보안 작업을 수행할 수 있습니다.</font>

3617
01:18:43,039 --> 01:18:45,440
So it's a very, very powerful tool.

3618
01:18:43,039 --> 01:18:45,440
<font color="#ffff54">아주 강력한 도구입니다.</font>

3619
01:18:45,440 --> 01:18:47,360
So this is an example of host port,

3620
01:18:45,440 --> 01:18:47,360
<font color="#ffff54">이것이 호스트 포트의 예시입니다,</font>

3621
01:18:47,360 --> 01:18:49,520
where you have host port in the pod spec

3622
01:18:47,360 --> 01:18:49,520
<font color="#ffff54">파드 스펙에 호스트 포트가 있는 경우</font>

3623
01:18:49,520 --> 01:18:50,840
and then the container port.

3624
01:18:49,520 --> 01:18:50,840
<font color="#ffff54">그리고 컨테이너 포트.</font>

3625
01:18:50,840 --> 01:18:52,720
And if there's no host with that port open,

3626
01:18:50,840 --> 01:18:52,720
<font color="#ffff54">그리고 해당 포트가 열려있는 호스트가 없으면,</font>

3627
01:18:52,720 --> 01:18:54,340
your pod's pending forever

3628
01:18:52,720 --> 01:18:54,340
<font color="#ffff54">파드가 영원히 보류된다.</font>

3629
01:18:54,340 --> 01:18:56,720
until that port is available somewhere.

3630
01:18:54,340 --> 01:18:56,720
<font color="#ffff54">해당 포트를 어딘가에서 사용할 수 있을 때까지.</font>

3631
01:18:56,720 --> 01:18:59,600
So not a great thing for developers or users,

3632
01:18:56,720 --> 01:18:59,600
<font color="#ffff54">개발자나 사용자 모두에게 좋지 않습니다,</font>

3633
01:18:59,600 --> 01:19:01,079
more for operators.

3634
01:18:59,600 --> 01:19:01,079
<font color="#ffff54">운영자에게는 더 좋습니다.</font>

3635
01:19:01,079 --> 01:19:02,320
That's a node port.

3636
01:19:01,079 --> 01:19:02,320
<font color="#ffff54">노드 포트입니다.</font>

3637
01:19:02,320 --> 01:19:04,920
You just ask for type node port,

3638
01:19:02,320 --> 01:19:04,920
<font color="#ffff54">노드 포트를 요청하면 됩니다,</font>

3639
01:19:04,940 --> 01:19:06,800
and then you can ask for the port that you want,

3640
01:19:04,940 --> 01:19:06,800
<font color="#ffff54">그리고 원하는 포트를 요청하면 됩니다,</font>

3641
01:19:06,800 --> 01:19:09,659
but if it's in use, you'll get an error.

3642
01:19:06,800 --> 01:19:09,659
<font color="#ffff54">하지만 사용 중이면 오류가 발생합니다.</font>

3643
01:19:09,659 --> 01:19:10,980
If you leave the node port off,

3644
01:19:09,659 --> 01:19:10,980
<font color="#ffff54">노드 포트를 꺼두면</font>

3645
01:19:10,980 --> 01:19:13,340
Kubernetes will assign you one from the range,

3646
01:19:10,980 --> 01:19:13,340
<font color="#ffff54">쿠버네티스가 이 범위에서 하나를 할당한다,</font>

3647
01:19:13,340 --> 01:19:15,699
just like with the cluster IP, as we saw.

3648
01:19:13,340 --> 01:19:15,699
<font color="#ffff54">클러스터 IP와 마찬가지로.</font>

3649
01:19:15,699 --> 01:19:17,659
And then this is a load balancer.

3650
01:19:15,699 --> 01:19:17,659
<font color="#ffff54">그리고 이것은 로드밸런서입니다.</font>

3651
01:19:17,659 --> 01:19:20,100
You just say type load balancer.

3652
01:19:17,659 --> 01:19:20,100
<font color="#ffff54">로드 밸런서라고 입력하면 됩니다.</font>

3653
01:19:20,100 --> 01:19:21,340
That's it.

3654
01:19:20,100 --> 01:19:21,340
<font color="#ffff54">끝났습니다.</font>

3655
01:19:21,340 --> 01:19:23,140
In this case, this guy has two ports,

3656
01:19:21,340 --> 01:19:23,140
<font color="#ffff54">이 경우, 이 녀석은 두 개의 포트를 가지고 있습니다,</font>

3657
01:19:23,140 --> 01:19:26,300
HTTP and HTTPS, which is kind of common.

3658
01:19:23,140 --> 01:19:26,300
<font color="#ffff54">HTTP와 HTTPS, 꽤나 일반적인 포트입니다.</font>

3659
01:19:26,300 --> 01:19:28,140
And then you've got ingress.

3660
01:19:26,300 --> 01:19:28,140
<font color="#ffff54">그리고 인그레스가 들어옵니다.</font>

3661
01:19:28,140 --> 01:19:29,819
This is an ingress rule.

3662
01:19:28,140 --> 01:19:29,819
<font color="#ffff54">이것이 진입 규칙입니다.</font>

3663
01:19:29,819 --> 01:19:31,180
This ingress rule says,

3664
01:19:29,819 --> 01:19:31,180
<font color="#ffff54">이 진입 규칙은 이렇게 말합니다,</font>

3665
01:19:31,180 --> 01:19:34,180
hey, if somebody hits the ingress controller

3666
01:19:31,180 --> 01:19:34,180
<font color="#ffff54">이봐, 만약 누군가가 진입 컨트롤러를 치면</font>

3667
01:19:34,200 --> 01:19:36,400
using the HTTP protocol,

3668
01:19:34,200 --> 01:19:36,400
<font color="#ffff54">HTTP 프로토콜을 사용합니다,</font>

3669
01:19:36,400 --> 01:19:39,640
and by the way, ingress only supports HTTP and HTTPS,

3670
01:19:36,400 --> 01:19:39,640
<font color="#ffff54">참고로 인그레스는 HTTP와 HTTPS만 지원합니다,</font>

3671
01:19:39,640 --> 01:19:43,460
and they are using the route slash engine as their prefix,

3672
01:19:39,640 --> 01:19:43,460
<font color="#ffff54">그리고 접두사로 경로 슬래시 엔진을 사용하고 있습니다,</font>

3673
01:19:43,460 --> 01:19:45,280
could be anything after that,

3674
01:19:43,460 --> 01:19:45,280
<font color="#ffff54">그 이후는 무엇이든 될 수 있습니다,</font>

3675
01:19:45,280 --> 01:19:47,880
then send them to the backend service called engine.

3676
01:19:45,280 --> 01:19:47,880
<font color="#ffff54">그런 다음 엔진이라는 백엔드 서비스로 보냅니다.</font>

3677
01:19:47,880 --> 01:19:52,200
That's the name of the service, DNS Resolved, on port 80.

3678
01:19:47,880 --> 01:19:52,200
<font color="#ffff54">이것이 포트 80의 DNS 확인된 서비스 이름입니다.</font>

3679
01:19:52,200 --> 01:19:53,039
Very simple.

3680
01:19:52,200 --> 01:19:53,039
<font color="#ffff54">아주 간단합니다.</font>

3681
01:19:53,039 --> 01:19:56,600
And the developers can create these rules.

3682
01:19:53,039 --> 01:19:56,600
<font color="#ffff54">그리고 개발자는 이러한 규칙을 만들 수 있습니다.</font>

3683
01:19:56,600 --> 01:20:01,600
My DevOps team can provide the deployment that runs my pods,

3684
01:19:56,600 --> 01:20:01,600
<font color="#ffff54">데브옵스 팀이 내 파드를 실행하는 배포를 제공할 수 있습니다,</font>

3685
01:20:01,680 --> 01:20:03,659
the service that lets people inside the cluster

3686
01:20:01,680 --> 01:20:03,659
<font color="#ffff54">클러스터 내부의 사람들이</font>

3687
01:20:04,119 --> 01:20:05,880
get to them, and the ingress rule

3688
01:20:04,119 --> 01:20:05,880
<font color="#ffff54">그리고 진입 규칙</font>

3689
01:20:05,880 --> 01:20:07,680
that allows traffic from the outside to route in.

3690
01:20:05,880 --> 01:20:07,680
<font color="#ffff54">외부에서 들어오는 트래픽을 허용합니다.</font>

3691
01:20:07,680 --> 01:20:09,359
Now obviously I gotta coordinate with the other people

3692
01:20:07,680 --> 01:20:09,359
<font color="#ffff54">이제 당연히 다른 사람들과 조율해야 합니다.</font>

3693
01:20:09,359 --> 01:20:11,039
so we don't have overlapping routes and stuff,

3694
01:20:09,359 --> 01:20:11,039
<font color="#ffff54">경로가 겹치지 않게요,</font>

3695
01:20:11,039 --> 01:20:13,159
but that's the idea, right?

3696
01:20:11,039 --> 01:20:13,159
<font color="#ffff54">하지만 그게 아이디어죠?</font>

3697
01:20:13,159 --> 01:20:14,859
Let those teams be independent.

3698
01:20:13,159 --> 01:20:14,859
<font color="#ffff54">그 팀들을 독립시키자.</font>

3699
01:20:15,800 --> 01:20:17,479
And then the last thing is the gateway.

3700
01:20:15,800 --> 01:20:17,479
<font color="#ffff54">그리고 마지막은 관문입니다.</font>

3701
01:20:17,479 --> 01:20:19,220
This is an example of configuring a gateway.

3702
01:20:17,479 --> 01:20:19,220
<font color="#ffff54">다음은 게이트웨이를 구성하는 예제입니다.</font>

3703
01:20:19,220 --> 01:20:20,960
That's a custom resource definition.

3704
01:20:19,220 --> 01:20:20,960
<font color="#ffff54">사용자 정의 리소스 정의입니다.</font>

3705
01:20:20,960 --> 01:20:23,079
It's not part of Kubernetes,

3706
01:20:20,960 --> 01:20:23,079
<font color="#ffff54">쿠버네티스의 일부가 아니다,</font>

3707
01:20:23,079 --> 01:20:24,479
but Kubernetes gives you the ability

3708
01:20:23,079 --> 01:20:24,479
<font color="#ffff54">하지만 쿠버네티스는 다음과 같은 기능을 제공한다.</font>

3709
01:20:24,479 --> 01:20:27,920
to create your own resource definitions like this one.

3710
01:20:24,479 --> 01:20:27,920
<font color="#ffff54">를 사용하여 이와 같은 리소스 정의를 직접 생성할 수 있다.</font>

3711
01:20:27,920 --> 01:20:29,599
And this one gives you the ability then

3712
01:20:27,920 --> 01:20:29,599
<font color="#ffff54">그리고 이것은 다음과 같은 기능을 제공합니다.</font>

3713
01:20:29,599 --> 01:20:31,579
to do things like inject headers,

3714
01:20:29,599 --> 01:20:31,579
<font color="#ffff54">헤더 인젝션과 같은 작업을 수행할 수 있습니다,</font>

3715
01:20:31,579 --> 01:20:34,739
and fancy stuff like control the maximum connections.

3716
01:20:31,579 --> 01:20:34,739
<font color="#ffff54">그리고 최대 연결 제어와 같은 멋진 것들을 할 수 있습니다.</font>

3717
01:20:34,739 --> 01:20:36,640
None of that's supported in ingress,

3718
01:20:34,739 --> 01:20:36,640
<font color="#ffff54">인그레스에서는 이 중 어느 것도 지원되지 않습니다,</font>

3719
01:20:36,640 --> 01:20:39,180
but emissary's super powerful

3720
01:20:36,640 --> 01:20:39,180
<font color="#ffff54">하지만 사절은 매우 강력하다</font>

3721
01:20:39,180 --> 01:20:40,800
and has all these kind of advanced features,

3722
01:20:39,180 --> 01:20:40,800
<font color="#ffff54">그리고 이런 고급 기능들을 모두 가지고 있습니다,</font>

3723
01:20:40,800 --> 01:20:42,720
so we would call it typically a gateway.

3724
01:20:40,800 --> 01:20:42,720
<font color="#ffff54">따라서 일반적으로 게이트웨이라고 부릅니다.</font>

3725
01:20:42,720 --> 01:20:44,439
It also supports protocols

3726
01:20:42,720 --> 01:20:44,439
<font color="#ffff54">프로토콜도 지원합니다.</font>

3727
01:20:44,439 --> 01:20:47,340
that the ingress controller doesn't support.

3728
01:20:44,439 --> 01:20:47,340
<font color="#ffff54">수신 컨트롤러가 지원하지 않는 프로토콜도 지원합니다.</font>

3729
01:20:47,340 --> 01:20:49,319
Ingress, only HTTP and HTTPS.

3730
01:20:47,340 --> 01:20:49,319
<font color="#ffff54">인그레스, HTTP와 HTTPS만 가능합니다.</font>

3731
01:20:49,319 --> 01:20:53,199
If you want SCTP or UDP, you're gonna need a gateway.

3732
01:20:49,319 --> 01:20:53,199
<font color="#ffff54">SCTP 또는 UDP를 원한다면 게이트웨이가 필요합니다.</font>

3733
01:20:53,199 --> 01:20:57,680
And so lab step four walks you through installing emissary

3734
01:20:53,199 --> 01:20:57,680
<font color="#ffff54">그래서 실습 4단계에서는 엠시전 설치를 안내합니다.</font>

3735
01:20:57,680 --> 01:21:02,680
and doing some ingress and some gateway stuff.

3736
01:20:57,680 --> 01:21:02,680
<font color="#ffff54">진입과 게이트웨이 작업도 해봅니다.</font>

3737
01:21:02,980 --> 01:21:04,619
So you get a chance to work with the CRDs

3738
01:21:02,980 --> 01:21:04,619
<font color="#ffff54">그래서 CRD와 함께 일할 기회를 얻었습니다.</font>

3739
01:21:04,619 --> 01:21:05,860
that emissary installs

3740
01:21:04,619 --> 01:21:05,860
<font color="#ffff54">그 사절단이 설치한다</font>

3741
01:21:05,860 --> 01:21:09,079
and the ingress controller standard Kubernetes stuff.

3742
01:21:05,860 --> 01:21:09,079
<font color="#ffff54">그리고 인그레스 컨트롤러 표준 쿠버네티스 물건.</font>

3743
01:21:09,079 --> 01:21:10,159
Why would you use ingress

3744
01:21:09,079 --> 01:21:10,159
<font color="#ffff54">왜 인그레스를 사용하는가?</font>

3745
01:21:10,159 --> 01:21:12,220
if gateways are so much more powerful?

3746
01:21:10,159 --> 01:21:12,220
<font color="#ffff54">게이트웨이가 훨씬 더 강력하다면?</font>

3747
01:21:12,220 --> 01:21:13,619
Well, those specs I just showed you,

3748
01:21:12,220 --> 01:21:13,619
<font color="#ffff54">방금 보여드린 사양이 그렇죠,</font>

3749
01:21:13,619 --> 01:21:15,220
those custom resource definitions

3750
01:21:13,619 --> 01:21:15,220
<font color="#ffff54">그 커스텀 리소스 정의들</font>

3751
01:21:15,220 --> 01:21:17,820
are emissary custom resource definitions.

3752
01:21:15,220 --> 01:21:17,820
<font color="#ffff54">은 에미시 커스텀 리소스 정의입니다.</font>

3753
01:21:17,820 --> 01:21:20,619
If you later switch to something else,

3754
01:21:17,820 --> 01:21:20,619
<font color="#ffff54">나중에 다른 것으로 전환하는 경우,</font>

3755
01:21:20,619 --> 01:21:22,060
they're not gonna work.

3756
01:21:20,619 --> 01:21:22,060
<font color="#ffff54">작동하지 않습니다.</font>

3757
01:21:22,060 --> 01:21:24,780
But ingress is a Kubernetes framework standard.

3758
01:21:22,060 --> 01:21:24,780
<font color="#ffff54">하지만 인그레스는 쿠버네티스 프레임워크 표준이다.</font>

3759
01:21:24,780 --> 01:21:26,140
It's gonna work everywhere.

3760
01:21:24,780 --> 01:21:26,140
<font color="#ffff54">어디에서나 작동할 겁니다.</font>

3761
01:21:26,160 --> 01:21:28,400
The nginx ingress controller will take them.

3762
01:21:26,160 --> 01:21:28,400
<font color="#ffff54">nginx 인그레스 컨트롤러가 가져갈 것입니다.</font>

3763
01:21:28,400 --> 01:21:29,640
The emissary will take them.

3764
01:21:28,400 --> 01:21:29,640
<font color="#ffff54">사절단이 가져갈 것입니다.</font>

3765
01:21:29,640 --> 01:21:31,960
So if you can get away with just using ingress,

3766
01:21:29,640 --> 01:21:31,960
<font color="#ffff54">침입만으로 도망칠 수 있다면,</font>

3767
01:21:31,960 --> 01:21:33,160
it's portable, right?

3768
01:21:31,960 --> 01:21:33,160
<font color="#ffff54">휴대가 가능하죠?</font>

3769
01:21:33,160 --> 01:21:34,240
Not a bad thing.

3770
01:21:33,160 --> 01:21:34,240
<font color="#ffff54">나쁘지 않네.</font>

3771
01:21:34,240 --> 01:21:36,680
So you have to decide what you need.

3772
01:21:34,240 --> 01:21:36,680
<font color="#ffff54">그러니 필요한 게 뭔지 결정해야지.</font>

3773
01:21:36,680 --> 01:21:40,160
All right, what I'm gonna do is cover service mesh

3774
01:21:36,680 --> 01:21:40,160
<font color="#ffff54">좋아, 내가 할 일은 서비스 메시를 커버하는 거야.</font>

3775
01:21:40,160 --> 01:21:41,360
because we got a little bit of time left.

3776
01:21:40,160 --> 01:21:41,360
<font color="#ffff54">시간이 조금 남았으니까요.</font>

3777
01:21:41,360 --> 01:21:44,320
If you wanna start on the emissary lab, go for it.

3778
01:21:41,360 --> 01:21:44,320
<font color="#ffff54">사절단 연구소를 시작하고 싶으면 시작하세요.</font>

3779
01:21:44,320 --> 01:21:46,200
But I'm gonna cover service mesh real quick.

3780
01:21:44,320 --> 01:21:46,200
<font color="#ffff54">하지만 난 서비스 메시를 빨리 다룰 거야.</font>

3781
01:21:46,200 --> 01:21:47,740
And I tell you what,

3782
01:21:46,200 --> 01:21:47,740
<font color="#ffff54">그리고 이렇게 말하죠,</font>

3783
01:21:47,740 --> 01:21:51,600
we'll leave these boxes up for another hour or two.

3784
01:21:47,740 --> 01:21:51,600
<font color="#ffff54">이 상자를 한두 시간 더 열어두겠습니다.</font>

3785
01:21:51,600 --> 01:21:53,340
So if you didn't get through all the labs,

3786
01:21:51,600 --> 01:21:53,340
<font color="#ffff54">모든 실험실을 통과하지 못했다면,</font>

3787
01:21:53,340 --> 01:21:54,240
you'll have some time there.

3788
01:21:53,340 --> 01:21:54,240
<font color="#ffff54">시간이 좀 있을 겁니다.</font>

3789
01:21:54,240 --> 01:21:55,960
And then probably like after lunch,

3790
01:21:54,240 --> 01:21:55,960
<font color="#ffff54">그리고 아마 점심 식사 후에,</font>

3791
01:21:56,739 --> 01:21:57,579
we'll shut them down, let's say that way.

3792
01:21:56,739 --> 01:21:57,579
<font color="#ffff54">그렇게 해서 종료하겠습니다.</font>

3793
01:21:57,579 --> 01:21:59,699
So if you wanna work through lunch, you can.

3794
01:21:57,579 --> 01:21:59,699
<font color="#ffff54">점심시간까지 일하고 싶으면 그렇게 하세요.</font>

3795
01:21:59,699 --> 01:22:01,739
So let's hit the service mesh stuff.

3796
01:21:59,699 --> 01:22:01,739
<font color="#ffff54">그럼 서비스 메시 작업을 시작해보죠.</font>

3797
01:22:01,739 --> 01:22:03,100
Service mesh functionality.

3798
01:22:01,739 --> 01:22:03,100
<font color="#ffff54">서비스 메시 기능.</font>

3799
01:22:03,100 --> 01:22:05,300
I mean, we've got all this functionality

3800
01:22:03,100 --> 01:22:05,300
<font color="#ffff54">이 모든 기능이 있습니다.</font>

3801
01:22:05,300 --> 01:22:06,319
built into Kubernetes.

3802
01:22:05,300 --> 01:22:06,319
<font color="#ffff54">쿠버네티스에 내장되어 있다.</font>

3803
01:22:06,319 --> 01:22:08,140
We've got the CNI, we've got services,

3804
01:22:06,319 --> 01:22:08,140
<font color="#ffff54">CNI가 있고, 서비스가 있습니다,</font>

3805
01:22:08,140 --> 01:22:10,600
we've got ingress, and now these gateways.

3806
01:22:08,140 --> 01:22:10,600
<font color="#ffff54">인그레스, 그리고 이제 이 게이트웨이들.</font>

3807
01:22:10,600 --> 01:22:13,460
And there's just so much power and capability

3808
01:22:10,600 --> 01:22:13,460
<font color="#ffff54">그리고 엄청난 힘과 능력이 있습니다.</font>

3809
01:22:13,460 --> 01:22:15,340
from a networking standpoint.

3810
01:22:13,460 --> 01:22:15,340
<font color="#ffff54">네트워킹 관점에서 보면 말이죠.</font>

3811
01:22:15,340 --> 01:22:16,739
And there is complexity,

3812
01:22:15,340 --> 01:22:16,739
<font color="#ffff54">그리고 복잡성도 있습니다,</font>

3813
01:22:16,739 --> 01:22:18,980
but when you start poking around and looking at it

3814
01:22:16,739 --> 01:22:18,980
<font color="#ffff54">하지만 이리저리 뒤져보고 저리 뒤져보면</font>

3815
01:22:18,980 --> 01:22:21,779
in the labs here, you realize that it's manageable.

3816
01:22:18,980 --> 01:22:21,779
<font color="#ffff54">여기 실험실에서는 관리가 가능하다는 것을 깨닫게 됩니다.</font>

3817
01:22:21,779 --> 01:22:23,460
But what's left, right?

3818
01:22:21,779 --> 01:22:23,460
<font color="#ffff54">하지만 남은 건 뭐죠?</font>

3819
01:22:23,460 --> 01:22:25,699
Well, if you're a developer

3820
01:22:23,460 --> 01:22:25,699
<font color="#ffff54">글쎄, 만약 당신이 개발자라면</font>

3821
01:22:26,399 --> 01:22:28,239
and your boss is hammering on you about security,

3822
01:22:26,399 --> 01:22:28,239
<font color="#ffff54">상사가 보안에 대해 잔소리를 하는 경우,</font>

3823
01:22:28,239 --> 01:22:30,039
security, security,

3824
01:22:28,239 --> 01:22:30,039
<font color="#ffff54">보안, 보안,</font>

3825
01:22:30,039 --> 01:22:33,059
do you really want to go back and instrument

3826
01:22:30,039 --> 01:22:33,059
<font color="#ffff54">"정말 돌아가서 악기를 연주하고 싶니?</font>

3827
01:22:33,059 --> 01:22:37,559
every single service you wrote with mutual TLS?

3828
01:22:33,059 --> 01:22:37,559
<font color="#ffff54">모든 서비스를 상호 TLS로 작성했나요?</font>

3829
01:22:37,559 --> 01:22:41,019
And how likely are you to get that right anyway?

3830
01:22:37,559 --> 01:22:41,019
<font color="#ffff54">이걸 맞출 확률이 얼마나 될까요?</font>

3831
01:22:41,019 --> 01:22:42,559
And then you're gonna be,

3832
01:22:41,019 --> 01:22:42,559
<font color="#ffff54">그리고 넌 그렇게 될 거야,</font>

3833
01:22:42,559 --> 01:22:45,079
now you've got another thing to debug and to manage.

3834
01:22:42,559 --> 01:22:45,079
<font color="#ffff54">이제 디버깅하고 관리해야 할 것이 하나 더 생겼습니다.</font>

3835
01:22:45,079 --> 01:22:46,760
That alone right there is a killer.

3836
01:22:45,079 --> 01:22:46,760
<font color="#ffff54">그것만으로도 살인자네.</font>

3837
01:22:46,760 --> 01:22:47,739
And then as soon as you do it,

3838
01:22:46,760 --> 01:22:47,739
<font color="#ffff54">그리고 곧바로</font>

3839
01:22:47,739 --> 01:22:49,399
now all your customers are broken.

3840
01:22:47,739 --> 01:22:49,399
<font color="#ffff54">이제 모든 고객이 망가졌습니다.</font>

3841
01:22:49,399 --> 01:22:52,800
They gotta implement on their side, the mutual TLS stuff.

3842
01:22:49,399 --> 01:22:52,800
<font color="#ffff54">상호 TLS를 구현해야 합니다.</font>

3843
01:22:52,800 --> 01:22:56,800
That's a pain in Java or C++ or Go or Rust or whatever.

3844
01:22:52,800 --> 01:22:56,800
<font color="#ffff54">자바나 C++, 고, 러스트 등에서는 골치 아픈 일이죠.</font>

3845
01:22:56,800 --> 01:22:59,539
Well, wouldn't it be amazing

3846
01:22:56,800 --> 01:22:59,539
<font color="#ffff54">글쎄, 정말 놀랍지 않겠어?</font>

3847
01:22:59,539 --> 01:23:01,100
if you could just flip a switch

3848
01:22:59,539 --> 01:23:01,100
<font color="#ffff54">스위치 하나만 돌릴 수 있다면</font>

3849
01:23:02,140 --> 01:23:04,699
and inject a proxy into every pod

3850
01:23:02,140 --> 01:23:04,699
<font color="#ffff54">모든 파드에 프록시를 주입한다.</font>

3851
01:23:04,699 --> 01:23:07,060
that did the mutual TLS automatically

3852
01:23:04,699 --> 01:23:07,060
<font color="#ffff54">상호 TLS를 자동으로 수행했다.</font>

3853
01:23:07,060 --> 01:23:09,199
for every single outbound connection

3854
01:23:07,060 --> 01:23:09,199
<font color="#ffff54">모든 단일 아웃바운드 연결에 대해</font>

3855
01:23:09,199 --> 01:23:12,020
and on the other side for everything that comes in?

3856
01:23:09,199 --> 01:23:12,020
<font color="#ffff54">그리고 반대쪽에서 들어오는 모든 연결에 대해?</font>

3857
01:23:12,020 --> 01:23:13,480
That would be amazing.

3858
01:23:12,020 --> 01:23:13,480
<font color="#ffff54">정말 멋지네요.</font>

3859
01:23:13,480 --> 01:23:15,960
And wouldn't it be amazing if those pods,

3860
01:23:13,480 --> 01:23:15,960
<font color="#ffff54">저 포드가 있다면 정말 놀랍지 않을까요?</font>

3861
01:23:15,960 --> 01:23:18,680
so that you didn't have to, reported telemetry that says,

3862
01:23:15,960 --> 01:23:18,680
<font color="#ffff54">라는 텔레메트리를 보고했습니다,</font>

3863
01:23:18,680 --> 01:23:21,300
I'm connecting at this moment in time.

3864
01:23:18,680 --> 01:23:21,300
<font color="#ffff54">지금 이 순간 연결 중입니다.</font>

3865
01:23:21,300 --> 01:23:23,199
I've been connected for this period of time.

3866
01:23:21,300 --> 01:23:23,199
<font color="#ffff54">이 시간 동안 연결되었습니다.</font>

3867
01:23:23,199 --> 01:23:25,680
Ooh, I'm seeing these errors come back

3868
01:23:23,199 --> 01:23:25,680
<font color="#ffff54">오, 이런 오류가 다시 나타납니다.</font>

3869
01:23:25,680 --> 01:23:29,079
and just reported that all to a central repository

3870
01:23:25,680 --> 01:23:29,079
<font color="#ffff54">방금 중앙 저장소에 보고했습니다.</font>

3871
01:23:29,079 --> 01:23:30,920
that you could open up in Prometheus and chart

3872
01:23:29,079 --> 01:23:30,920
<font color="#ffff54">프로메테우스에서 열어서 차트를 만들 수 있습니다.</font>

3873
01:23:30,920 --> 01:23:32,840
and look at and set alerts on.

3874
01:23:30,920 --> 01:23:32,840
<font color="#ffff54">보고 알림을 설정할 수 있습니다.</font>

3875
01:23:32,840 --> 01:23:34,039
That would be amazing.

3876
01:23:32,840 --> 01:23:34,039
<font color="#ffff54">대단하네요.</font>

3877
01:23:34,039 --> 01:23:36,539
And that's why service meshes are amazing.

3878
01:23:34,039 --> 01:23:36,539
<font color="#ffff54">이것이 바로 서비스 메시가 놀라운 이유입니다.</font>

3879
01:23:36,539 --> 01:23:38,039
Those are the things that they do.

3880
01:23:36,539 --> 01:23:38,039
<font color="#ffff54">그게 바로 그들이 하는 일입니다.</font>

3881
01:23:38,039 --> 01:23:39,520
They give you MTLS for free,

3882
01:23:38,039 --> 01:23:39,520
<font color="#ffff54">그들은 당신에게 MTLS를 무료로 제공합니다,</font>

3883
01:23:39,520 --> 01:23:41,060
communications metrics for free,

3884
01:23:39,520 --> 01:23:41,060
<font color="#ffff54">통신 지표를 무료로 제공합니다,</font>

3885
01:23:41,060 --> 01:23:42,340
communication policy.

3886
01:23:41,060 --> 01:23:42,340
<font color="#ffff54">통신 정책.</font>

3887
01:23:42,340 --> 01:23:44,720
You can't talk to that guy, but you can't talk to this guy.

3888
01:23:42,340 --> 01:23:44,720
<font color="#ffff54">저 사람과 대화할 수도 없고, 이 사람과도 대화할 수 없습니다.</font>

3889
01:23:44,720 --> 01:23:46,960
And you can't talk to that guy on Friday or whatever.

3890
01:23:44,720 --> 01:23:46,960
<font color="#ffff54">그리고 금요일 같은 날에는 저 남자랑 얘기할 수 없어.</font>

3891
01:23:46,960 --> 01:23:48,340
Policy.

3892
01:23:46,960 --> 01:23:48,340
<font color="#ffff54">정책.</font>

3893
01:23:48,340 --> 01:23:50,920
Traces, fault injection, chaos support,

3894
01:23:48,340 --> 01:23:50,920
<font color="#ffff54">트레이스, 오류 주입, 카오스 지원,</font>

3895
01:23:51,460 --> 01:23:52,300
advanced traffic management.

3896
01:23:51,460 --> 01:23:52,300
<font color="#ffff54">고급 트래픽 관리.</font>

3897
01:23:52,300 --> 01:23:54,960
This is what service mesh brings to the table.

3898
01:23:52,300 --> 01:23:54,960
<font color="#ffff54">서비스 메시가 등장합니다.</font>

3899
01:23:54,960 --> 01:23:58,020
And there are a bunch of them to choose from.

3900
01:23:54,960 --> 01:23:58,020
<font color="#ffff54">그리고 선택할 수 있는 여러 가지가 있습니다.</font>

3901
01:23:58,020 --> 01:24:00,279
There are proxy-based service meshes.

3902
01:23:58,020 --> 01:24:00,279
<font color="#ffff54">프록시 기반 서비스 메시가 있습니다.</font>

3903
01:24:00,279 --> 01:24:04,220
So this is the longstanding group, right?

3904
01:24:00,279 --> 01:24:04,220
<font color="#ffff54">이 그룹이 가장 오래된 그룹이죠?</font>

3905
01:24:04,220 --> 01:24:08,239
Your linkerdys and istios and open service meshes

3906
01:24:04,220 --> 01:24:08,239
<font color="#ffff54">링커디와 이스티오, 개방형 서비스 메시가 등장합니다.</font>

3907
01:24:08,239 --> 01:24:10,239
and so on and so forth.

3908
01:24:08,239 --> 01:24:10,239
<font color="#ffff54">그리고 등등.</font>

3909
01:24:10,239 --> 01:24:14,220
And so those guys are well understood.

3910
01:24:10,239 --> 01:24:14,220
<font color="#ffff54">그래서 그 사람들은 잘 이해합니다.</font>

3911
01:24:14,220 --> 01:24:17,720
They're also nice because they operate in the pod sphere.

3912
01:24:14,220 --> 01:24:17,720
<font color="#ffff54">그들은 또한 포드 구체에서 작동하기 때문에 좋습니다.</font>

3913
01:24:17,720 --> 01:24:20,199
They're not messing around in the kernel

3914
01:24:17,720 --> 01:24:20,199
<font color="#ffff54">그들은 커널에서 장난치지 않는다.</font>

3915
01:24:20,720 --> 01:24:22,760
or down at the host level.

3916
01:24:20,720 --> 01:24:22,760
<font color="#ffff54">또는 호스트 레벨에서 다운되었습니다.</font>

3917
01:24:22,760 --> 01:24:25,920
And this means that the second your traffic leaves your pod,

3918
01:24:22,760 --> 01:24:25,920
<font color="#ffff54">이는 트래픽이 파드를 떠나는 순간을 의미합니다,</font>

3919
01:24:25,920 --> 01:24:27,199
it's encrypted.

3920
01:24:25,920 --> 01:24:27,199
<font color="#ffff54">암호화된다.</font>

3921
01:24:27,199 --> 01:24:28,519
And so that's nice, right?

3922
01:24:27,199 --> 01:24:28,519
<font color="#ffff54">멋지지 않나요?</font>

3923
01:24:28,519 --> 01:24:30,840
If you're running some sensitive workloads,

3924
01:24:28,519 --> 01:24:30,840
<font color="#ffff54">민감한 워크로드를 실행하는 경우,</font>

3925
01:24:30,840 --> 01:24:33,479
who are the administrators on those computers, right?

3926
01:24:30,840 --> 01:24:33,479
<font color="#ffff54">해당 컴퓨터의 관리자는 누구죠?</font>

3927
01:24:33,479 --> 01:24:34,800
So there's some really nice things

3928
01:24:33,479 --> 01:24:34,800
<font color="#ffff54">그래서 정말 좋은 것들이 있습니다.</font>

3929
01:24:34,800 --> 01:24:37,319
about having a proxy-based solution.

3930
01:24:34,800 --> 01:24:37,319
<font color="#ffff54">프록시 기반 솔루션에 대해</font>

3931
01:24:37,319 --> 01:24:39,939
And then the other thing that's also nice about that

3932
01:24:37,319 --> 01:24:39,939
<font color="#ffff54">그리고 또 한 가지 좋은 점이 있습니다.</font>

3933
01:24:39,939 --> 01:24:42,840
is that it's not in your software.

3934
01:24:39,939 --> 01:24:42,840
<font color="#ffff54">이 소프트웨어에 없다는 것입니다.</font>

3935
01:24:42,840 --> 01:24:44,239
You can upgrade the proxy

3936
01:24:42,840 --> 01:24:44,239
<font color="#ffff54">프록시를 업그레이드할 수 있습니다.</font>

3937
01:24:44,239 --> 01:24:45,880
without messing with your software, right?

3938
01:24:44,239 --> 01:24:45,880
<font color="#ffff54">소프트웨어를 망치지 않고도 말이죠?</font>

3939
01:24:45,880 --> 01:24:48,840
They have different life cycles and stuff.

3940
01:24:45,880 --> 01:24:48,840
<font color="#ffff54">수명 주기도 다르고요.</font>

3941
01:24:48,840 --> 01:24:50,119
Then you have eBPF-based.

3942
01:24:48,840 --> 01:24:50,119
<font color="#ffff54">그리고 eBPF 기반이 있습니다.</font>

3943
01:24:51,000 --> 01:24:51,880
So this is a little bit bleeding edge.

3944
01:24:51,000 --> 01:24:51,880
<font color="#ffff54">이것은 약간 최첨단입니다.</font>

3945
01:24:51,880 --> 01:24:55,279
There's some really awesome stuff in the hopper there,

3946
01:24:51,880 --> 01:24:55,279
<font color="#ffff54">저기 호퍼에 정말 멋진 물건이 있네요,</font>

3947
01:24:55,279 --> 01:24:57,239
but there's some downsides too.

3948
01:24:55,279 --> 01:24:57,239
<font color="#ffff54">하지만 몇 가지 단점도 있습니다.</font>

3949
01:24:57,239 --> 01:24:59,760
And the biggest thing is that I don't think

3950
01:24:57,239 --> 01:24:59,760
<font color="#ffff54">그리고 가장 큰 것은 제가 생각하기에</font>

3951
01:24:59,760 --> 01:25:03,140
you're gonna see a lot of GA eBPF service mesh

3952
01:24:59,760 --> 01:25:03,140
<font color="#ffff54">많은 GA eBPF 서비스 메시를 보게 될 것입니다.</font>

3953
01:25:03,140 --> 01:25:06,079
implementations at this moment, soon,

3954
01:25:03,140 --> 01:25:06,079
<font color="#ffff54">곧 구현될 예정입니다,</font>

3955
01:25:06,079 --> 01:25:08,519
but it's a little early days there.

3956
01:25:06,079 --> 01:25:08,519
<font color="#ffff54">하지만 아직은 조금 이른 시기입니다.</font>

3957
01:25:08,519 --> 01:25:10,800
Cilium, for example, and others can provide

3958
01:25:08,519 --> 01:25:10,800
<font color="#ffff54">예를 들어 실리움 등은</font>

3959
01:25:10,800 --> 01:25:12,239
that kind of functionality.

3960
01:25:10,800 --> 01:25:12,239
<font color="#ffff54">그런 종류의 기능을 제공합니다.</font>

3961
01:25:12,239 --> 01:25:13,880
And then library-based.

3962
01:25:12,239 --> 01:25:13,880
<font color="#ffff54">그리고 라이브러리 기반.</font>

3963
01:25:13,880 --> 01:25:16,800
What if you're using gRPC everywhere?

3964
01:25:13,880 --> 01:25:16,800
<font color="#ffff54">모든 곳에서 gRPC를 사용한다면 어떨까요?</font>

3965
01:25:16,800 --> 01:25:19,720
Well, gRPC could do the TLS for you.

3966
01:25:16,800 --> 01:25:19,720
<font color="#ffff54">gRPC가 TLS를 대신 해줄 수 있습니다.</font>

3967
01:25:20,280 --> 01:25:21,400
And it's gRPC library, right?

3968
01:25:20,280 --> 01:25:21,400
<font color="#ffff54">그리고 gRPC 라이브러리 맞죠?</font>

3969
01:25:21,400 --> 01:25:22,840
If you're using it on both sides,

3970
01:25:21,400 --> 01:25:22,840
<font color="#ffff54">양쪽에서 모두 사용하는 경우,</font>

3971
01:25:22,840 --> 01:25:24,480
then you could flip that on.

3972
01:25:22,840 --> 01:25:24,480
<font color="#ffff54">뒤집으면 됩니다.</font>

3973
01:25:24,480 --> 01:25:27,440
And gRPC just, I think, went GA

3974
01:25:24,480 --> 01:25:27,440
<font color="#ffff54">그리고 gRPC는 그냥 GA가 된 것 같아요.</font>

3975
01:25:27,440 --> 01:25:30,320
with their proxy-less service mesh.

3976
01:25:27,440 --> 01:25:30,320
<font color="#ffff54">프록시 없는 서비스 메시로.</font>

3977
01:25:30,320 --> 01:25:32,840
And so you could use the control plane

3978
01:25:30,320 --> 01:25:32,840
<font color="#ffff54">그래서 컨트롤 플레인을 사용할 수 있습니다.</font>

3979
01:25:32,840 --> 01:25:36,300
of a standard service mesh to talk to your gRPC libraries

3980
01:25:32,840 --> 01:25:36,300
<font color="#ffff54">표준 서비스 메시를 사용하여 gRPC 라이브러리와 통신할 수 있습니다.</font>

3981
01:25:36,300 --> 01:25:38,320
and tell them to do what they need to do

3982
01:25:36,300 --> 01:25:38,320
<font color="#ffff54">필요한 작업을 수행하도록 지시합니다.</font>

3983
01:25:38,320 --> 01:25:40,000
to do the service mesh stuff.

3984
01:25:38,320 --> 01:25:40,000
<font color="#ffff54">서비스 메시 작업을 수행합니다.</font>

3985
01:25:40,000 --> 01:25:40,920
And now you don't have a proxy.

3986
01:25:40,000 --> 01:25:40,920
<font color="#ffff54">이제 프록시가 없습니다.</font>

3987
01:25:40,920 --> 01:25:43,400
So the proxy does add some latency, right?

3988
01:25:40,920 --> 01:25:43,400
<font color="#ffff54">프록시 때문에 지연 시간이 늘어난 거죠?</font>

3989
01:25:43,400 --> 01:25:45,579
So that's why the people who build their proxies

3990
01:25:43,400 --> 01:25:45,579
<font color="#ffff54">그래서 프록시를 구축하는 사람들이</font>

3991
01:25:45,579 --> 01:25:47,060
build them to be crazy fast.

3992
01:25:45,579 --> 01:25:47,060
<font color="#ffff54">엄청나게 빠르게 구축합니다.</font>

3993
01:25:47,100 --> 01:25:48,860
And then the linkerd, which is what we're gonna use,

3994
01:25:47,100 --> 01:25:48,860
<font color="#ffff54">그리고 링커드를 사용할 것입니다,</font>

3995
01:25:48,860 --> 01:25:52,380
is super awesome and has a Rust-based proxy.

3996
01:25:48,860 --> 01:25:52,380
<font color="#ffff54">은 정말 멋지고 Rust 기반 프록시가 있습니다.</font>

3997
01:25:52,380 --> 01:25:56,260
So compiled down to super compact, fast, native code.

3998
01:25:52,380 --> 01:25:56,260
<font color="#ffff54">따라서 매우 작고 빠른 네이티브 코드로 컴파일됩니다.</font>

3999
01:25:56,260 --> 01:26:00,060
And linkerd's kind of famous for being the fastest

4000
01:25:56,260 --> 01:26:00,060
<font color="#ffff54">그리고 링커드는 가장 빠른 것으로 유명합니다.</font>

4001
01:26:00,060 --> 01:26:02,820
of the proxy-based service meshes out there.

4002
01:26:00,060 --> 01:26:02,820
<font color="#ffff54">프록시 기반 서비스 메시 중 가장 빠른 것으로 유명합니다.</font>

4003
01:26:02,820 --> 01:26:05,900
And it's also super easy to install and works really great.

4004
01:26:02,820 --> 01:26:05,900
<font color="#ffff54">또한 설치가 매우 쉽고 정말 훌륭하게 작동합니다.</font>

4005
01:26:05,900 --> 01:26:08,020
So the last lab, which I know there's no slide,

4006
01:26:05,900 --> 01:26:08,020
<font color="#ffff54">마지막 실험실은 슬라이드가 없는 것으로 알고 있습니다,</font>

4007
01:26:08,020 --> 01:26:11,400
lab five, is gonna have you install linkerd

4008
01:26:08,020 --> 01:26:11,400
<font color="#ffff54">5번 실험실에서는 링커드를 설치해야 합니다.</font>

4009
01:26:11,400 --> 01:26:13,420
and then start looking at some of the metrics,

4010
01:26:11,400 --> 01:26:13,420
<font color="#ffff54">그리고 몇 가지 메트릭을 살펴봅니다,</font>

4011
01:26:13,420 --> 01:26:14,660
how you can see connections

4012
01:26:13,420 --> 01:26:14,660
<font color="#ffff54">연결을 보는 방법</font>

4013
01:26:14,660 --> 01:26:16,140
and see them that they're secured.

4014
01:26:14,660 --> 01:26:16,140
<font color="#ffff54">보안이 설정되어 있는지 확인합니다.</font>

4015
01:26:16,539 --> 01:26:19,060
It's really an amazing thing to see

4016
01:26:16,539 --> 01:26:19,060
<font color="#ffff54">정말 놀라운 일입니다.</font>

4017
01:26:19,060 --> 01:26:20,920
and it's so easy to try out.

4018
01:26:19,060 --> 01:26:20,920
<font color="#ffff54">시도하기 너무 쉬워요.</font>

4019
01:26:20,920 --> 01:26:22,940
So one of the shorter lab steps.

4020
01:26:20,920 --> 01:26:22,940
<font color="#ffff54">실험실 단계가 짧아졌습니다.</font>

4021
01:26:22,940 --> 01:26:27,640
So what I am going to do is say thank you a ton for coming.

4022
01:26:22,940 --> 01:26:27,640
<font color="#ffff54">와주셔서 정말 감사하다는 말씀을 드리고 싶습니다.</font>

4023
01:26:27,640 --> 01:26:29,420
We do have another few minutes if you wanna hang out

4024
01:26:27,640 --> 01:26:29,420
<font color="#ffff54">더 놀고 싶으시면 몇 분 더 있습니다.</font>

4025
01:26:29,420 --> 01:26:30,300
to the bottom of the hour,

4026
01:26:29,420 --> 01:26:30,300
<font color="#ffff54">한 시간 남았습니다,</font>

4027
01:26:30,300 --> 01:26:33,100
but I think they will kick us out in like three minutes.

4028
01:26:30,300 --> 01:26:33,100
<font color="#ffff54">3분 안에 쫓겨날 것 같아요.</font>

4029
01:26:33,100 --> 01:26:35,780
So feel free to keep working on the lab up until the last

4030
01:26:33,100 --> 01:26:35,780
<font color="#ffff54">그러니 마지막까지 실험실에서 계속 일하세요.</font>

4031
01:26:35,780 --> 01:26:37,340
if you want to, or work on it for lunch.

4032
01:26:35,780 --> 01:26:37,340
<font color="#ffff54">원한다면 점심시간에 작업해도 됩니다.</font>

4033
01:26:37,340 --> 01:26:38,780
We'll leave the boxes up for a bit.

4034
01:26:37,340 --> 01:26:38,780
<font color="#ffff54">잠시 상자를 열어두겠습니다.</font>

4035
01:26:38,780 --> 01:26:40,300
And yeah, thanks a bunch for coming.

4036
01:26:38,780 --> 01:26:40,300
<font color="#ffff54">네, 와주셔서 감사합니다.</font>

4037
01:26:40,300 --> 01:26:41,940
Have a wonderful rest of your convention.

4038
01:26:40,300 --> 01:26:41,940
<font color="#ffff54">남은 컨벤션도 즐겁게 보내세요.</font>

4039
01:26:41,940 --> 01:26:42,780
Thank you.

4040
01:26:41,940 --> 01:26:42,780
<font color="#ffff54">감사합니다.</font>
