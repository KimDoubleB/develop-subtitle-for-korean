1
00:00:00,000 --> 00:00:05,960
Hey, thank you guys for joining this session.

2
00:00:00,000 --> 00:00:05,960
<font color="#ffff54">이 세션에 참여해 주셔서 감사합니다.</font>

3
00:00:05,960 --> 00:00:09,120
A technical session at 4 p.m. in the afternoon.

4
00:00:05,960 --> 00:00:09,120
<font color="#ffff54">오후 4시에 기술 세션이 있습니다.</font>

5
00:00:09,120 --> 00:00:13,280
Hope you guys are ready for that.

6
00:00:09,120 --> 00:00:13,280
<font color="#ffff54">다들 준비됐길 바랍니다.</font>

7
00:00:13,280 --> 00:00:14,280
How was the day today?

8
00:00:13,280 --> 00:00:14,280
<font color="#ffff54">오늘 하루 어땠어요?</font>

9
00:00:14,280 --> 00:00:15,280
How was the talk?

10
00:00:14,280 --> 00:00:15,280
<font color="#ffff54">대화는 어땠어요?</font>

11
00:00:15,280 --> 00:00:17,280
Did you guys have awesome?

12
00:00:15,280 --> 00:00:17,280
<font color="#ffff54">재밌었어?</font>

13
00:00:17,280 --> 00:00:18,280
Amazing.

14
00:00:17,280 --> 00:00:18,280
<font color="#ffff54">굉장해.</font>

15
00:00:18,280 --> 00:00:23,800
All right, so let me try to close it with like a good note, I guess.

16
00:00:18,280 --> 00:00:23,800
<font color="#ffff54">좋아, 그럼 좋은 느낌으로 마무리해보자.</font>

17
00:00:23,800 --> 00:00:35,840
Today we're going to do a workshop on how to build an eBPF, a CNI plugin that uses eBPF.

18
00:00:23,800 --> 00:00:35,840
<font color="#ffff54">오늘은 eBPF를 사용하는 CNI 플러그인인 eBPF를 구축하는 방법에 대한 워크샵을 진행하겠습니다.</font>

19
00:00:35,840 --> 00:00:39,359
It's going to be a tutorial for about an hour and a half.

20
00:00:35,840 --> 00:00:39,359
<font color="#ffff54">약 한 시간 반 동안 튜토리얼이 진행될 예정입니다.</font>

21
00:00:39,359 --> 00:00:44,480
I'm going to try to make it actually shorter just for you guys to rest a bit from this

22
00:00:39,359 --> 00:00:44,480
<font color="#ffff54">여러분들이 잠시 쉴 수 있도록 실제로는 더 짧게 만들려고 합니다.</font>

23
00:00:44,480 --> 00:00:45,480
long day.

24
00:00:44,480 --> 00:00:45,480
<font color="#ffff54">긴 하루였어.</font>

25
00:00:45,480 --> 00:00:46,480
All right.

26
00:00:45,480 --> 00:00:46,480
<font color="#ffff54">다 됐다.</font>

27
00:00:46,480 --> 00:00:47,480
You guys ready?

28
00:00:46,480 --> 00:00:47,480
<font color="#ffff54">준비됐어?</font>

29
00:00:47,480 --> 00:00:48,480
Amazing.

30
00:00:47,480 --> 00:00:48,480
<font color="#ffff54">놀랍군.</font>

31
00:00:48,480 --> 00:00:49,480
Let's do it.

32
00:00:48,480 --> 00:00:49,480
<font color="#ffff54">해보자.</font>

33
00:00:49,480 --> 00:00:50,480
All right.

34
00:00:49,480 --> 00:00:50,480
<font color="#ffff54">됐어요.</font>

35
00:00:50,480 --> 00:00:56,840
A bit by myself, my name is Adam Saya.

36
00:00:50,480 --> 00:00:56,840
<font color="#ffff54">조금 혼자서, 제 이름은 아담 사야입니다.</font>

37
00:00:56,840 --> 00:01:00,960
I work at Solo.

38
00:00:56,840 --> 00:01:00,960
<font color="#ffff54">저는 솔로에서 일해요.</font>

39
00:01:00,960 --> 00:01:07,080
In the past couple years, I've been very focused on what we call application networking in

40
00:01:00,960 --> 00:01:07,080
<font color="#ffff54">지난 몇 년 동안 저는 애플리케이션 네트워킹이라는 분야에 집중해 왔습니다.</font>

41
00:01:07,080 --> 00:01:08,320
general.

42
00:01:07,080 --> 00:01:08,320
<font color="#ffff54">일반.</font>

43
00:01:08,320 --> 00:01:12,560
So I deal with API getways and service mesh every day.

44
00:01:08,320 --> 00:01:12,560
<font color="#ffff54">그래서 저는 매일 API 겟웨이와 서비스 메시를 처리합니다.</font>

45
00:01:12,560 --> 00:01:17,680
And kind of the focus there is to secure the traffic and secure the network in general.

46
00:01:12,560 --> 00:01:17,680
<font color="#ffff54">그리고 트래픽을 보호하고 네트워크를 전반적으로 보호하는 데 중점을 두고 있습니다.</font>

47
00:01:17,680 --> 00:01:25,560
Now one thing I'm very much interested in these days is how can I do more instead of

48
00:01:17,680 --> 00:01:25,560
<font color="#ffff54">요즘 제가 가장 관심을 갖고 있는 것은 어떻게 하면 더 많은 일을 할 수 있을까 하는 것입니다.</font>

49
00:01:25,560 --> 00:01:32,680
operating at L7 on the layer seven, where it's kind of the application layer, I want

50
00:01:25,560 --> 00:01:32,680
<font color="#ffff54">애플리케이션 레이어에 해당하는 레이어 7의 L7에서 작동하는 것입니다.</font>

51
00:01:32,680 --> 00:01:40,960
to see how many policies and how much we can get from controlling the traffic way earlier

52
00:01:32,680 --> 00:01:40,960
<font color="#ffff54">얼마나 많은 정책과 트래픽을 더 일찍 제어할 수 있는지 확인합니다.</font>

53
00:01:40,960 --> 00:01:42,840
on the network stack.

54
00:01:40,960 --> 00:01:42,840
<font color="#ffff54">네트워크 스택에서</font>

55
00:01:42,840 --> 00:01:47,520
That's basically where the CNI and eBPF operates, right?

56
00:01:42,840 --> 00:01:47,520
<font color="#ffff54">기본적으로 CNI와 eBPF가 작동하는 위치죠?</font>

57
00:01:47,519 --> 00:01:52,159
It's very much networking at a very low level.

58
00:01:47,519 --> 00:01:52,159
<font color="#ffff54">아주 낮은 수준에서 네트워킹을 하는 거죠.</font>

59
00:01:52,159 --> 00:02:02,079
So today, again, we are going to do a CNI eBPF workshop, but we are not going to recreate

60
00:01:52,159 --> 00:02:02,079
<font color="#ffff54">그래서 오늘도 CNI eBPF 워크숍을 진행하되, 다음과 같은 상황을 재현하지는 않을 것입니다.</font>

61
00:02:02,079 --> 00:02:03,079
Solyan.

62
00:02:02,079 --> 00:02:03,079
<font color="#ffff54">솔리안.</font>

63
00:02:03,079 --> 00:02:06,560
We are not going to do something, anything complicated.

64
00:02:03,079 --> 00:02:06,560
<font color="#ffff54">우리는 뭔가 복잡한 일을 하지 않을 거야.</font>

65
00:02:06,560 --> 00:02:13,439
I think the goal of this session is mainly to solve this curiosity that everyone has.

66
00:02:06,560 --> 00:02:13,439
<font color="#ffff54">이 세션의 목표는 주로 모든 사람이 가지고 있는 이 궁금증을 해결하는 것이라고 생각합니다.</font>

67
00:02:13,439 --> 00:02:17,479
For example, for me, when I was a kid, I always been asking my dad, like, hey, how

68
00:02:13,439 --> 00:02:17,479
<font color="#ffff54">예를 들어, 저는 어렸을 때 항상 아빠에게 이렇게 물었습니다.</font>

69
00:02:17,479 --> 00:02:18,479
things work?

70
00:02:17,479 --> 00:02:18,479
<font color="#ffff54">작동하는 거야?</font>

71
00:02:18,479 --> 00:02:20,960
And he gave me like the quick pitch, right?

72
00:02:18,479 --> 00:02:20,960
<font color="#ffff54">그리고 그는 나에게 빠른 피치를 주었지?</font>

73
00:02:20,960 --> 00:02:26,280
For example, for us today is like opening a car and, you know, open the hood and saying,

74
00:02:20,960 --> 00:02:26,280
<font color="#ffff54">예를 들어, 오늘 우리에게는 자동차를 열고 보닛을 열면서 이렇게 말하는 것과 같습니다,</font>

75
00:02:26,280 --> 00:02:28,960
hey, this is the engine and this is the battery.

76
00:02:26,280 --> 00:02:28,960
<font color="#ffff54">이봐, 이건 엔진이고 이건 배터리야.</font>

77
00:02:28,960 --> 00:02:31,020
And, you know, that's pretty much it.

78
00:02:28,960 --> 00:02:31,020
<font color="#ffff54">여기까지입니다.</font>

79
00:02:31,020 --> 00:02:36,479
As long as if we can understand the kind of the underlying mechanism being used in these

80
00:02:31,020 --> 00:02:36,479
<font color="#ffff54">만약 우리가 이것들에 사용되는 기본 메커니즘의 종류를 이해할 수 있다면.</font>

81
00:02:36,479 --> 00:02:42,400
technologies like Solyan and other big project that use eBPF, then it's a good it's a good

82
00:02:36,479 --> 00:02:42,400
<font color="#ffff54">솔리안과 같은 기술이나 eBPF를 사용하는 다른 대형 프로젝트에서 사용되는 기본 메커니즘의 종류를 이해할 수만 있다면</font>

83
00:02:42,400 --> 00:02:43,400
day.

84
00:02:42,400 --> 00:02:43,400
<font color="#ffff54">day.</font>

85
00:02:43,400 --> 00:02:44,400
All right.

86
00:02:43,400 --> 00:02:44,400
<font color="#ffff54">알았어요.</font>

87
00:02:44,400 --> 00:02:45,400
All right.

88
00:02:44,400 --> 00:02:45,400
<font color="#ffff54">끝났어요.</font>

89
00:02:45,400 --> 00:02:48,840
So let's get started.

90
00:02:45,400 --> 00:02:48,840
<font color="#ffff54">그럼 시작하죠.</font>

91
00:02:48,840 --> 00:02:51,680
What we are going to do today, a couple of things.

92
00:02:48,840 --> 00:02:51,680
<font color="#ffff54">오늘 우리가 할 일은 몇 가지입니다.</font>

93
00:02:51,680 --> 00:02:55,520
We're going to start with a small presentation around what's a CNI.

94
00:02:51,680 --> 00:02:55,520
<font color="#ffff54">먼저 CNI가 무엇인지에 대한 간단한 프레젠테이션으로 시작하겠습니다.</font>

95
00:02:55,520 --> 00:03:00,439
Okay, very few slides going on talking about the basics.

96
00:02:55,520 --> 00:03:00,439
<font color="#ffff54">자, 기본에 대해 설명하는 슬라이드가 거의 없습니다.</font>

97
00:03:00,439 --> 00:03:05,240
We're not going to deep dive too much into it, but at least just to get the main idea

98
00:03:00,439 --> 00:03:05,240
<font color="#ffff54">너무 깊게 파고들지는 않겠지만, 최소한 주요 아이디어는 얻을 수 있습니다.</font>

99
00:03:05,240 --> 00:03:06,640
of how things work.

100
00:03:05,240 --> 00:03:06,640
<font color="#ffff54">어떻게 작동하는지에 대해서요.</font>

101
00:03:06,640 --> 00:03:10,080
After that, we are going to use our laptops.

102
00:03:06,640 --> 00:03:10,080
<font color="#ffff54">그 후에는 노트북을 사용할 것입니다.</font>

103
00:03:10,080 --> 00:03:12,520
I don't know if you guys are ready for that.

104
00:03:10,080 --> 00:03:12,520
<font color="#ffff54">여러분들이 준비되었는지 모르겠네요.</font>

105
00:03:12,520 --> 00:03:20,020
You guys can follow with me to to create our own first CNI.

106
00:03:12,520 --> 00:03:20,020
<font color="#ffff54">여러분은 저와 함께 우리만의 첫 번째 CNI를 만들 수 있습니다.</font>

107
00:03:20,020 --> 00:03:24,520
After that, we're going to talk about eBPF and kind of the use cases we can use it with

108
00:03:20,020 --> 00:03:24,520
<font color="#ffff54">그 다음에는 eBPF와 이를 사용할 수 있는 몇 가지 사용 사례에 대해 이야기하겠습니다.</font>

109
00:03:24,520 --> 00:03:25,520
the CNI.

110
00:03:24,520 --> 00:03:25,520
<font color="#ffff54">CNI.</font>

111
00:03:25,520 --> 00:03:32,000
We are going to talk about a bit of more complexity there when we talk about monitoring.

112
00:03:25,520 --> 00:03:32,000
<font color="#ffff54">모니터링에 대해 이야기할 때 조금 더 복잡한 이야기를 하려고 합니다.</font>

113
00:03:32,000 --> 00:03:39,780
And we're going to end with how we can use eBPF for security in our in our CNI.

114
00:03:32,000 --> 00:03:39,780
<font color="#ffff54">마지막으로 CNI에서 보안을 위해 eBPF를 사용하는 방법을 살펴보겠습니다.</font>

115
00:03:39,780 --> 00:03:43,259
And at the end, we're just going to have a small conclusion and any questions.

116
00:03:39,780 --> 00:03:43,259
<font color="#ffff54">마지막에는 간단한 결론과 질문이 있을 것입니다.</font>

117
00:03:43,259 --> 00:03:44,259
All right.

118
00:03:43,259 --> 00:03:44,259
<font color="#ffff54">좋아요.</font>

119
00:03:44,259 --> 00:03:46,259
You guys ready again?

120
00:03:44,259 --> 00:03:46,259
<font color="#ffff54">다시 준비됐어?</font>

121
00:03:46,259 --> 00:03:47,259
Awesome.

122
00:03:46,259 --> 00:03:47,259
<font color="#ffff54">멋지네.</font>

123
00:03:47,259 --> 00:03:48,259
Awesome.

124
00:03:47,259 --> 00:03:48,259
<font color="#ffff54">굉장해.</font>

125
00:03:48,259 --> 00:03:49,259
All right.

126
00:03:48,259 --> 00:03:49,259
<font color="#ffff54">좋아.</font>

127
00:03:49,259 --> 00:03:54,300
So a quick question because I was very much when designing this workshop, I was, you know,

128
00:03:49,259 --> 00:03:54,300
<font color="#ffff54">이 워크샵을 디자인할 때 정말 궁금한 게 많아서 질문 하나만 할게요,</font>

129
00:03:54,300 --> 00:03:58,379
trying to figure out the right technology to use especially for the code.

130
00:03:54,300 --> 00:03:58,379
<font color="#ffff54">특히 코드에 사용할 적절한 기술을 찾으려고 노력했습니다.</font>

131
00:03:58,379 --> 00:04:02,379
So just by a raise of hand here, who writes Golang?

132
00:03:58,379 --> 00:04:02,379
<font color="#ffff54">골랑을 쓰는 사람 손들어 보세요.</font>

133
00:04:02,379 --> 00:04:04,819
All right.

134
00:04:02,379 --> 00:04:04,819
<font color="#ffff54">알았어요.</font>

135
00:04:04,819 --> 00:04:07,620
Good thing because we're going to do this in bash.

136
00:04:04,819 --> 00:04:07,620
<font color="#ffff54">잘됐네, 배쉬에서 이걸 할 거니까.</font>

137
00:04:07,620 --> 00:04:08,620
Right.

138
00:04:07,620 --> 00:04:08,620
<font color="#ffff54">그렇군요.</font>

139
00:04:08,620 --> 00:04:09,620
Right.

140
00:04:08,620 --> 00:04:09,620
<font color="#ffff54">오른쪽</font>

141
00:04:10,460 --> 00:04:14,420
I was looking for the kind of the simplest way to do it.

142
00:04:10,460 --> 00:04:14,420
<font color="#ffff54">가장 간단한 방법을 찾고 있었어요.</font>

143
00:04:14,420 --> 00:04:16,500
And I think bash helps a lot.

144
00:04:14,420 --> 00:04:16,500
<font color="#ffff54">그리고 배쉬가 많은 도움이 될 것 같아요.</font>

145
00:04:16,500 --> 00:04:22,180
Bash has a lot of abstractions and you can just like use, you know, CLI that are pretty

146
00:04:16,500 --> 00:04:22,180
<font color="#ffff54">배쉬는 추상화가 많이 되어 있고 예쁜 CLI를 사용할 수 있습니다.</font>

147
00:04:22,180 --> 00:04:25,180
much simplifying our life.

148
00:04:22,180 --> 00:04:25,180
<font color="#ffff54">우리 삶을 훨씬 단순화시켜주죠.</font>

149
00:04:25,180 --> 00:04:29,300
Golang is definitely the language of choice when you try to deal with this situation.

150
00:04:25,180 --> 00:04:29,300
<font color="#ffff54">골랑은 이러한 상황을 처리할 때 확실히 선택할 수 있는 언어입니다.</font>

151
00:04:29,300 --> 00:04:30,579
Selium uses it.

152
00:04:29,300 --> 00:04:30,579
<font color="#ffff54">셀리움은 그것을 사용합니다.</font>

153
00:04:30,579 --> 00:04:32,780
There's there's good documentation out there.

154
00:04:30,579 --> 00:04:32,780
<font color="#ffff54">좋은 문서가 있습니다.</font>

155
00:04:32,780 --> 00:04:36,680
But obviously it brings its own complexity around error handling all these things today.

156
00:04:32,780 --> 00:04:36,680
<font color="#ffff54">하지만 오늘날 이 모든 오류를 처리하는 데는 분명 복잡성이 존재합니다.</font>

157
00:04:36,680 --> 00:04:37,680
We don't need that today.

158
00:04:36,680 --> 00:04:37,680
<font color="#ffff54">지금은 그럴 필요가 없습니다.</font>

159
00:04:37,720 --> 00:04:40,240
We just need to understand the mechanisms.

160
00:04:37,720 --> 00:04:40,240
<font color="#ffff54">메커니즘만 이해하면 돼요.</font>

161
00:04:40,240 --> 00:04:41,240
Okay.

162
00:04:40,240 --> 00:04:41,240
<font color="#ffff54">알았어.</font>

163
00:04:41,240 --> 00:04:44,959
All right.

164
00:04:41,240 --> 00:04:44,959
<font color="#ffff54">알았어요.</font>

165
00:04:44,959 --> 00:04:46,560
Let's get going here.

166
00:04:44,959 --> 00:04:46,560
<font color="#ffff54">이제 가자.</font>

167
00:04:46,560 --> 00:04:49,720
What is a CNI?

168
00:04:46,560 --> 00:04:49,720
<font color="#ffff54">CNI란 무엇인가요?</font>

169
00:04:49,720 --> 00:04:57,639
A CNI is basically if you think about any Kubernetes cluster, Docker, other projects

170
00:04:49,720 --> 00:04:57,639
<font color="#ffff54">CNI는 기본적으로 모든 쿠버네티스 클러스터, 도커, 기타 프로젝트를 생각하면 된다.</font>

171
00:04:57,639 --> 00:05:04,840
use CNI is a way to provide the wiring provide a wiring for any container.

172
00:04:57,639 --> 00:05:04,840
<font color="#ffff54">CNI를 사용하는 것은 모든 컨테이너에 대한 배선 제공을 제공하는 방법이다.</font>

173
00:05:04,840 --> 00:05:05,840
Right.

174
00:05:04,840 --> 00:05:05,840
<font color="#ffff54">맞습니다.</font>

175
00:05:06,000 --> 00:05:10,080
In our case here, we're talking about Kubernetes, a pod, right?

176
00:05:06,000 --> 00:05:10,080
<font color="#ffff54">여기서는 쿠버네티스, 즉 파드에 대해 이야기하고 있죠?</font>

177
00:05:10,080 --> 00:05:15,920
How can I allow a certain pod to have a certain IP be connected, be able to reach it, be able

178
00:05:10,080 --> 00:05:15,920
<font color="#ffff54">어떻게 특정 파드에 특정 IP가 연결되도록 허용하고, 연결할 수 있고, 도달할 수 있고, 도달할 수 있도록 할 수 있을까?</font>

179
00:05:15,920 --> 00:05:17,520
to interact with it.

180
00:05:15,920 --> 00:05:17,520
<font color="#ffff54">상호 작용할 수 있다.</font>

181
00:05:17,520 --> 00:05:24,840
That's the core thing around what a CNI is a CNI plugin this in this example.

182
00:05:17,520 --> 00:05:24,840
<font color="#ffff54">이것이 이 예제에서 CNI 플러그인이란 무엇인지에 대한 핵심적인 내용입니다.</font>

183
00:05:24,840 --> 00:05:31,800
Now you can think about a CNI plugin as the, you know, a plumber, basically wire like creating

184
00:05:24,840 --> 00:05:31,800
<font color="#ffff54">이제 CNI 플러그인을 배관공이 기본적으로 다음과 같은 와이어를 만드는 것과 같다고 생각할 수 있습니다.</font>

185
00:05:31,800 --> 00:05:40,520
the pipes between kind of the network host, the host network and your containers and pods.

186
00:05:31,800 --> 00:05:40,520
<font color="#ffff54">일종의 네트워크 호스트, 호스트 네트워크, 컨테이너와 파드 사이의 파이프를 연결한다.</font>

187
00:05:40,520 --> 00:05:47,720
Okay, so that's definitely the easiest way to describe what a CNI is.

188
00:05:40,520 --> 00:05:47,720
<font color="#ffff54">자, 이것이 CNI가 무엇인지 설명하는 가장 쉬운 방법이다.</font>

189
00:05:47,720 --> 00:05:52,759
And now we're going to talk about basically the spec a bit.

190
00:05:47,720 --> 00:05:52,759
<font color="#ffff54">이제 기본적인 사양에 대해 조금 이야기해 보겠습니다.</font>

191
00:05:52,759 --> 00:05:56,879
Okay, the spec of the CNI project is stable now.

192
00:05:52,759 --> 00:05:56,879
<font color="#ffff54">자, 이제 CNI 프로젝트의 스펙은 안정적입니다.</font>

193
00:05:56,879 --> 00:05:59,600
It's been 100 for a while.

194
00:05:56,879 --> 00:05:59,600
<font color="#ffff54">100이 된지 꽤 됐네요.</font>

195
00:05:59,600 --> 00:06:03,640
It has a very well documented way of operating.

196
00:05:59,600 --> 00:06:03,640
<font color="#ffff54">작동 방식이 매우 잘 문서화되어 있습니다.</font>

197
00:06:03,640 --> 00:06:04,640
It's straightforward.

198
00:06:03,640 --> 00:06:04,640
<font color="#ffff54">간단합니다.</font>

199
00:06:04,640 --> 00:06:08,720
And I definitely invite you guys to read this documentation.

200
00:06:04,640 --> 00:06:08,720
<font color="#ffff54">이 문서를 꼭 읽어보시길 권합니다.</font>

201
00:06:08,720 --> 00:06:11,800
In this couple slides, we're just gonna go through the basics.

202
00:06:08,720 --> 00:06:11,800
<font color="#ffff54">이 두 개의 슬라이드에서는 기본 사항만 살펴보겠습니다.</font>

203
00:06:11,800 --> 00:06:17,240
But again, there is a couple nuances that I would like you guys to go and review after all.

204
00:06:11,800 --> 00:06:17,240
<font color="#ffff54">하지만 다시 한 번 말씀드리지만, 몇 가지 미묘한 차이가 있으니 다시 한 번 살펴보시기 바랍니다.</font>

205
00:06:17,240 --> 00:06:19,879
So what does CNI project provide us?

206
00:06:17,240 --> 00:06:19,879
<font color="#ffff54">CNI 프로젝트는 우리에게 무엇을 제공하나요?</font>

207
00:06:19,879 --> 00:06:21,879
It provides us three main things.

208
00:06:19,879 --> 00:06:21,879
<font color="#ffff54">이 프로젝트는 크게 세 가지를 제공합니다.</font>

209
00:06:21,879 --> 00:06:27,720
First is the specification of what a CNI is and how it should operate.

210
00:06:21,879 --> 00:06:27,720
<font color="#ffff54">첫 번째는 CNI가 무엇이며 어떻게 작동해야 하는지에 대한 사양입니다.</font>

211
00:06:27,720 --> 00:06:32,920
It provides us some example implementation that you can just use and reuse.

212
00:06:27,720 --> 00:06:32,920
<font color="#ffff54">여러분이 바로 사용하고 재사용할 수 있는 몇 가지 구현 예제를 제공합니다.</font>

213
00:06:32,920 --> 00:06:37,240
And at the end also provide us some libraries to kind of simplify our life.

214
00:06:32,920 --> 00:06:37,240
<font color="#ffff54">그리고 마지막에는 삶을 단순화할 수 있는 몇 가지 라이브러리를 제공합니다.</font>

215
00:06:37,240 --> 00:06:40,360
We don't have to reinvent the wheel every single time.

216
00:06:37,240 --> 00:06:40,360
<font color="#ffff54">매번 같은 일을 반복할 필요가 없습니다.</font>

217
00:06:40,360 --> 00:06:41,360
Okay.

218
00:06:40,360 --> 00:06:41,360
<font color="#ffff54">알았어요.</font>

219
00:06:41,360 --> 00:06:47,040
And obviously today, we are reinventing the wheel just for an educational purpose.

220
00:06:41,360 --> 00:06:47,040
<font color="#ffff54">그리고 분명히 오늘날 우리는 교육적인 목적으로 바퀴를 다시 발명하고 있습니다.</font>

221
00:06:47,040 --> 00:06:57,240
Alright, so if we zoom in a bit of how actually things operate, there is a couple steps.

222
00:06:47,040 --> 00:06:57,240
<font color="#ffff54">자, 실제로 어떻게 작동하는지 조금 더 자세히 살펴보면 몇 가지 단계가 있습니다.</font>

223
00:06:57,280 --> 00:07:01,920
Okay, so there's always this, what we call a container runtime.

224
00:06:57,280 --> 00:07:01,920
<font color="#ffff54">컨테이너 런타임이라고 부르는 것이 항상 있습니다.</font>

225
00:07:01,920 --> 00:07:07,319
You know, when you use different technology, it means different things.

226
00:07:01,920 --> 00:07:07,319
<font color="#ffff54">다른 기술을 사용할 때는 다른 것을 의미합니다.</font>

227
00:07:07,319 --> 00:07:10,720
And if you talk about communities, that's probably kubelets.

228
00:07:07,319 --> 00:07:10,720
<font color="#ffff54">그리고 커뮤니티에 대해 이야기한다면 아마도 쿠벨렛일 것입니다.</font>

229
00:07:10,720 --> 00:07:16,480
That needs to create, you know, it needs to create a pod, it needs to wire it.

230
00:07:10,720 --> 00:07:16,480
<font color="#ffff54">이것은 파드를 만들어야 하고, 그것을 연결해야 합니다.</font>

231
00:07:16,480 --> 00:07:22,240
So the way it works is you have this container runtime that needs to interact with something

232
00:07:16,480 --> 00:07:22,240
<font color="#ffff54">그래서 작동 방식은 컨테이너 런타임이 무언가와 상호 작용해야 한다는 것이다.</font>

233
00:07:22,240 --> 00:07:25,160
to wire this pods that got created.

234
00:07:22,240 --> 00:07:25,160
<font color="#ffff54">과 상호작용해야 하는 컨테이너 런타임이 있다.</font>

235
00:07:25,160 --> 00:07:29,640
In this case, we are using a CNI plugin for this.

236
00:07:25,160 --> 00:07:29,640
<font color="#ffff54">이 경우 CNI 플러그인을 사용하고 있다.</font>

237
00:07:29,640 --> 00:07:37,000
The container runtime is going to do first, it's going to go and read a certain configuration.

238
00:07:29,640 --> 00:07:37,000
<font color="#ffff54">컨테이너 런타임이 먼저 할 일은 특정 구성을 읽는 것입니다.</font>

239
00:07:37,000 --> 00:07:39,040
We're going to go into this detail in a bit, right?

240
00:07:37,000 --> 00:07:39,040
<font color="#ffff54">이 부분은 잠시 후에 자세히 살펴보도록 하죠?</font>

241
00:07:39,040 --> 00:07:42,560
Right now, we don't have to very much focus on this.

242
00:07:39,040 --> 00:07:42,560
<font color="#ffff54">지금은 여기에 크게 집중할 필요가 없습니다.</font>

243
00:07:42,560 --> 00:07:48,160
But now that the CNI runtime, the container runtime, sorry, in this case kubelets for

244
00:07:42,560 --> 00:07:48,160
<font color="#ffff54">하지만 이제 CNI 런타임, 컨테이너 런타임, 미안하지만 이 경우 쿠벨렛은</font>

245
00:07:48,160 --> 00:07:52,400
communities, we'll go and look for a network configuration.

246
00:07:48,160 --> 00:07:52,400
<font color="#ffff54">커뮤니티로 이동하여 네트워크 구성을 찾아보겠습니다.</font>

247
00:07:52,400 --> 00:07:53,400
Okay, it's a file.

248
00:07:52,400 --> 00:07:53,400
<font color="#ffff54">좋아요, 파일입니다.</font>

249
00:07:53,640 --> 00:07:57,720
It's just a JSON file that describes certain things that we need to pass to a CNI.

250
00:07:53,640 --> 00:07:57,720
<font color="#ffff54">CNI에 전달해야 하는 특정 사항을 설명하는 JSON 파일입니다.</font>

251
00:07:57,720 --> 00:08:05,840
And then it's going to actually call a binary, just a bin, passing certain environment variables

252
00:07:57,720 --> 00:08:05,840
<font color="#ffff54">그리고 실제로 바이너리를 호출하여 특정 환경 변수를 전달합니다.</font>

253
00:08:05,840 --> 00:08:11,320
and that network configuration and expects couple things from that CNI plugin.

254
00:08:05,840 --> 00:08:11,320
<font color="#ffff54">그리고 그 네트워크 구성과 CNI 플러그인에서 몇 가지를 기대합니다.</font>

255
00:08:11,320 --> 00:08:15,120
So the CNI plugin is going to receive this configuration, it's going to be invoked with

256
00:08:11,320 --> 00:08:15,120
<font color="#ffff54">따라서 CNI 플러그인은 이 구성을 수신하고, 다음과 같이 호출됩니다.</font>

257
00:08:15,120 --> 00:08:17,640
certain environment variables.

258
00:08:15,120 --> 00:08:17,640
<font color="#ffff54">특정 환경 변수.</font>

259
00:08:17,640 --> 00:08:22,320
The CNI plugin based on this information is going to do what the CNI plugin is doing,

260
00:08:17,640 --> 00:08:22,320
<font color="#ffff54">이 정보를 기반으로 CNI 플러그인은 CNI 플러그인이 수행하는 작업을 수행합니다,</font>

261
00:08:22,360 --> 00:08:28,319
you know, creating the interface, wiring everything, and then returns a result that goes back to

262
00:08:22,360 --> 00:08:28,319
<font color="#ffff54">인터페이스를 만들고, 모든 것을 배선하고, 그리고 나서 다시</font>

263
00:08:28,319 --> 00:08:31,560
the container runtime to say, well, this was a success.

264
00:08:28,319 --> 00:08:31,560
<font color="#ffff54">로 돌아가는 결과를 컨테이너 런타임에 반환합니다.</font>

265
00:08:31,560 --> 00:08:33,279
My container now is wired.

266
00:08:31,560 --> 00:08:33,279
<font color="#ffff54">이제 컨테이너가 연결되었습니다.</font>

267
00:08:33,279 --> 00:08:35,399
Okay, in a nutshell, that's what it is.

268
00:08:33,279 --> 00:08:35,399
<font color="#ffff54">네, 간단히 말해서 그렇습니다.</font>

269
00:08:35,399 --> 00:08:40,600
It's basically a configuration file, a binary, and something that calls the binary with this

270
00:08:35,399 --> 00:08:40,600
<font color="#ffff54">기본적으로 구성 파일, 바이너리, 그리고 이 바이너리를 호출하는 무언가입니다.</font>

271
00:08:40,600 --> 00:08:42,000
configuration file.

272
00:08:40,600 --> 00:08:42,000
<font color="#ffff54">구성 파일입니다.</font>

273
00:08:42,000 --> 00:08:43,000
Okay.

274
00:08:42,000 --> 00:08:43,000
<font color="#ffff54">오케이.</font>

275
00:08:43,000 --> 00:08:45,840
All right.

276
00:08:43,000 --> 00:08:45,840
<font color="#ffff54">알았어요.</font>

277
00:08:45,840 --> 00:08:47,639
So let's take a look at the configuration file.

278
00:08:45,840 --> 00:08:47,639
<font color="#ffff54">이제 구성 파일을 살펴봅시다.</font>

279
00:08:47,639 --> 00:08:50,960
And this is a very simple one.

280
00:08:47,639 --> 00:08:50,960
<font color="#ffff54">이것은 매우 간단합니다.</font>

281
00:08:51,000 --> 00:08:55,519
Every CNI configuration file has couple fields.

282
00:08:51,000 --> 00:08:55,519
<font color="#ffff54">모든 CNI 구성 파일에는 몇 개의 필드가 있습니다.</font>

283
00:08:55,519 --> 00:09:00,800
Certain are mandatory and certain are optional.

284
00:08:55,519 --> 00:09:00,800
<font color="#ffff54">어떤 것은 필수이고 어떤 것은 선택 사항입니다.</font>

285
00:09:00,800 --> 00:09:03,600
Definitely the thing that is very important here is the CNI version.

286
00:09:00,800 --> 00:09:03,600
<font color="#ffff54">여기서 가장 중요한 것은 CNI 버전입니다.</font>

287
00:09:03,600 --> 00:09:06,600
Again, I said there is multiple specifications.

288
00:09:03,600 --> 00:09:06,600
<font color="#ffff54">다시 말하지만, 여러 가지 사양이 있다고 말씀드렸습니다.</font>

289
00:09:06,600 --> 00:09:08,440
The last one is 100.

290
00:09:06,600 --> 00:09:08,440
<font color="#ffff54">마지막은 100입니다.</font>

291
00:09:08,440 --> 00:09:10,240
That's the one we're using today.

292
00:09:08,440 --> 00:09:10,240
<font color="#ffff54">이것이 우리가 오늘 사용하는 것입니다.</font>

293
00:09:10,240 --> 00:09:17,840
But there's also other ones like, you know, 300400, like zero, sorry, 040 and 030 and,

294
00:09:10,240 --> 00:09:17,840
<font color="#ffff54">하지만 300400, 040, 030 등 다른 숫자도 있습니다,</font>

295
00:09:17,840 --> 00:09:20,480
you know, old versions.

296
00:09:17,840 --> 00:09:20,480
<font color="#ffff54">옛날 버전도 있죠</font>

297
00:09:20,519 --> 00:09:22,039
Then there is the type.

298
00:09:20,519 --> 00:09:22,039
<font color="#ffff54">그리고 유형이 있습니다.</font>

299
00:09:22,039 --> 00:09:26,840
The type is, in our case, if you want to simplify it, is the binary name that we are going to

300
00:09:22,039 --> 00:09:26,840
<font color="#ffff54">유형은, 우리의 경우 단순화하자면, 다음과 같은 바이너리 이름입니다.</font>

301
00:09:26,840 --> 00:09:28,840
invoke, right?

302
00:09:26,840 --> 00:09:28,840
<font color="#ffff54">호출하는 거죠?</font>

303
00:09:28,840 --> 00:09:32,519
In this case, it's called bridge.

304
00:09:28,840 --> 00:09:32,519
<font color="#ffff54">이 경우 브리지라고 합니다.</font>

305
00:09:32,519 --> 00:09:38,759
Then we have certain keys that are called well-known keys, right?

306
00:09:32,519 --> 00:09:38,759
<font color="#ffff54">그렇다면 잘 알려진 키라고 불리는 특정 키가 있지요?</font>

307
00:09:38,759 --> 00:09:43,560
Well-known keys, like in my example here, IPAM and DNS.

308
00:09:38,759 --> 00:09:43,560
<font color="#ffff54">여기 예시에서처럼 잘 알려진 키는 IPAM과 DNS입니다.</font>

309
00:09:43,560 --> 00:09:51,040
Well-known keys can be used by CNI to invoke another CNI plugin, right?

310
00:09:43,560 --> 00:09:51,040
<font color="#ffff54">잘 알려진 키는 CNI에서 다른 CNI 플러그인을 호출하는 데 사용할 수 있지요?</font>

311
00:09:51,040 --> 00:09:53,040
That's what you call like delegation, for example.

312
00:09:51,040 --> 00:09:53,040
<font color="#ffff54">예를 들어 위임과 같은 것을 위임이라고 합니다.</font>

313
00:09:53,040 --> 00:09:56,760
I don't want to go too much in detail about this subject.

314
00:09:53,040 --> 00:09:56,760
<font color="#ffff54">이 주제에 대해 너무 자세히 설명하고 싶지 않아요.</font>

315
00:09:56,760 --> 00:09:58,440
We're not going to use it today.

316
00:09:56,760 --> 00:09:58,440
<font color="#ffff54">오늘은 사용하지 않겠습니다.</font>

317
00:09:58,440 --> 00:10:03,560
But for example, if you are invoking a CNI plugin that needs to basically assign a certain

318
00:09:58,440 --> 00:10:03,560
<font color="#ffff54">그러나 예를 들어, 기본적으로 특정 값을 할당해야 하는 CNI 플러그인을 호출할 때</font>

319
00:10:03,560 --> 00:10:09,480
IP, sometimes you want to use another CNI plugin that is much actually very focused

320
00:10:03,560 --> 00:10:09,480
<font color="#ffff54">IP를 할당해야 하는 경우, 다른 CNI 플러그인을 사용하고 싶을 때가 있습니다.</font>

321
00:10:09,480 --> 00:10:11,920
on actually IP generation, right?

322
00:10:09,480 --> 00:10:11,920
<font color="#ffff54">실제로 IP 생성에 집중하는 거죠?</font>

323
00:10:11,919 --> 00:10:17,599
It can be host vocal, it can be the ICP, it can be other processes.

324
00:10:11,919 --> 00:10:17,599
<font color="#ffff54">호스트 보컬일 수도 있고, ICP일 수도 있고, 다른 프로세스일 수도 있습니다.</font>

325
00:10:17,599 --> 00:10:20,399
But again, that's just a small parenthesis here.

326
00:10:17,599 --> 00:10:20,399
<font color="#ffff54">하지만 다시 말하지만, 여기서는 작은 괄호입니다.</font>

327
00:10:20,399 --> 00:10:25,679
And again, there is also this field that's called capabilities.

328
00:10:20,399 --> 00:10:25,679
<font color="#ffff54">그리고 역량이라는 필드도 있습니다.</font>

329
00:10:25,679 --> 00:10:29,399
And these capabilities are dynamic fields that are being invoked.

330
00:10:25,679 --> 00:10:29,399
<font color="#ffff54">그리고 이러한 기능은 호출되는 동적 필드입니다.</font>

331
00:10:29,399 --> 00:10:35,000
When the container runtime invokes the CNI, it dynamically changes this field with certain

332
00:10:29,399 --> 00:10:35,000
<font color="#ffff54">컨테이너 런타임이 CNI를 호출할 때, 이 필드를 동적으로 변경하여 특정</font>

333
00:10:35,000 --> 00:10:36,000
values.

334
00:10:35,000 --> 00:10:36,000
<font color="#ffff54">값으로 변경한다.</font>

335
00:10:36,000 --> 00:10:38,679
Again, this is probably too much detail right now.

336
00:10:36,000 --> 00:10:38,679
<font color="#ffff54">다시 말하지만, 지금은 너무 자세한 내용일 수 있습니다.</font>

337
00:10:38,680 --> 00:10:42,400
We're not going to use that today, but just to know that exists there.

338
00:10:38,680 --> 00:10:42,400
<font color="#ffff54">오늘은 사용하지 않을 것이지만, 저게 존재한다는 것만 알아두세요.</font>

339
00:10:42,400 --> 00:10:48,480
I think the last one, which is important in our example, is that you can pass custom key

340
00:10:42,400 --> 00:10:48,480
<font color="#ffff54">이 예제에서 마지막으로 중요한 것은 사용자 정의 키를 전달할 수 있다는 것입니다.</font>

341
00:10:48,480 --> 00:10:49,480
value keys.

342
00:10:48,480 --> 00:10:49,480
<font color="#ffff54">값 키입니다.</font>

343
00:10:49,480 --> 00:10:53,920
So it's going to be any detail you want to pass to your CNI plugin.

344
00:10:49,480 --> 00:10:53,920
<font color="#ffff54">따라서 CNI 플러그인에 전달할 세부 정보가 될 것입니다.</font>

345
00:10:53,920 --> 00:10:57,120
We're going to use this today in our workshop.

346
00:10:53,920 --> 00:10:57,120
<font color="#ffff54">오늘 워크샵에서 이걸 사용할 거예요.</font>

347
00:10:57,120 --> 00:10:59,120
All right.

348
00:10:57,120 --> 00:10:59,120
<font color="#ffff54">알았어요.</font>

349
00:10:59,120 --> 00:11:03,920
So now let's talk about, I talked about the configuration file.

350
00:10:59,120 --> 00:11:03,920
<font color="#ffff54">이제 구성 파일에 대해 이야기해 보겠습니다.</font>

351
00:11:03,920 --> 00:11:05,720
I said it's a binary.

352
00:11:03,920 --> 00:11:05,720
<font color="#ffff54">바이너리라고 했잖아요.</font>

353
00:11:05,720 --> 00:11:09,000
We need to invoke the binary with the configuration file.

354
00:11:05,720 --> 00:11:09,000
<font color="#ffff54">구성 파일로 바이너리를 호출해야 합니다.</font>

355
00:11:09,000 --> 00:11:14,860
But I also mentioned that when we have a successful call to the CNI plugin, it returns a certain

356
00:11:09,000 --> 00:11:14,860
<font color="#ffff54">하지만 CNI 플러그인에 대한 호출이 성공하면 다음과 같은 특정</font>

357
00:11:14,860 --> 00:11:23,360
result that the container runtime reads and be able to process and obviously update itself.

358
00:11:14,860 --> 00:11:23,360
<font color="#ffff54">결과를 반환하여 컨테이너 런타임이 이를 읽고 처리하고 분명히 업데이트할 수 있습니다.</font>

359
00:11:23,360 --> 00:11:29,860
The container runtime probably just print that in stdout.

360
00:11:23,360 --> 00:11:29,860
<font color="#ffff54">컨테이너 런타임은 아마도 이 결과를 그냥 stdout으로 출력할 것입니다.</font>

361
00:11:29,860 --> 00:11:34,060
It's kind of a format here in JSON that define the IPs, define the routes.

362
00:11:29,860 --> 00:11:34,060
<font color="#ffff54">여기에는 IP를 정의하고 경로를 정의하는 일종의 JSON 형식이 있습니다.</font>

363
00:11:34,100 --> 00:11:38,900
Also that's all part of the CNI spec.

364
00:11:34,100 --> 00:11:38,900
<font color="#ffff54">이것도 모두 CNI 사양의 일부입니다.</font>

365
00:11:38,900 --> 00:11:42,900
And we don't have to really much dig into it here today right now, but just know that

366
00:11:38,900 --> 00:11:42,900
<font color="#ffff54">지금 당장 여기서 자세히 설명할 필요는 없지만, 다음 사항만 알아두세요.</font>

367
00:11:42,900 --> 00:11:43,900
there is a result.

368
00:11:42,900 --> 00:11:43,900
<font color="#ffff54">결과가 있다는 것만 알아두세요.</font>

369
00:11:43,900 --> 00:11:48,500
And the result is in our example here for the bridge is to return the IP that's been

370
00:11:43,900 --> 00:11:48,500
<font color="#ffff54">이 예제에서 브리지에 대한 결과는 다음과 같습니다.</font>

371
00:11:48,500 --> 00:11:53,980
assigned to the certain container or a certain pod if we're talking about Kubernetes.

372
00:11:48,500 --> 00:11:53,980
<font color="#ffff54">특정 컨테이너 또는 쿠버네티스의 경우 특정 파드에 할당된 IP를 반환합니다.</font>

373
00:11:53,980 --> 00:11:56,940
All right.

374
00:11:53,980 --> 00:11:56,940
<font color="#ffff54">알겠습니다.</font>

375
00:11:56,940 --> 00:11:59,740
One last quick step here.

376
00:11:56,940 --> 00:11:59,740
<font color="#ffff54">마지막 한 단계만 남았습니다.</font>

377
00:11:59,740 --> 00:12:01,900
Let's talk about execution.

378
00:11:59,740 --> 00:12:01,900
<font color="#ffff54">실행에 대해 이야기해 봅시다.</font>

379
00:12:01,900 --> 00:12:03,420
Okay.

380
00:12:01,900 --> 00:12:03,420
<font color="#ffff54">알았어요.</font>

381
00:12:03,779 --> 00:12:07,699
So the execution of the CNI plugin is pretty straightforward.

382
00:12:03,779 --> 00:12:07,699
<font color="#ffff54">따라서 CNI 플러그인의 실행은 매우 간단합니다.</font>

383
00:12:07,699 --> 00:12:08,699
You have the container runtime.

384
00:12:07,699 --> 00:12:08,699
<font color="#ffff54">컨테이너 런타임이 있습니다.</font>

385
00:12:08,699 --> 00:12:15,779
They're going to go and read a certain configuration that is by default put under slash etc cni

386
00:12:08,699 --> 00:12:15,779
<font color="#ffff54">이들은 기본적으로 슬래시 등 cni 아래에 있는 특정 구성을 읽을 것입니다.</font>

387
00:12:15,779 --> 00:12:17,979
netd and the name of the configuration.

388
00:12:15,779 --> 00:12:17,979
<font color="#ffff54">netd와 설정의 이름.</font>

389
00:12:17,979 --> 00:12:26,539
It's going to read that configuration and then invoke the CNI binary based on that configuration

390
00:12:17,979 --> 00:12:26,539
<font color="#ffff54">해당 구성을 읽은 다음 해당 구성을 기반으로 CNI 바이너리를 호출합니다.</font>

391
00:12:26,539 --> 00:12:31,939
that is under by default is under slash optc and I've been in the binary itself.

392
00:12:26,539 --> 00:12:31,939
<font color="#ffff54">기본적으로 슬래시 옵션 아래에 있으며 바이너리 자체에 있습니다.</font>

393
00:12:31,980 --> 00:12:39,300
So in this case and it passes again, it's executes and pass certain environment variables.

394
00:12:31,980 --> 00:12:39,300
<font color="#ffff54">따라서 이 경우 다시 통과하면 특정 환경 변수를 실행하고 전달합니다.</font>

395
00:12:39,300 --> 00:12:40,300
Okay.

396
00:12:39,300 --> 00:12:40,300
<font color="#ffff54">Okay.</font>

397
00:12:40,300 --> 00:12:43,300
And the environment variables, we're going to see that in a second here.

398
00:12:40,300 --> 00:12:43,300
<font color="#ffff54">환경 변수에 대해서는 잠시 후에 살펴보겠습니다.</font>

399
00:12:43,300 --> 00:12:48,620
Kind of just a quick intro to things we're going to use later.

400
00:12:43,300 --> 00:12:48,620
<font color="#ffff54">나중에 사용할 기능에 대한 간단한 소개입니다.</font>

401
00:12:48,620 --> 00:12:54,820
Every invocation of the CNI plugin has again, it's invoking the binary and passing environment

402
00:12:48,620 --> 00:12:54,820
<font color="#ffff54">CNI 플러그인을 호출할 때마다 다시 바이너리를 호출하고 환경을 전달합니다.</font>

403
00:12:54,820 --> 00:12:56,420
variables.

404
00:12:54,820 --> 00:12:56,420
<font color="#ffff54">변수를 전달합니다.</font>

405
00:12:56,420 --> 00:13:00,020
This environment variables are the CNI command.

406
00:12:56,420 --> 00:13:00,020
<font color="#ffff54">이 환경 변수는 CNI 명령어입니다.</font>

407
00:13:00,179 --> 00:13:02,819
Are we trying to add the container?

408
00:13:00,179 --> 00:13:02,819
<font color="#ffff54">컨테이너를 추가하려고 하나요?</font>

409
00:13:02,819 --> 00:13:04,860
Are we trying to delete the container?

410
00:13:02,819 --> 00:13:04,860
<font color="#ffff54">컨테이너를 삭제하려고 하나요?</font>

411
00:13:04,860 --> 00:13:07,539
Just checking if the container is good.

412
00:13:04,860 --> 00:13:07,539
<font color="#ffff54">컨테이너가 정상인지 확인하는 중입니다.</font>

413
00:13:07,539 --> 00:13:14,220
Then we're passing a container, the CNI container IDs basically in Kubernetes that's the container

414
00:13:07,539 --> 00:13:14,220
<font color="#ffff54">그런 다음 컨테이너를 전달하는데, 기본적으로 쿠버네티스에서 컨테이너인 CNI 컨테이너 ID는 다음과 같다.</font>

415
00:13:14,220 --> 00:13:16,220
ID itself.

416
00:13:14,220 --> 00:13:16,220
<font color="#ffff54">ID 자체.</font>

417
00:13:16,220 --> 00:13:20,139
Just a reference to the pod that needs to be set.

418
00:13:16,220 --> 00:13:20,139
<font color="#ffff54">설정해야 하는 파드에 대한 참조.</font>

419
00:13:20,139 --> 00:13:24,579
We are passing a CNI netns and we're going to get to this later.

420
00:13:20,139 --> 00:13:24,579
<font color="#ffff54">CNI 네트웍을 통과 중이며 나중에 설명하겠습니다.</font>

421
00:13:24,620 --> 00:13:32,980
That's basically to, you know, a way for us to control where this network namespace and

422
00:13:24,620 --> 00:13:32,980
<font color="#ffff54">이는 기본적으로 이 네트워크 네임스페이스와</font>

423
00:13:32,980 --> 00:13:36,420
I'm going to talk about network namespace in a second, where the network namespace is

424
00:13:32,980 --> 00:13:36,420
<font color="#ffff54">잠시 후에 네트워크 네임스페이스에 대해 이야기하겠습니다.</font>

425
00:13:36,420 --> 00:13:39,100
going to be created.

426
00:13:36,420 --> 00:13:39,100
<font color="#ffff54">이 생성될 것입니다.</font>

427
00:13:39,100 --> 00:13:46,500
A CNI if name is the interface, like, you know, the network interface that the container

428
00:13:39,100 --> 00:13:46,500
<font color="#ffff54">이름이 CNI이면 컨테이너가 사용하는 네트워크 인터페이스와 같은 인터페이스입니다.</font>

429
00:13:46,500 --> 00:13:54,259
runtime is expecting from the CNI to create on a specific container or pod in this case.

430
00:13:46,500 --> 00:13:54,259
<font color="#ffff54">런타임이 특정 컨테이너나 파드에 생성할 것으로 예상하는 네트워크 인터페이스다.</font>

431
00:13:54,740 --> 00:14:01,340
The CNI args are all the values that we put in our configuration earlier that can be passed

432
00:13:54,740 --> 00:14:01,340
<font color="#ffff54">CNI 인자는 앞서 구성에서 전달할 수 있는 모든 값이다.</font>

433
00:14:01,340 --> 00:14:05,899
down to our CNI.

434
00:14:01,340 --> 00:14:05,899
<font color="#ffff54">를 CNI로 전달합니다.</font>

435
00:14:05,899 --> 00:14:11,019
And CNI path is optional here, but again, if basically the CNI is not on a default path,

436
00:14:05,899 --> 00:14:11,019
<font color="#ffff54">여기서 CNI 경로는 선택 사항이지만 기본적으로 CNI가 기본 경로에 있지 않은 경우 다시 한 번 확인합니다,</font>

437
00:14:11,019 --> 00:14:14,819
then we have to look for where is the, you know, the binaries.

438
00:14:11,019 --> 00:14:14,819
<font color="#ffff54">이면 바이너리가 어디에 있는지 찾아야 합니다.</font>

439
00:14:16,819 --> 00:14:17,860
All right.

440
00:14:16,819 --> 00:14:17,860
<font color="#ffff54">알았어요.</font>

441
00:14:17,860 --> 00:14:19,419
One last thing here.

442
00:14:17,860 --> 00:14:19,419
<font color="#ffff54">마지막으로 한 가지 더.</font>

443
00:14:19,419 --> 00:14:22,379
CNI's can, you can use multiple CNI's, right?

444
00:14:19,419 --> 00:14:22,379
<font color="#ffff54">CNI는 여러 개를 사용할 수 있는 거죠?</font>

445
00:14:22,379 --> 00:14:25,379
You can use multiple CNI's, you have to use only one.

446
00:14:22,379 --> 00:14:25,379
<font color="#ffff54">여러 개의 CNI를 사용할 수 있지만 하나만 사용해야 합니다.</font>

447
00:14:25,379 --> 00:14:27,779
So sometimes you have different use cases.

448
00:14:25,379 --> 00:14:27,779
<font color="#ffff54">따라서 때때로 다른 사용 사례가 있습니다.</font>

449
00:14:27,779 --> 00:14:29,139
You probably have an interface.

450
00:14:27,779 --> 00:14:29,139
<font color="#ffff54">아마 인터페이스가 있을 겁니다.</font>

451
00:14:29,139 --> 00:14:33,939
CNI is basically the one that creates the wiring, that creates the interface itself.

452
00:14:29,139 --> 00:14:33,939
<font color="#ffff54">CNI는 기본적으로 배선을 생성하고 인터페이스 자체를 생성하는 것입니다.</font>

453
00:14:33,939 --> 00:14:40,059
But sometimes you have another CNI that just do some sort of tuning or whatever it is,

454
00:14:33,939 --> 00:14:40,059
<font color="#ffff54">하지만 때때로 튜닝이나 기타 작업을 수행하는 다른 CNI가 있을 수 있습니다,</font>

455
00:14:40,059 --> 00:14:41,059
right?

456
00:14:40,059 --> 00:14:41,059
<font color="#ffff54">맞죠?</font>

457
00:14:41,059 --> 00:14:44,100
And sometimes you want to split this logic into multiple plugins.

458
00:14:41,059 --> 00:14:44,100
<font color="#ffff54">때로는 이 로직을 여러 개의 플러그인으로 분할하고 싶을 때가 있습니다.</font>

459
00:14:44,100 --> 00:14:50,659
In our case here, CNI one, you know, let's say CNI two is invoked and you get the previous

460
00:14:44,100 --> 00:14:50,659
<font color="#ffff54">여기서의 경우, CNI 1이 호출되고 CNI 2가 호출되어 이전의</font>

461
00:14:50,659 --> 00:14:56,819
result from the execution of CNI one passed to the plugin two and to plugin three.

462
00:14:50,659 --> 00:14:56,819
<font color="#ffff54">CNI 1의 실행 결과가 플러그인 2와 플러그인 3으로 전달됩니다.</font>

463
00:14:56,819 --> 00:14:59,419
And again, if you have 10, it's going to operate the same.

464
00:14:56,819 --> 00:14:59,419
<font color="#ffff54">다시 말하지만, 10이 있으면 동일하게 작동합니다.</font>

465
00:14:59,419 --> 00:15:03,980
You know, that's kind of a way to say, don't think that the CNI is just a replacement.

466
00:14:59,419 --> 00:15:03,980
<font color="#ffff54">CNI가 단순히 대체품이라고 생각하지 말라는 뜻이죠.</font>

467
00:15:03,980 --> 00:15:07,500
You have to like completely replace the CNI you have running.

468
00:15:03,980 --> 00:15:07,500
<font color="#ffff54">실행 중인 CNI를 완전히 교체해야 합니다.</font>

469
00:15:07,500 --> 00:15:10,980
Sometimes it's complement, they complement it themselves.

470
00:15:07,500 --> 00:15:10,980
<font color="#ffff54">때로는 보완이 되기도 하고, 스스로 보완하기도 합니다.</font>

471
00:15:10,980 --> 00:15:14,579
All right.

472
00:15:10,980 --> 00:15:14,579
<font color="#ffff54">알았어.</font>

473
00:15:14,579 --> 00:15:19,299
Time to start our first CNI plugin.

474
00:15:14,579 --> 00:15:19,299
<font color="#ffff54">첫 번째 CNI 플러그인을 시작할 시간입니다.</font>

475
00:15:19,300 --> 00:15:22,100
You guys all have like access to a laptop.

476
00:15:19,300 --> 00:15:22,100
<font color="#ffff54">여러분 모두 노트북에 접속할 수 있군요.</font>

477
00:15:22,100 --> 00:15:25,180
Again, you guys can follow with me here.

478
00:15:22,100 --> 00:15:25,180
<font color="#ffff54">다시 말하지만, 여러분은 여기서 저를 따라오세요.</font>

479
00:15:25,180 --> 00:15:31,860
But if you have a laptop and you want to do this lab, like run it on your own environments,

480
00:15:25,180 --> 00:15:31,860
<font color="#ffff54">하지만 노트북이 있고 이 실습을 하고 싶다면 자신의 환경에서 실행해 보세요,</font>

481
00:15:31,860 --> 00:15:34,700
that'd be great.

482
00:15:31,860 --> 00:15:34,700
<font color="#ffff54">좋겠네요.</font>

483
00:15:34,700 --> 00:15:38,100
All right.

484
00:15:34,700 --> 00:15:38,100
<font color="#ffff54">알았어.</font>

485
00:15:38,100 --> 00:15:46,340
The exercise today, what we are going to do is we are going to create a bridge plugin.

486
00:15:38,100 --> 00:15:46,340
<font color="#ffff54">오늘 연습에서는 브리지 플러그인을 만들어 보겠습니다.</font>

487
00:15:46,340 --> 00:15:48,420
This is a very simple example.

488
00:15:46,340 --> 00:15:48,420
<font color="#ffff54">아주 간단한 예제입니다.</font>

489
00:15:48,420 --> 00:15:52,980
And again, there is multiple ways of creating a CNI.

490
00:15:48,420 --> 00:15:52,980
<font color="#ffff54">다시 말하지만, CNI를 생성하는 방법은 여러 가지가 있습니다.</font>

491
00:15:52,980 --> 00:15:58,620
There is, you know, in terms of like defining an interface, there's a point to point that

492
00:15:52,980 --> 00:15:58,620
<font color="#ffff54">인터페이스를 정의하는 것과 같은 측면에서 다음과 같은 점을 지적할 수 있습니다.</font>

493
00:15:58,620 --> 00:16:00,500
like villain, there's multiple ones.

494
00:15:58,620 --> 00:16:00,500
<font color="#ffff54">악당처럼 여러 가지가 있죠.</font>

495
00:16:00,500 --> 00:16:05,700
But the simplest one, I think to instead, the basic of CNI is the bridge plugin.

496
00:16:00,500 --> 00:16:05,700
<font color="#ffff54">하지만 가장 간단한 것은 CNI의 기본인 브리지 플러그인이라고 생각합니다.</font>

497
00:16:05,700 --> 00:16:08,220
So here's what we're going to do in this session.

498
00:16:05,700 --> 00:16:08,220
<font color="#ffff54">이번 세션에서는 이렇게 하겠습니다.</font>

499
00:16:08,220 --> 00:16:17,580
Actually, before I get there, if anyone wants to run this workshop on their laptop, right,

500
00:16:08,220 --> 00:16:17,580
<font color="#ffff54">사실, 제가 시작하기 전에 이 워크숍을 노트북에서 실행하고 싶은 사람이 있다면, 맞죠?</font>

501
00:16:17,580 --> 00:16:20,420
go on this link.

502
00:16:17,580 --> 00:16:20,420
<font color="#ffff54">이 링크를 클릭하세요.</font>

503
00:16:20,420 --> 00:16:28,540
Okay, I'm going to pause there for a second for everyone to copy it.

504
00:16:20,420 --> 00:16:28,540
<font color="#ffff54">좋아요, 모두 복사할 수 있도록 잠시 멈추겠습니다.</font>

505
00:16:28,540 --> 00:16:29,540
It's pretty simple.

506
00:16:28,540 --> 00:16:29,540
<font color="#ffff54">아주 간단해요.</font>

507
00:16:29,540 --> 00:16:34,860
It's just bit.ly slash eBPF CNI.

508
00:16:29,540 --> 00:16:34,860
<font color="#ffff54">bit.ly 슬래시 eBPF CNI입니다.</font>

509
00:16:34,860 --> 00:16:43,379
Okay, that will take you to our lab environment that we're going to use for the exercise.

510
00:16:34,860 --> 00:16:43,379
<font color="#ffff54">이제 실습에 사용할 실험실 환경으로 이동합니다.</font>

511
00:16:43,379 --> 00:16:45,020
Are you guys good?

512
00:16:43,379 --> 00:16:45,020
<font color="#ffff54">다들 괜찮아?</font>

513
00:16:45,020 --> 00:16:47,100
Just let me know if you guys all okay.

514
00:16:45,020 --> 00:16:47,100
<font color="#ffff54">다들 괜찮은지 알려줘.</font>

515
00:16:47,620 --> 00:16:48,620
Awesome.

516
00:16:47,620 --> 00:16:48,620
<font color="#ffff54">멋지네.</font>

517
00:16:48,620 --> 00:16:49,620
Okay, cool.

518
00:16:48,620 --> 00:16:49,620
<font color="#ffff54">좋아, 멋지다.</font>

519
00:16:49,620 --> 00:16:54,980
I'm going to go back to let me actually start my environment too.

520
00:16:49,620 --> 00:16:54,980
<font color="#ffff54">돌아가서 내 환경도 실제로 시작할 수 있게 해볼게요.</font>

521
00:16:54,980 --> 00:16:57,980
So because it takes about two minutes to be ready.

522
00:16:54,980 --> 00:16:57,980
<font color="#ffff54">준비하는데 2분 정도 걸리니까요.</font>

523
00:16:57,980 --> 00:17:01,399
Click on that just in the meantime.

524
00:16:57,980 --> 00:17:01,399
<font color="#ffff54">그동안 저걸 클릭하세요.</font>

525
00:17:01,399 --> 00:17:07,779
And if you click on start, you should get on this page here, where it tells you that

526
00:17:01,399 --> 00:17:07,779
<font color="#ffff54">그리고 시작을 클릭하면 다음과 같은 페이지가 나타납니다.</font>

527
00:17:07,779 --> 00:17:11,259
the challenges is loading.

528
00:17:07,779 --> 00:17:11,259
<font color="#ffff54">챌린지가 로딩 중입니다.</font>

529
00:17:11,259 --> 00:17:15,700
And yeah, let's talk about what we are going to do today.

530
00:17:11,259 --> 00:17:15,700
<font color="#ffff54">자, 오늘 할 일에 대해 이야기해 봅시다.</font>

531
00:17:15,819 --> 00:17:20,740
Let's create a bridge CNI plugin.

532
00:17:15,819 --> 00:17:20,740
<font color="#ffff54">브리지 CNI 플러그인을 만들어 봅시다.</font>

533
00:17:20,740 --> 00:17:27,180
What we are going to do is define the CNI plugin that first creates a bridge if it's

534
00:17:20,740 --> 00:17:27,180
<font color="#ffff54">우리가 할 일은 먼저 브리지를 생성하는 CNI 플러그인을 정의하는 것입니다.</font>

535
00:17:27,180 --> 00:17:35,700
not existing, we're going to call it bridge zero, we're going to assign an IP to the bridge,

536
00:17:27,180 --> 00:17:35,700
<font color="#ffff54">존재하지 않는 경우, 이를 브리지 0이라고 부르고 브리지에 IP를 할당합니다,</font>

537
00:17:35,700 --> 00:17:37,019
right?

538
00:17:35,700 --> 00:17:37,019
<font color="#ffff54">맞죠?</font>

539
00:17:37,019 --> 00:17:42,759
The bridge is connecting is connected with the, you know, host network.

540
00:17:37,019 --> 00:17:42,759
<font color="#ffff54">브리지가 호스트 네트워크와 연결되고 있습니다.</font>

541
00:17:42,759 --> 00:17:46,279
So that's how we get the connectivity to the host.

542
00:17:42,759 --> 00:17:46,279
<font color="#ffff54">이렇게 호스트에 연결됩니다.</font>

543
00:17:46,279 --> 00:17:52,200
And then the bridge, we're going to define what we call V8 pairs.

544
00:17:46,279 --> 00:17:52,200
<font color="#ffff54">그리고 브리지에서는 V8 쌍이라고 부르는 것을 정의할 것입니다.</font>

545
00:17:52,200 --> 00:17:58,119
One V8 pair is like, you can think like a cord, you know, so basically, you're going

546
00:17:52,200 --> 00:17:58,119
<font color="#ffff54">하나의 V8 쌍은 코드처럼 생각하면 됩니다.</font>

547
00:17:58,119 --> 00:18:04,519
to put one end plugged to the bridge, the other end plugged to the container.

548
00:17:58,119 --> 00:18:04,519
<font color="#ffff54">한쪽 끝을 다리에 꽂고 다른 쪽 끝을 컨테이너에 꽂는 거죠.</font>

549
00:18:04,519 --> 00:18:05,519
Very simple.

550
00:18:04,519 --> 00:18:05,519
<font color="#ffff54">아주 간단해요.</font>

551
00:18:05,519 --> 00:18:11,000
Again, have a bridge connected to the host network, have a V8 pair, one attached to the

552
00:18:05,519 --> 00:18:11,000
<font color="#ffff54">다시 말하지만, 호스트 네트워크에 연결된 브리지가 있고, V8 쌍이 있고, 그 중 하나는</font>

553
00:18:11,000 --> 00:18:14,279
bridge, one attached to the container.

554
00:18:11,000 --> 00:18:14,279
<font color="#ffff54">브리지에 하나, 컨테이너에 하나 연결합니다.</font>

555
00:18:14,279 --> 00:18:18,000
Again, that's what we're going to do.

556
00:18:14,279 --> 00:18:18,000
<font color="#ffff54">다시 말하지만, 이것이 우리가 할 일입니다.</font>

557
00:18:18,000 --> 00:18:22,160
So let's go back to this one.

558
00:18:18,000 --> 00:18:22,160
<font color="#ffff54">그럼 다시 이걸로 돌아가 봅시다.</font>

559
00:18:22,160 --> 00:18:26,960
Probably take about a minute here.

560
00:18:22,160 --> 00:18:26,960
<font color="#ffff54">여기까지 1분 정도 걸릴 겁니다.</font>

561
00:18:26,960 --> 00:18:35,299
Yeah, so in the meantime, since I have a minute here to talk about things, again, we are going

562
00:18:26,960 --> 00:18:35,299
<font color="#ffff54">네, 그동안 제가 잠깐 얘기할 시간이 있으니 다시 한 번 말씀드리죠.</font>

563
00:18:35,299 --> 00:18:40,559
to do everything here today in bash for simplicity, and we're taking a lot of abstractions.

564
00:18:35,299 --> 00:18:40,559
<font color="#ffff54">단순화를 위해 오늘 여기서 모든 것을 배쉬로 처리하고, 추상화를 많이 하고 있습니다.</font>

565
00:18:40,559 --> 00:18:45,759
But the good thing is, we are going like if you want to do this for real, like and

566
00:18:40,559 --> 00:18:45,759
<font color="#ffff54">하지만 좋은 점은 우리가 이걸 진짜로 하고 싶으면</font>

567
00:18:45,759 --> 00:18:49,240
just use like the right technologies, there is multiple projects.

568
00:18:45,759 --> 00:18:49,240
<font color="#ffff54">올바른 기술처럼 사용하면 여러 프로젝트가 있습니다.</font>

569
00:18:49,240 --> 00:18:55,639
For example, there is the Selium eBPF project that has good examples of like how you how

570
00:18:49,240 --> 00:18:55,639
<font color="#ffff54">예를 들어, 다음과 같은 좋은 예가 있는 Selium eBPF 프로젝트가 있습니다.</font>

571
00:18:55,639 --> 00:19:00,299
you can define actually, you know, the EPF integration later on.

572
00:18:55,639 --> 00:19:00,299
<font color="#ffff54">나중에 실제로 EPF 통합을 정의할 수 있습니다.</font>

573
00:19:00,299 --> 00:19:08,319
There is the container network, you know, networking repo, and it has a lot of good

574
00:19:00,299 --> 00:19:08,319
<font color="#ffff54">컨테이너 네트워크가 있고, 네트워킹 저장소가 있고, 많은 좋은 점이 있습니다.</font>

575
00:19:08,319 --> 00:19:09,319
examples.

576
00:19:08,319 --> 00:19:09,319
<font color="#ffff54">예제들이 있죠.</font>

577
00:19:09,319 --> 00:19:15,000
If you go here on the plugins that are provided, actually the bridge one we're going to do

578
00:19:09,319 --> 00:19:15,000
<font color="#ffff54">제공된 플러그인에서 여기로 이동하면 실제로 우리가 할 브리지 플러그인은 다음과 같습니다.</font>

579
00:19:15,000 --> 00:19:22,200
right now in bash already exists in Golang, and you can just go and copy it right away.

580
00:19:15,000 --> 00:19:22,200
<font color="#ffff54">는 이미 골랑에 존재하므로 바로 가서 복사하면 됩니다.</font>

581
00:19:22,200 --> 00:19:27,279
Okay, let's go back here to instruct.

582
00:19:22,200 --> 00:19:27,279
<font color="#ffff54">자, 이제 다시 돌아가서 지시해 봅시다.</font>

583
00:19:27,279 --> 00:19:30,839
Sticking about 20 seconds.

584
00:19:27,279 --> 00:19:30,839
<font color="#ffff54">20초 정도 붙었습니다.</font>

585
00:19:30,839 --> 00:19:34,319
If anyone has a good joke.

586
00:19:30,839 --> 00:19:34,319
<font color="#ffff54">좋은 농담이 있는 사람.</font>

587
00:19:34,319 --> 00:19:36,200
No.

588
00:19:34,319 --> 00:19:36,200
<font color="#ffff54">아니요.</font>

589
00:19:36,200 --> 00:19:39,120
Okay.

590
00:19:36,200 --> 00:19:39,120
<font color="#ffff54">오케이.</font>

591
00:19:39,120 --> 00:19:41,080
So instruct is pretty easy here.

592
00:19:39,120 --> 00:19:41,080
<font color="#ffff54">여기서 인스트럭트는 꽤 쉽습니다.</font>

593
00:19:41,080 --> 00:19:43,880
You don't have you don't have to install anything.

594
00:19:41,080 --> 00:19:43,880
<font color="#ffff54">아무것도 설치할 필요가 없습니다.</font>

595
00:19:43,880 --> 00:19:50,460
What we're going to need is basically this tab here is going to have a panel on the left

596
00:19:43,880 --> 00:19:50,460
<font color="#ffff54">필요한 것은 기본적으로 여기 이 탭의 왼쪽에 패널이 있는 것입니다.</font>

597
00:19:50,460 --> 00:19:52,559
where we're going to have all the instructions.

598
00:19:50,460 --> 00:19:52,559
<font color="#ffff54">여기에 모든 지침이 있습니다.</font>

599
00:19:52,559 --> 00:19:58,039
And then we're going to have a terminal on the sorry, a terminal on the right.

600
00:19:52,559 --> 00:19:58,039
<font color="#ffff54">그리고 오른쪽에 터미널이 있고, 왼쪽에 터미널이 있습니다.</font>

601
00:19:58,039 --> 00:20:00,039
And we have all the instruction.

602
00:19:58,039 --> 00:20:00,039
<font color="#ffff54">그리고 우리는 모든 지시를 받았습니다.</font>

603
00:20:00,039 --> 00:20:04,160
No way saying the terminal is in the left, sorry, in instruction are on the right.

604
00:20:00,039 --> 00:20:04,160
<font color="#ffff54">터미널은 왼쪽에 있고, 명령어는 오른쪽에 있습니다.</font>

605
00:20:04,160 --> 00:20:09,560
And it's probably just a copy paste exercise at this point.

606
00:20:04,160 --> 00:20:09,560
<font color="#ffff54">지금은 그냥 복사해서 붙여넣기만 하면 되겠군요.</font>

607
00:20:09,560 --> 00:20:12,880
So quick question here, who has this the environments ready?

608
00:20:09,560 --> 00:20:12,880
<font color="#ffff54">잠깐만요, 누가 이 환경을 준비했나요?</font>

609
00:20:12,880 --> 00:20:16,840
Wow, so you guys faster than me here.

610
00:20:12,880 --> 00:20:16,840
<font color="#ffff54">와, 저보다 더 빠르시네요.</font>

611
00:20:16,840 --> 00:20:21,920
Okay, well, wait for me, right.

612
00:20:16,840 --> 00:20:21,920
<font color="#ffff54">알았어, 잠깐만 기다려봐.</font>

613
00:20:21,920 --> 00:20:23,920
Okay.

614
00:20:21,920 --> 00:20:23,920
<font color="#ffff54">알았어.</font>

615
00:20:23,920 --> 00:20:27,680
Keep going.

616
00:20:23,920 --> 00:20:27,680
<font color="#ffff54">계속해.</font>

617
00:20:27,680 --> 00:20:31,600
Time soon.

618
00:20:27,680 --> 00:20:31,600
<font color="#ffff54">곧 도착합니다.</font>

619
00:20:31,600 --> 00:20:51,600
Do you

620
00:20:31,600 --> 00:20:51,600
<font color="#ffff54">Do you</font>

621
00:20:51,600 --> 00:20:56,080
guys see the the terminal?

622
00:20:51,600 --> 00:20:56,080
<font color="#ffff54">터미널 보여?</font>

623
00:20:56,080 --> 00:21:01,000
Okay, good.

624
00:20:56,080 --> 00:21:01,000
<font color="#ffff54">그래, 좋아.</font>

625
00:21:01,000 --> 00:21:03,720
Interesting.

626
00:21:01,000 --> 00:21:03,720
<font color="#ffff54">흥미롭군.</font>

627
00:21:03,720 --> 00:21:14,400
I'll give it another try on different tab.

628
00:21:03,720 --> 00:21:14,400
<font color="#ffff54">다른 탭에서 다시 시도해볼게요.</font>

629
00:21:14,400 --> 00:21:15,400
Ah, there you go.

630
00:21:14,400 --> 00:21:15,400
<font color="#ffff54">여기 있네요.</font>

631
00:21:15,400 --> 00:21:16,400
Okay, just being patient.

632
00:21:15,400 --> 00:21:16,400
<font color="#ffff54">좋아, 조금만 더 기다려.</font>

633
00:21:16,400 --> 00:21:19,119
Okay, there you go.

634
00:21:16,400 --> 00:21:19,119
<font color="#ffff54">좋아, 됐어.</font>

635
00:21:19,119 --> 00:21:20,119
Let's go.

636
00:21:19,119 --> 00:21:20,119
<font color="#ffff54">가자.</font>

637
00:21:20,119 --> 00:21:21,720
Let's start.

638
00:21:20,119 --> 00:21:21,720
<font color="#ffff54">시작하자.</font>

639
00:21:21,720 --> 00:21:26,000
So what we're going today to do today is pretty straightforward.

640
00:21:21,720 --> 00:21:26,000
<font color="#ffff54">오늘 우리가 할 일은 아주 간단합니다.</font>

641
00:21:26,000 --> 00:21:32,839
We are going to first create a Kubernetes cluster, a single node Kubernetes cluster

642
00:21:26,000 --> 00:21:32,839
<font color="#ffff54">먼저 단일 노드 쿠버네티스 클러스터인 쿠버네티스 클러스터를 생성하겠습니다.</font>

643
00:21:32,839 --> 00:21:34,400
that doesn't have anything much.

644
00:21:32,839 --> 00:21:34,400
<font color="#ffff54">아무것도 없는 노드입니다.</font>

645
00:21:34,400 --> 00:21:35,799
It doesn't have any CNI.

646
00:21:34,400 --> 00:21:35,799
<font color="#ffff54">CNI가 없습니다.</font>

647
00:21:35,799 --> 00:21:39,039
Okay, for that we're going to use kube EDM.

648
00:21:35,799 --> 00:21:39,039
<font color="#ffff54">자, 여기서는 kube EDM을 사용하겠습니다.</font>

649
00:21:39,039 --> 00:21:45,140
It's it's, it's very simple Kubernetes cluster here again, basics.

650
00:21:39,039 --> 00:21:45,140
<font color="#ffff54">다시 한번 아주 간단한 쿠버네티스 클러스터입니다.</font>

651
00:21:45,140 --> 00:21:49,660
So to use this platform is straightforward.

652
00:21:45,140 --> 00:21:49,660
<font color="#ffff54">따라서 이 플랫폼을 사용하는 것은 간단합니다.</font>

653
00:21:49,660 --> 00:21:53,920
Go and click on the command, right?

654
00:21:49,660 --> 00:21:53,920
<font color="#ffff54">가서 명령을 클릭하세요.</font>

655
00:21:53,920 --> 00:21:58,960
Click on whatever you want to copy, and then go to the terminal and paste.

656
00:21:53,920 --> 00:21:58,960
<font color="#ffff54">복사할 내용을 클릭한 다음 터미널로 이동하여 붙여넣기하세요.</font>

657
00:21:58,960 --> 00:22:10,320
All right, first step is creating a Kubernetes cluster without any CNI installed.

658
00:21:58,960 --> 00:22:10,320
<font color="#ffff54">자, 첫 번째 단계는 CNI를 설치하지 않고 쿠버네티스 클러스터를 생성하는 것입니다.</font>

659
00:22:10,320 --> 00:22:13,620
It's taking a couple seconds to get it ready.

660
00:22:10,320 --> 00:22:13,620
<font color="#ffff54">준비하는 데 몇 초가 걸립니다.</font>

661
00:22:13,620 --> 00:22:16,840
And once done, now we have a Kubernetes cluster.

662
00:22:13,620 --> 00:22:16,840
<font color="#ffff54">완료되면 이제 쿠버네티스 클러스터가 생겼습니다.</font>

663
00:22:16,840 --> 00:22:19,200
I can run the second command here.

664
00:22:16,840 --> 00:22:19,200
<font color="#ffff54">여기서 두 번째 명령을 실행할 수 있습니다.</font>

665
00:22:19,200 --> 00:22:25,580
It's just to basically wire, you know, the kube config.

666
00:22:19,200 --> 00:22:25,580
<font color="#ffff54">이것은 기본적으로 큐브 구성을 연결하기 위한 것입니다.</font>

667
00:22:25,580 --> 00:22:29,319
So now I can run commands like kubectl get pod.

668
00:22:25,580 --> 00:22:29,319
<font color="#ffff54">이제 다음과 같은 명령을 실행할 수 있다.</font>

669
00:22:29,319 --> 00:22:36,799
If I run the kubectl get pod command, you guys can see from back there.

670
00:22:29,319 --> 00:22:36,799
<font color="#ffff54">kubectl get pod 명령을 실행하면, 저 뒤에서 볼 수 있다.</font>

671
00:22:36,799 --> 00:22:37,799
Good.

672
00:22:36,799 --> 00:22:37,799
<font color="#ffff54">좋아.</font>

673
00:22:37,799 --> 00:22:39,360
All right.

674
00:22:37,799 --> 00:22:39,360
<font color="#ffff54">알았어.</font>

675
00:22:39,360 --> 00:22:49,520
So if I run the kubectl command, oops, I see here that I have a couple pods that are running,

676
00:22:39,360 --> 00:22:49,520
<font color="#ffff54">그래서 kubectl 명령을 실행하면, 여기에 몇 개의 파드가 실행 중인 것을 볼 수 있다,</font>

677
00:22:49,520 --> 00:22:51,800
but I have two that are pending.

678
00:22:49,520 --> 00:22:51,800
<font color="#ffff54">하지만 보류 중인 파드가 두 개 있다.</font>

679
00:22:51,800 --> 00:22:52,880
Right?

680
00:22:51,800 --> 00:22:52,880
<font color="#ffff54">그렇죠?</font>

681
00:22:52,880 --> 00:22:57,220
So the core ones, the core Kubernetes pods are started, that's fine.

682
00:22:52,880 --> 00:22:57,220
<font color="#ffff54">핵심 쿠버네티스 파드가 시작되었으니 괜찮습니다.</font>

683
00:22:57,220 --> 00:23:02,880
But anything that is need that needs a CNI to operate, it's impending, right?

684
00:22:57,220 --> 00:23:02,880
<font color="#ffff54">하지만 작동을 위해 CNI가 필요한 모든 것은 임박한 거죠?</font>

685
00:23:02,880 --> 00:23:08,800
That's because we don't have any CNI installed at this point.

686
00:23:02,880 --> 00:23:08,800
<font color="#ffff54">현재로서는 CNI가 설치되지 않았기 때문입니다.</font>

687
00:23:08,799 --> 00:23:15,440
So even if you start any like hell world or, you know, HTTP bin, whatever service,

688
00:23:08,799 --> 00:23:15,440
<font color="#ffff54">따라서 지옥의 세계나 HTTP 빈 등 어떤 서비스를 시작해도 마찬가지입니다,</font>

689
00:23:15,440 --> 00:23:18,200
it will not work at this point.

690
00:23:15,440 --> 00:23:18,200
<font color="#ffff54">이 시점에서는 작동하지 않습니다.</font>

691
00:23:18,200 --> 00:23:20,399
So let's fix that.

692
00:23:18,200 --> 00:23:20,399
<font color="#ffff54">그럼 고쳐봅시다.</font>

693
00:23:20,399 --> 00:23:24,279
Let's actually create our first CNI plugin.

694
00:23:20,399 --> 00:23:24,279
<font color="#ffff54">실제로 첫 번째 CNI 플러그인을 만들어 봅시다.</font>

695
00:23:24,279 --> 00:23:30,480
The first step we're going to do here is to copy the skeleton of our CNI plugin.

696
00:23:24,279 --> 00:23:30,480
<font color="#ffff54">여기서 할 첫 번째 단계는 CNI 플러그인의 골격을 복사하는 것입니다.</font>

697
00:23:30,480 --> 00:23:34,680
Let's copy it and let's open it on this tab.

698
00:23:30,480 --> 00:23:34,680
<font color="#ffff54">복사한 후 이 탭에서 열어 봅시다.</font>

699
00:23:34,680 --> 00:23:40,580
So copy the command, like run the command copy, and then let's go to the editor here.

700
00:23:34,680 --> 00:23:40,580
<font color="#ffff54">복사 명령을 실행한 다음 여기 에디터로 이동해 보겠습니다.</font>

701
00:23:40,580 --> 00:23:42,480
Press refresh if you don't see it right away.

702
00:23:40,580 --> 00:23:42,480
<font color="#ffff54">바로 보이지 않으면 새로고침을 누르세요.</font>

703
00:23:42,480 --> 00:23:47,700
You know, sometimes it takes a couple times to pop up.

704
00:23:42,480 --> 00:23:47,700
<font color="#ffff54">가끔 팝업이 뜨는데 몇 번 걸리기도 해요.</font>

705
00:23:47,700 --> 00:23:53,039
Now that you click on the file and let's just read the first, you know, this is the kind

706
00:23:47,700 --> 00:23:53,039
<font color="#ffff54">이제 파일을 클릭하고 첫 번째 파일을 읽어보겠습니다.</font>

707
00:23:53,039 --> 00:23:56,720
of the basics of our CNI plugin.

708
00:23:53,039 --> 00:23:56,720
<font color="#ffff54">CNI 플러그인의 기본 사항입니다.</font>

709
00:23:56,720 --> 00:24:01,380
It's just a bash file and it has a couple commands that we need to do.

710
00:23:56,720 --> 00:24:01,380
<font color="#ffff54">이 파일에는 우리가 수행해야 할 몇 가지 명령이 들어 있습니다.</font>

711
00:24:01,380 --> 00:24:04,540
So we are reading this environment variable CNI command.

712
00:24:01,380 --> 00:24:04,540
<font color="#ffff54">이 환경 변수 CNI 명령을 읽습니다.</font>

713
00:24:04,540 --> 00:24:06,640
Remember, right?

714
00:24:04,540 --> 00:24:06,640
<font color="#ffff54">기억하시죠?</font>

715
00:24:06,640 --> 00:24:11,800
The container and time execute the binary and pass certain environment variable.

716
00:24:06,640 --> 00:24:11,800
<font color="#ffff54">컨테이너와 시간은 바이너리를 실행하고 특정 환경 변수를 전달합니다.</font>

717
00:24:11,800 --> 00:24:15,420
As part of this environment variable, we have the CNI command.

718
00:24:11,800 --> 00:24:15,420
<font color="#ffff54">이 환경 변수의 일부로 CNI 명령이 있습니다.</font>

719
00:24:15,420 --> 00:24:20,260
What we want to do in this case, there's multiple operations.

720
00:24:15,420 --> 00:24:20,260
<font color="#ffff54">이 경우 수행하고자 하는 작업은 여러 가지입니다.</font>

721
00:24:20,260 --> 00:24:23,300
Actually I'm missing one here that doesn't really matter.

722
00:24:20,260 --> 00:24:23,300
<font color="#ffff54">사실 여기서 하나 빠진 게 있는데, 별로 중요하지 않아요.</font>

723
00:24:23,300 --> 00:24:28,620
But in our case, we want to focus on adding a pod and deleting a pod, right?

724
00:24:23,300 --> 00:24:28,620
<font color="#ffff54">하지만 우리의 경우, 우리는 파드를 추가하고 삭제하는 것에 집중하고 싶지 않나요?</font>

725
00:24:28,620 --> 00:24:33,860
So in this case, we have case add, delete, check, and version.

726
00:24:28,620 --> 00:24:33,860
<font color="#ffff54">이 경우에는 추가, 삭제, 확인, 버전이 있다.</font>

727
00:24:33,860 --> 00:24:37,260
All right, this is very basic.

728
00:24:33,860 --> 00:24:37,260
<font color="#ffff54">자, 아주 기본적인 내용입니다.</font>

729
00:24:37,260 --> 00:24:45,600
Let's keep going here and now let's implement the add function in our CNI plugin.

730
00:24:37,260 --> 00:24:45,600
<font color="#ffff54">여기서 계속 진행하여 이제 CNI 플러그인에서 추가 기능을 구현해 보겠습니다.</font>

731
00:24:45,600 --> 00:24:52,080
So the add function is going to do a couple things.

732
00:24:45,600 --> 00:24:52,080
<font color="#ffff54">추가 함수는 몇 가지 작업을 수행할 것입니다.</font>

733
00:24:52,079 --> 00:24:59,119
The add function is going to grab, you know, first we're going to get the CRDR of the pod,

734
00:24:52,079 --> 00:24:59,119
<font color="#ffff54">add 함수는 먼저 파드의 CRDR을 가져올 것이다,</font>

735
00:24:59,119 --> 00:25:00,119
of the node.

736
00:24:59,119 --> 00:25:00,119
<font color="#ffff54">를 가져온다.</font>

737
00:25:00,119 --> 00:25:05,460
Like what kind of IPs are allowed on a certain node?

738
00:25:00,119 --> 00:25:05,460
<font color="#ffff54">특정 노드에서 어떤 종류의 IP가 허용되는지 궁금하신가요?</font>

739
00:25:05,460 --> 00:25:11,359
Then we are going to create, again, a bridge like we said.

740
00:25:05,460 --> 00:25:11,359
<font color="#ffff54">그런 다음 다시 말씀드린 것처럼 브리지를 만들겠습니다.</font>

741
00:25:11,359 --> 00:25:16,919
And then we're going to create the V8 pair, one plugged to the bridge, one plugged to

742
00:25:11,359 --> 00:25:16,919
<font color="#ffff54">그리고 하나는 브리지에 연결하고 다른 하나는 다음에 연결하여 V8 쌍을 만듭니다.</font>

743
00:25:16,920 --> 00:25:22,340
the container, and then we're going to return a certain result saying, well, everything's

744
00:25:16,920 --> 00:25:22,340
<font color="#ffff54">컨테이너에 연결한 다음 모든 것이 완료되었다는 특정 결과를 반환할 것입니다.</font>

745
00:25:22,340 --> 00:25:25,360
done, everything's good.

746
00:25:22,340 --> 00:25:25,360
<font color="#ffff54">완료, 모든 것이 정상입니다.</font>

747
00:25:25,360 --> 00:25:28,160
So let's run this command here.

748
00:25:25,360 --> 00:25:28,160
<font color="#ffff54">이제 이 명령을 실행해 봅시다.</font>

749
00:25:28,160 --> 00:25:35,920
We're going to copy the step two add, going back to the terminal, run this.

750
00:25:28,160 --> 00:25:35,920
<font color="#ffff54">2단계 추가를 복사하고 터미널로 돌아가서 이 명령을 실행합니다.</font>

751
00:25:35,920 --> 00:25:40,200
And now if you go to the editor, just again, refresh the page if you don't see the new

752
00:25:35,920 --> 00:25:40,200
<font color="#ffff54">이제 편집기로 돌아가서 다시 한 번 페이지를 새로고침합니다.</font>

753
00:25:40,200 --> 00:25:41,380
code.

754
00:25:40,200 --> 00:25:41,380
<font color="#ffff54">코드가 표시되지 않으면</font>

755
00:25:41,380 --> 00:25:44,800
And let's go line by line here trying to understand what we did.

756
00:25:41,380 --> 00:25:44,800
<font color="#ffff54">이제 우리가 무엇을 했는지 한 줄 한 줄 살펴봅시다.</font>

757
00:25:44,799 --> 00:25:45,799
Again, this is Bash.

758
00:25:44,799 --> 00:25:45,799
<font color="#ffff54">다시, 배쉬입니다.</font>

759
00:25:45,799 --> 00:25:48,879
It's very much simplified for a lot of things.

760
00:25:45,799 --> 00:25:48,879
<font color="#ffff54">많은 것들이 매우 단순화되었습니다.</font>

761
00:25:48,879 --> 00:25:51,960
Write and go if you want to do it.

762
00:25:48,879 --> 00:25:51,960
<font color="#ffff54">하고 싶으면 쓰고 가세요.</font>

763
00:25:51,960 --> 00:26:00,240
The first thing is to, we are going to pass, right, we are going to pass the pod CRDR using

764
00:25:51,960 --> 00:26:00,240
<font color="#ffff54">첫 번째는, 우리는 다음을 사용하여 파드 CRDR을 전달할 것이다.</font>

765
00:26:00,240 --> 00:26:03,839
the, remember, the configuration, the JSON configuration.

766
00:26:00,240 --> 00:26:03,839
<font color="#ffff54">구성, JSON 구성을 기억하세요.</font>

767
00:26:03,839 --> 00:26:09,119
We are going to pass in that JSON configuration the pod CRDR of the node.

768
00:26:03,839 --> 00:26:09,119
<font color="#ffff54">이 JSON 구성에 노드의 파드 CRDR을 전달할 것이다.</font>

769
00:26:09,119 --> 00:26:11,519
So every single node has a pod CRDR.

770
00:26:09,119 --> 00:26:11,519
<font color="#ffff54">모든 노드에는 파드 CRDR이 있다.</font>

771
00:26:12,240 --> 00:26:16,519
We're going to pass that to the CNI plugin.

772
00:26:12,240 --> 00:26:16,519
<font color="#ffff54">이를 CNI 플러그인에 전달한다.</font>

773
00:26:16,519 --> 00:26:19,799
Then we are going to create a bridge.

774
00:26:16,519 --> 00:26:19,799
<font color="#ffff54">그런 다음 브리지를 만들겠습니다.</font>

775
00:26:19,799 --> 00:26:23,559
We are using, again, just CLI commands to do a lot of things.

776
00:26:19,799 --> 00:26:23,559
<font color="#ffff54">다시 한 번 CLI 명령어만 사용하여 많은 작업을 수행합니다.</font>

777
00:26:23,559 --> 00:26:26,759
In this case, we are creating a bridge called bridge zero.

778
00:26:23,559 --> 00:26:26,759
<font color="#ffff54">이 경우 브리지 0이라는 브리지를 만들고 있습니다.</font>

779
00:26:26,759 --> 00:26:31,519
Sorry, I'm just going to remove this so it's easy to read.

780
00:26:26,759 --> 00:26:31,519
<font color="#ffff54">읽기 쉽도록 이 부분을 삭제하겠습니다.</font>

781
00:26:31,519 --> 00:26:34,960
Okay, there you go.

782
00:26:31,519 --> 00:26:34,960
<font color="#ffff54">이제 됐어요.</font>

783
00:26:34,960 --> 00:26:40,480
Yeah, so the first step, again, is creating the bridge if it doesn't exist.

784
00:26:34,960 --> 00:26:40,480
<font color="#ffff54">네, 첫 번째 단계는 다시 말하지만, 존재하지 않는 다리를 만드는 것입니다.</font>

785
00:26:40,480 --> 00:26:44,680
In this case, it's called bridge zero.

786
00:26:40,480 --> 00:26:44,680
<font color="#ffff54">이 경우에는 브리지 0이라고 합니다.</font>

787
00:26:44,680 --> 00:26:52,000
Then we are assigning like a gateway IP and IP itself to the bridge, right?

788
00:26:44,680 --> 00:26:52,000
<font color="#ffff54">그러면 게이트웨이 IP와 IP 자체를 브리지에 할당하는 거죠?</font>

789
00:26:52,000 --> 00:26:59,400
So the step here is to assign the IP and then we are going, we need to figure out the IP

790
00:26:52,000 --> 00:26:59,400
<font color="#ffff54">그래서 여기서 단계는 IP를 할당하는 것이고, 그 다음에는 IP를 알아내야 합니다.</font>

791
00:26:59,400 --> 00:27:00,960
of a container, right?

792
00:26:59,400 --> 00:27:00,960
<font color="#ffff54">컨테이너의 IP를 알아내야 하죠?</font>

793
00:27:00,960 --> 00:27:04,000
Again, this is very, very bad code.

794
00:27:00,960 --> 00:27:04,000
<font color="#ffff54">다시 말하지만, 이것은 아주 아주 나쁜 코드입니다.</font>

795
00:27:04,000 --> 00:27:06,519
You don't do that in general, right?

796
00:27:04,000 --> 00:27:06,519
<font color="#ffff54">일반적으로는 이렇게 하지 않죠?</font>

797
00:27:06,519 --> 00:27:11,639
Do not go and do a random to figure out what kind of IP we have.

798
00:27:06,519 --> 00:27:11,639
<font color="#ffff54">우리가 어떤 종류의 IP를 가지고 있는지 알아내기 위해 무작위로 하지 마세요.</font>

799
00:27:11,639 --> 00:27:15,000
But you probably use the ICP instead and so on.

800
00:27:11,639 --> 00:27:15,000
<font color="#ffff54">하지만 대신 ICP를 사용할 수도 있습니다.</font>

801
00:27:15,000 --> 00:27:19,559
In this case, we are running this command to figure out, let's grab an IP.

802
00:27:15,000 --> 00:27:19,559
<font color="#ffff54">이 경우, 이 명령을 실행하여 IP를 파악해 보겠습니다.</font>

803
00:27:19,559 --> 00:27:25,039
Let's grab an IP within the CRDR range that we pass in the configuration.

804
00:27:19,559 --> 00:27:25,039
<font color="#ffff54">구성에서 전달한 CRDR 범위 내의 IP를 가져와 보겠습니다.</font>

805
00:27:25,039 --> 00:27:30,200
So we are doing a random between two and 255, okay?

806
00:27:25,039 --> 00:27:30,200
<font color="#ffff54">2와 255 사이에서 무작위 추출을 하는 거죠?</font>

807
00:27:30,200 --> 00:27:31,799
Basically an IP there.

808
00:27:30,200 --> 00:27:31,799
<font color="#ffff54">기본적으로 저기 IP입니다.</font>

809
00:27:31,799 --> 00:27:36,319
We're going to grab this IP, put it in the variable called IP.

810
00:27:31,799 --> 00:27:36,319
<font color="#ffff54">이 IP를 가져와서 IP라는 변수에 넣겠습니다.</font>

811
00:27:36,319 --> 00:27:38,519
And again, remember the steps are pretty easy.

812
00:27:36,319 --> 00:27:38,519
<font color="#ffff54">다시 한 번, 단계는 매우 간단하다는 것을 기억하세요.</font>

813
00:27:38,519 --> 00:27:43,559
First create the bridge, define an IP for the container, create the V8 pair, plug one

814
00:27:38,519 --> 00:27:43,559
<font color="#ffff54">먼저 브리지를 생성하고, 컨테이너의 IP를 정의하고, V8 쌍을 생성하고, 하나를 연결합니다.</font>

815
00:27:43,559 --> 00:27:46,359
in the bridge, plug one in the container.

816
00:27:43,559 --> 00:27:46,359
<font color="#ffff54">브리지에서 컨테이너에 연결합니다.</font>

817
00:27:46,359 --> 00:27:50,359
All right, so we did, we did the two first ones.

818
00:27:46,359 --> 00:27:50,359
<font color="#ffff54">좋아, 처음 두 개는 해냈어.</font>

819
00:27:50,359 --> 00:27:54,599
We created the bridge and we generated an IP randomly.

820
00:27:50,359 --> 00:27:54,599
<font color="#ffff54">브리지를 생성하고 무작위로 IP를 생성했습니다.</font>

821
00:27:54,599 --> 00:27:59,879
The step after that is to basically create the V8 pair.

822
00:27:54,599 --> 00:27:59,879
<font color="#ffff54">그 다음 단계는 기본적으로 V8 쌍을 생성하는 것입니다.</font>

823
00:27:59,880 --> 00:28:08,920
To create the V8 pair, we are using IP link add where with the one side of the V8 pair

824
00:27:59,880 --> 00:28:08,920
<font color="#ffff54">V8 쌍을 생성하기 위해 V8 쌍의 한 쪽에 IP 링크 추가 위치를 사용합니다.</font>

825
00:28:08,920 --> 00:28:15,600
is the CNI if name that's been passed through the execution of the CNI plugin.

826
00:28:08,920 --> 00:28:15,600
<font color="#ffff54">는 CNI 플러그인 실행을 통해 전달된 CNI if 이름입니다.</font>

827
00:28:15,600 --> 00:28:21,000
Again, that's configuration coming from the container runtime.

828
00:28:15,600 --> 00:28:21,000
<font color="#ffff54">이 역시 컨테이너 런타임에서 가져온 설정입니다.</font>

829
00:28:21,000 --> 00:28:26,700
And the other end is basically the name of the interface that we are going to create

830
00:28:21,000 --> 00:28:26,700
<font color="#ffff54">그리고 다른 쪽 끝은 기본적으로 우리가 생성할 인터페이스의 이름입니다.</font>

831
00:28:26,700 --> 00:28:28,520
for this specific pod.

832
00:28:26,700 --> 00:28:28,520
<font color="#ffff54">이 특정 파드에 대해.</font>

833
00:28:29,519 --> 00:28:35,480
This new interface is the one that's going to be plugged to the bridge.

834
00:28:29,519 --> 00:28:35,480
<font color="#ffff54">이 새로운 인터페이스는 브리지에 연결될 인터페이스이다.</font>

835
00:28:35,480 --> 00:28:37,400
So here's the V8 pair.

836
00:28:35,480 --> 00:28:37,400
<font color="#ffff54">여기 V8 쌍이 있습니다.</font>

837
00:28:37,400 --> 00:28:39,680
Now we have our extension cord, right?

838
00:28:37,400 --> 00:28:39,680
<font color="#ffff54">이제 연장 코드가 있죠?</font>

839
00:28:39,680 --> 00:28:40,740
But it's not plugged yet.

840
00:28:39,680 --> 00:28:40,740
<font color="#ffff54">하지만 아직 꽂혀 있지 않아요.</font>

841
00:28:40,740 --> 00:28:44,000
We just have that.

842
00:28:40,740 --> 00:28:44,000
<font color="#ffff54">방금 찾았습니다.</font>

843
00:28:44,000 --> 00:28:48,799
What we are going to do is to plug one end in the bridge.

844
00:28:44,000 --> 00:28:48,799
<font color="#ffff54">이제 한쪽 끝을 다리에 꽂으면 됩니다.</font>

845
00:28:48,799 --> 00:28:49,799
There you go.

846
00:28:48,799 --> 00:28:49,799
<font color="#ffff54">됐어요.</font>

847
00:28:49,799 --> 00:28:57,799
IP link set, the end of one of the V8 pairs is now plugged in the bridge zero.

848
00:28:49,799 --> 00:28:57,799
<font color="#ffff54">IP 링크가 설정되었고, 이제 V8 쌍 중 하나의 끝이 브리지 0에 연결되었습니다.</font>

849
00:28:57,799 --> 00:29:05,759
Now we have the other end of our extension cord that we need to plug in the container itself.

850
00:28:57,799 --> 00:29:05,759
<font color="#ffff54">이제 연장 코드의 다른 쪽 끝을 컨테이너 자체에 연결해야 합니다.</font>

851
00:29:05,759 --> 00:29:12,940
So what we are going to do is to define the network namespace.

852
00:29:05,759 --> 00:29:12,940
<font color="#ffff54">이제 우리가 할 일은 네트워크 네임스페이스를 정의하는 것입니다.</font>

853
00:29:12,940 --> 00:29:15,839
To do this, we're going to do a couple of commands here.

854
00:29:12,940 --> 00:29:15,839
<font color="#ffff54">이를 위해 여기에 몇 가지 명령을 실행합니다.</font>

855
00:29:15,839 --> 00:29:23,960
But long story short, we are defining our network namespace that we called in, you know,

856
00:29:15,839 --> 00:29:23,960
<font color="#ffff54">간단히 말해서, 우리가 호출한 네트워크 네임스페이스를 정의하는 것입니다,</font>

857
00:29:24,120 --> 00:29:27,640
we're just using a link here to container.

858
00:29:24,120 --> 00:29:27,640
<font color="#ffff54">여기서는 컨테이너로 연결되는 링크를 사용하고 있습니다.</font>

859
00:29:27,640 --> 00:29:33,360
CNI is going to be slash var run netns slash container, CNI container ID.

860
00:29:27,640 --> 00:29:33,360
<font color="#ffff54">CNI는 슬래시 var run netns 슬래시 컨테이너, CNI 컨테이너 ID가 될 것입니다.</font>

861
00:29:33,360 --> 00:29:38,559
That's basically our network namespace being defined.

862
00:29:33,360 --> 00:29:38,559
<font color="#ffff54">기본적으로 네트워크 네임스페이스가 정의되었습니다.</font>

863
00:29:38,559 --> 00:29:48,039
Then what we are going to do is to basically go and put that other end of the extension

864
00:29:38,559 --> 00:29:48,039
<font color="#ffff54">이제 우리가 할 일은 기본적으로 확장자의 다른 쪽 끝을 넣는 것입니다.</font>

865
00:29:48,039 --> 00:29:53,920
cord within this network namespace that we just defined.

866
00:29:48,039 --> 00:29:53,920
<font color="#ffff54">코드의 다른 쪽 끝을 방금 정의한 네트워크 네임스페이스 안에 넣습니다.</font>

867
00:29:53,920 --> 00:29:54,920
Okay?

868
00:29:53,920 --> 00:29:54,920
<font color="#ffff54">알겠지?</font>

869
00:29:54,920 --> 00:29:56,680
We're going to plug it there.

870
00:29:54,920 --> 00:29:56,680
<font color="#ffff54">저기 연결할게요.</font>

871
00:29:56,680 --> 00:29:59,440
The second thing, we're going to define the IP, right?

872
00:29:56,680 --> 00:29:59,440
<font color="#ffff54">두 번째는 IP를 정의하는 거죠?</font>

873
00:29:59,440 --> 00:30:00,440
Important.

874
00:29:59,440 --> 00:30:00,440
<font color="#ffff54">중요.</font>

875
00:30:00,440 --> 00:30:01,759
We haven't used the IP yet.

876
00:30:00,440 --> 00:30:01,759
<font color="#ffff54">아직 IP를 사용하지 않았습니다.</font>

877
00:30:01,759 --> 00:30:04,740
Right now we're using the IP, the one we generated randomly.

878
00:30:01,759 --> 00:30:04,740
<font color="#ffff54">지금은 무작위로 생성한 IP를 사용하고 있습니다.</font>

879
00:30:04,740 --> 00:30:09,500
We are defining that, putting that in our network namespace.

880
00:30:04,740 --> 00:30:09,500
<font color="#ffff54">이를 정의하여 네트워크 네임스페이스에 넣습니다.</font>

881
00:30:09,500 --> 00:30:11,000
So we did the two things.

882
00:30:09,500 --> 00:30:11,000
<font color="#ffff54">두 가지 작업을 수행했습니다.</font>

883
00:30:11,000 --> 00:30:13,680
Again, we plugged the other end to the container.

884
00:30:11,000 --> 00:30:13,680
<font color="#ffff54">다시 다른 쪽 끝을 컨테이너에 연결했습니다.</font>

885
00:30:13,680 --> 00:30:15,000
We defined the IP.

886
00:30:13,680 --> 00:30:15,000
<font color="#ffff54">IP를 정의했습니다.</font>

887
00:30:15,000 --> 00:30:20,160
The last thing is to define the default gateway that basically just to carry all the traffic

888
00:30:15,000 --> 00:30:20,160
<font color="#ffff54">마지막으로 기본적으로 모든 트래픽을 전달하는 기본 게이트웨이를 정의합니다.</font>

889
00:30:20,160 --> 00:30:25,599
that goes within the network namespace out and that through the default gateway that

890
00:30:20,160 --> 00:30:25,599
<font color="#ffff54">네트워크 네임스페이스 내에서 나가는 기본 게이트웨이를 통해</font>

891
00:30:25,599 --> 00:30:28,279
we just defined in the bridge.

892
00:30:25,599 --> 00:30:28,279
<font color="#ffff54">로 이동합니다.</font>

893
00:30:28,279 --> 00:30:33,380
That's kind of the way to say this is how you route traffic.

894
00:30:28,279 --> 00:30:33,380
<font color="#ffff54">이것이 바로 트래픽을 라우팅하는 방식이라고 할 수 있습니다.</font>

895
00:30:33,380 --> 00:30:40,880
So once we did these steps, right, we did, again, probably repeating myself, but just

896
00:30:33,380 --> 00:30:40,880
<font color="#ffff54">이 단계를 수행한 후, 다시 한 번 반복해서 말하지만</font>

897
00:30:40,880 --> 00:30:45,120
to understand the concept, we created the bridge, if not existing.

898
00:30:40,880 --> 00:30:45,120
<font color="#ffff54">개념을 이해하기 위해 존재하지 않는다면 다리를 만들었습니다.</font>

899
00:30:45,120 --> 00:30:46,780
We defined an IP.

900
00:30:45,120 --> 00:30:46,780
<font color="#ffff54">IP를 정의했습니다.</font>

901
00:30:46,780 --> 00:30:51,180
We created the V8 pair and we plugged the both ends.

902
00:30:46,780 --> 00:30:51,180
<font color="#ffff54">V8 쌍을 생성하고 양쪽 끝을 연결했습니다.</font>

903
00:30:51,180 --> 00:30:54,680
Now that, you know, you mean like we mean it's good.

904
00:30:51,180 --> 00:30:54,680
<font color="#ffff54">이제, 알다시피, 우리가 좋다는 뜻이죠.</font>

905
00:30:54,680 --> 00:30:55,680
We're done now.

906
00:30:54,680 --> 00:30:55,680
<font color="#ffff54">이제 끝났어.</font>

907
00:30:55,680 --> 00:30:58,840
We defined connectivity to our container.

908
00:30:55,680 --> 00:30:58,840
<font color="#ffff54">컨테이너에 대한 연결을 정의했습니다.</font>

909
00:30:58,840 --> 00:31:03,760
Let's report this success to our container runtime.

910
00:30:58,840 --> 00:31:03,760
<font color="#ffff54">이 성공을 컨테이너 런타임에 보고해 봅시다.</font>

911
00:31:03,760 --> 00:31:08,860
The container runtime now will get a result to say, oh, you know what?

912
00:31:03,760 --> 00:31:08,860
<font color="#ffff54">이제 컨테이너 런타임은 다음과 같은 결과를 얻을 것입니다.</font>

913
00:31:08,860 --> 00:31:09,860
That's good.

914
00:31:08,860 --> 00:31:09,860
<font color="#ffff54">좋네요.</font>

915
00:31:09,860 --> 00:31:17,860
We are using, obviously, the CNI specification format to return certain results.

916
00:31:09,860 --> 00:31:17,860
<font color="#ffff54">분명히 특정 결과를 반환하기 위해 CNI 사양 형식을 사용하고 있습니다.</font>

917
00:31:17,860 --> 00:31:23,460
What we are going to use here is we're going to return the certain information, for example,

918
00:31:17,860 --> 00:31:23,460
<font color="#ffff54">여기서 사용할 것은 예를 들어 특정 정보를 반환하는 것입니다,</font>

919
00:31:23,460 --> 00:31:29,860
the IP of this specific, we're going to return this IP of this specific container that we

920
00:31:23,460 --> 00:31:29,860
<font color="#ffff54">이 특정 컨테이너의 IP, 이 특정 컨테이너의 IP를 반환할 것입니다.</font>

921
00:31:29,860 --> 00:31:30,860
generated.

922
00:31:29,860 --> 00:31:30,860
<font color="#ffff54">생성했습니다.</font>

923
00:31:30,860 --> 00:31:35,460
We're going to return the MAC address and so on, okay, which gateway is being used and

924
00:31:30,860 --> 00:31:35,460
<font color="#ffff54">어떤 게이트웨이가 사용 중인지, 어떤 MAC 주소 등을 반환할 것입니다.</font>

925
00:31:35,460 --> 00:31:36,460
so on.

926
00:31:35,460 --> 00:31:36,460
<font color="#ffff54">등등.</font>

927
00:31:36,460 --> 00:31:44,019
Again, the CNI spec is very much, very flexible and the way it operates is it's captured.

928
00:31:36,460 --> 00:31:44,019
<font color="#ffff54">다시 말하지만, CNI 사양은 매우 유연하며 작동 방식이 캡처됩니다.</font>

929
00:31:44,019 --> 00:31:46,400
You know, we don't even have to return it in a certain way.

930
00:31:44,019 --> 00:31:46,400
<font color="#ffff54">특정 방식으로 반환할 필요도 없습니다.</font>

931
00:31:46,400 --> 00:31:48,480
Just print it in stdout.

932
00:31:46,400 --> 00:31:48,480
<font color="#ffff54">그냥 출력하면 돼요.</font>

933
00:31:48,480 --> 00:31:50,180
That's all we need to do.

934
00:31:48,480 --> 00:31:50,180
<font color="#ffff54">그게 우리가 해야 할 전부입니다.</font>

935
00:31:50,180 --> 00:31:52,400
So we're doing a print right now.

936
00:31:50,180 --> 00:31:52,400
<font color="#ffff54">그래서 지금 인쇄를 하고 있습니다.</font>

937
00:31:52,400 --> 00:31:57,940
That's the result that the container runtime will capture and say, hey, well, now that's

938
00:31:52,400 --> 00:31:57,940
<font color="#ffff54">이것이 컨테이너 런타임이 캡처한 결과입니다.</font>

939
00:31:57,940 --> 00:32:00,240
a success.

940
00:31:57,940 --> 00:32:00,240
<font color="#ffff54">성공입니다.</font>

941
00:32:00,240 --> 00:32:01,440
You see?

942
00:32:00,240 --> 00:32:01,440
<font color="#ffff54">봤지?</font>

943
00:32:01,440 --> 00:32:02,440
Very basic.

944
00:32:01,440 --> 00:32:02,440
<font color="#ffff54">아주 기본이죠.</font>

945
00:32:02,440 --> 00:32:05,039
Again, this is a very basic container.

946
00:32:02,440 --> 00:32:05,039
<font color="#ffff54">다시 말하지만, 이것은 매우 기본적인 컨테이너입니다.</font>

947
00:32:05,039 --> 00:32:06,039
Yeah.

948
00:32:05,039 --> 00:32:06,039
<font color="#ffff54">그렇군요.</font>

949
00:32:06,039 --> 00:32:07,039
Good question.

950
00:32:06,039 --> 00:32:07,039
<font color="#ffff54">좋은 질문이야.</font>

951
00:32:07,039 --> 00:32:08,039
Good question.

952
00:32:07,039 --> 00:32:08,039
<font color="#ffff54">좋은 질문입니다.</font>

953
00:32:08,039 --> 00:32:29,720
So the question is how we got the POD CRDR and why it's not part of the environment variable.

954
00:32:08,039 --> 00:32:29,720
<font color="#ffff54">문제는 POD CRDR을 어떻게 얻었는지, 그리고 왜 환경 변수의 일부가 아닌지입니다.</font>

955
00:32:29,720 --> 00:32:33,480
The POD CRDR, this is not part of the spec, right?

956
00:32:29,720 --> 00:32:33,480
<font color="#ffff54">POD CRDR, 이건 사양의 일부가 아니죠?</font>

957
00:32:33,480 --> 00:32:37,920
This is basically the spec defines the way to wire a certain POD.

958
00:32:33,480 --> 00:32:37,920
<font color="#ffff54">이것은 기본적으로 특정 POD를 배선하는 방법을 정의하는 사양입니다.</font>

959
00:32:37,920 --> 00:32:40,960
It doesn't do it in the context of Kubernetes.

960
00:32:37,920 --> 00:32:40,960
<font color="#ffff54">쿠버네티스 컨텍스트에서는 이 작업을 수행하지 않는다.</font>

961
00:32:40,960 --> 00:32:47,039
The POD CRDR in this case is very much tied to the POD CRDR of a node and that's why we

962
00:32:40,960 --> 00:32:47,039
<font color="#ffff54">이 경우의 POD CRDR은 노드의 POD CRDR과 매우 밀접하게 연결되어 있기 때문에</font>

963
00:32:47,039 --> 00:32:51,920
have to pass it through the configuration and not through an environment variable.

964
00:32:47,039 --> 00:32:51,920
<font color="#ffff54">를 환경 변수가 아닌 구성을 통해 전달해야 한다.</font>

965
00:32:51,920 --> 00:32:53,920
That's basically the result.

966
00:32:51,920 --> 00:32:53,920
<font color="#ffff54">이것이 기본적으로 결과입니다.</font>

967
00:32:53,920 --> 00:32:54,920
Okay?

968
00:32:53,920 --> 00:32:54,920
<font color="#ffff54">알겠지?</font>

969
00:32:54,920 --> 00:32:55,920
Awesome.

970
00:32:54,920 --> 00:32:55,920
<font color="#ffff54">굉장해.</font>

971
00:32:55,920 --> 00:32:56,920
So good.

972
00:32:55,920 --> 00:32:56,920
<font color="#ffff54">너무 좋다.</font>

973
00:32:56,920 --> 00:33:02,079
The last thing we have to do here is to define the DELL, the delete command.

974
00:32:56,920 --> 00:33:02,079
<font color="#ffff54">여기서 마지막으로 해야 할 일은 삭제 명령어인 DELL을 정의하는 것입니다.</font>

975
00:33:02,080 --> 00:33:09,140
And you guys are going to see it's very hard, very complicated code to add the deletes.

976
00:33:02,080 --> 00:33:09,140
<font color="#ffff54">이제 삭제 기능을 추가하는 코드가 매우 어렵고 복잡하다는 것을 알게 될 것입니다.</font>

977
00:33:09,140 --> 00:33:13,480
So copy the delete code, refresh.

978
00:33:09,140 --> 00:33:13,480
<font color="#ffff54">삭제 코드를 복사하고 새로고침하세요.</font>

979
00:33:13,480 --> 00:33:14,480
There you go.

980
00:33:13,480 --> 00:33:14,480
<font color="#ffff54">이제 됐어요.</font>

981
00:33:14,480 --> 00:33:15,480
Very complicated code.

982
00:33:14,480 --> 00:33:15,480
<font color="#ffff54">매우 복잡한 코드입니다.</font>

983
00:33:15,480 --> 00:33:16,480
Okay.

984
00:33:15,480 --> 00:33:16,480
<font color="#ffff54">오케이.</font>

985
00:33:16,480 --> 00:33:23,080
That's all we have to do to delete a network namespace in this case, you know, removing

986
00:33:16,480 --> 00:33:23,080
<font color="#ffff54">이 경우 네트워크 네임스페이스를 삭제하기 위해 해야 할 일은 다음과 같습니다.</font>

987
00:33:23,080 --> 00:33:24,080
the POD.

988
00:33:23,080 --> 00:33:24,080
<font color="#ffff54">POD를 제거하면 됩니다.</font>

989
00:33:24,080 --> 00:33:29,240
It's just going to go and remove the certain network namespace on that path.

990
00:33:24,080 --> 00:33:29,240
<font color="#ffff54">해당 경로의 특정 네트워크 네임스페이스를 제거합니다.</font>

991
00:33:29,240 --> 00:33:31,680
Very simple.

992
00:33:29,240 --> 00:33:31,680
<font color="#ffff54">아주 간단합니다.</font>

993
00:33:31,680 --> 00:33:33,240
We don't have to define the check.

994
00:33:31,680 --> 00:33:33,240
<font color="#ffff54">수표를 정의할 필요가 없습니다.</font>

995
00:33:33,240 --> 00:33:36,779
The version we're just going to return basically which kind of CNI version we're using in this

996
00:33:33,240 --> 00:33:36,779
<font color="#ffff54">여기서 반환할 버전은 기본적으로 어떤 종류의 CNI 버전을 사용하고 있는지를 반환합니다.</font>

997
00:33:36,779 --> 00:33:39,360
case, which kind of spec.

998
00:33:36,779 --> 00:33:39,360
<font color="#ffff54">경우, 어떤 사양인지 반환합니다.</font>

999
00:33:39,360 --> 00:33:44,840
In this case, we're using 1.0.0, but this code is compatible with multiple versions.

1000
00:33:39,360 --> 00:33:44,840
<font color="#ffff54">이 경우 1.0.0을 사용하고 있지만 이 코드는 여러 버전과 호환됩니다.</font>

1001
00:33:44,840 --> 00:33:50,720
All the, you know, we're not doing anything complicated, so basically we have very much

1002
00:33:44,840 --> 00:33:50,720
<font color="#ffff54">알다시피, 우리는 복잡한 작업을 하고 있지 않으므로 기본적으로 우리는 매우 많은</font>

1003
00:33:50,720 --> 00:33:52,759
compatibility with everything.

1004
00:33:50,720 --> 00:33:52,759
<font color="#ffff54">모든 것과 호환됩니다.</font>

1005
00:33:52,759 --> 00:33:53,799
Amazing.

1006
00:33:52,759 --> 00:33:53,799
<font color="#ffff54">놀랍다.</font>

1007
00:33:53,799 --> 00:33:55,920
You guys ready to see that in action?

1008
00:33:53,799 --> 00:33:55,920
<font color="#ffff54">실제로 볼 준비가 되셨나요?</font>

1009
00:33:55,920 --> 00:33:59,920
I don't want to see some excitement.

1010
00:33:55,920 --> 00:33:59,920
<font color="#ffff54">흥분되는 걸 보고 싶지 않아.</font>

1011
00:33:59,920 --> 00:34:01,320
All right.

1012
00:33:59,920 --> 00:34:01,320
<font color="#ffff54">알았어.</font>

1013
00:34:01,960 --> 00:34:02,960
Okay.

1014
00:34:01,960 --> 00:34:02,960
<font color="#ffff54">알았어</font>

1015
00:34:02,960 --> 00:34:09,400
So before we get there, let's actually talk about the good point that our friend asked

1016
00:34:02,960 --> 00:34:09,400
<font color="#ffff54">그 전에 친구가 물어본 좋은 점에 대해 실제로 이야기해 봅시다.</font>

1017
00:34:09,400 --> 00:34:16,219
here is basically how to pass this POD CIDR information.

1018
00:34:09,400 --> 00:34:16,219
<font color="#ffff54">기본적으로 이 POD CIDR 정보를 전달하는 방법은 다음과 같습니다.</font>

1019
00:34:16,219 --> 00:34:22,799
In this case, I'm putting that directly here, 10.0.0.24.

1020
00:34:16,219 --> 00:34:22,799
<font color="#ffff54">이 경우에는 10.0.0.24를 바로 여기에 넣습니다.</font>

1021
00:34:22,799 --> 00:34:23,799
Why?

1022
00:34:22,799 --> 00:34:23,799
<font color="#ffff54">왜?</font>

1023
00:34:23,799 --> 00:34:28,559
Just because I also controlled the POD CIDR during the installation itself.

1024
00:34:23,799 --> 00:34:28,559
<font color="#ffff54">설치하는 동안 POD CIDR도 제어했기 때문입니다.</font>

1025
00:34:28,799 --> 00:34:29,799
Right.

1026
00:34:28,799 --> 00:34:29,799
<font color="#ffff54">맞아요.</font>

1027
00:34:29,799 --> 00:34:36,440
I passed the same version, so I kind of guessed what kind of version I need in my CNI.

1028
00:34:29,799 --> 00:34:36,440
<font color="#ffff54">같은 버전을 통과했으니 CNI에 어떤 버전이 필요한지 어느 정도 짐작이 갑니다.</font>

1029
00:34:36,440 --> 00:34:37,579
This is not common.

1030
00:34:36,440 --> 00:34:37,579
<font color="#ffff54">이런 경우는 흔하지 않습니다.</font>

1031
00:34:37,579 --> 00:34:38,579
This is not...

1032
00:34:37,579 --> 00:34:38,579
<font color="#ffff54">이것은...</font>

1033
00:34:38,579 --> 00:34:40,460
In real world, this doesn't work like this.

1034
00:34:38,579 --> 00:34:40,460
<font color="#ffff54">현실에서는 이렇게 작동하지 않습니다.</font>

1035
00:34:40,460 --> 00:34:45,599
In the real world, you will need to create a certain process that goes and read, you

1036
00:34:40,460 --> 00:34:45,599
<font color="#ffff54">현실 세계에서는 다음과 같은 특정 프로세스를 만들어서 읽어야 합니다.</font>

1037
00:34:45,599 --> 00:34:50,239
know, calls the Kube API, get the POD...

1038
00:34:45,599 --> 00:34:50,239
<font color="#ffff54">알고, Kube API를 호출하고, POD를 가져오고...</font>

1039
00:34:50,239 --> 00:34:51,679
You're going to need to do this.

1040
00:34:50,239 --> 00:34:51,679
<font color="#ffff54">이 작업을 수행해야 합니다.</font>

1041
00:34:51,679 --> 00:34:52,679
Look.

1042
00:34:51,679 --> 00:34:52,679
<font color="#ffff54">보세요.</font>

1043
00:34:52,679 --> 00:34:57,159
If I take a look at my node...

1044
00:34:52,679 --> 00:34:57,159
<font color="#ffff54">내 노드를 보면...</font>

1045
00:34:57,159 --> 00:34:58,159
It's very small actually.

1046
00:34:57,159 --> 00:34:58,159
<font color="#ffff54">사실 아주 작네요.</font>

1047
00:34:58,259 --> 00:35:00,679
I think I should zoom in.

1048
00:34:58,259 --> 00:35:00,679
<font color="#ffff54">확대해야 할 것 같아.</font>

1049
00:35:00,679 --> 00:35:01,679
So if I do...

1050
00:35:00,679 --> 00:35:01,679
<font color="#ffff54">그럼...</font>

1051
00:35:01,679 --> 00:35:08,519
Maybe I zoom in more.

1052
00:35:01,679 --> 00:35:08,519
<font color="#ffff54">더 확대해야겠어.</font>

1053
00:35:08,519 --> 00:35:16,379
So if I do K get node, so K for kubectl get node, and take a look at what I have, I have

1054
00:35:08,519 --> 00:35:16,379
<font color="#ffff54">그래서 내가 K가 노드를 얻고, 그래서 kubectl이 노드를 얻고, 내가 가진 것을 살펴보면 다음과 같다.</font>

1055
00:35:16,379 --> 00:35:17,379
only one node.

1056
00:35:16,379 --> 00:35:17,379
<font color="#ffff54">노드가 하나뿐이다.</font>

1057
00:35:17,379 --> 00:35:19,639
Again, it's a single node, Kubernetes cluster in this case.

1058
00:35:17,379 --> 00:35:19,639
<font color="#ffff54">다시 말하지만, 이 경우에는 단일 노드인 쿠버네티스 클러스터입니다.</font>

1059
00:35:19,920 --> 00:35:28,079
And if I take a look and do a dash o yaml, then I'll see, like if I scroll up...

1060
00:35:19,920 --> 00:35:28,079
<font color="#ffff54">그리고 대시 오얌을 실행해서 보면, 스크롤을 위로 올리면...</font>

1061
00:35:28,079 --> 00:35:30,719
There you go.

1062
00:35:28,079 --> 00:35:30,719
<font color="#ffff54">여기 있네요.</font>

1063
00:35:30,719 --> 00:35:31,719
You see?

1064
00:35:30,719 --> 00:35:31,719
<font color="#ffff54">봤지?</font>

1065
00:35:31,719 --> 00:35:36,059
The POD CIDR, that's the one I actually just put statically in my configuration file that

1066
00:35:31,719 --> 00:35:36,059
<font color="#ffff54">POD CIDR은 실제로 내 구성 파일에 정적으로 넣은 것이다.</font>

1067
00:35:36,059 --> 00:35:37,799
I'm going to use as an example.

1068
00:35:36,059 --> 00:35:37,799
<font color="#ffff54">예시로 사용하겠습니다.</font>

1069
00:35:37,799 --> 00:35:39,279
But this process is not like that.

1070
00:35:37,799 --> 00:35:39,279
<font color="#ffff54">하지만 이 과정은 그렇지 않습니다.</font>

1071
00:35:39,279 --> 00:35:44,279
You know, if you want to use a real use case, you want to create a mechanism that goes and

1072
00:35:39,279 --> 00:35:44,279
<font color="#ffff54">실제 사용 사례를 사용하려면 다음과 같은 메커니즘을 만들어야 합니다.</font>

1073
00:35:44,280 --> 00:35:49,880
rediscriminates this API, get this address, put it in the template of the configuration

1074
00:35:44,280 --> 00:35:49,880
<font color="#ffff54">이 API를 재차별하고, 이 주소를 가져와서 구성의 템플릿에 넣습니다.</font>

1075
00:35:49,880 --> 00:35:52,640
file that's going to be set on the host.

1076
00:35:49,880 --> 00:35:52,640
<font color="#ffff54">파일을 호스트에 설정합니다.</font>

1077
00:35:52,640 --> 00:35:56,160
So going back to our example.

1078
00:35:52,640 --> 00:35:56,160
<font color="#ffff54">예제로 돌아가서</font>

1079
00:35:56,160 --> 00:35:57,580
So we have the binary now.

1080
00:35:56,160 --> 00:35:57,580
<font color="#ffff54">이제 바이너리가 생겼습니다.</font>

1081
00:35:57,580 --> 00:35:58,580
We're good there.

1082
00:35:57,580 --> 00:35:58,580
<font color="#ffff54">이제 됐어요.</font>

1083
00:35:58,580 --> 00:36:01,240
We're going to create the configuration file.

1084
00:35:58,580 --> 00:36:01,240
<font color="#ffff54">구성 파일을 생성하겠습니다.</font>

1085
00:36:01,240 --> 00:36:02,240
It's very basic.

1086
00:36:01,240 --> 00:36:02,240
<font color="#ffff54">아주 기본적인 내용입니다.</font>

1087
00:36:02,240 --> 00:36:05,720
You see the configuration file for us, the network configuration?

1088
00:36:02,240 --> 00:36:05,720
<font color="#ffff54">네트워크 구성 파일이 보이시죠?</font>

1089
00:36:05,720 --> 00:36:07,440
Very, very basic.

1090
00:36:05,720 --> 00:36:07,440
<font color="#ffff54">아주, 아주 기본이죠.</font>

1091
00:36:07,440 --> 00:36:10,360
We are just putting the CNI version.

1092
00:36:07,440 --> 00:36:10,360
<font color="#ffff54">CNI 버전을 넣는 중입니다.</font>

1093
00:36:10,360 --> 00:36:15,019
We're going to put the type, which is, again, it's the binary name in our case.

1094
00:36:10,360 --> 00:36:15,019
<font color="#ffff54">유형을 넣겠습니다. 이 경우에는 다시 바이너리 이름입니다.</font>

1095
00:36:15,019 --> 00:36:19,599
And we are putting the POD CIDR that I just showed you right now through Kubernetes.

1096
00:36:15,019 --> 00:36:19,599
<font color="#ffff54">그리고 쿠버네티스를 통해 방금 보여드린 POD CIDR을 넣습니다.</font>

1097
00:36:19,599 --> 00:36:20,599
Right?

1098
00:36:19,599 --> 00:36:20,599
<font color="#ffff54">그렇죠?</font>

1099
00:36:20,599 --> 00:36:21,599
That's it.

1100
00:36:20,599 --> 00:36:21,599
<font color="#ffff54">그거예요.</font>

1101
00:36:21,599 --> 00:36:22,599
All right.

1102
00:36:21,599 --> 00:36:22,599
<font color="#ffff54">끝났어요.</font>

1103
00:36:22,599 --> 00:36:25,400
Let's try it.

1104
00:36:22,599 --> 00:36:25,400
<font color="#ffff54">해봅시다.</font>

1105
00:36:25,400 --> 00:36:28,400
If we run this...

1106
00:36:25,400 --> 00:36:28,400
<font color="#ffff54">이걸 실행하면...</font>

1107
00:36:28,400 --> 00:36:31,320
So in this case, I just created two more PODs.

1108
00:36:28,400 --> 00:36:31,320
<font color="#ffff54">이 경우, 방금 두 개의 POD를 더 생성했습니다.</font>

1109
00:36:31,320 --> 00:36:35,800
Okay, just to demonstrate that this thing is broken still very much.

1110
00:36:31,320 --> 00:36:35,800
<font color="#ffff54">좋아, 이게 여전히 많이 망가졌다는 것을 보여주기 위해서.</font>

1111
00:36:35,800 --> 00:36:45,240
So right now, I have two PODs impending my HTTP bin service or POD here is impending.

1112
00:36:35,800 --> 00:36:45,240
<font color="#ffff54">지금 내 HTTP 빈 서비스에 두 개의 POD가 임박했거나 여기 POD가 임박했습니다.</font>

1113
00:36:45,240 --> 00:36:48,120
The sleep one, two, and this coordinates once.

1114
00:36:45,240 --> 00:36:48,120
<font color="#ffff54">수면 1, 2와 이 좌표가 한 번 일치합니다.</font>

1115
00:36:48,120 --> 00:36:51,320
But basically, yeah, I don't have a CNI yet.

1116
00:36:48,120 --> 00:36:51,320
<font color="#ffff54">하지만 기본적으로, 네, 아직 CNI가 없습니다.</font>

1117
00:36:51,320 --> 00:36:53,500
Let's fix this.

1118
00:36:51,320 --> 00:36:53,500
<font color="#ffff54">이걸 고치자.</font>

1119
00:36:53,500 --> 00:36:58,519
What you have to do is just to copy again, I talked about kind of the default where you

1120
00:36:53,500 --> 00:36:58,519
<font color="#ffff54">당신이 해야 할 일은 다시 복사하는 것뿐입니다. 나는 일종의 기본값에 대해 이야기했습니다.</font>

1121
00:36:58,519 --> 00:37:01,120
need to put the configuration.

1122
00:36:58,519 --> 00:37:01,120
<font color="#ffff54">구성을 넣어야 합니다.</font>

1123
00:37:01,119 --> 00:37:09,039
We're going to put our binary, our bash script we've just created under slash opt cni bin.

1124
00:37:01,119 --> 00:37:09,039
<font color="#ffff54">바이너리, 즉 방금 만든 bash 스크립트를 슬래시 옵트 cni bin에 넣겠습니다.</font>

1125
00:37:09,039 --> 00:37:13,199
And I'm going to put the configuration that we just wrote right now, again, under the

1126
00:37:09,039 --> 00:37:13,199
<font color="#ffff54">그리고 지금 방금 작성한 구성을 다시 한 번</font>

1127
00:37:13,199 --> 00:37:17,400
default slash etc cni netd.

1128
00:37:13,199 --> 00:37:17,400
<font color="#ffff54">기본 슬래시 등 CNI NETD.</font>

1129
00:37:17,400 --> 00:37:20,179
Let's do this.

1130
00:37:17,400 --> 00:37:20,179
<font color="#ffff54">해봅시다.</font>

1131
00:37:20,179 --> 00:37:22,599
Wait for it.

1132
00:37:20,179 --> 00:37:22,599
<font color="#ffff54">기다려봐.</font>

1133
00:37:22,599 --> 00:37:28,759
And then give it a couple seconds.

1134
00:37:22,599 --> 00:37:28,759
<font color="#ffff54">몇 초만 기다려주세요.</font>

1135
00:37:28,760 --> 00:37:31,480
More.

1136
00:37:28,760 --> 00:37:31,480
<font color="#ffff54">더.</font>

1137
00:37:31,480 --> 00:37:34,640
Okay.

1138
00:37:31,480 --> 00:37:34,640
<font color="#ffff54">오케이.</font>

1139
00:37:34,640 --> 00:37:41,080
How long am I going to have to wait here?

1140
00:37:34,640 --> 00:37:41,080
<font color="#ffff54">여기서 얼마나 더 기다려야 하나요?</font>

1141
00:37:41,080 --> 00:37:45,800
I should probably do that.

1142
00:37:41,080 --> 00:37:45,800
<font color="#ffff54">그래야겠어.</font>

1143
00:37:45,800 --> 00:37:51,280
I don't think it's erred.

1144
00:37:45,800 --> 00:37:51,280
<font color="#ffff54">틀린 것 같지 않아요.</font>

1145
00:37:51,280 --> 00:37:54,840
Kind of control all the code here.

1146
00:37:51,280 --> 00:37:54,840
<font color="#ffff54">여기 모든 코드를 제어하는 것 같네요.</font>

1147
00:37:54,840 --> 00:37:56,840
What would I err?

1148
00:37:54,840 --> 00:37:56,840
<font color="#ffff54">내가 뭘 잘못했지?</font>

1149
00:37:56,840 --> 00:37:58,840
Did I?

1150
00:37:56,840 --> 00:37:58,840
<font color="#ffff54">내가 실수했나?</font>

1151
00:37:58,840 --> 00:38:00,559
Wait a second.

1152
00:37:58,840 --> 00:38:00,559
<font color="#ffff54">잠깐만요.</font>

1153
00:38:00,559 --> 00:38:04,960
So what do we have here?

1154
00:38:00,559 --> 00:38:04,960
<font color="#ffff54">이게 뭐지?</font>

1155
00:38:04,960 --> 00:38:08,400
We did the modification of the POD.

1156
00:38:04,960 --> 00:38:08,400
<font color="#ffff54">POD를 수정했습니다.</font>

1157
00:38:08,400 --> 00:38:10,400
Take a look.

1158
00:38:08,400 --> 00:38:10,400
<font color="#ffff54">보세요.</font>

1159
00:38:10,400 --> 00:38:12,400
Cop.

1160
00:38:10,400 --> 00:38:12,400
<font color="#ffff54">Cop.</font>

1161
00:38:12,400 --> 00:38:16,760
Oh, there you go.

1162
00:38:12,400 --> 00:38:16,760
<font color="#ffff54">여기 있네요.</font>

1163
00:38:16,760 --> 00:38:20,800
What's going on?

1164
00:38:16,760 --> 00:38:20,800
<font color="#ffff54">무슨 일이야?</font>

1165
00:38:20,800 --> 00:38:26,760
Oh, there you go.

1166
00:38:20,800 --> 00:38:26,760
<font color="#ffff54">여기 있네.</font>

1167
00:38:26,760 --> 00:38:33,680
What's going on here?

1168
00:38:26,760 --> 00:38:33,680
<font color="#ffff54">무슨 일이야?</font>

1169
00:38:33,680 --> 00:38:43,760
Do I have like, let's just force the deletion just to kind of force cube.

1170
00:38:33,680 --> 00:38:43,760
<font color="#ffff54">그냥 강제 삭제를 해버려야 할까요?</font>

1171
00:38:43,760 --> 00:38:49,720
What is that?

1172
00:38:43,760 --> 00:38:49,720
<font color="#ffff54">저게 뭐야?</font>

1173
00:38:49,720 --> 00:38:58,880
Get what is that?

1174
00:38:49,720 --> 00:38:58,880
<font color="#ffff54">저게 뭔지 알아?</font>

1175
00:38:58,880 --> 00:38:59,880
After the copy?

1176
00:38:58,880 --> 00:38:59,880
<font color="#ffff54">복사 다음에?</font>

1177
00:38:59,880 --> 00:39:02,280
Yeah, I mean, yeah, the copy.

1178
00:38:59,880 --> 00:39:02,280
<font color="#ffff54">네, 네, 네, 복사본이요.</font>

1179
00:39:02,280 --> 00:39:03,280
I don't know.

1180
00:39:02,280 --> 00:39:03,280
<font color="#ffff54">모르겠어.</font>

1181
00:39:03,280 --> 00:39:06,920
Let's see.

1182
00:39:03,280 --> 00:39:06,920
<font color="#ffff54">어디 보자.</font>

1183
00:39:06,920 --> 00:39:17,400
I'm just going to force the recreation of the PODs.

1184
00:39:06,920 --> 00:39:17,400
<font color="#ffff54">POD를 강제로 재생성해볼게요.</font>

1185
00:39:17,400 --> 00:39:18,400
Pending still.

1186
00:39:17,400 --> 00:39:18,400
<font color="#ffff54">아직 대기 중입니다.</font>

1187
00:39:18,400 --> 00:39:19,400
What's going on?

1188
00:39:18,400 --> 00:39:19,400
<font color="#ffff54">무슨 일이야?</font>

1189
00:39:19,400 --> 00:39:23,280
Sorry, let me double check.

1190
00:39:19,400 --> 00:39:23,280
<font color="#ffff54">죄송합니다, 다시 확인하겠습니다.</font>

1191
00:39:23,280 --> 00:39:25,280
Okay.

1192
00:39:23,280 --> 00:39:25,280
<font color="#ffff54">알았어요.</font>

1193
00:39:25,280 --> 00:39:27,280
Describe.

1194
00:39:25,280 --> 00:39:27,280
<font color="#ffff54">설명해줘.</font>

1195
00:39:27,280 --> 00:39:29,280
Yeah.

1196
00:39:27,280 --> 00:39:29,280
<font color="#ffff54">예</font>

1197
00:39:29,280 --> 00:39:43,800
Oh, okay, okay, okay.

1198
00:39:29,280 --> 00:39:43,800
<font color="#ffff54">알았어, 알았어, 알았어.</font>

1199
00:39:43,800 --> 00:39:48,559
Why this is not...

1200
00:39:43,800 --> 00:39:48,559
<font color="#ffff54">이게 왜...</font>

1201
00:39:48,559 --> 00:39:53,480
I did, I put the, yeah.

1202
00:39:48,559 --> 00:39:53,480
<font color="#ffff54">내가 했어, 내가 넣었어.</font>

1203
00:39:53,480 --> 00:39:55,119
This was int-tainted anyway.

1204
00:39:53,480 --> 00:39:55,119
<font color="#ffff54">어차피 오염됐어.</font>

1205
00:39:55,119 --> 00:39:58,119
That's crazy.

1206
00:39:55,119 --> 00:39:58,119
<font color="#ffff54">미치겠네.</font>

1207
00:39:58,119 --> 00:40:12,119
No, I needed to remove the taint for me to schedule the PODs on the master node.

1208
00:39:58,119 --> 00:40:12,119
<font color="#ffff54">아니요, 마스터 노드에서 POD를 스케줄링하려면 오염을 제거해야 합니다.</font>

1209
00:40:12,119 --> 00:40:16,039
But the taints are not there anymore because it scheduled, actually it scheduled the two

1210
00:40:12,119 --> 00:40:16,039
<font color="#ffff54">그러나 테인트는 더 이상 존재하지 않습니다.</font>

1211
00:40:16,039 --> 00:40:17,039
PODs.

1212
00:40:16,039 --> 00:40:17,039
<font color="#ffff54">POD.</font>

1213
00:40:17,039 --> 00:40:18,519
Where is it going on here?

1214
00:40:17,039 --> 00:40:18,519
<font color="#ffff54">무슨 일이야?</font>

1215
00:40:18,519 --> 00:40:19,519
What's going on?

1216
00:40:18,519 --> 00:40:19,519
<font color="#ffff54">무슨 일이야?</font>

1217
00:40:19,519 --> 00:40:21,159
Let's see, let's see, let's see.

1218
00:40:19,519 --> 00:40:21,159
<font color="#ffff54">어디 보자, 어디 보자, 어디 보자.</font>

1219
00:40:21,159 --> 00:40:23,920
Did I miss something else?

1220
00:40:21,159 --> 00:40:23,920
<font color="#ffff54">내가 뭘 놓쳤나?</font>

1221
00:40:23,920 --> 00:40:25,920
Oops.

1222
00:40:23,920 --> 00:40:25,920
<font color="#ffff54">이런.</font>

1223
00:40:25,920 --> 00:40:34,280
What is that?

1224
00:40:25,920 --> 00:40:34,280
<font color="#ffff54">저게 뭐지?</font>

1225
00:40:34,280 --> 00:40:36,280
The node is not ready?

1226
00:40:34,280 --> 00:40:36,280
<font color="#ffff54">노드가 준비되지 않았나요?</font>

1227
00:40:36,280 --> 00:40:39,039
Oh, yeah.

1228
00:40:36,280 --> 00:40:39,039
<font color="#ffff54">아, 그렇군요.</font>

1229
00:40:39,039 --> 00:40:48,079
Yeah, I mean, the node is not ready because the CNI is not there.

1230
00:40:39,039 --> 00:40:48,079
<font color="#ffff54">네, CNI가 없어서 노드가 준비되지 않았어요.</font>

1231
00:40:48,079 --> 00:40:51,360
Once the CNI is installed, it's going to put it back to ready.

1232
00:40:48,079 --> 00:40:51,360
<font color="#ffff54">CNI가 설치되면 다시 준비 상태로 돌아갑니다.</font>

1233
00:40:51,360 --> 00:40:55,679
Okay, what's happening here?

1234
00:40:51,360 --> 00:40:55,679
<font color="#ffff54">좋아, 무슨 일이야?</font>

1235
00:40:55,679 --> 00:40:59,519
Yeah, I did.

1236
00:40:55,679 --> 00:40:59,519
<font color="#ffff54">그래, 그랬어.</font>

1237
00:40:59,519 --> 00:41:02,639
Okay, look, let's do this.

1238
00:40:59,519 --> 00:41:02,639
<font color="#ffff54">좋아, 해보자.</font>

1239
00:41:02,639 --> 00:41:03,639
So not block on this.

1240
00:41:02,639 --> 00:41:03,639
<font color="#ffff54">차단하지 마세요.</font>

1241
00:41:03,639 --> 00:41:06,360
I'm going to get to that in a second.

1242
00:41:03,639 --> 00:41:06,360
<font color="#ffff54">잠깐만 기다려봐.</font>

1243
00:41:06,360 --> 00:41:11,079
I'm going to go back to do the command quickly, just creating a new environment quick, you

1244
00:41:06,360 --> 00:41:11,079
<font color="#ffff54">다시 돌아가서 명령을 빠르게 수행하겠습니다. 새 환경을 빠르게 생성합니다.</font>

1245
00:41:11,079 --> 00:41:15,960
know, to not be blocked on, like try to debug this live because it's not going to happen.

1246
00:41:11,079 --> 00:41:15,960
<font color="#ffff54">차단되지 않도록, 예를 들어 이걸 실시간으로 디버깅하려고 하면 안 되니까요.</font>

1247
00:41:15,960 --> 00:41:19,840
But question, do you guys have the PODs container running?

1248
00:41:15,960 --> 00:41:19,840
<font color="#ffff54">근데 질문이 있는데요, POD 컨테이너를 실행하고 있나요?</font>

1249
00:41:19,840 --> 00:41:21,920
Okay, that's what matters.

1250
00:41:19,840 --> 00:41:21,920
<font color="#ffff54">좋아, 그게 중요해.</font>

1251
00:41:21,920 --> 00:41:23,240
I did that already.

1252
00:41:21,920 --> 00:41:23,240
<font color="#ffff54">이미 했어.</font>

1253
00:41:23,240 --> 00:41:24,880
Meant to both times.

1254
00:41:23,240 --> 00:41:24,880
<font color="#ffff54">두 번 모두.</font>

1255
00:41:24,880 --> 00:41:29,920
So what we are going to do, I think the way I'm going to do it to kind of simplify this,

1256
00:41:24,880 --> 00:41:29,920
<font color="#ffff54">그래서 우리가 할 일은, 이걸 좀 더 단순화하기 위해 할 것 같아요,</font>

1257
00:41:29,920 --> 00:41:32,659
now that PODs are running and all this, that's awesome.

1258
00:41:29,920 --> 00:41:32,659
<font color="#ffff54">이제 POD가 실행되고 있으니 정말 멋지네요.</font>

1259
00:41:32,659 --> 00:41:43,159
So what I'm going to do this quickly is to create, let's go back to my exercise.

1260
00:41:32,659 --> 00:41:43,159
<font color="#ffff54">그럼 이제 다시 운동하러 가죠.</font>

1261
00:41:43,359 --> 00:41:53,359
I'm just going to start that on here and I'm going to catch up.

1262
00:41:43,359 --> 00:41:53,359
<font color="#ffff54">여기서부터 시작해서 따라잡을게요.</font>

1263
00:41:53,359 --> 00:41:57,399
Don't worry, we'll figure this out.

1264
00:41:53,359 --> 00:41:57,399
<font color="#ffff54">걱정 마, 우리가 알아서 할게.</font>

1265
00:41:57,399 --> 00:42:01,359
I have to dime the, should not debug live, never works.

1266
00:41:57,399 --> 00:42:01,359
<font color="#ffff54">라이브 디버깅을 하면 안 되는데, 절대 안 돼요.</font>

1267
00:42:01,359 --> 00:42:04,119
All right, let's go back to this.

1268
00:42:01,359 --> 00:42:04,119
<font color="#ffff54">좋아, 이걸로 돌아가자.</font>

1269
00:42:04,119 --> 00:42:05,119
Okay, awesome.

1270
00:42:04,119 --> 00:42:05,119
<font color="#ffff54">좋아, 멋지네.</font>

1271
00:42:05,119 --> 00:42:08,440
So again, let me know how many ones have that thing running.

1272
00:42:05,119 --> 00:42:08,440
<font color="#ffff54">다시 한 번, 몇 대가 작동하는지 알려줘.</font>

1273
00:42:08,440 --> 00:42:10,399
All right, that makes me happy.

1274
00:42:08,440 --> 00:42:10,399
<font color="#ffff54">좋아, 다행이네.</font>

1275
00:42:10,399 --> 00:42:13,119
That's all that matters.

1276
00:42:10,399 --> 00:42:13,119
<font color="#ffff54">그게 중요한 거야.</font>

1277
00:42:13,119 --> 00:42:16,920
So what we are going to do next is to talk about the next step from there.

1278
00:42:13,119 --> 00:42:16,920
<font color="#ffff54">이제부터는 다음 단계에 대해 이야기하겠습니다.</font>

1279
00:42:16,920 --> 00:42:26,880
So now we have the CNI being installed, the node is ready to take traffic, we have the

1280
00:42:16,920 --> 00:42:26,880
<font color="#ffff54">이제 CNI가 설치되었고, 노드가 트래픽을 받을 준비가 되었으니, 이제</font>

1281
00:42:26,880 --> 00:42:30,759
PODs networking figured out, that's great.

1282
00:42:26,880 --> 00:42:30,759
<font color="#ffff54">POD의 네트워킹을 알아냈군요, 잘됐네요.</font>

1283
00:42:30,759 --> 00:42:34,579
The step from there is, okay, let's talk about EPPF now.

1284
00:42:30,759 --> 00:42:34,579
<font color="#ffff54">다음 단계는 이제 EPPF에 대해 이야기해 봅시다.</font>

1285
00:42:34,579 --> 00:42:40,440
Let's talk about how we can improve certain things using EPPF.

1286
00:42:34,579 --> 00:42:40,440
<font color="#ffff54">EPPF를 사용하여 특정 사항을 개선할 수 있는 방법에 대해 이야기해 봅시다.</font>

1287
00:42:40,440 --> 00:42:43,019
So in our example, we did something very basic.

1288
00:42:40,440 --> 00:42:43,019
<font color="#ffff54">이 예제에서는 아주 기본적인 작업을 수행했습니다.</font>

1289
00:42:43,019 --> 00:42:44,880
We just created the interface.

1290
00:42:43,019 --> 00:42:44,880
<font color="#ffff54">방금 인터페이스를 만들었습니다.</font>

1291
00:42:44,880 --> 00:42:51,099
But what if I want to control this interface to, for example, monitor all the traffic going

1292
00:42:44,880 --> 00:42:51,099
<font color="#ffff54">하지만 이 인터페이스를 제어하여 예를 들어 다음과 같은 모든 트래픽을 모니터링하고 싶다면 어떻게 해야 할까요?</font>

1293
00:42:51,099 --> 00:42:57,099
through, or I want to secure the traffic that goes through that interface, right?

1294
00:42:51,099 --> 00:42:57,099
<font color="#ffff54">통과하는 모든 트래픽을 모니터링하거나 해당 인터페이스를 통과하는 트래픽을 보호하고 싶을 때 어떻게 해야 할까요?</font>

1295
00:42:57,099 --> 00:42:59,900
For this, we're going to use EPPF.

1296
00:42:57,099 --> 00:42:59,900
<font color="#ffff54">이를 위해 EPPF를 사용하겠습니다.</font>

1297
00:42:59,900 --> 00:43:03,460
By raising your hand here, who knows about EPPF in general?

1298
00:42:59,900 --> 00:43:03,460
<font color="#ffff54">EPPF에 대해 전반적으로 아는 사람 손들어 보세요.</font>

1299
00:43:03,460 --> 00:43:05,920
Okay, great, great.

1300
00:43:03,460 --> 00:43:05,920
<font color="#ffff54">좋아요, 좋아요.</font>

1301
00:43:05,920 --> 00:43:09,980
So who wrote an EPPF code before?

1302
00:43:05,920 --> 00:43:09,980
<font color="#ffff54">그럼 누가 전에 EPPF 코드를 작성했나요?</font>

1303
00:43:09,980 --> 00:43:11,980
What's that?

1304
00:43:09,980 --> 00:43:11,980
<font color="#ffff54">저게 뭐지?</font>

1305
00:43:12,940 --> 00:43:14,940
Yes, it's by definition.

1306
00:43:12,940 --> 00:43:14,940
<font color="#ffff54">네, 정의대로입니다.</font>

1307
00:43:14,940 --> 00:43:16,940
Okay, so we have a couple ones.

1308
00:43:14,940 --> 00:43:16,940
<font color="#ffff54">좋아요, 두 개가 있습니다.</font>

1309
00:43:16,940 --> 00:43:17,940
Awesome.

1310
00:43:16,940 --> 00:43:17,940
<font color="#ffff54">멋지다.</font>

1311
00:43:17,940 --> 00:43:18,940
All right.

1312
00:43:17,940 --> 00:43:18,940
<font color="#ffff54">알았어.</font>

1313
00:43:18,940 --> 00:43:23,500
So again, this is going to be very, very, very basic code, EPPF code.

1314
00:43:18,940 --> 00:43:23,500
<font color="#ffff54">다시 말하지만, 이것은 아주 아주 아주 기본적인 코드, EPPF 코드가 될 것입니다.</font>

1315
00:43:23,500 --> 00:43:24,500
So don't be scared.

1316
00:43:23,500 --> 00:43:24,500
<font color="#ffff54">그러니 겁내지 마세요.</font>

1317
00:43:24,500 --> 00:43:29,219
We have to write some code, but it's going to be very, very straightforward.

1318
00:43:24,500 --> 00:43:29,219
<font color="#ffff54">몇 가지 코드를 작성해야 하지만 아주 간단할 거예요.</font>

1319
00:43:29,219 --> 00:43:32,420
So EPPF, what it is.

1320
00:43:29,219 --> 00:43:32,420
<font color="#ffff54">EPPF가 뭐죠?</font>

1321
00:43:32,420 --> 00:43:36,380
We can think about EPPF, I'm probably going to skip this because I think it matters more

1322
00:43:32,420 --> 00:43:36,380
<font color="#ffff54">EPPF에 대해 생각해볼 수 있겠지만, 더 중요한 게 있다고 생각해서 생략할게요.</font>

1323
00:43:36,380 --> 00:43:38,059
to talk about this.

1324
00:43:36,380 --> 00:43:38,059
<font color="#ffff54">이 얘기를 하려고요.</font>

1325
00:43:38,059 --> 00:43:44,739
EPPF is, you can think about it as like a VM within the kernel, where you can run some

1326
00:43:38,059 --> 00:43:44,739
<font color="#ffff54">EPPF는 커널 내의 가상머신과 같다고 생각하면 된다.</font>

1327
00:43:44,739 --> 00:43:51,980
code that is very much, you know, in the sandbox that can do things for you, like it can attach

1328
00:43:44,739 --> 00:43:51,980
<font color="#ffff54">코드를 실행할 수 있는 샌드박스라고 생각하시면 됩니다.</font>

1329
00:43:51,980 --> 00:43:53,420
to certain hooks.

1330
00:43:51,980 --> 00:43:53,420
<font color="#ffff54">특정 후크에.</font>

1331
00:43:53,420 --> 00:43:55,099
So there's hooks for everything.

1332
00:43:53,420 --> 00:43:55,099
<font color="#ffff54">모든 것을 위한 후크가 있군요.</font>

1333
00:43:55,099 --> 00:43:56,980
There's hooks for networking.

1334
00:43:55,099 --> 00:43:56,980
<font color="#ffff54">네트워킹을 위한 후크가 있습니다.</font>

1335
00:43:56,980 --> 00:43:59,259
There's hooks for like file access.

1336
00:43:56,980 --> 00:43:59,259
<font color="#ffff54">파일 액세스와 같은 후크가 있습니다.</font>

1337
00:43:59,259 --> 00:44:02,940
Linux defines a lot of hooks for different things.

1338
00:43:59,259 --> 00:44:02,940
<font color="#ffff54">리눅스는 여러 가지를 위한 많은 훅을 정의합니다.</font>

1339
00:44:02,940 --> 00:44:07,380
And EPPF in our case, and here we're going to talk about networking mostly, we can attach

1340
00:44:02,940 --> 00:44:07,380
<font color="#ffff54">여기서는 주로 네트워킹에 대해 이야기할 것이고, 우리의 경우 EPPF를 첨부할 수 있습니다.</font>

1341
00:44:07,380 --> 00:44:12,700
a certain code, watching for a certain hook, and do something.

1342
00:44:07,380 --> 00:44:12,700
<font color="#ffff54">특정 코드를 붙이고, 특정 훅을 찾아서 뭔가를 하는 거죠.</font>

1343
00:44:12,700 --> 00:44:17,220
That's kind of the three parts of what we can do in EPPF.

1344
00:44:12,700 --> 00:44:17,220
<font color="#ffff54">이것이 EPPF에서 우리가 할 수 있는 일의 세 가지 부분입니다.</font>

1345
00:44:17,220 --> 00:44:24,019
Now the do something can be monitor the traffic, it can be secure the traffic, it can be detect

1346
00:44:17,220 --> 00:44:24,019
<font color="#ffff54">이제 트래픽을 모니터링하고, 트래픽을 보호하고, 트래픽을 탐지할 수 있습니다.</font>

1347
00:44:24,019 --> 00:44:28,940
anomalies, it can be a lot of things like this.

1348
00:44:24,019 --> 00:44:28,940
<font color="#ffff54">이상 징후 등 여러 가지가 있을 수 있습니다.</font>

1349
00:44:28,940 --> 00:44:36,980
So here is an example of, you know, if you look at the stack, there's multiple hooks,

1350
00:44:28,940 --> 00:44:36,980
<font color="#ffff54">다음은 스택을 보면 여러 개의 후크가 있는 예시입니다,</font>

1351
00:44:36,980 --> 00:44:40,699
oops, I'm going to put it on slideshow to go there.

1352
00:44:36,980 --> 00:44:40,699
<font color="#ffff54">웁스, 슬라이드쇼에 올려서 보여줄게요.</font>

1353
00:44:40,699 --> 00:44:47,659
If you look at, there's multiple hooks, you know, there's hooks under the lowest level

1354
00:44:40,699 --> 00:44:47,659
<font color="#ffff54">보시면, 여러 개의 후크가 있고, 가장 낮은 레벨 아래에 후크가 있습니다.</font>

1355
00:44:47,659 --> 00:44:49,260
is XDP.

1356
00:44:47,659 --> 00:44:49,260
<font color="#ffff54">는 XDP입니다.</font>

1357
00:44:49,260 --> 00:44:54,099
Okay, from there, there's hooks that goes to traffic control.

1358
00:44:49,260 --> 00:44:54,099
<font color="#ffff54">자, 거기서부터 트래픽 제어로 가는 후크가 있습니다.</font>

1359
00:44:54,099 --> 00:44:59,860
And there's all the way up some some BPF code that can watch for syscalls.

1360
00:44:54,099 --> 00:44:59,860
<font color="#ffff54">그리고 그 위쪽에는 시스템 호출을 감시하는 BPF 코드가 있습니다.</font>

1361
00:44:59,860 --> 00:45:02,980
Who knows here what's XDP or heard of before?

1362
00:44:59,860 --> 00:45:02,980
<font color="#ffff54">여기서 XDP가 뭔지 알거나 들어본 사람?</font>

1363
00:45:02,980 --> 00:45:05,059
Okay, a couple ones.

1364
00:45:02,980 --> 00:45:05,059
<font color="#ffff54">좋아요, 몇 개만요.</font>

1365
00:45:05,059 --> 00:45:06,059
All right.

1366
00:45:05,059 --> 00:45:06,059
<font color="#ffff54">알았어.</font>

1367
00:45:06,139 --> 00:45:11,019
XDP, you can think about it as way like, it's called Express Data Path.

1368
00:45:06,139 --> 00:45:11,019
<font color="#ffff54">XDP는 익스프레스 데이터 경로라고 생각하시면 됩니다.</font>

1369
00:45:11,019 --> 00:45:19,340
It's an EPPF, you know, it's an EPPF that allows you to basically, like, connect to

1370
00:45:11,019 --> 00:45:19,340
<font color="#ffff54">EPPF는 기본적으로 다음과 같이 연결할 수 있는 EPPF입니다.</font>

1371
00:45:19,340 --> 00:45:22,019
the lowest level level of your network.

1372
00:45:19,340 --> 00:45:22,019
<font color="#ffff54">네트워크의 가장 낮은 수준입니다.</font>

1373
00:45:22,019 --> 00:45:25,380
Okay, very, very low level.

1374
00:45:22,019 --> 00:45:25,380
<font color="#ffff54">좋아요, 아주 아주 낮은 수준입니다.</font>

1375
00:45:25,380 --> 00:45:32,299
The thing because it's low level, it is doesn't have much access to a lot of the data of the

1376
00:45:25,380 --> 00:45:32,299
<font color="#ffff54">낮은 레벨이기 때문에 많은 데이터에 액세스 할 수 없습니다.</font>

1377
00:45:32,299 --> 00:45:33,519
traffic.

1378
00:45:32,299 --> 00:45:33,519
<font color="#ffff54">트래픽.</font>

1379
00:45:33,519 --> 00:45:34,519
But it's very fast.

1380
00:45:33,519 --> 00:45:34,519
<font color="#ffff54">하지만 매우 빠릅니다.</font>

1381
00:45:34,519 --> 00:45:38,119
This is kind of the down the pros and cons.

1382
00:45:34,519 --> 00:45:38,119
<font color="#ffff54">이게 장단점이네요.</font>

1383
00:45:38,119 --> 00:45:44,119
The XDP allows us to do traffic shifting fast, rewriting a full packet, like for example,

1384
00:45:38,119 --> 00:45:44,119
<font color="#ffff54">XDP를 사용하면 예를 들어 전체 패킷을 재작성하는 등 트래픽 이동을 빠르게 수행할 수 있습니다,</font>

1385
00:45:44,119 --> 00:45:47,079
I want to load balance from from different points.

1386
00:45:44,119 --> 00:45:47,079
<font color="#ffff54">다른 지점에서 부하를 분산하고 싶습니다.</font>

1387
00:45:47,079 --> 00:45:50,199
I want to detect anomalies super fast.

1388
00:45:47,079 --> 00:45:50,199
<font color="#ffff54">이상 징후를 매우 빠르게 감지하고 싶습니다.</font>

1389
00:45:50,199 --> 00:45:52,400
I want to restrict traffic very fast.

1390
00:45:50,199 --> 00:45:52,400
<font color="#ffff54">트래픽을 매우 빠르게 제한하고 싶습니다.</font>

1391
00:45:52,400 --> 00:45:58,199
You know, I want to I want to build like, let's say, firewalls or someone.

1392
00:45:52,400 --> 00:45:58,199
<font color="#ffff54">방화벽 같은 걸 구축하고 싶어요.</font>

1393
00:45:58,199 --> 00:46:00,119
XDP is very good for that.

1394
00:45:58,199 --> 00:46:00,119
<font color="#ffff54">XDP는 그거에 아주 좋아요.</font>

1395
00:46:00,119 --> 00:46:03,199
TC is a little bit up the stack.

1396
00:46:00,119 --> 00:46:03,199
<font color="#ffff54">TC는 스택에서 약간 위쪽에 있습니다.</font>

1397
00:46:03,240 --> 00:46:07,240
TCs actually have more data around the packets.

1398
00:46:03,240 --> 00:46:07,240
<font color="#ffff54">TC는 실제로 패킷 주변에 더 많은 데이터를 가지고 있습니다.</font>

1399
00:46:07,240 --> 00:46:11,040
So you can do, you know, packet mingling, we can change ports, we can, you know, change

1400
00:46:07,240 --> 00:46:11,040
<font color="#ffff54">그래서 패킷 밍글링을 할 수 있고, 포트를 변경할 수 있고, 변경할 수 있습니다.</font>

1401
00:46:11,040 --> 00:46:15,560
the queue, we can, there's different things that we can do at the at the TC level.

1402
00:46:11,040 --> 00:46:15,560
<font color="#ffff54">대기열, TC 레벨에서 할 수 있는 다양한 일들이 있습니다.</font>

1403
00:46:15,560 --> 00:46:20,240
If you look at Selium, actually, Selium uses both.

1404
00:46:15,560 --> 00:46:20,240
<font color="#ffff54">셀리움을 보면, 사실 셀리움은 둘 다 사용합니다.</font>

1405
00:46:20,240 --> 00:46:26,720
Selium would use certain parts of the of the system in you know, using TC for control of

1406
00:46:20,240 --> 00:46:26,720
<font color="#ffff54">셀륨은 시스템의 특정 부분을 사용하는데, TC를 사용하여 다음을 제어합니다.</font>

1407
00:46:26,720 --> 00:46:33,560
like probably especially routing on ingress because TC can be routed, routing on egress

1408
00:46:26,720 --> 00:46:33,560
<font color="#ffff54">예를 들어 TC가 라우팅될 수 있기 때문에 특히 수신 시 라우팅, 송신 시 라우팅과 같이요.</font>

1409
00:46:33,560 --> 00:46:37,560
where XDP can only be on ingress.

1410
00:46:33,560 --> 00:46:37,560
<font color="#ffff54">여기서 XDP는 수신만 가능합니다.</font>

1411
00:46:37,560 --> 00:46:42,400
XDP allow you to kind of do you know, load balancing again at low level.

1412
00:46:37,560 --> 00:46:42,400
<font color="#ffff54">XDP를 사용하면 낮은 수준에서 다시 로드 밸런싱을 할 수 있습니다.</font>

1413
00:46:42,400 --> 00:46:53,560
In comparison, if you use Selium using XDP, here, here's a, you know, an interesting diagram

1414
00:46:42,400 --> 00:46:53,560
<font color="#ffff54">이와 비교하여, XDP를 사용하여 Selium을 사용하는 경우, 여기 흥미로운 다이어그램이 있습니다.</font>

1415
00:46:53,559 --> 00:47:00,440
I got from the Selium documentation, where it shows you that if you use Selium with XDP,

1416
00:46:53,559 --> 00:47:00,440
<font color="#ffff54">셀리움 설명서에서 가져온 것인데, XDP와 함께 셀리움을 사용하면 다음과 같이 표시됩니다,</font>

1417
00:47:00,440 --> 00:47:08,079
the amount of free data like free CPU is huge compared to like the basic queue proxy.

1418
00:47:00,440 --> 00:47:08,079
<font color="#ffff54">기본 큐 프록시와 비교했을 때 무료 CPU와 같은 무료 데이터의 양이 엄청납니다.</font>

1419
00:47:08,079 --> 00:47:13,840
That is basically saying that using XDP is way faster, more efficient in term of like

1420
00:47:08,079 --> 00:47:13,840
<font color="#ffff54">이는 기본적으로 XDP를 사용하는 것이 훨씬 빠르고 효율적이라는 것을 의미합니다.</font>

1421
00:47:13,840 --> 00:47:17,239
processing of the traffic.

1422
00:47:13,840 --> 00:47:17,239
<font color="#ffff54">트래픽을 처리합니다.</font>

1423
00:47:17,240 --> 00:47:25,080
So let's go back to my environment fast and see if I can catch up with you guys.

1424
00:47:17,240 --> 00:47:25,080
<font color="#ffff54">빨리 제 환경으로 돌아가서 여러분을 따라잡을 수 있는지 보겠습니다.</font>

1425
00:47:25,080 --> 00:47:32,920
So I'm gonna go here, I'm going to create my, right?

1426
00:47:25,080 --> 00:47:32,920
<font color="#ffff54">그럼 난 여기로 가서 내 것을 만들어야겠어, 그렇지?</font>

1427
00:47:32,920 --> 00:47:33,920
Hopefully this time works.

1428
00:47:32,920 --> 00:47:33,920
<font color="#ffff54">이번엔 잘 되길 바라.</font>

1429
00:47:33,920 --> 00:47:39,560
I'm gonna create my environment.

1430
00:47:33,920 --> 00:47:39,560
<font color="#ffff54">내 환경을 만들어야겠어.</font>

1431
00:47:39,560 --> 00:47:41,560
Taking time here.

1432
00:47:39,560 --> 00:47:41,560
<font color="#ffff54">시간을 좀 가져요.</font>

1433
00:47:41,560 --> 00:47:43,080
Great.

1434
00:47:41,560 --> 00:47:43,080
<font color="#ffff54">잘했어.</font>

1435
00:47:43,080 --> 00:47:44,680
Okay.

1436
00:47:43,080 --> 00:47:44,680
<font color="#ffff54">오케이.</font>

1437
00:47:44,679 --> 00:47:49,319
There you go.

1438
00:47:44,679 --> 00:47:49,319
<font color="#ffff54">이제 됐어요.</font>

1439
00:47:49,319 --> 00:47:54,960
Now I'm gonna connect my, my, my queue config.

1440
00:47:49,319 --> 00:47:54,960
<font color="#ffff54">이제 내, 내, 내 큐 구성을 연결하겠습니다.</font>

1441
00:47:54,960 --> 00:48:01,819
I'm gonna skip straight to the final version, which is Dell.

1442
00:47:54,960 --> 00:48:01,819
<font color="#ffff54">바로 최종 버전인 Dell으로 넘어가겠습니다.</font>

1443
00:48:01,819 --> 00:48:06,719
I'm gonna create my EPPF configuration.

1444
00:48:01,819 --> 00:48:06,719
<font color="#ffff54">EPPF 구성을 만들겠습니다.</font>

1445
00:48:06,719 --> 00:48:12,239
Sorry, my my CNI plugin configuration.

1446
00:48:06,719 --> 00:48:12,239
<font color="#ffff54">죄송합니다, 제 CNI 플러그인 설정입니다.</font>

1447
00:48:12,280 --> 00:48:18,520
I'm gonna deploy certain data, like certain application, and tinted the node for master

1448
00:48:12,280 --> 00:48:18,520
<font color="#ffff54">특정 애플리케이션과 같은 특정 데이터를 배포하고 노드를 마스터로 틴팅했습니다.</font>

1449
00:48:18,520 --> 00:48:20,760
so I can schedule things on it.

1450
00:48:18,520 --> 00:48:20,760
<font color="#ffff54">그래서 스케줄을 잡을 수 있습니다.</font>

1451
00:48:20,760 --> 00:48:34,200
And then I'm gonna move my, I'm gonna move my CNI configuration here.

1452
00:48:20,760 --> 00:48:34,200
<font color="#ffff54">그리고 내 CNI 구성을 여기로 옮기겠습니다.</font>

1453
00:48:34,200 --> 00:48:35,200
There you go.

1454
00:48:34,200 --> 00:48:35,200
<font color="#ffff54">다 됐어요.</font>

1455
00:48:35,200 --> 00:48:36,200
Container creating.

1456
00:48:35,200 --> 00:48:36,200
<font color="#ffff54">컨테이너 생성 중입니다.</font>

1457
00:48:36,200 --> 00:48:37,200
I don't know what I did last time.

1458
00:48:36,200 --> 00:48:37,200
<font color="#ffff54">지난번에 내가 뭘 했는지 모르겠다.</font>

1459
00:48:37,200 --> 00:48:38,200
It didn't work.

1460
00:48:37,200 --> 00:48:38,200
<font color="#ffff54">성공하지 못했어.</font>

1461
00:48:38,200 --> 00:48:39,200
All right.

1462
00:48:38,200 --> 00:48:39,200
<font color="#ffff54">됐어요.</font>

1463
00:48:40,200 --> 00:48:41,200
All right.

1464
00:48:40,200 --> 00:48:41,200
<font color="#ffff54">알았어요.</font>

1465
00:48:43,200 --> 00:48:48,600
I don't know, like sometimes you do that thousand times before it works.

1466
00:48:43,200 --> 00:48:48,600
<font color="#ffff54">글쎄요, 가끔은 수천 번을 해야 되는 것 같아요.</font>

1467
00:48:48,600 --> 00:48:50,200
You have to do it in front of people.

1468
00:48:48,600 --> 00:48:50,200
<font color="#ffff54">사람들 앞에서 해야지.</font>

1469
00:48:50,200 --> 00:48:52,520
It breaks, right?

1470
00:48:50,200 --> 00:48:52,520
<font color="#ffff54">부러지죠?</font>

1471
00:48:52,520 --> 00:48:54,000
I guess that's the deal.

1472
00:48:52,520 --> 00:48:54,000
<font color="#ffff54">그런 것 같네요.</font>

1473
00:48:54,000 --> 00:48:55,000
All right.

1474
00:48:54,000 --> 00:48:55,000
<font color="#ffff54">알았어.</font>

1475
00:48:55,000 --> 00:48:57,440
Okay, so all the pods are running.

1476
00:48:55,000 --> 00:48:57,440
<font color="#ffff54">좋아, 모든 파드가 실행되고 있다.</font>

1477
00:48:57,440 --> 00:48:58,440
Amazing.

1478
00:48:57,440 --> 00:48:58,440
<font color="#ffff54">놀랍군.</font>

1479
00:48:58,440 --> 00:49:05,620
So I can go to basically take a look at the configuration.

1480
00:48:58,440 --> 00:49:05,620
<font color="#ffff54">이제 기본적으로 구성을 살펴볼 수 있습니다.</font>

1481
00:49:05,619 --> 00:49:11,279
So yeah, if I do an exact, if I do a curl, I'm getting results from HTTP bin.

1482
00:49:05,619 --> 00:49:11,279
<font color="#ffff54">네, 정확히 말하면 컬을 실행하면 HTTP 빈에서 결과를 얻습니다.</font>

1483
00:49:11,279 --> 00:49:17,400
So basically this sleep pod, this sleep pod, think about as the client and HTTP bin as

1484
00:49:11,279 --> 00:49:17,400
<font color="#ffff54">그래서 기본적으로 이 슬립 파드, 이 슬립 파드는 클라이언트와 HTTP 빈으로 생각하면 됩니다.</font>

1485
00:49:17,400 --> 00:49:18,400
being the server.

1486
00:49:17,400 --> 00:49:18,400
<font color="#ffff54">서버라고 생각하면 됩니다.</font>

1487
00:49:18,400 --> 00:49:20,619
So it's just to simulate client server connectivity.

1488
00:49:18,400 --> 00:49:20,619
<font color="#ffff54">클라이언트 서버 연결을 시뮬레이션하기 위한 것입니다.</font>

1489
00:49:20,619 --> 00:49:21,619
Awesome.

1490
00:49:20,619 --> 00:49:21,619
<font color="#ffff54">멋지네요.</font>

1491
00:49:21,619 --> 00:49:23,619
There you go.

1492
00:49:21,619 --> 00:49:23,619
<font color="#ffff54">됐어요.</font>

1493
00:49:23,619 --> 00:49:24,619
Good.

1494
00:49:23,619 --> 00:49:24,619
<font color="#ffff54">잘했어.</font>

1495
00:49:24,619 --> 00:49:25,619
Let's keep going.

1496
00:49:24,619 --> 00:49:25,619
<font color="#ffff54">계속 가자.</font>

1497
00:49:25,619 --> 00:49:30,059
So let's go back to the slides quickly just to explain what we're going to do in the next

1498
00:49:25,619 --> 00:49:30,059
<font color="#ffff54">이제 슬라이드로 돌아가서 다음에 할 일을 설명하겠습니다.</font>

1499
00:49:30,059 --> 00:49:32,739
step.

1500
00:49:30,059 --> 00:49:32,739
<font color="#ffff54">단계입니다.</font>

1501
00:49:32,739 --> 00:49:34,259
Here's what we're going to do.

1502
00:49:32,739 --> 00:49:34,259
<font color="#ffff54">다음은 다음과 같습니다.</font>

1503
00:49:34,260 --> 00:49:38,540
So we created our bridge plugin also.

1504
00:49:34,260 --> 00:49:38,540
<font color="#ffff54">그래서 브리지 플러그인도 만들었습니다.</font>

1505
00:49:38,540 --> 00:49:43,860
Now what we want to do every time we're going to create the V8 pair and every time we're

1506
00:49:38,540 --> 00:49:43,860
<font color="#ffff54">이제 V8 쌍을 생성할 때마다 우리가 하고 싶은 일은</font>

1507
00:49:43,860 --> 00:49:52,540
going to create the interface in our container, we want to plug in an EBPF code.

1508
00:49:43,860 --> 00:49:52,540
<font color="#ffff54">컨테이너에 인터페이스를 생성할 때마다 EBPF 코드를 삽입하고 싶습니다.</font>

1509
00:49:52,540 --> 00:49:53,540
That's it.

1510
00:49:52,540 --> 00:49:53,540
<font color="#ffff54">끝났습니다.</font>

1511
00:49:53,540 --> 00:49:55,460
That's the goal for this first exercise.

1512
00:49:53,540 --> 00:49:55,460
<font color="#ffff54">이것이 이번 첫 번째 연습의 목표입니다.</font>

1513
00:49:55,460 --> 00:50:00,540
Let's write our first EBPF code.

1514
00:49:55,460 --> 00:50:00,540
<font color="#ffff54">첫 번째 EBPF 코드를 작성해 봅시다.</font>

1515
00:50:00,540 --> 00:50:02,900
Very simple.

1516
00:50:00,540 --> 00:50:02,900
<font color="#ffff54">아주 간단합니다.</font>

1517
00:50:02,900 --> 00:50:09,980
So in our case, again, we're going to attach every single time EBPF at every single interface

1518
00:50:02,900 --> 00:50:09,980
<font color="#ffff54">우리의 경우, 다시 말하지만 모든 인터페이스에서 매번 EBPF를 첨부할 것입니다.</font>

1519
00:50:09,980 --> 00:50:12,780
we create.

1520
00:50:09,980 --> 00:50:12,780
<font color="#ffff54">생성합니다.</font>

1521
00:50:12,780 --> 00:50:20,579
Let's go back to our environment.

1522
00:50:12,780 --> 00:50:20,579
<font color="#ffff54">우리의 환경으로 돌아가 봅시다.</font>

1523
00:50:20,579 --> 00:50:24,099
Let's get started here.

1524
00:50:20,579 --> 00:50:24,099
<font color="#ffff54">여기서부터 시작하죠.</font>

1525
00:50:24,099 --> 00:50:31,380
So let's take a look at a very basic BPF code.

1526
00:50:24,099 --> 00:50:31,380
<font color="#ffff54">이제 아주 기본적인 BPF 코드를 살펴봅시다.</font>

1527
00:50:31,380 --> 00:50:35,740
You can open the editor here and let's go through it.

1528
00:50:31,380 --> 00:50:35,740
<font color="#ffff54">여기에서 에디터를 열고 살펴봅시다.</font>

1529
00:50:35,740 --> 00:50:40,460
In this example, in all this workshop, I'm using XDP.

1530
00:50:35,740 --> 00:50:40,460
<font color="#ffff54">이 예제에서는 이 모든 워크샵에서 XDP를 사용하고 있습니다.</font>

1531
00:50:40,460 --> 00:50:45,460
We could have been using TC because more Selenium related, but I'm XDP too.

1532
00:50:40,460 --> 00:50:45,460
<font color="#ffff54">셀레늄과 관련된 것이 더 많기 때문에 TC를 사용할 수도 있었지만, 저는 XDP를 사용합니다.</font>

1533
00:50:45,460 --> 00:50:50,900
But XDP, the good thing here is that is very simple.

1534
00:50:45,460 --> 00:50:50,900
<font color="#ffff54">하지만 XDP의 장점은 매우 간단하다는 것입니다.</font>

1535
00:50:50,900 --> 00:50:53,980
You can actually go online.

1536
00:50:50,900 --> 00:50:53,980
<font color="#ffff54">실제로 온라인에 접속할 수 있습니다.</font>

1537
00:50:53,980 --> 00:50:57,619
There's a lot of XDP information.

1538
00:50:53,980 --> 00:50:57,619
<font color="#ffff54">많은 XDP 정보가 있습니다.</font>

1539
00:50:57,619 --> 00:50:58,619
There's a lot of tutorials.

1540
00:50:57,619 --> 00:50:58,619
<font color="#ffff54">튜토리얼이 많이 있습니다.</font>

1541
00:50:58,619 --> 00:51:02,779
I can give you links at the end of this workshop to go and learn more about it.

1542
00:50:58,619 --> 00:51:02,779
<font color="#ffff54">이 워크샵이 끝나면 더 자세히 알아볼 수 있는 링크를 알려드릴게요.</font>

1543
00:51:02,779 --> 00:51:10,500
So I think XDP is the right technology to first play with EBPF in the networking space.

1544
00:51:02,779 --> 00:51:10,500
<font color="#ffff54">그래서 저는 XDP가 네트워킹 공간에서 EBPF를 처음 사용하기에 적합한 기술이라고 생각합니다.</font>

1545
00:51:10,500 --> 00:51:15,179
So here's the code that we are going to create.

1546
00:51:10,500 --> 00:51:15,179
<font color="#ffff54">우리가 만들 코드는 다음과 같습니다.</font>

1547
00:51:15,179 --> 00:51:20,279
Ignore the includes that actually we're using this library called libBPF that allows us

1548
00:51:15,179 --> 00:51:20,279
<font color="#ffff54">인클루드는 무시하고 실제로는 libBPF라는 라이브러리를 사용하여 다음과 같은 코드를 작성합니다.</font>

1549
00:51:20,279 --> 00:51:24,380
to write our BPF code.

1550
00:51:20,279 --> 00:51:24,380
<font color="#ffff54">을 사용하여 BPF 코드를 작성합니다.</font>

1551
00:51:24,380 --> 00:51:32,460
But the main thing that we need to be watching for is, so this section, in our case, we are

1552
00:51:24,380 --> 00:51:32,460
<font color="#ffff54">하지만 우리가 주목해야 할 가장 중요한 것은 이 섹션의 경우 다음과 같습니다.</font>

1553
00:51:32,460 --> 00:51:33,900
putting XDP.

1554
00:51:32,460 --> 00:51:33,900
<font color="#ffff54">XDP를 넣습니다.</font>

1555
00:51:33,900 --> 00:51:38,140
The section is defining which kind of hook we are looking for.

1556
00:51:33,900 --> 00:51:38,140
<font color="#ffff54">이 섹션은 우리가 찾고 있는 후크의 종류를 정의하고 있습니다.</font>

1557
00:51:38,140 --> 00:51:45,880
So in this case, the section is saying, well, we are going to trigger this on the XDP hook

1558
00:51:38,140 --> 00:51:45,880
<font color="#ffff54">이 경우, 섹션은 XDP 훅에서 이것을 트리거할 것이라고 말하고 있습니다.</font>

1559
00:51:45,880 --> 00:51:48,599
in our network stack.

1560
00:51:45,880 --> 00:51:48,599
<font color="#ffff54">에서 트리거합니다.</font>

1561
00:51:48,599 --> 00:51:54,019
Then every time we get there, we're going to process this method here called process

1562
00:51:48,599 --> 00:51:54,019
<font color="#ffff54">그런 다음 매번 여기에 도달할 때마다 process라는 메서드를 처리합니다.</font>

1563
00:51:54,019 --> 00:51:55,019
XDP.

1564
00:51:54,019 --> 00:51:55,019
<font color="#ffff54">XDP.</font>

1565
00:51:55,019 --> 00:51:56,019
You can call it whatever.

1566
00:51:55,019 --> 00:51:56,019
<font color="#ffff54">아무거나 불러도 됩니다.</font>

1567
00:51:56,019 --> 00:51:57,019
It doesn't matter.

1568
00:51:56,019 --> 00:51:57,019
<font color="#ffff54">상관없어.</font>

1569
00:51:57,019 --> 00:51:58,019
The name here doesn't really matter.

1570
00:51:57,019 --> 00:51:58,019
<font color="#ffff54">여기서 이름은 중요하지 않습니다.</font>

1571
00:51:58,019 --> 00:52:00,339
I think the section matters more.

1572
00:51:58,019 --> 00:52:00,339
<font color="#ffff54">섹션이 더 중요한 것 같아요.</font>

1573
00:52:00,339 --> 00:52:05,659
And then every time, again, I talked about the fact that every layer has different, like

1574
00:52:00,339 --> 00:52:05,659
<font color="#ffff54">그리고 매번 다시 말하지만, 저는 모든 계층이 서로 다르다는 사실에 대해 이야기했습니다.</font>

1575
00:52:05,659 --> 00:52:07,199
more information.

1576
00:52:05,659 --> 00:52:07,199
<font color="#ffff54">더 많은 정보.</font>

1577
00:52:07,199 --> 00:52:17,079
And since it's very low level, in XDP, we have access to this structure called XDP-MD.

1578
00:52:07,199 --> 00:52:17,079
<font color="#ffff54">그리고 매우 낮은 수준이기 때문에 XDP에서는 XDP-MD라는 구조에 접근할 수 있습니다.</font>

1579
00:52:17,079 --> 00:52:21,380
So what we are going to do is straightforward.

1580
00:52:17,079 --> 00:52:21,380
<font color="#ffff54">우리가 할 일은 간단합니다.</font>

1581
00:52:21,380 --> 00:52:23,599
The first step is we're going to get the data.

1582
00:52:21,380 --> 00:52:23,599
<font color="#ffff54">첫 번째 단계는 데이터를 가져오는 것입니다.</font>

1583
00:52:23,599 --> 00:52:31,579
So every time the packets go through this V8, every time we capture these packets, we

1584
00:52:23,599 --> 00:52:31,579
<font color="#ffff54">따라서 패킷이 이 V8을 통과할 때마다, 이 패킷을 캡처할 때마다, 우리는</font>

1585
00:52:31,579 --> 00:52:33,239
are going to do a couple of things.

1586
00:52:31,579 --> 00:52:33,239
<font color="#ffff54">몇 가지 작업을 수행합니다.</font>

1587
00:52:33,239 --> 00:52:35,579
So we captured the data, which is the packets.

1588
00:52:33,239 --> 00:52:35,579
<font color="#ffff54">그래서 우리는 패킷인 데이터를 캡처했습니다.</font>

1589
00:52:35,579 --> 00:52:38,099
We're going to capture the beginning and the end.

1590
00:52:35,579 --> 00:52:38,099
<font color="#ffff54">시작과 끝을 캡처하겠습니다.</font>

1591
00:52:38,099 --> 00:52:39,099
Right?

1592
00:52:38,099 --> 00:52:39,099
<font color="#ffff54">그렇지?</font>

1593
00:52:39,119 --> 00:52:47,519
Then we're going to try to parse this data as if it's like an Ethernet, you know, packet.

1594
00:52:39,119 --> 00:52:47,519
<font color="#ffff54">이제 이 데이터를 이더넷의 패킷처럼 파싱해 보겠습니다.</font>

1595
00:52:47,519 --> 00:52:55,279
We're going to make sure that basically the data itself is not bigger than the Ethernet

1596
00:52:47,519 --> 00:52:55,279
<font color="#ffff54">기본적으로 데이터 자체가 이더넷보다 크지 않은지 확인하겠습니다.</font>

1597
00:52:55,279 --> 00:52:56,279
packet.

1598
00:52:55,279 --> 00:52:56,279
<font color="#ffff54">패킷.</font>

1599
00:52:56,279 --> 00:53:00,360
Basically, if that happens, that means that's a bad packet.

1600
00:52:56,279 --> 00:53:00,360
<font color="#ffff54">기본적으로 이런 일이 발생하면 불량 패킷이라는 뜻입니다.</font>

1601
00:53:00,360 --> 00:53:02,400
That's actually something you don't need on your system.

1602
00:53:00,360 --> 00:53:02,400
<font color="#ffff54">이는 실제로 시스템에서 필요하지 않은 것입니다.</font>

1603
00:53:02,400 --> 00:53:04,199
That's the first filtering, basically.

1604
00:53:02,400 --> 00:53:04,199
<font color="#ffff54">이것이 기본적으로 첫 번째 필터링입니다.</font>

1605
00:53:04,199 --> 00:53:07,960
You are filtering bad traffic going through your services.

1606
00:53:04,199 --> 00:53:07,960
<font color="#ffff54">서비스를 통과하는 악성 트래픽을 필터링하고 있습니다.</font>

1607
00:53:07,980 --> 00:53:09,500
That's what we're doing here.

1608
00:53:07,980 --> 00:53:09,500
<font color="#ffff54">이것이 우리가 여기서 하는 일입니다.</font>

1609
00:53:09,500 --> 00:53:15,860
XDP abort, the way in XDP, the way it works, there's codes for everything.

1610
00:53:09,500 --> 00:53:15,860
<font color="#ffff54">XDP 중단, XDP의 방식, 작동 방식, 모든 것에 대한 코드가 있습니다.</font>

1611
00:53:15,860 --> 00:53:23,360
If you return a certain value, it instructs the XDP code or EBPF code to do something.

1612
00:53:15,860 --> 00:53:23,360
<font color="#ffff54">특정 값을 반환하면 XDP 코드나 EBPF 코드에 무언가를 하도록 지시합니다.</font>

1613
00:53:23,360 --> 00:53:29,500
In our case here, XDP abort just, you know, stops.

1614
00:53:23,360 --> 00:53:29,500
<font color="#ffff54">이 경우 XDP 중단은 그냥 멈춥니다.</font>

1615
00:53:29,500 --> 00:53:33,119
Like it doesn't process this code.

1616
00:53:29,500 --> 00:53:33,119
<font color="#ffff54">이 코드를 처리하지 않는 것처럼.</font>

1617
00:53:33,119 --> 00:53:34,119
It's not going to filter out.

1618
00:53:33,119 --> 00:53:34,119
<font color="#ffff54">필터링되지 않습니다.</font>

1619
00:53:34,119 --> 00:53:37,179
It's just going to not run on this particular code.

1620
00:53:34,119 --> 00:53:37,179
<font color="#ffff54">이 특정 코드에서는 실행되지 않습니다.</font>

1621
00:53:38,940 --> 00:53:46,059
Then the second thing is we're going to check actually if this is like an Ethernet, you

1622
00:53:38,940 --> 00:53:46,059
<font color="#ffff54">두 번째는 이것이 이더넷과 같은지 실제로 확인해 보겠습니다.</font>

1623
00:53:46,059 --> 00:53:50,099
know, IPv4 code.

1624
00:53:46,059 --> 00:53:50,099
<font color="#ffff54">알다시피, IPv4 코드.</font>

1625
00:53:50,099 --> 00:53:52,980
Like are we looking for an IPv4 structure?

1626
00:53:50,099 --> 00:53:52,980
<font color="#ffff54">IPv4 구조를 찾고 있나요?</font>

1627
00:53:52,980 --> 00:53:59,340
And for that we're using, you know, we're just checking the proto on our code and saying,

1628
00:53:52,980 --> 00:53:59,340
<font color="#ffff54">이를 위해 우리는 코드의 프로토타입을 확인하고 다음과 같이 말하고 있습니다,</font>

1629
00:53:59,340 --> 00:54:07,960
well, does it match, there's a predefined proto for, you know, value for IPv4 packets.

1630
00:53:59,340 --> 00:54:07,960
<font color="#ffff54">IPv4 패킷의 값에 대해 미리 정의된 프로토콜이 있습니다.</font>

1631
00:54:07,960 --> 00:54:08,960
We're going to check that.

1632
00:54:07,960 --> 00:54:08,960
<font color="#ffff54">확인해보죠.</font>

1633
00:54:08,960 --> 00:54:10,360
Okay, that's good.

1634
00:54:08,960 --> 00:54:10,360
<font color="#ffff54">좋아, 됐어.</font>

1635
00:54:10,360 --> 00:54:15,559
If that's a packet that is IPv4, then, if not IPv4, then just pass.

1636
00:54:10,360 --> 00:54:15,559
<font color="#ffff54">IPv4 패킷이라면, IPv4가 아니라면 그냥 통과하세요.</font>

1637
00:54:15,559 --> 00:54:20,760
XDP pass says it means just like follow, don't do anything, right?

1638
00:54:15,559 --> 00:54:20,760
<font color="#ffff54">XDP 패스는 그냥 따라가기만 하고 아무것도 하지 말라는 뜻이죠?</font>

1639
00:54:20,760 --> 00:54:23,000
We don't need to do anything right now.

1640
00:54:20,760 --> 00:54:23,000
<font color="#ffff54">지금은 아무것도 할 필요가 없습니다.</font>

1641
00:54:23,000 --> 00:54:24,960
Just forward these packets.

1642
00:54:23,000 --> 00:54:24,960
<font color="#ffff54">그냥 이 패킷들을 전달하세요.</font>

1643
00:54:24,960 --> 00:54:27,280
I don't have to deal with it.

1644
00:54:24,960 --> 00:54:27,280
<font color="#ffff54">처리할 필요 없어.</font>

1645
00:54:27,280 --> 00:54:32,740
Now if it's actually an IPv4 packet, then we can get more data.

1646
00:54:27,280 --> 00:54:32,740
<font color="#ffff54">이제 실제로 IPv4 패킷이라면 더 많은 데이터를 얻을 수 있습니다.</font>

1647
00:54:32,740 --> 00:54:40,900
And here we're forwarding to, we're actually going to parse it into an IPv4 structure,

1648
00:54:32,740 --> 00:54:40,900
<font color="#ffff54">그리고 여기서 우리는 이 패킷을 실제로 IPv4 구조로 파싱할 것입니다,</font>

1649
00:54:40,900 --> 00:54:41,900
right?

1650
00:54:40,900 --> 00:54:41,900
<font color="#ffff54">맞죠?</font>

1651
00:54:41,900 --> 00:54:46,500
As part of this IPv4 structure, first we're going to check, hey, is it actually an IPv4

1652
00:54:41,900 --> 00:54:46,500
<font color="#ffff54">이 IPv4 구조의 일부로, 먼저 이것이 실제로 IPv4인지 확인하겠습니다.</font>

1653
00:54:46,500 --> 00:54:47,500
structure here?

1654
00:54:46,500 --> 00:54:47,500
<font color="#ffff54">구조인가요?</font>

1655
00:54:47,500 --> 00:54:48,500
Right?

1656
00:54:47,500 --> 00:54:48,500
<font color="#ffff54">그렇지?</font>

1657
00:54:48,500 --> 00:54:54,300
If it's not, so if the size of it is too big, then, well, again, two, I don't have to run

1658
00:54:48,500 --> 00:54:54,300
<font color="#ffff54">만약 그렇지 않다면, 그래서 크기가 너무 크다면, 다시, 두 번, 나는 실행할 필요가 없습니다.</font>

1659
00:54:54,320 --> 00:54:57,680
XDP in this case, abort.

1660
00:54:54,320 --> 00:54:57,680
<font color="#ffff54">이 경우 XDP, 중단합니다.</font>

1661
00:54:57,680 --> 00:55:04,400
But now, again, if it's actually a valid packet, an IPv4 packet, that we parse it correctly,

1662
00:54:57,680 --> 00:55:04,400
<font color="#ffff54">하지만 이제 다시 한 번, 실제로 유효한 패킷, 즉 IPv4 패킷이라면 올바르게 파싱합니다,</font>

1663
00:55:04,400 --> 00:55:09,820
okay, so now I have access to the source and destination address, all the things that comes

1664
00:55:04,400 --> 00:55:09,820
<font color="#ffff54">좋아, 이제 소스 및 목적지 주소에 액세스 할 수 있습니다.</font>

1665
00:55:09,820 --> 00:55:12,160
with the IPv4 structure.

1666
00:55:09,820 --> 00:55:12,160
<font color="#ffff54">IPv4 구조로</font>

1667
00:55:12,160 --> 00:55:18,200
So what I can do, look, I can print in the kernel, right, that's the thing.

1668
00:55:12,160 --> 00:55:18,200
<font color="#ffff54">제가 할 수 있는 일은 커널에서 인쇄할 수 있다는 것입니다.</font>

1669
00:55:18,200 --> 00:55:22,440
Here we're printing in the kernel this source and the destination address.

1670
00:55:18,200 --> 00:55:22,440
<font color="#ffff54">여기서는 커널에서 이 소스와 대상 주소를 인쇄하고 있습니다.</font>

1671
00:55:22,579 --> 00:55:29,579
We're going to say, hey, I got a packet from this address, and I get this packet is going

1672
00:55:22,579 --> 00:55:29,579
<font color="#ffff54">이 주소에서 패킷을 받았고, 이 패킷이 다음 주소로 가고 있다고 말할 것입니다.</font>

1673
00:55:29,579 --> 00:55:33,780
to this address, and let's print that again on the kernel side.

1674
00:55:29,579 --> 00:55:33,780
<font color="#ffff54">이 주소로 가는 것을 확인하고 커널 쪽에서 다시 인쇄해 보겠습니다.</font>

1675
00:55:33,780 --> 00:55:36,179
And that's it.

1676
00:55:33,780 --> 00:55:36,179
<font color="#ffff54">이제 끝입니다.</font>

1677
00:55:36,179 --> 00:55:39,500
Let's actually run this code.

1678
00:55:36,179 --> 00:55:39,500
<font color="#ffff54">실제로 이 코드를 실행해 봅시다.</font>

1679
00:55:39,500 --> 00:55:41,900
Let's go back to the terminal.

1680
00:55:39,500 --> 00:55:41,900
<font color="#ffff54">터미널로 돌아가 봅시다.</font>

1681
00:55:41,900 --> 00:55:49,340
Let's actually just pull the dependency, which is libbpf in our case, and then let's actually

1682
00:55:41,900 --> 00:55:49,340
<font color="#ffff54">실제로는 의존성(이 경우 libbpf)을 가져온 다음 실제로</font>

1683
00:55:49,340 --> 00:55:51,380
build this binary.

1684
00:55:49,340 --> 00:55:51,380
<font color="#ffff54">이 바이너리를 빌드합니다.</font>

1685
00:55:51,400 --> 00:55:57,920
We're building this binary using clang, which is actually our C builder in this case, it

1686
00:55:51,400 --> 00:55:57,920
<font color="#ffff54">이 바이너리는 clang을 사용하여 빌드하고 있는데, 이 경우 실제로는 C 빌더입니다.</font>

1687
00:55:57,920 --> 00:55:59,800
built it into a BPF code.

1688
00:55:57,920 --> 00:55:59,800
<font color="#ffff54">BPF 코드로 빌드합니다.</font>

1689
00:55:59,800 --> 00:56:04,960
Okay, at this point, we have our first BPF code compiled, we're good.

1690
00:55:59,800 --> 00:56:04,960
<font color="#ffff54">자, 이제 첫 번째 BPF 코드가 컴파일되었습니다.</font>

1691
00:56:04,960 --> 00:56:10,760
Let's actually now use it on our interface.

1692
00:56:04,960 --> 00:56:10,760
<font color="#ffff54">이제 실제로 인터페이스에서 사용해 봅시다.</font>

1693
00:56:10,760 --> 00:56:18,880
To do this, we actually need to load, we have to load a specific BPF program.

1694
00:56:10,760 --> 00:56:18,880
<font color="#ffff54">이렇게 하려면 실제로 특정 BPF 프로그램을 로드해야 합니다.</font>

1695
00:56:18,880 --> 00:56:26,700
The binary that got outputted for the previous command is now loaded under sysfs-bpf-bpf-cni.

1696
00:56:18,880 --> 00:56:26,700
<font color="#ffff54">이전 명령에 대해 출력된 바이너리가 이제 sysfs-bpf-bpf-cni 아래에 로드됩니다.</font>

1697
00:56:26,700 --> 00:56:33,820
Okay, so again, at this point, I have some EPF code that can be used.

1698
00:56:26,700 --> 00:56:33,820
<font color="#ffff54">자, 이제 다시 이 시점에서 사용할 수 있는 EPF 코드가 생겼습니다.</font>

1699
00:56:33,820 --> 00:56:39,180
I haven't done the wiring in my CNI to every time I create an interface, attach this code

1700
00:56:33,820 --> 00:56:39,180
<font color="#ffff54">인터페이스를 만들 때마다 CNI에서 배선을 하지 않았으므로 다음 코드를 첨부합니다.</font>

1701
00:56:39,180 --> 00:56:40,180
to it, not yet.

1702
00:56:39,180 --> 00:56:40,180
<font color="#ffff54">아직은 아니야.</font>

1703
00:56:40,180 --> 00:56:43,760
We're going to do this in this section.

1704
00:56:40,180 --> 00:56:43,760
<font color="#ffff54">이 섹션에서 이 작업을 수행하겠습니다.</font>

1705
00:56:43,760 --> 00:56:47,800
So let's run this command.

1706
00:56:43,760 --> 00:56:47,800
<font color="#ffff54">이제 이 명령을 실행해 보겠습니다.</font>

1707
00:56:47,800 --> 00:56:51,380
Let's get to the editor to take a look at what we did.

1708
00:56:47,800 --> 00:56:51,380
<font color="#ffff54">편집기로 이동하여 우리가 한 일을 살펴봅시다.</font>

1709
00:56:51,380 --> 00:56:56,900
No, sorry, on the editor tab, which is a CNI plugin, do some refresh.

1710
00:56:51,380 --> 00:56:56,900
<font color="#ffff54">아니요, CNI 플러그인인 편집기 탭에서 새로 고침을 수행하세요.</font>

1711
00:56:56,900 --> 00:56:59,080
It's the exact same code as earlier.

1712
00:56:56,900 --> 00:56:59,080
<font color="#ffff54">이전과 똑같은 코드입니다.</font>

1713
00:56:59,080 --> 00:57:06,380
The only difference is here is after I actually output my result, I'm saying, okay, everything

1714
00:56:59,080 --> 00:57:06,380
<font color="#ffff54">여기서 유일한 차이점은 실제로 결과를 출력한 후, 다음과 같이 말합니다.</font>

1715
00:57:06,380 --> 00:57:07,380
is good.

1716
00:57:06,380 --> 00:57:07,380
<font color="#ffff54">좋네요.</font>

1717
00:57:07,380 --> 00:57:13,340
Well, actually, wait a second, before we finish this, let's actually attach this BPF code

1718
00:57:07,380 --> 00:57:13,340
<font color="#ffff54">잠깐만요, 이 작업을 완료하기 전에 실제로 이 BPF 코드를 첨부해 봅시다.</font>

1719
00:57:13,340 --> 00:57:15,220
that I just loaded.

1720
00:57:13,340 --> 00:57:15,220
<font color="#ffff54">방금 로드한</font>

1721
00:57:15,240 --> 00:57:24,200
We are using BPF tool net attach xdp on the interface we just created.

1722
00:57:15,240 --> 00:57:24,200
<font color="#ffff54">방금 만든 인터페이스에서 BPF 도구 net attach xdp를 사용하고 있습니다.</font>

1723
00:57:24,200 --> 00:57:30,000
This command here is basically saying run this xdp code on every packet that goes through

1724
00:57:24,200 --> 00:57:30,000
<font color="#ffff54">이 명령은 기본적으로 다음 패킷을 통과하는 모든 패킷에 대해 이 xdp 코드를 실행하라는 것입니다.</font>

1725
00:57:30,000 --> 00:57:35,640
this interface, the network interface we created for the networking in our pod.

1726
00:57:30,000 --> 00:57:35,640
<font color="#ffff54">이 인터페이스는 우리가 파드에서 네트워킹을 위해 만든 네트워크 인터페이스입니다.</font>

1727
00:57:35,640 --> 00:57:40,080
Again, it seems maybe complicated, but it's very straightforward.

1728
00:57:35,640 --> 00:57:40,080
<font color="#ffff54">다시 말하지만, 복잡해 보이지만 매우 간단합니다.</font>

1729
00:57:40,099 --> 00:57:46,739
We wrote some code, we built it, we loaded it, and then we attached it to a specific

1730
00:57:40,099 --> 00:57:46,739
<font color="#ffff54">코드를 작성하고, 빌드하고, 로드한 다음, 이 코드를 특정</font>

1731
00:57:46,739 --> 00:57:48,059
interface.

1732
00:57:46,739 --> 00:57:48,059
<font color="#ffff54">인터페이스에 연결합니다.</font>

1733
00:57:48,059 --> 00:57:51,340
In this case, I'm using BPF tool for this.

1734
00:57:48,059 --> 00:57:51,340
<font color="#ffff54">이 경우에는 BPF 도구를 사용하고 있습니다.</font>

1735
00:57:51,340 --> 00:57:56,239
But again, if you want to do this in a real scenario, and for example, Selium, the way

1736
00:57:51,340 --> 00:57:56,239
<font color="#ffff54">그러나 다시 말하지만, 실제 시나리오(예: Selium)에서 이 작업을 수행하려는 경우</font>

1737
00:57:56,239 --> 00:58:01,679
they do it in other projects, there's different loaders, there's actually some code, you can

1738
00:57:56,239 --> 00:58:01,679
<font color="#ffff54">다른 프로젝트에서 이 작업을 수행하고 다른 로더가 있고 실제로 일부 코드가 있습니다.</font>

1739
00:58:01,679 --> 00:58:06,739
write it in Go, for example, that grabs, you know, they're going to grab this BPF code

1740
00:58:01,679 --> 00:58:06,739
<font color="#ffff54">예를 들어 Go로 작성하면 이 BPF 코드를 가져올 수 있습니다.</font>

1741
00:58:06,760 --> 00:58:11,840
and attach it to a certain interface, you know, in Go instead of like using a CLI like

1742
00:58:06,760 --> 00:58:11,840
<font color="#ffff54">같은 CLI를 사용하는 대신 Go에서 특정 인터페이스에 연결합니다.</font>

1743
00:58:11,840 --> 00:58:12,840
I'm doing.

1744
00:58:11,840 --> 00:58:12,840
<font color="#ffff54">하고 있습니다.</font>

1745
00:58:12,840 --> 00:58:15,280
CLI here is just for simplifying things.

1746
00:58:12,840 --> 00:58:15,280
<font color="#ffff54">여기서 CLI는 작업을 단순화하기 위한 것입니다.</font>

1747
00:58:15,280 --> 00:58:16,440
Awesome.

1748
00:58:15,280 --> 00:58:16,440
<font color="#ffff54">멋지네요.</font>

1749
00:58:16,440 --> 00:58:18,920
So now I modified my CNI code.

1750
00:58:16,440 --> 00:58:18,920
<font color="#ffff54">이제 CNI 코드를 수정했습니다.</font>

1751
00:58:18,920 --> 00:58:19,920
That's great.

1752
00:58:18,920 --> 00:58:19,920
<font color="#ffff54">잘됐네요.</font>

1753
00:58:19,920 --> 00:58:30,640
So what I'm going to do is I'm going to, yes, I'm going to basically update, you know, I'm

1754
00:58:19,920 --> 00:58:30,640
<font color="#ffff54">그래서 제가 할 일은, 예, 기본적으로 업데이트 할 것입니다.</font>

1755
00:58:30,640 --> 00:58:36,720
moving this CNI code to OPT CNI bin again, when we have the CNI previously, some override

1756
00:58:30,640 --> 00:58:36,720
<font color="#ffff54">이 CNI 코드를 OPT CNI 빈으로 다시 옮기면 이전에 CNI가 있을 때 일부 오버라이드는</font>

1757
00:58:36,860 --> 00:58:38,900
writing the old code.

1758
00:58:36,860 --> 00:58:38,900
<font color="#ffff54">이전 코드를 작성합니다.</font>

1759
00:58:38,900 --> 00:58:41,180
And let's just delete the pod.

1760
00:58:38,900 --> 00:58:41,180
<font color="#ffff54">그리고 파드를 삭제한다.</font>

1761
00:58:41,180 --> 00:58:51,100
We're going to delete the pod just to force the recreation of the new network interfaces,

1762
00:58:41,180 --> 00:58:51,100
<font color="#ffff54">새로운 네트워크 인터페이스를 강제로 재생성하기 위해 파드를 삭제한다,</font>

1763
00:58:51,100 --> 00:58:58,460
the new pods with this CNI code, CNI plugin code attached to it.

1764
00:58:51,100 --> 00:58:58,460
<font color="#ffff54">이 CNI 코드, CNI 플러그인 코드가 첨부된 새 파드를 생성한다.</font>

1765
00:58:58,460 --> 00:59:03,140
So okay, my two pods are now up and running, which is awesome.

1766
00:58:58,460 --> 00:59:03,140
<font color="#ffff54">이제 두 개의 파드가 실행 중이며, 정말 멋지다.</font>

1767
00:59:03,159 --> 00:59:07,759
So if I run, let's say I'm going to run some traffic.

1768
00:59:03,159 --> 00:59:07,759
<font color="#ffff54">이제 실행하면, 트래픽이 좀 발생한다고 가정해 봅시다.</font>

1769
00:59:07,759 --> 00:59:08,759
There you go.

1770
00:59:07,759 --> 00:59:08,759
<font color="#ffff54">됐어요.</font>

1771
00:59:08,759 --> 00:59:10,039
So I'm making a curl.

1772
00:59:08,759 --> 00:59:10,039
<font color="#ffff54">컬을 만들고 있어요.</font>

1773
00:59:10,039 --> 00:59:13,940
What do you guys think would happen now?

1774
00:59:10,039 --> 00:59:13,940
<font color="#ffff54">이제 어떻게 될 것 같아?</font>

1775
00:59:13,940 --> 00:59:19,739
Now that I run the code, the package went through the V8, my XDP code got executed,

1776
00:59:13,940 --> 00:59:19,739
<font color="#ffff54">이제 코드를 실행했더니 패키지가 V8을 통과해서 내 XDP 코드가 실행되었습니다,</font>

1777
00:59:19,739 --> 00:59:25,059
and I should have logs now in the kernel that shows that this packet got processed.

1778
00:59:19,739 --> 00:59:25,059
<font color="#ffff54">이제 커널에 이 패킷이 처리되었음을 보여주는 로그가 있어야 합니다.</font>

1779
00:59:25,059 --> 00:59:28,219
Let's take a look.

1780
00:59:25,059 --> 00:59:28,219
<font color="#ffff54">한번 살펴봅시다.</font>

1781
00:59:28,219 --> 00:59:31,519
We are reading the kernel logs.

1782
00:59:28,219 --> 00:59:31,519
<font color="#ffff54">커널 로그를 읽고 있습니다.</font>

1783
00:59:31,519 --> 00:59:33,179
There you go.

1784
00:59:31,519 --> 00:59:33,179
<font color="#ffff54">여기까지입니다.</font>

1785
00:59:33,179 --> 00:59:39,179
We see curl got packaged from something to something.

1786
00:59:33,179 --> 00:59:39,179
<font color="#ffff54">컬이 무언가에서 무언가로 패키징된 것을 볼 수 있습니다.</font>

1787
00:59:39,179 --> 00:59:42,219
Okay, there you go.

1788
00:59:39,179 --> 00:59:42,219
<font color="#ffff54">이제 됐어요.</font>

1789
00:59:42,219 --> 00:59:49,699
Our first eBPF code, it just printed something, it just got automatically using our CNI, we

1790
00:59:42,219 --> 00:59:49,699
<font color="#ffff54">우리의 첫 번째 eBPF 코드, 방금 무언가를 인쇄했습니다. CNI를 사용하여 자동으로 가져옵니다.</font>

1791
00:59:49,699 --> 00:59:54,980
not only created all the networking things, all the networking components for the plugin

1792
00:59:49,699 --> 00:59:54,980
<font color="#ffff54">모든 네트워킹을 만들었을 뿐만 아니라 플러그인을 위한 모든 네트워킹 구성 요소를 만들었습니다.</font>

1793
00:59:54,980 --> 00:59:59,099
for, sorry, for the pod to be wired correctly, so we can interact with it.

1794
00:59:54,980 --> 00:59:59,099
<font color="#ffff54">파드와 상호 작용할 수 있도록 올바르게 연결해야 한다.</font>

1795
00:59:59,119 --> 01:00:04,159
But we also loaded an XDP code for us to do stuff on it, right?

1796
00:59:59,119 --> 01:00:04,159
<font color="#ffff54">하지만 우리가 뭔가를 할 수 있도록 XDP 코드도 로드했죠?</font>

1797
01:00:04,159 --> 01:00:10,679
We haven't done yet nothing, we just logged some of the source and the destination address,

1798
01:00:04,159 --> 01:00:10,679
<font color="#ffff54">아직 아무 것도 하지 않았고, 소스 주소와 목적지 주소를 일부 기록했을 뿐입니다,</font>

1799
01:00:10,679 --> 01:00:13,360
but now let's do some interesting things.

1800
01:00:10,679 --> 01:00:13,360
<font color="#ffff54">하지만 이제 흥미로운 일을 해봅시다.</font>

1801
01:00:13,360 --> 01:00:21,759
All right, so the next section, the next exercise is to use eBPF for different scenarios.

1802
01:00:13,360 --> 01:00:21,759
<font color="#ffff54">자, 다음 섹션에서는 다양한 시나리오에 대해 eBPF를 사용해 보겠습니다.</font>

1803
01:00:21,759 --> 01:00:26,360
eBPF, again, can be used for multiple things.

1804
01:00:21,759 --> 01:00:26,360
<font color="#ffff54">다시 한 번 말씀드리지만, eBPF는 여러 가지 용도로 사용할 수 있습니다.</font>

1805
01:00:26,380 --> 01:00:33,620
The main three things that we can think about in networking is eBPF can be used for monitoring,

1806
01:00:26,380 --> 01:00:33,620
<font color="#ffff54">네트워킹에서 생각할 수 있는 세 가지 주요 사항은 eBPF가 모니터링에 사용될 수 있다는 것입니다,</font>

1807
01:00:33,620 --> 01:00:39,200
so you can have metrics and stats around your traffic.

1808
01:00:33,620 --> 01:00:39,200
<font color="#ffff54">트래픽에 대한 지표와 통계를 얻을 수 있습니다.</font>

1809
01:00:39,200 --> 01:00:48,300
It can be used for security, so to block calls that you don't want or traffic from A to B

1810
01:00:39,200 --> 01:00:48,300
<font color="#ffff54">보안을 위해 원치 않는 통화나 A에서 B로의 트래픽을 차단하는 데 사용할 수 있습니다.</font>

1811
01:00:48,300 --> 01:00:53,620
without interrupting basically packets that are not meant to be sent from A to B, for

1812
01:00:48,300 --> 01:00:53,620
<font color="#ffff54">기본적으로 A에서 B로 보내지 말아야 할 패킷을 방해하지 않고</font>

1813
01:00:53,620 --> 01:00:54,620
example.

1814
01:00:53,620 --> 01:00:54,620
<font color="#ffff54">예시.</font>

1815
01:00:54,639 --> 01:01:00,839
The third aspect, or rate limiting actually, or a lot of controls basically can do in security.

1816
01:00:54,639 --> 01:01:00,839
<font color="#ffff54">세 번째 측면, 즉 실제로 속도를 제한하는 것은 보안에서 기본적으로 할 수 있는 많은 제어입니다.</font>

1817
01:01:00,839 --> 01:01:02,679
The third aspect is routing.

1818
01:01:00,839 --> 01:01:02,679
<font color="#ffff54">세 번째 측면은 라우팅입니다.</font>

1819
01:01:02,679 --> 01:01:09,079
Routing, for example, in Selium, I showed you the data earlier, Selium uses it as a

1820
01:01:02,679 --> 01:01:09,079
<font color="#ffff54">라우팅은 예를 들어, 앞서 데이터를 보여드린 셀리움에서, 셀리움은 이를</font>

1821
01:01:09,079 --> 01:01:11,460
replacement of kube-proxy.

1822
01:01:09,079 --> 01:01:11,460
<font color="#ffff54">kube-proxy로 대체합니다.</font>

1823
01:01:11,460 --> 01:01:17,519
You don't need actually to use IPVS or IP tables for routing.

1824
01:01:11,460 --> 01:01:17,519
<font color="#ffff54">라우팅을 위해 실제로 IPVS나 IP 테이블을 사용할 필요는 없다.</font>

1825
01:01:17,519 --> 01:01:22,460
IP tables being, they got created for firewalling, not actually for traffic routing.

1826
01:01:17,519 --> 01:01:22,460
<font color="#ffff54">IP 테이블은 방화벽을 위해 만들어진 것이지 트래픽 라우팅을 위해 만들어진 것이 아니기 때문입니다.</font>

1827
01:01:22,460 --> 01:01:28,159
You can use eBPF and XDP in this case to get way faster traffic routing.

1828
01:01:22,460 --> 01:01:28,159
<font color="#ffff54">이 경우 eBPF와 XDP를 사용하면 훨씬 빠른 트래픽 라우팅을 얻을 수 있습니다.</font>

1829
01:01:28,159 --> 01:01:32,760
In our example in today's workshop, we're going to probably focus on the two things,

1830
01:01:28,159 --> 01:01:32,760
<font color="#ffff54">오늘 워크숍의 예제에서는 이 두 가지에 중점을 두겠습니다,</font>

1831
01:01:32,760 --> 01:01:40,559
monitoring and we're going to focus on security, like a small example.

1832
01:01:32,760 --> 01:01:40,559
<font color="#ffff54">모니터링과 작은 예제처럼 보안에 초점을 맞출 것입니다.</font>

1833
01:01:40,559 --> 01:01:47,039
So before we start talking about, before we start talking about monitoring in details,

1834
01:01:40,559 --> 01:01:47,039
<font color="#ffff54">모니터링에 대해 자세히 이야기하기 전에, 먼저 보안에 대해 이야기하겠습니다,</font>

1835
01:01:47,420 --> 01:01:55,699
actually something we haven't talked about yet is the, you know, I talked about eBPF

1836
01:01:47,420 --> 01:01:55,699
<font color="#ffff54">사실 우리가 아직 이야기하지 않은 것은, 제가 말씀드린 eBPF입니다.</font>

1837
01:01:55,699 --> 01:02:01,860
running in the sandbox in the kernel code, but you cannot get data out of that.

1838
01:01:55,699 --> 01:02:01,860
<font color="#ffff54">커널 코드의 샌드박스에서 실행되지만 거기서 데이터를 가져올 수 없다는 것입니다.</font>

1839
01:02:01,860 --> 01:02:06,860
You know, kernel is basically an isolation in our system.

1840
01:02:01,860 --> 01:02:06,860
<font color="#ffff54">커널은 기본적으로 우리 시스템에서 격리되어 있습니다.</font>

1841
01:02:06,860 --> 01:02:11,059
There's no way to interact directly to get metrics or whatever.

1842
01:02:06,860 --> 01:02:11,059
<font color="#ffff54">메트릭 등을 얻기 위해 직접 상호작용할 수 있는 방법이 없습니다.</font>

1843
01:02:11,059 --> 01:02:16,360
In our user space, user space is basically everything you run on your node, everything

1844
01:02:11,059 --> 01:02:16,360
<font color="#ffff54">사용자 공간에서 사용자 공간은 기본적으로 노드에서 실행하는 모든 것, 모든 것을 의미합니다.</font>

1845
01:02:16,380 --> 01:02:20,340
you create, that's user space.

1846
01:02:16,380 --> 01:02:20,340
<font color="#ffff54">생성하는 모든 것이 사용자 공간입니다.</font>

1847
01:02:20,340 --> 01:02:25,660
Now a user space program cannot interact directly with the kernel space program.

1848
01:02:20,340 --> 01:02:25,660
<font color="#ffff54">이제 사용자 공간 프로그램은 커널 공간 프로그램과 직접 상호작용할 수 없습니다.</font>

1849
01:02:25,660 --> 01:02:33,740
The way they interact and interchange data is to use what we call a BPF map.

1850
01:02:25,660 --> 01:02:33,740
<font color="#ffff54">이 둘이 상호작용하고 데이터를 교환하는 방식은 BPF 맵이라고 부르는 것을 사용하는 것입니다.</font>

1851
01:02:33,740 --> 01:02:38,820
A BPF map, like it says here, it's just a map, a certain type of map.

1852
01:02:33,740 --> 01:02:38,820
<font color="#ffff54">BPF 맵은 여기에 나와 있듯이 그냥 지도, 특정 유형의 지도일 뿐입니다.</font>

1853
01:02:38,820 --> 01:02:41,940
You can do like a ring buffer for streaming data.

1854
01:02:38,820 --> 01:02:41,940
<font color="#ffff54">스트리밍 데이터를 위한 링 버퍼처럼 사용할 수 있습니다.</font>

1855
01:02:41,940 --> 01:02:44,780
You can do hash maps for key value storage.

1856
01:02:41,940 --> 01:02:44,780
<font color="#ffff54">키 값 저장을 위해 해시 맵을 사용할 수 있습니다.</font>

1857
01:02:44,800 --> 01:02:49,560
You can do arrays for just like saving a random number of things.

1858
01:02:44,800 --> 01:02:49,560
<font color="#ffff54">임의의 숫자를 저장하는 것처럼 배열을 할 수 있습니다.</font>

1859
01:02:49,560 --> 01:02:54,600
Basically you define a map and then now the kernel space, the eBPF program that we wrote

1860
01:02:49,560 --> 01:02:54,600
<font color="#ffff54">기본적으로 맵을 정의하고 이제 커널 공간, 우리가 작성한 eBPF 프로그램을 정의합니다.</font>

1861
01:02:54,600 --> 01:02:59,600
can write to that, can write to that map and actually the user space program can also write

1862
01:02:54,600 --> 01:02:59,600
<font color="#ffff54">에 쓸 수 있고, 그 맵에 쓸 수 있고, 실제로 사용자 공간 프로그램도 쓸 수 있습니다.</font>

1863
01:02:59,600 --> 01:03:02,240
to that map, read write in both directions.

1864
01:02:59,600 --> 01:03:02,240
<font color="#ffff54">에 양방향으로 읽을 수 있습니다.</font>

1865
01:03:02,240 --> 01:03:06,760
The user space program can read and write to the map and same thing for the kernel space

1866
01:03:02,240 --> 01:03:06,760
<font color="#ffff54">사용자 공간 프로그램은 맵을 읽고 쓸 수 있으며 커널 공간에 대해서도 마찬가지입니다.</font>

1867
01:03:06,760 --> 01:03:09,000
program.

1868
01:03:06,760 --> 01:03:09,000
<font color="#ffff54">프로그램.</font>

1869
01:03:09,000 --> 01:03:12,920
So what we are going to do in the next exercise?

1870
01:03:09,000 --> 01:03:12,920
<font color="#ffff54">다음 연습에서는 무엇을 할까요?</font>

1871
01:03:12,940 --> 01:03:15,260
We created already our BPF code.

1872
01:03:12,940 --> 01:03:15,260
<font color="#ffff54">이미 BPF 코드를 만들었습니다.</font>

1873
01:03:15,260 --> 01:03:19,200
We just demoed a log to the kernel.

1874
01:03:15,260 --> 01:03:19,200
<font color="#ffff54">방금 커널에 대한 로그를 데모했습니다.</font>

1875
01:03:19,200 --> 01:03:21,980
Now let's do something a bit more interesting.

1876
01:03:19,200 --> 01:03:21,980
<font color="#ffff54">이제 좀 더 흥미로운 것을 해봅시다.</font>

1877
01:03:21,980 --> 01:03:25,300
What we are going to do is a couple steps.

1878
01:03:21,980 --> 01:03:25,300
<font color="#ffff54">몇 단계만 거치면 됩니다.</font>

1879
01:03:25,300 --> 01:03:26,579
We are going to capture the traffic.

1880
01:03:25,300 --> 01:03:26,579
<font color="#ffff54">트래픽을 캡처하겠습니다.</font>

1881
01:03:26,579 --> 01:03:30,119
I mean we did that earlier, same thing.

1882
01:03:26,579 --> 01:03:30,119
<font color="#ffff54">아까도 똑같이 했잖아요.</font>

1883
01:03:30,119 --> 01:03:37,340
We are going to basically write the number of packets that we receive from a certain

1884
01:03:30,119 --> 01:03:37,340
<font color="#ffff54">우리는 기본적으로 특정 패킷으로부터 받는 패킷의 수를 기록할 것입니다.</font>

1885
01:03:37,340 --> 01:03:39,180
source in the map.

1886
01:03:37,340 --> 01:03:39,180
<font color="#ffff54">소스로부터 받은 패킷 수입니다.</font>

1887
01:03:39,680 --> 01:03:43,520
We are going to create basically a map first before all that but then we are going to create

1888
01:03:39,680 --> 01:03:43,520
<font color="#ffff54">그 전에 기본적으로 맵을 먼저 생성한 다음 다음을 생성하겠습니다.</font>

1889
01:03:43,520 --> 01:03:48,680
the number of packets we receive from a certain source in a map and then we are going to use

1890
01:03:43,520 --> 01:03:48,680
<font color="#ffff54">맵에서 특정 소스로부터 수신하는 패킷의 수를 계산한 다음</font>

1891
01:03:48,680 --> 01:03:56,000
what we call user space program to go and read a certain map and expose that as metrics

1892
01:03:48,680 --> 01:03:56,000
<font color="#ffff54">사용자 공간 프로그램이라고 부르는 것을 사용하여 특정 지도를 읽고 이를 메트릭으로 노출합니다.</font>

1893
01:03:56,000 --> 01:03:57,720
that we can see in Prometheus.

1894
01:03:56,000 --> 01:03:57,720
<font color="#ffff54">프로메테우스에서 볼 수 있습니다.</font>

1895
01:03:57,720 --> 01:04:04,800
That is basically full cycle around monitoring and all that needs to be loaded using our

1896
01:03:57,720 --> 01:04:04,800
<font color="#ffff54">이것은 기본적으로 모니터링과 관련된 전체 사이클이며, 우리의</font>

1897
01:04:04,800 --> 01:04:06,400
CNI.

1898
01:04:04,800 --> 01:04:06,400
<font color="#ffff54">CNI.</font>

1899
01:04:06,400 --> 01:04:07,400
So let's go.

1900
01:04:06,400 --> 01:04:07,400
<font color="#ffff54">그럼 가자.</font>

1901
01:04:07,400 --> 01:04:08,400
Let's do it.

1902
01:04:07,400 --> 01:04:08,400
<font color="#ffff54">해보자.</font>

1903
01:04:09,700 --> 01:04:14,040
So the first step here, click on next.

1904
01:04:09,700 --> 01:04:14,040
<font color="#ffff54">첫 번째 단계는 다음을 클릭하세요.</font>

1905
01:04:17,480 --> 01:04:18,480
All right.

1906
01:04:17,480 --> 01:04:18,480
<font color="#ffff54">알았어요.</font>

1907
01:04:19,480 --> 01:04:21,480
Man, who is tired here?

1908
01:04:19,480 --> 01:04:21,480
<font color="#ffff54">이봐, 누가 피곤해?</font>

1909
01:04:21,480 --> 01:04:27,480
I mean 5.30 in the afternoon I get you.

1910
01:04:21,480 --> 01:04:27,480
<font color="#ffff54">내 말은 오후 5시 반에 데리러 갈게.</font>

1911
01:04:27,480 --> 01:04:28,480
All right.

1912
01:04:27,480 --> 01:04:28,480
<font color="#ffff54">알았어.</font>

1913
01:04:28,480 --> 01:04:34,960
So let's create the map.

1914
01:04:28,480 --> 01:04:34,960
<font color="#ffff54">그럼 지도를 만들어 봅시다.</font>

1915
01:04:34,960 --> 01:04:37,180
The map is pretty straightforward.

1916
01:04:34,960 --> 01:04:37,180
<font color="#ffff54">지도는 꽤 간단합니다.</font>

1917
01:04:37,180 --> 01:04:41,480
What we have to do is define a structure in a certain way, define the values we need

1918
01:04:37,180 --> 01:04:41,480
<font color="#ffff54">우리가 해야 할 일은 특정 방식으로 구조를 정의하고 필요한 값을 정의하는 것입니다.</font>

1919
01:04:41,480 --> 01:04:46,920
to store in and label it a certain way and that basically what creates a map.

1920
01:04:41,480 --> 01:04:46,920
<font color="#ffff54">저장하고 특정 방식으로 레이블을 지정하면 기본적으로 맵이 만들어집니다.</font>

1921
01:04:46,920 --> 01:04:56,560
So in our case here, we go back to the editor, take a look at the code.

1922
01:04:46,920 --> 01:04:56,560
<font color="#ffff54">여기서는 편집기로 돌아가서 코드를 살펴봅니다.</font>

1923
01:04:56,560 --> 01:04:57,560
There you go.

1924
01:04:56,560 --> 01:04:57,560
<font color="#ffff54">여기까지입니다.</font>

1925
01:04:57,560 --> 01:05:00,420
This is the new code of basically the monitoring.

1926
01:04:57,560 --> 01:05:00,420
<font color="#ffff54">이것은 기본적으로 모니터링의 새로운 코드입니다.</font>

1927
01:05:00,420 --> 01:05:06,680
So what we do first is defining the structure that is basically defining the key value and

1928
01:05:00,420 --> 01:05:06,680
<font color="#ffff54">그래서 우리가 먼저 하는 일은 기본적으로 키 값을 정의하는 구조를 정의하고</font>

1929
01:05:06,680 --> 01:05:07,680
we give it a name.

1930
01:05:06,680 --> 01:05:07,680
<font color="#ffff54">이름을 지정합니다.</font>

1931
01:05:07,680 --> 01:05:09,360
We call that counter.

1932
01:05:07,680 --> 01:05:09,360
<font color="#ffff54">우리는 그것을 카운터라고 부릅니다.</font>

1933
01:05:09,360 --> 01:05:10,440
That's our map name.

1934
01:05:09,360 --> 01:05:10,440
<font color="#ffff54">이것이 우리 지도 이름입니다.</font>

1935
01:05:10,440 --> 01:05:13,300
It's called counter, okay?

1936
01:05:10,440 --> 01:05:13,300
<font color="#ffff54">카운터라고 해요.</font>

1937
01:05:13,300 --> 01:05:22,480
We define that is basically storing a key size of U32 and a value size of U64.

1938
01:05:13,300 --> 01:05:22,480
<font color="#ffff54">기본적으로 키 크기 U32와 값 크기 U64를 저장하는 것으로 정의합니다.</font>

1939
01:05:22,480 --> 01:05:23,480
That's it.

1940
01:05:22,480 --> 01:05:23,480
<font color="#ffff54">끝입니다.</font>

1941
01:05:23,480 --> 01:05:29,540
Think about it as a hash map, has a key value pair where the key is a certain size, the

1942
01:05:23,480 --> 01:05:29,540
<font color="#ffff54">해시 맵이라고 생각하면, 키가 특정 크기인 키 값 쌍이 있습니다.</font>

1943
01:05:29,540 --> 01:05:30,680
value is a certain size.

1944
01:05:29,540 --> 01:05:30,680
<font color="#ffff54">값은 특정 크기입니다.</font>

1945
01:05:30,680 --> 01:05:32,240
Very simple.

1946
01:05:30,680 --> 01:05:32,240
<font color="#ffff54">아주 간단합니다.</font>

1947
01:05:33,240 --> 01:05:38,660
Now same thing as all our code from earlier, so we don't really care about this.

1948
01:05:33,240 --> 01:05:38,660
<font color="#ffff54">이제 앞서의 모든 코드와 동일하므로 크게 신경 쓰지 않아도 됩니다.</font>

1949
01:05:38,660 --> 01:05:44,560
The only thing actually we care about is after now at this point since we actually have the

1950
01:05:38,660 --> 01:05:44,560
<font color="#ffff54">실제로 우리가 신경 쓰는 것은 지금 이 시점 이후입니다.</font>

1951
01:05:44,560 --> 01:05:49,840
source address of packets, let's put that in the value and call that source IP key.

1952
01:05:44,560 --> 01:05:49,840
<font color="#ffff54">패킷의 소스 주소가 있으므로 이를 값에 넣고 해당 소스 IP 키를 호출해 보겠습니다.</font>

1953
01:05:49,840 --> 01:05:58,680
So the key is the source of a certain packet, so the IP address of a certain packet.

1954
01:05:49,840 --> 01:05:58,680
<font color="#ffff54">키는 특정 패킷의 소스이므로 특정 패킷의 IP 주소입니다.</font>

1955
01:05:59,120 --> 01:06:05,920
Every time we basically are going to run this method here that comes with libBPF, again

1956
01:05:59,120 --> 01:06:05,920
<font color="#ffff54">여기서 기본적으로 libBPF와 함께 제공되는 이 메서드를 실행할 때마다 다시 한 번</font>

1957
01:06:05,920 --> 01:06:10,920
I'm using this library called libBPF, they're going to give us access to the map so you

1958
01:06:05,920 --> 01:06:10,920
<font color="#ffff54">저는 libBPF라는 라이브러리를 사용하고 있는데, 이 라이브러리는 우리에게 지도에 대한 접근 권한을 줄 것입니다.</font>

1959
01:06:10,920 --> 01:06:15,880
can just call the BPF map and look for the key.

1960
01:06:10,920 --> 01:06:15,880
<font color="#ffff54">BPF 맵을 호출하고 키를 찾을 수 있습니다.</font>

1961
01:06:15,880 --> 01:06:20,760
If this key which is the source address exists, just increment it.

1962
01:06:15,880 --> 01:06:20,760
<font color="#ffff54">소스 주소인 이 키가 존재하면 이 키를 증가시키면 됩니다.</font>

1963
01:06:20,760 --> 01:06:24,000
Just say, okay, well I got one more packet, another packet.

1964
01:06:20,760 --> 01:06:24,000
<font color="#ffff54">알았어, 패킷이 하나 더 왔어, 또 패킷이 왔어.</font>

1965
01:06:24,000 --> 01:06:27,540
Every time I see the key, increment the value.

1966
01:06:24,000 --> 01:06:27,540
<font color="#ffff54">키가 보일 때마다 값을 증가시켜.</font>

1967
01:06:27,539 --> 01:06:32,259
If it doesn't actually exist, well just say, hey, I received my first packet.

1968
01:06:27,539 --> 01:06:32,259
<font color="#ffff54">실제로 존재하지 않는다면, 그냥 첫 번째 패킷을 받았다고 말하세요.</font>

1969
01:06:32,259 --> 01:06:35,420
Again, if-else, very basic here.

1970
01:06:32,259 --> 01:06:35,420
<font color="#ffff54">다시 말하지만, 만약-그렇지 않다면, 아주 기본입니다.</font>

1971
01:06:35,420 --> 01:06:42,219
And then we do return XDP pass which means forward this packet, let it go, let it continue

1972
01:06:35,420 --> 01:06:42,219
<font color="#ffff54">그리고 나서 이 패킷을 전달하고, 보내주고, 계속 보내주는 것을 의미하는 XDP 패스를 반환합니다.</font>

1973
01:06:42,219 --> 01:06:44,019
on the networking here.

1974
01:06:42,219 --> 01:06:44,019
<font color="#ffff54">여기 네트워킹에서.</font>

1975
01:06:44,019 --> 01:06:47,179
So we're going to do the same exact step we did earlier.

1976
01:06:44,019 --> 01:06:47,179
<font color="#ffff54">이제 앞에서 했던 것과 똑같은 단계를 수행하겠습니다.</font>

1977
01:06:47,180 --> 01:07:01,380
So we're going to build our BPF code and then we loaded it again.

1978
01:06:47,180 --> 01:07:01,380
<font color="#ffff54">BPF 코드를 빌드한 다음 다시 로드합니다.</font>

1979
01:07:01,380 --> 01:07:04,260
So we kind of did a reload here.

1980
01:07:01,380 --> 01:07:04,260
<font color="#ffff54">여기서 다시 로드했습니다.</font>

1981
01:07:04,260 --> 01:07:08,860
And we don't have to modify our CNI because it's actually pointing the same value, slash

1982
01:07:04,260 --> 01:07:08,860
<font color="#ffff54">그리고 CNI는 실제로 동일한 값인 슬래시를 가리키고 있기 때문에 수정할 필요가 없습니다.</font>

1983
01:07:08,860 --> 01:07:13,100
sys fs BPF eBPF CNI.

1984
01:07:08,860 --> 01:07:13,100
<font color="#ffff54">sys fs BPF eBPF CNI.</font>

1985
01:07:13,099 --> 01:07:21,059
All right, so let's delete the pods just for us to force them to restart with this

1986
01:07:13,099 --> 01:07:21,059
<font color="#ffff54">좋아, 이제 파드를 삭제하여 다음과 같이 강제로 재시작해 보자.</font>

1987
01:07:21,059 --> 01:07:24,779
new code we just created.

1988
01:07:21,059 --> 01:07:24,779
<font color="#ffff54">방금 생성한 새 코드.</font>

1989
01:07:24,779 --> 01:07:30,900
Take about a second here to create the new pods for us and we're going to see what happens.

1990
01:07:24,779 --> 01:07:30,900
<font color="#ffff54">여기서 잠시 시간을 내어 새 파드를 생성하고 어떤 일이 일어나는지 살펴보겠습니다.</font>

1991
01:07:30,900 --> 01:07:38,319
All right, so the two pods being recreated, now let's send a packet, let's send some traffic.

1992
01:07:30,900 --> 01:07:38,319
<font color="#ffff54">자, 두 개의 파드가 다시 생성되었으니 이제 패킷을 보내서 트래픽을 전송해 봅시다.</font>

1993
01:07:38,320 --> 01:07:46,160
So we're going to do a curl call from the sleep pod to the HTTP bin pod.

1994
01:07:38,320 --> 01:07:46,160
<font color="#ffff54">이제 슬립 파드에서 HTTP 빈 파드로 컬 호출을 할 것입니다.</font>

1995
01:07:46,160 --> 01:07:47,640
There you go, I'm getting some results.

1996
01:07:46,160 --> 01:07:47,640
<font color="#ffff54">이제 결과가 나옵니다.</font>

1997
01:07:47,640 --> 01:07:49,920
I can run this a couple of times, it doesn't really matter.

1998
01:07:47,640 --> 01:07:49,920
<font color="#ffff54">몇 번 실행해도 상관없어요.</font>

1999
01:07:49,920 --> 01:07:59,880
Oops, I actually deleted my pods but yeah, I have to, oops, where's my curl?

2000
01:07:49,920 --> 01:07:59,880
<font color="#ffff54">웁스, 사실 내 포드를 삭제했는데 그래야겠어, 웁스, 내 컬은 어디 있지?</font>

2001
01:07:59,880 --> 01:08:04,640
Yeah, so let's do this.

2002
01:07:59,880 --> 01:08:04,640
<font color="#ffff54">그래, 그럼 해보자.</font>

2003
01:08:04,640 --> 01:08:06,960
All right.

2004
01:08:04,640 --> 01:08:06,960
<font color="#ffff54">알았어요.</font>

2005
01:08:06,960 --> 01:08:09,559
I'm getting some returns.

2006
01:08:06,960 --> 01:08:09,559
<font color="#ffff54">반송이 좀 있습니다.</font>

2007
01:08:09,559 --> 01:08:15,720
Now if I use this BPF tool map that's going to dump the values under the counter, again

2008
01:08:09,559 --> 01:08:15,720
<font color="#ffff54">이제 카운터 아래에 값을 덤프하는 이 BPF 도구 맵을 사용하면 다음과 같이 다시 나타납니다.</font>

2009
01:08:15,720 --> 01:08:19,920
I created the map, I called it counter, okay, so it's automatically now loaded.

2010
01:08:15,720 --> 01:08:19,920
<font color="#ffff54">맵을 만들고 카운터라고 이름을 붙였으니 이제 자동으로 로드됩니다.</font>

2011
01:08:19,920 --> 01:08:23,480
If I run this command, there you go.

2012
01:08:19,920 --> 01:08:23,480
<font color="#ffff54">이 명령을 실행하면 됩니다.</font>

2013
01:08:23,480 --> 01:08:31,039
I see now two elements, two values in my BPF map.

2014
01:08:23,480 --> 01:08:31,039
<font color="#ffff54">이제 BPF 맵에 두 개의 요소, 두 개의 값이 표시됩니다.</font>

2015
01:08:31,039 --> 01:08:36,800
So every time I'm running some traffic within my V8 pair, now a certain value is getting

2016
01:08:31,039 --> 01:08:36,800
<font color="#ffff54">따라서 내 V8 쌍 내에서 트래픽을 실행할 때마다 이제 특정 값이</font>

2017
01:08:36,800 --> 01:08:39,039
incremented in my counter.

2018
01:08:36,800 --> 01:08:39,039
<font color="#ffff54">내 카운터에서 증가합니다.</font>

2019
01:08:39,039 --> 01:08:40,560
You saw the power here?

2020
01:08:39,039 --> 01:08:40,560
<font color="#ffff54">여기서 힘을 보셨나요?</font>

2021
01:08:40,560 --> 01:08:48,600
Basically we did pretty much nothing to get certain metrics out of eBPF.

2022
01:08:40,560 --> 01:08:48,600
<font color="#ffff54">기본적으로 우리는 eBPF에서 특정 지표를 얻기 위해 거의 아무것도 하지 않았습니다.</font>

2023
01:08:48,600 --> 01:08:53,360
Actually now let's use what we call a user space program.

2024
01:08:48,600 --> 01:08:53,360
<font color="#ffff54">이제 사용자 공간 프로그램이라고 부르는 것을 사용해 보겠습니다.</font>

2025
01:08:53,360 --> 01:08:58,020
User space program again is a way for us to interact with eBPF.

2026
01:08:53,360 --> 01:08:58,020
<font color="#ffff54">사용자 공간 프로그램은 우리가 eBPF와 상호작용할 수 있는 방법입니다.</font>

2027
01:08:58,020 --> 01:09:06,760
We are going to use this cool project I found online called eBPF exporter, right?

2028
01:08:58,020 --> 01:09:06,760
<font color="#ffff54">온라인에서 찾은 멋진 프로젝트인 eBPF 익스포터를 사용할 거죠?</font>

2029
01:09:06,760 --> 01:09:08,480
It's on GitHub.

2030
01:09:06,760 --> 01:09:08,480
<font color="#ffff54">깃허브에 있어요.</font>

2031
01:09:08,480 --> 01:09:12,039
It allows us to automatically go and read an eBPF map.

2032
01:09:08,480 --> 01:09:12,039
<font color="#ffff54">자동으로 eBPF 지도를 읽을 수 있습니다.</font>

2033
01:09:12,039 --> 01:09:15,000
We don't have to write any code.

2034
01:09:12,039 --> 01:09:15,000
<font color="#ffff54">코드를 작성할 필요가 없습니다.</font>

2035
01:09:15,000 --> 01:09:16,260
So this is running.

2036
01:09:15,000 --> 01:09:16,260
<font color="#ffff54">실행 중입니다.</font>

2037
01:09:16,260 --> 01:09:20,680
So if I do this curl localhost, there you go.

2038
01:09:16,260 --> 01:09:20,680
<font color="#ffff54">이제 로컬호스트를 컬하면 끝입니다.</font>

2039
01:09:20,680 --> 01:09:21,680
See that?

2040
01:09:20,680 --> 01:09:21,680
<font color="#ffff54">보이시죠?</font>

2041
01:09:21,680 --> 01:09:30,000
Now automatically now I have Prometheus metrics that is representing the BPF code, the BPF

2042
01:09:21,680 --> 01:09:30,000
<font color="#ffff54">이제 자동으로 BPF 코드를 나타내는 Prometheus 메트릭이 생겼습니다.</font>

2043
01:09:30,000 --> 01:09:32,100
metrics as Prometheus metrics.

2044
01:09:30,000 --> 01:09:32,100
<font color="#ffff54">메트릭이 프로메테우스 메트릭으로 표시됩니다.</font>

2045
01:09:32,100 --> 01:09:38,320
And actually I can even use Prometheus here to capture that.

2046
01:09:32,100 --> 01:09:38,320
<font color="#ffff54">실제로 여기서도 Prometheus를 사용하여 이를 캡처할 수 있습니다.</font>

2047
01:09:38,320 --> 01:09:41,020
There you go.

2048
01:09:38,320 --> 01:09:41,020
<font color="#ffff54">여기 있네요.</font>

2049
01:09:41,020 --> 01:09:50,260
If I restart Prometheus, now if I go to Prometheus, right?

2050
01:09:41,020 --> 01:09:50,260
<font color="#ffff54">프로메테우스를 다시 시작하면 이제 프로메테우스로 갈 수 있죠?</font>

2051
01:09:50,260 --> 01:09:56,020
Let's take a look at what we have.

2052
01:09:50,260 --> 01:09:56,020
<font color="#ffff54">우리가 가진 것을 살펴봅시다.</font>

2053
01:09:56,020 --> 01:10:08,100
Now we can do, let's see, counter.

2054
01:09:56,020 --> 01:10:08,100
<font color="#ffff54">이제 카운터를 해봅시다.</font>

2055
01:10:08,100 --> 01:10:15,420
See what we have here.

2056
01:10:08,100 --> 01:10:15,420
<font color="#ffff54">여기 뭐가 있는지 보세요.</font>

2057
01:10:15,420 --> 01:10:18,340
I think it's called.

2058
01:10:15,420 --> 01:10:18,340
<font color="#ffff54">호출된 것 같아요.</font>

2059
01:10:18,340 --> 01:10:25,260
Do you see it?

2060
01:10:18,340 --> 01:10:25,260
<font color="#ffff54">보여요?</font>

2061
01:10:25,260 --> 01:10:26,260
Oh.

2062
01:10:25,260 --> 01:10:26,260
<font color="#ffff54">오</font>

2063
01:10:26,260 --> 01:10:41,579
Did I put the metric name here?

2064
01:10:26,260 --> 01:10:41,579
<font color="#ffff54">내가 여기에 메트릭 이름을 넣었나요?</font>

2065
01:10:41,579 --> 01:10:44,340
Oh.

2066
01:10:41,579 --> 01:10:44,340
<font color="#ffff54">오</font>

2067
01:10:44,340 --> 01:10:48,340
Oh, OK.

2068
01:10:44,340 --> 01:10:48,340
<font color="#ffff54">오, 알았어.</font>

2069
01:10:48,340 --> 01:10:49,340
I do things right sometimes.

2070
01:10:48,340 --> 01:10:49,340
<font color="#ffff54">난 때때로 옳은 일을 한다.</font>

2071
01:10:49,340 --> 01:10:50,340
I just don't realize.

2072
01:10:49,340 --> 01:10:50,340
<font color="#ffff54">나는 단지 깨닫지 못할 뿐이다.</font>

2073
01:10:50,340 --> 01:10:57,619
It just, OK, great.

2074
01:10:50,340 --> 01:10:57,619
<font color="#ffff54">그냥, 알았어.</font>

2075
01:10:57,619 --> 01:11:01,579
So you see here we have the two metrics coming back in awesome.

2076
01:10:57,619 --> 01:11:01,579
<font color="#ffff54">두 가지 메트릭이 멋지게 돌아온 것을 볼 수 있습니다.</font>

2077
01:11:01,579 --> 01:11:06,779
So here if you do like in there, I don't know, like five minutes and take a look.

2078
01:11:01,579 --> 01:11:06,779
<font color="#ffff54">여기서 5분 정도만 시간을 내서 살펴보세요.</font>

2079
01:11:06,779 --> 01:11:07,779
Look.

2080
01:11:06,779 --> 01:11:07,779
<font color="#ffff54">봐봐.</font>

2081
01:11:07,779 --> 01:11:09,220
You see that?

2082
01:11:07,779 --> 01:11:09,220
<font color="#ffff54">저거 보여?</font>

2083
01:11:09,220 --> 01:11:15,860
We built a CNI plugin and we built some eBPF code that go and count packets, automatically

2084
01:11:09,220 --> 01:11:15,860
<font color="#ffff54">우리는 CNI 플러그인을 만들었고 패킷을 자동으로 계산하는 eBPF 코드를 만들었습니다.</font>

2085
01:11:15,860 --> 01:11:20,039
load that and now we can see that in Prometheus.

2086
01:11:15,860 --> 01:11:20,039
<font color="#ffff54">로드하면 이제 Prometheus에서 확인할 수 있습니다.</font>

2087
01:11:20,039 --> 01:11:22,579
We did that in, you know, let's say session.

2088
01:11:20,039 --> 01:11:22,579
<font color="#ffff54">세션에서 이 작업을 수행했습니다.</font>

2089
01:11:22,579 --> 01:11:31,159
So basically on eBPF, with eBPF we can do things very low level, super fast.

2090
01:11:22,579 --> 01:11:31,159
<font color="#ffff54">기본적으로 eBPF를 사용하면 매우 낮은 수준의 작업을 매우 빠르게 수행할 수 있습니다.</font>

2091
01:11:31,159 --> 01:11:32,680
You can think about that.

2092
01:11:31,159 --> 01:11:32,680
<font color="#ffff54">그렇게 생각할 수 있습니다.</font>

2093
01:11:32,680 --> 01:11:34,079
Think about things you can do here.

2094
01:11:32,680 --> 01:11:34,079
<font color="#ffff54">여기서 할 수 있는 일을 생각해 보세요.</font>

2095
01:11:34,079 --> 01:11:41,239
OK, here was a very basic example, but now you can write the C code to do probably anything

2096
01:11:34,079 --> 01:11:41,239
<font color="#ffff54">아주 기본적인 예제였지만, 이제 C 코드를 작성해 다음과 같은 작업을 수행할 수 있습니다.</font>

2097
01:11:41,239 --> 01:11:43,359
you want with the packets.

2098
01:11:41,239 --> 01:11:43,359
<font color="#ffff54">패킷으로 원하는 모든 것을 할 수 있습니다.</font>

2099
01:11:43,359 --> 01:11:47,119
And talking about anything we want, let's talk about the next example.

2100
01:11:43,359 --> 01:11:47,119
<font color="#ffff54">우리가 원하는 것에 대해 이야기하면서 다음 예제에 대해 이야기해 봅시다.</font>

2101
01:11:47,119 --> 01:11:48,340
So we talk about monitoring.

2102
01:11:47,119 --> 01:11:48,340
<font color="#ffff54">이제 모니터링에 대해 이야기해 봅시다.</font>

2103
01:11:48,340 --> 01:11:50,199
Let's see what we can do next.

2104
01:11:48,340 --> 01:11:50,199
<font color="#ffff54">다음에 무엇을 할 수 있는지 봅시다.</font>

2105
01:11:50,199 --> 01:11:55,100
And what we can do next is basically security.

2106
01:11:50,199 --> 01:11:55,100
<font color="#ffff54">다음으로 할 수 있는 것은 기본적으로 보안입니다.</font>

2107
01:11:55,100 --> 01:11:56,579
Right?

2108
01:11:55,100 --> 01:11:56,579
<font color="#ffff54">그렇죠?</font>

2109
01:11:56,579 --> 01:12:00,220
So who here used network policies?

2110
01:11:56,579 --> 01:12:00,220
<font color="#ffff54">여기 누가 네트워크 정책을 사용했나요?</font>

2111
01:12:00,220 --> 01:12:03,460
Pretty much a lot of people.

2112
01:12:00,220 --> 01:12:03,460
<font color="#ffff54">꽤 많은 사람들이요.</font>

2113
01:12:03,460 --> 01:12:04,779
All right.

2114
01:12:03,460 --> 01:12:04,779
<font color="#ffff54">알았어.</font>

2115
01:12:04,779 --> 01:12:11,340
Network policies is a fundamental component of, you know, networking in communities.

2116
01:12:04,779 --> 01:12:11,340
<font color="#ffff54">네트워크 정책은 커뮤니티 네트워킹의 기본 요소입니다.</font>

2117
01:12:11,340 --> 01:12:16,920
It allows us to deny traffic from A to B and do a lot of fine tuning, defining multi-tenancy

2118
01:12:11,340 --> 01:12:16,920
<font color="#ffff54">네트워크 정책을 통해 A에서 B로의 트래픽을 거부하고, 멀티 테넌시를 정의하는 등 다양한 미세 조정을 수행할 수 있습니다.</font>

2119
01:12:16,920 --> 01:12:19,239
and all of the things.

2120
01:12:16,920 --> 01:12:19,239
<font color="#ffff54">그리고 모든 것들.</font>

2121
01:12:19,239 --> 01:12:26,199
Network policies, if you want to use eBPF for that, you probably would use something

2122
01:12:19,239 --> 01:12:26,199
<font color="#ffff54">네트워크 정책, 이를 위해 eBPF를 사용하려면 아마도 다음과 같은 것을 사용할 것입니다.</font>

2123
01:12:26,199 --> 01:12:28,420
similar to what I'm showing you right now.

2124
01:12:26,199 --> 01:12:28,420
<font color="#ffff54">지금 보여드리는 것과 비슷합니다.</font>

2125
01:12:28,420 --> 01:12:30,079
If you want to implement that, let's say from scratch.

2126
01:12:28,420 --> 01:12:30,079
<font color="#ffff54">이를 구현하고 싶다면 처음부터 구현해 봅시다.</font>

2127
01:12:30,079 --> 01:12:33,140
And again, this is a very, very basic scenario.

2128
01:12:30,079 --> 01:12:33,140
<font color="#ffff54">다시 말하지만, 이것은 아주 아주 기본적인 시나리오입니다.</font>

2129
01:12:33,140 --> 01:12:38,600
So what we are going to do for the next example is pretty straightforward.

2130
01:12:33,140 --> 01:12:38,600
<font color="#ffff54">다음 예제에서 할 일은 매우 간단합니다.</font>

2131
01:12:38,600 --> 01:12:47,200
We are going to first create, we're going to create our network policy in communities.

2132
01:12:38,600 --> 01:12:47,200
<font color="#ffff54">먼저 커뮤니티에서 네트워크 정책을 만들겠습니다.</font>

2133
01:12:47,200 --> 01:12:48,200
Okay?

2134
01:12:47,200 --> 01:12:48,200
<font color="#ffff54">알았지?</font>

2135
01:12:48,200 --> 01:12:52,920
Just a super basic one, simple, just for demo.

2136
01:12:48,200 --> 01:12:52,920
<font color="#ffff54">데모용으로 아주 기본적인 것만 만들었습니다.</font>

2137
01:12:52,920 --> 01:12:58,880
We're going to create a user space program to kind of read this network policy and actually

2138
01:12:52,920 --> 01:12:58,880
<font color="#ffff54">이 네트워크 정책을 읽을 수 있는 사용자 공간 프로그램을 만들어서 실제로</font>

2139
01:12:58,880 --> 01:13:03,560
go and create certain rules in like our BPF map.

2140
01:12:58,880 --> 01:13:03,560
<font color="#ffff54">BPF 맵과 같은 특정 규칙을 생성합니다.</font>

2141
01:13:03,560 --> 01:13:09,680
Then our eBPF code on the kernel side is going to read these rules from the map and

2142
01:13:03,560 --> 01:13:09,680
<font color="#ffff54">그러면 커널 쪽의 eBPF 코드가 맵에서 이 규칙을 읽어와서</font>

2143
01:13:09,680 --> 01:13:10,680
enforce something.

2144
01:13:09,680 --> 01:13:10,680
<font color="#ffff54">무언가를 실행합니다.</font>

2145
01:13:10,680 --> 01:13:16,320
That actually, if you think about communities and network policies enforcement using eBPF,

2146
01:13:10,680 --> 01:13:16,320
<font color="#ffff54">실제로 커뮤니티와 네트워크 정책 시행에 대해 생각해보면, eBPF를 사용하는 것이 좋습니다,</font>

2147
01:13:16,320 --> 01:13:17,760
in a nutshell, that's how it works.

2148
01:13:16,320 --> 01:13:17,760
<font color="#ffff54">간단히 말해서 이렇게 작동합니다.</font>

2149
01:13:17,760 --> 01:13:20,600
And now this is very much simplifying a lot.

2150
01:13:17,760 --> 01:13:20,600
<font color="#ffff54">이제 이것은 매우 단순화되었습니다.</font>

2151
01:13:20,600 --> 01:13:22,760
But yeah, you have a process.

2152
01:13:20,600 --> 01:13:22,760
<font color="#ffff54">하지만 네, 프로세스가 있죠.</font>

2153
01:13:22,760 --> 01:13:26,000
They're going to watch for communities policies.

2154
01:13:22,760 --> 01:13:26,000
<font color="#ffff54">그들은 커뮤니티 정책을 지켜볼 거야.</font>

2155
01:13:26,000 --> 01:13:30,460
It's going to transform it into data that can be pushed into a BPF map.

2156
01:13:26,000 --> 01:13:30,460
<font color="#ffff54">이를 BPF 맵에 푸시할 수 있는 데이터로 변환할 것입니다.</font>

2157
01:13:30,460 --> 01:13:36,659
On the other side, you have an eBPF code that reads from this map and enforce the policy.

2158
01:13:30,460 --> 01:13:36,659
<font color="#ffff54">다른 쪽에는 이 맵을 읽고 정책을 적용하는 eBPF 코드가 있습니다.</font>

2159
01:13:36,659 --> 01:13:37,980
So let's do it.

2160
01:13:36,659 --> 01:13:37,980
<font color="#ffff54">그럼 실행해 봅시다.</font>

2161
01:13:37,980 --> 01:13:44,619
Let's see how this would work in communities, or actually in our example here.

2162
01:13:37,980 --> 01:13:44,619
<font color="#ffff54">이것이 커뮤니티에서 어떻게 작동하는지, 실제로 여기 예제에서 어떻게 작동하는지 살펴봅시다.</font>

2163
01:13:44,619 --> 01:13:47,140
So all right, let's keep going here.

2164
01:13:44,619 --> 01:13:47,140
<font color="#ffff54">그럼 여기서 계속 진행해보죠.</font>

2165
01:13:47,140 --> 01:13:49,300
Let's get to our example.

2166
01:13:47,140 --> 01:13:49,300
<font color="#ffff54">예제를 살펴봅시다.</font>

2167
01:13:49,300 --> 01:13:51,300
Click on next.

2168
01:13:49,300 --> 01:13:51,300
<font color="#ffff54">다음을 클릭합니다.</font>

2169
01:13:51,300 --> 01:13:57,980
All right, let's start.

2170
01:13:51,300 --> 01:13:57,980
<font color="#ffff54">좋아, 시작하자.</font>

2171
01:13:58,020 --> 01:14:00,940
So for this example, we're defining a new map.

2172
01:13:58,020 --> 01:14:00,940
<font color="#ffff54">이 예제에서는 새 맵을 정의하겠습니다.</font>

2173
01:14:00,940 --> 01:14:04,420
We're calling that IP rules.

2174
01:14:00,940 --> 01:14:04,420
<font color="#ffff54">이를 IP 규칙이라고 부릅니다.</font>

2175
01:14:04,420 --> 01:14:06,140
It's very straightforward.

2176
01:14:04,420 --> 01:14:06,140
<font color="#ffff54">아주 간단합니다.</font>

2177
01:14:06,140 --> 01:14:10,560
We're actually putting the kind of, you know, a key pair.

2178
01:14:06,140 --> 01:14:10,560
<font color="#ffff54">우리는 실제로 일종의 키 쌍을 넣고 있습니다.</font>

2179
01:14:10,560 --> 01:14:13,500
That's the bit more complicated thing.

2180
01:14:10,560 --> 01:14:13,500
<font color="#ffff54">그게 좀 더 복잡하죠.</font>

2181
01:14:13,500 --> 01:14:17,300
As a key, it's not like a straightforward, like we're not using a direct like an int value

2182
01:14:13,500 --> 01:14:17,300
<font color="#ffff54">키로서, 우리는 int 값과 같은 다이렉트를 사용하지 않는 것처럼 간단하지 않습니다.</font>

2183
01:14:17,300 --> 01:14:18,300
or something.

2184
01:14:17,300 --> 01:14:18,300
<font color="#ffff54">뭐 그런 거죠.</font>

2185
01:14:18,300 --> 01:14:21,700
We're using it in a pair source destination.

2186
01:14:18,300 --> 01:14:21,700
<font color="#ffff54">페어 소스 대상에서 사용하고 있습니다.</font>

2187
01:14:21,700 --> 01:14:24,700
So if we see this source and destination, that's going to be the key.

2188
01:14:21,700 --> 01:14:24,700
<font color="#ffff54">따라서 이 소스와 목적지를 확인하면 이것이 핵심이 될 것입니다.</font>

2189
01:14:24,739 --> 01:14:28,460
The value is going to be a boolean, like just zero or one.

2190
01:14:24,739 --> 01:14:28,460
<font color="#ffff54">값은 0 또는 1과 같은 부울이 될 것입니다.</font>

2191
01:14:28,460 --> 01:14:34,380
And every time we see this key source destination with value zero or one, it will be for us,

2192
01:14:28,460 --> 01:14:34,380
<font color="#ffff54">그리고 이 키 소스 목적지가 0 또는 1의 값을 가질 때마다 우리를 위한 것이 될 것입니다,</font>

2193
01:14:34,380 --> 01:14:36,300
if it's one, allow the traffic.

2194
01:14:34,380 --> 01:14:36,300
<font color="#ffff54">1이면 트래픽을 허용합니다.</font>

2195
01:14:36,300 --> 01:14:38,319
Zero, stop the traffic.

2196
01:14:36,300 --> 01:14:38,319
<font color="#ffff54">0, 트래픽을 중지합니다.</font>

2197
01:14:38,319 --> 01:14:41,059
Very simple.

2198
01:14:38,319 --> 01:14:41,059
<font color="#ffff54">아주 간단합니다.</font>

2199
01:14:41,059 --> 01:14:46,099
So yeah, let's keep going here and let's create our map.

2200
01:14:41,059 --> 01:14:46,099
<font color="#ffff54">자, 여기서 계속 진행해서 지도를 만들어 봅시다.</font>

2201
01:14:46,099 --> 01:14:50,399
Let's take a look at the eBPF code that we just updated.

2202
01:14:46,099 --> 01:14:50,399
<font color="#ffff54">방금 업데이트한 eBPF 코드를 살펴봅시다.</font>

2203
01:14:50,400 --> 01:14:55,400
And let's skip through kind of the first, whatever we talked about when we, you know,

2204
01:14:50,400 --> 01:14:55,400
<font color="#ffff54">그리고 우리가 처음에 이야기했던 부분은 건너뛰겠습니다,</font>

2205
01:14:55,400 --> 01:14:58,360
we talked about monitoring.

2206
01:14:55,400 --> 01:14:58,360
<font color="#ffff54">모니터링에 대해 얘기했었죠.</font>

2207
01:14:58,360 --> 01:14:59,920
Let's focus on security.

2208
01:14:58,360 --> 01:14:59,920
<font color="#ffff54">보안에 대해 집중해 봅시다.</font>

2209
01:14:59,920 --> 01:15:04,180
So we have this section again, it's a key pair source address is going to be the key.

2210
01:14:59,920 --> 01:15:04,180
<font color="#ffff54">이 섹션은 다시 키 쌍의 소스 주소가 핵심이 될 것입니다.</font>

2211
01:15:04,180 --> 01:15:06,040
The value is boolean.

2212
01:15:04,180 --> 01:15:06,040
<font color="#ffff54">값은 부울입니다.</font>

2213
01:15:06,040 --> 01:15:09,240
It just an int is going to be a zero or one.

2214
01:15:06,040 --> 01:15:09,240
<font color="#ffff54">그냥 0이나 1이 될 것입니다.</font>

2215
01:15:09,240 --> 01:15:14,680
Now in modification of our code, scroll all the way down, the same logic we use to write

2216
01:15:09,240 --> 01:15:14,680
<font color="#ffff54">이제 코드를 수정하여 아래로 스크롤하면 다음과 같은 로직을 작성할 수 있습니다.</font>

2217
01:15:14,680 --> 01:15:19,480
in the map, we're going to just read from the map.

2218
01:15:14,680 --> 01:15:19,480
<font color="#ffff54">지도에서는 그냥 지도를 읽겠습니다.</font>

2219
01:15:19,480 --> 01:15:20,880
And we're going to do both.

2220
01:15:19,480 --> 01:15:20,880
<font color="#ffff54">그리고 둘 다 할 것입니다.</font>

2221
01:15:20,880 --> 01:15:26,280
What we're going to do is we're going to say, hey, define a key pair with the source address

2222
01:15:20,880 --> 01:15:26,280
<font color="#ffff54">우리가 할 일은 소스 주소와 키 쌍을 정의하는 것입니다.</font>

2223
01:15:26,280 --> 01:15:28,620
is the source address of the packets.

2224
01:15:26,280 --> 01:15:28,620
<font color="#ffff54">는 패킷의 소스 주소입니다.</font>

2225
01:15:28,620 --> 01:15:32,880
The destination address is the destination address of a certain packets.

2226
01:15:28,620 --> 01:15:32,880
<font color="#ffff54">목적지 주소는 특정 패킷의 목적지 주소입니다.</font>

2227
01:15:32,880 --> 01:15:35,980
So this our key pair, this is our key right now.

2228
01:15:32,880 --> 01:15:35,980
<font color="#ffff54">이것이 우리의 키 쌍이고, 이것이 지금 우리의 키입니다.</font>

2229
01:15:35,980 --> 01:15:37,600
And take a look at the map.

2230
01:15:35,980 --> 01:15:37,600
<font color="#ffff54">그리고 지도를 보세요.</font>

2231
01:15:37,600 --> 01:15:45,200
If you don't see any value, meaning we didn't define any rule, put one, say, hey, well,

2232
01:15:37,600 --> 01:15:45,200
<font color="#ffff54">어떤 값도 보이지 않는다면, 즉 우리가 어떤 규칙도 정의하지 않았다면, 하나를 입력하세요,</font>

2233
01:15:45,200 --> 01:15:47,960
that traffic is allowed, put that in the map, it's fine.

2234
01:15:45,200 --> 01:15:47,960
<font color="#ffff54">트래픽이 허용된다는 것을 맵에 넣으면 됩니다.</font>

2235
01:15:47,960 --> 01:15:53,500
So for us, we can see that from A to B, a certain packet has been allowed.

2236
01:15:47,960 --> 01:15:53,500
<font color="#ffff54">이제 A에서 B로 특정 패킷이 허용되었음을 알 수 있습니다.</font>

2237
01:15:53,500 --> 01:16:00,880
Now if you see explicitly in our map, that the value we defined for this kind of interaction

2238
01:15:53,500 --> 01:16:00,880
<font color="#ffff54">이제 맵에서 명시적으로 볼 수 있듯이, 이러한 종류의 상호 작용에 대해 정의한 값은 다음과 같습니다.</font>

2239
01:16:00,880 --> 01:16:04,239
is zero, then just drop that packet.

2240
01:16:00,880 --> 01:16:04,239
<font color="#ffff54">가 0이면 해당 패킷을 삭제하면 됩니다.</font>

2241
01:16:04,239 --> 01:16:05,239
We don't want it.

2242
01:16:04,239 --> 01:16:05,239
<font color="#ffff54">원하지 않아요.</font>

2243
01:16:05,239 --> 01:16:07,680
All right, let's block that.

2244
01:16:05,239 --> 01:16:07,680
<font color="#ffff54">좋아, 차단하자.</font>

2245
01:16:07,680 --> 01:16:09,439
Amazing.

2246
01:16:07,680 --> 01:16:09,439
<font color="#ffff54">놀랍군.</font>

2247
01:16:09,439 --> 01:16:10,439
That's it.

2248
01:16:09,439 --> 01:16:10,439
<font color="#ffff54">끝났어요.</font>

2249
01:16:10,439 --> 01:16:14,840
That's pretty much what we need to do to define a way to enforce rules between two, like a

2250
01:16:10,439 --> 01:16:14,840
<font color="#ffff54">둘 사이에 규칙을 적용하는 방법을 정의하려면 다음과 같이 해야 합니다.</font>

2251
01:16:14,840 --> 01:16:19,440
source and destination address using eBPF.

2252
01:16:14,840 --> 01:16:19,440
<font color="#ffff54">소스 및 목적지 주소에 eBPF를 사용합니다.</font>

2253
01:16:19,440 --> 01:16:26,199
So let's get back to here.

2254
01:16:19,440 --> 01:16:26,199
<font color="#ffff54">이제 여기로 돌아가 봅시다.</font>

2255
01:16:26,199 --> 01:16:30,560
So we, yeah, so we updated the code.

2256
01:16:26,199 --> 01:16:30,560
<font color="#ffff54">그래서 코드를 업데이트했습니다.</font>

2257
01:16:30,560 --> 01:16:33,600
Let's build this again, the same thing we did earlier.

2258
01:16:30,560 --> 01:16:33,600
<font color="#ffff54">앞서 했던 것과 똑같이 다시 빌드해 봅시다.</font>

2259
01:16:33,600 --> 01:16:38,279
Let's build this again and reload the new code.

2260
01:16:33,600 --> 01:16:38,279
<font color="#ffff54">다시 빌드하고 새 코드를 다시 로드해 봅시다.</font>

2261
01:16:38,279 --> 01:16:44,079
Let's delete the pods.

2262
01:16:38,279 --> 01:16:44,079
<font color="#ffff54">파드를 삭제하겠습니다.</font>

2263
01:16:44,319 --> 01:16:48,319
And wait for them to be ready so we can keep going.

2264
01:16:44,319 --> 01:16:48,319
<font color="#ffff54">그리고 계속 진행할 수 있도록 준비가 될 때까지 기다리자.</font>

2265
01:16:48,319 --> 01:16:56,319
Take a couple seconds here.

2266
01:16:48,319 --> 01:16:56,319
<font color="#ffff54">여기서 몇 초만 기다려주세요.</font>

2267
01:16:56,319 --> 01:16:58,319
Yeah.

2268
01:16:56,319 --> 01:16:58,319
<font color="#ffff54">알았어</font>

2269
01:16:58,319 --> 01:17:08,600
Yeah, I mean, this is a very simple example.

2270
01:16:58,319 --> 01:17:08,600
<font color="#ffff54">네, 이건 아주 간단한 예시입니다.</font>

2271
01:17:08,600 --> 01:17:13,720
But yes, you can define, like you can use the map as hey, well, it's our source of truth

2272
01:17:08,600 --> 01:17:13,720
<font color="#ffff54">하지만 네, 지도를 다음과 같이 정의할 수 있습니다.</font>

2273
01:17:13,760 --> 01:17:16,880
of like what should happen in my network.

2274
01:17:13,760 --> 01:17:16,880
<font color="#ffff54">내 네트워크에서 어떤 일이 일어나야 하는지</font>

2275
01:17:16,880 --> 01:17:22,420
In my example, I'm populating like one saying hey, allow traffic for all the pods.

2276
01:17:16,880 --> 01:17:22,420
<font color="#ffff54">제 예제에서는 모든 파드에 대한 트래픽을 허용하는 것처럼 채우고 있습니다.</font>

2277
01:17:22,420 --> 01:17:28,240
Every time I see like a pair source address, if I don't have an explicit rule, put something

2278
01:17:22,420 --> 01:17:28,240
<font color="#ffff54">페어 소스 주소와 같은 것을 볼 때마다, 명시적인 규칙이 없다면, 무언가를 넣는다.</font>

2279
01:17:28,240 --> 01:17:31,920
in the map saying hey, well, I have one, meaning like I allowed it.

2280
01:17:28,240 --> 01:17:31,920
<font color="#ffff54">를 맵에 추가하여 내가 허용한 것처럼 보이게 하세요.</font>

2281
01:17:31,920 --> 01:17:37,920
But if I explicitly see a zero, then well, that's actually my, but then you can structure,

2282
01:17:31,920 --> 01:17:37,920
<font color="#ffff54">하지만 내가 명시적으로 0을 본다면, 그건 사실 내 것이지만 구조화할 수 있습니다,</font>

2283
01:17:37,920 --> 01:17:41,720
this is an example, you can structure basically your BPF map like you want.

2284
01:17:37,920 --> 01:17:41,720
<font color="#ffff54">이것은 예시이며, 기본적으로 원하는 대로 BPF 맵을 구조화할 수 있습니다.</font>

2285
01:17:41,920 --> 01:17:45,920
You just need to map your logic that you're going to have to do in your packet.

2286
01:17:41,920 --> 01:17:45,920
<font color="#ffff54">패킷에서 수행해야 할 로직을 매핑하기만 하면 됩니다.</font>

2287
01:17:45,920 --> 01:17:48,920
So you do lots of packing and unpacking?

2288
01:17:45,920 --> 01:17:48,920
<font color="#ffff54">포장과 포장을 푸는 일을 많이 하나요?</font>

2289
01:17:48,920 --> 01:17:52,920
The packet doesn't have any performance impact?

2290
01:17:48,920 --> 01:17:52,920
<font color="#ffff54">패킷이 성능에 영향을 미치지 않나요?</font>

2291
01:17:52,920 --> 01:17:57,920
On XDP, very, very minimal, because we're not unpacking.

2292
01:17:52,920 --> 01:17:57,920
<font color="#ffff54">XDP에서는 압축을 풀지 않기 때문에 매우, 매우 미미합니다.</font>

2293
01:17:57,920 --> 01:18:03,920
It's not like we are just, you know, we're just, you know, watching for the structure.

2294
01:17:57,920 --> 01:18:03,920
<font color="#ffff54">우린 그냥 구조물만 보고 있는 게 아니야.</font>

2295
01:18:03,920 --> 01:18:07,920
It's not, we're not modifying the packet itself, right?

2296
01:18:03,920 --> 01:18:07,920
<font color="#ffff54">패킷 자체를 수정하는 건 아니지?</font>

2297
01:18:07,920 --> 01:18:10,920
Like it's mostly, like you can, I mean, you can modify the packet itself.

2298
01:18:07,920 --> 01:18:10,920
<font color="#ffff54">대부분 패킷 자체를 수정할 수 있는 것처럼요.</font>

2299
01:18:11,119 --> 01:18:15,119
But when you just take a look at it, in our case, in this all examples, we didn't do,

2300
01:18:11,119 --> 01:18:15,119
<font color="#ffff54">하지만 그냥 살펴보면, 이 모든 예제에서 우리는 그렇게 하지 않았습니다,</font>

2301
01:18:15,119 --> 01:18:17,119
we didn't rewrite the packets.

2302
01:18:15,119 --> 01:18:17,119
<font color="#ffff54">패킷을 재작성하지 않았습니다.</font>

2303
01:18:17,119 --> 01:18:22,119
We just looked at the packets and made the decision to either monitor that, and in this

2304
01:18:17,119 --> 01:18:22,119
<font color="#ffff54">우리는 패킷을 살펴보고 이를 모니터링하기로 결정했습니다.</font>

2305
01:18:22,119 --> 01:18:24,119
case, we're going to just enforce certain policy.

2306
01:18:22,119 --> 01:18:24,119
<font color="#ffff54">특정 정책을 시행할 것입니다.</font>

2307
01:18:30,119 --> 01:18:34,119
Yes, we are talking about very, very XDP.

2308
01:18:30,119 --> 01:18:34,119
<font color="#ffff54">네, 우리는 아주 아주 XDP에 대해 이야기하고 있습니다.</font>

2309
01:18:34,119 --> 01:18:37,119
It's pretty much, you know, the packet, you don't, you can't see much from it.

2310
01:18:34,119 --> 01:18:37,119
<font color="#ffff54">거의 패킷에 불과해서 아무것도 볼 수 없습니다.</font>

2311
01:18:37,319 --> 01:18:40,319
More you go up, more you can see stuff.

2312
01:18:37,319 --> 01:18:40,319
<font color="#ffff54">위로 올라갈수록 더 많은 것을 볼 수 있습니다.</font>

2313
01:18:41,319 --> 01:18:44,319
So, yeah, let's run a command here.

2314
01:18:41,319 --> 01:18:44,319
<font color="#ffff54">그럼 여기서 명령을 실행해 봅시다.</font>

2315
01:18:44,319 --> 01:18:47,319
Let's make a call and take a look.

2316
01:18:44,319 --> 01:18:47,319
<font color="#ffff54">전화를 걸어서 살펴봅시다.</font>

2317
01:18:47,319 --> 01:18:49,319
Take a look at this map.

2318
01:18:47,319 --> 01:18:49,319
<font color="#ffff54">이 지도를 보세요.</font>

2319
01:18:49,319 --> 01:18:55,319
Now we have a new map that we called IP rules that has source and destination address with

2320
01:18:49,319 --> 01:18:55,319
<font color="#ffff54">이제 소스 및 목적지 주소가 다음과 같은 IP 규칙이라고 하는 새 맵이 생겼습니다.</font>

2321
01:18:55,319 --> 01:18:56,319
certain value.

2322
01:18:55,319 --> 01:18:56,319
<font color="#ffff54">특정 값입니다.</font>

2323
01:18:56,319 --> 01:19:01,319
Basically, we allow traffic from, if you see that split, like, you know, it's kind of the

2324
01:18:56,319 --> 01:19:01,319
<font color="#ffff54">기본적으로 우리는 트래픽을 허용합니다.</font>

2325
01:19:01,319 --> 01:19:04,319
same value, like flipped, but basically a request response.

2326
01:19:01,319 --> 01:19:04,319
<font color="#ffff54">같은 값이지만 기본적으로 요청 응답입니다.</font>

2327
01:19:04,519 --> 01:19:11,519
We sent a request from sleep pod to HTTP bin, it's a one, and from HTTP bin to sleep, when

2328
01:19:04,519 --> 01:19:11,519
<font color="#ffff54">슬립 파드에서 HTTP 빈으로 요청을 보내면 1이고, HTTP 빈에서 슬립으로 요청을 보내면 다음과 같습니다.</font>

2329
01:19:11,519 --> 01:19:14,519
it goes back for the response, it's one, two.

2330
01:19:11,519 --> 01:19:14,519
<font color="#ffff54">응답을 위해 되돌아가면 1, 2가 됩니다.</font>

2331
01:19:15,519 --> 01:19:23,519
So, yes, let's actually look at, now let's look at a user space program that can write

2332
01:19:15,519 --> 01:19:23,519
<font color="#ffff54">이제 실제로 다음과 같이 작성할 수 있는 사용자 공간 프로그램을 살펴봅시다.</font>

2333
01:19:23,519 --> 01:19:24,519
these rules.

2334
01:19:23,519 --> 01:19:24,519
<font color="#ffff54">이 규칙들을</font>

2335
01:19:26,519 --> 01:19:30,519
For that, I wrote something quick for you guys to read.

2336
01:19:26,519 --> 01:19:30,519
<font color="#ffff54">이를 위해 여러분들이 읽을 수 있도록 간단히 작성했습니다.</font>

2337
01:19:30,720 --> 01:19:34,720
We can open the, on the editor, on the user space code.

2338
01:19:30,720 --> 01:19:34,720
<font color="#ffff54">에디터의 사용자 공간 코드에서 열 수 있습니다.</font>

2339
01:19:35,720 --> 01:19:40,720
I already wrote this quickly just for us to save time.

2340
01:19:35,720 --> 01:19:40,720
<font color="#ffff54">시간 절약을 위해 빠르게 작성했습니다.</font>

2341
01:19:40,720 --> 01:19:42,720
What it does is very straightforward.

2342
01:19:40,720 --> 01:19:42,720
<font color="#ffff54">하는 일은 매우 간단합니다.</font>

2343
01:19:42,720 --> 01:19:48,720
It's going to look for the binary of the BDF code that we just wrote and it's going to

2344
01:19:42,720 --> 01:19:48,720
<font color="#ffff54">방금 작성한 BDF 코드의 바이너리를 찾아서 다음과 같이 실행합니다.</font>

2345
01:19:48,720 --> 01:19:49,720
load it, so we're going to skip all this.

2346
01:19:48,720 --> 01:19:49,720
<font color="#ffff54">로드할 것이므로 이 과정은 생략하겠습니다.</font>

2347
01:19:49,720 --> 01:19:55,720
But interesting is it's going to get values from the, kind of, when we call, we invoke

2348
01:19:49,720 --> 01:19:55,720
<font color="#ffff54">하지만 흥미로운 점은 우리가 호출할 때 일종의</font>

2349
01:19:55,720 --> 01:19:57,720
that program with three values.

2350
01:19:55,720 --> 01:19:57,720
<font color="#ffff54">세 개의 값을 가진 프로그램입니다.</font>

2351
01:19:57,920 --> 01:20:03,920
We're going to invoke it with the source address, source IP, a destination IP, and one or zero

2352
01:19:57,920 --> 01:20:03,920
<font color="#ffff54">소스 주소, 소스 IP, 대상 IP, 그리고 1 또는 0을 사용하여 호출합니다.</font>

2353
01:20:03,920 --> 01:20:05,920
to say, hey, allow traffic or not.

2354
01:20:03,920 --> 01:20:05,920
<font color="#ffff54">트래픽을 허용할지 말지를 알려줍니다.</font>

2355
01:20:07,920 --> 01:20:08,920
So, that's it.

2356
01:20:07,920 --> 01:20:08,920
<font color="#ffff54">이제 끝입니다.</font>

2357
01:20:08,920 --> 01:20:10,920
That's all we are doing here.

2358
01:20:08,920 --> 01:20:10,920
<font color="#ffff54">여기까지입니다.</font>

2359
01:20:10,920 --> 01:20:14,920
So, and if we take a look, actually, I already built this for a matter of time.

2360
01:20:10,920 --> 01:20:14,920
<font color="#ffff54">그래서, 우리가 살펴보면, 사실, 나는 이미 이것을 시간 문제로 만들었습니다.</font>

2361
01:20:15,920 --> 01:20:19,920
Take a look at the binary, I already have it.

2362
01:20:15,920 --> 01:20:19,920
<font color="#ffff54">바이너리를 봐요, 이미 가지고 있어요.</font>

2363
01:20:20,920 --> 01:20:25,920
So, again, if we take the, if we test the traffic already, that would work.

2364
01:20:20,920 --> 01:20:25,920
<font color="#ffff54">다시 말하지만, 우리가 이미 트래픽을 테스트하면 작동할 것입니다.</font>

2365
01:20:26,119 --> 01:20:30,119
But now let's actually put an explicit rule to stop the traffic.

2366
01:20:26,119 --> 01:20:30,119
<font color="#ffff54">하지만 이제 실제로 트래픽을 중지하는 명시적인 규칙을 넣어 봅시다.</font>

2367
01:20:30,119 --> 01:20:33,119
For that, I'm using the binary.

2368
01:20:30,119 --> 01:20:33,119
<font color="#ffff54">이를 위해 바이너리를 사용합니다.</font>

2369
01:20:33,119 --> 01:20:34,119
Take a look.

2370
01:20:33,119 --> 01:20:34,119
<font color="#ffff54">보세요.</font>

2371
01:20:34,119 --> 01:20:38,119
You see, IP rule, this is the binary of the user space I created.

2372
01:20:34,119 --> 01:20:38,119
<font color="#ffff54">보시다시피, IP 규칙, 이것은 제가 만든 사용자 공간의 바이너리입니다.</font>

2373
01:20:38,119 --> 01:20:42,119
I'm putting the source address as the IP of the sleep pod.

2374
01:20:38,119 --> 01:20:42,119
<font color="#ffff54">소스 주소를 슬립 파드의 IP로 설정합니다.</font>

2375
01:20:42,119 --> 01:20:46,119
The destination is the IP of HTTP bin pod.

2376
01:20:42,119 --> 01:20:46,119
<font color="#ffff54">대상은 HTTP 빈 파드의 IP입니다.</font>

2377
01:20:46,119 --> 01:20:52,119
And the value I'm putting for the rule is zero, meaning, hey, well, block this traffic.

2378
01:20:46,119 --> 01:20:52,119
<font color="#ffff54">그리고 규칙에 설정한 값은 0으로, 이 트래픽을 차단하라는 의미입니다.</font>

2379
01:20:52,319 --> 01:20:58,319
Let's do this, run it, meaning now in our BPF map, we can take a look at the value.

2380
01:20:52,319 --> 01:20:58,319
<font color="#ffff54">이제 실행해 보겠습니다. 이제 BPF 맵에서 값을 살펴볼 수 있습니다.</font>

2381
01:20:59,319 --> 01:21:04,319
Explicitly, I see a zero here, so don't let this packet go through.

2382
01:20:59,319 --> 01:21:04,319
<font color="#ffff54">분명히 0이 보이니 이 패킷을 통과시키지 마세요.</font>

2383
01:21:04,319 --> 01:21:12,319
And now if I make a call again, voila, blocked.

2384
01:21:04,319 --> 01:21:12,319
<font color="#ffff54">이제 다시 전화를 걸면 짜잔, 차단되었습니다.</font>

2385
01:21:12,319 --> 01:21:14,319
No traffic between A to B.

2386
01:21:12,319 --> 01:21:14,319
<font color="#ffff54">A와 B 사이에 트래픽이 없습니다.</font>

2387
01:21:14,319 --> 01:21:15,319
Okay?

2388
01:21:14,319 --> 01:21:15,319
<font color="#ffff54">알았지?</font>

2389
01:21:15,319 --> 01:21:21,319
This is basically the very simple version of like how we can enforce rules.

2390
01:21:15,319 --> 01:21:21,319
<font color="#ffff54">이것은 기본적으로 우리가 규칙을 적용하는 방법의 아주 간단한 버전입니다.</font>

2391
01:21:21,519 --> 01:21:22,519
Actually, you know what?

2392
01:21:21,519 --> 01:21:22,519
<font color="#ffff54">사실, 그거 알아요?</font>

2393
01:21:22,519 --> 01:21:26,519
As a fun exercise, I just recreated, and you don't do that, okay?

2394
01:21:22,519 --> 01:21:26,519
<font color="#ffff54">난 그냥 재미삼아 재현한 건데, 넌 그러지 마, 알았지?</font>

2395
01:21:26,519 --> 01:21:28,519
That's not how it should be.

2396
01:21:26,519 --> 01:21:28,519
<font color="#ffff54">그렇게 하면 안 돼요.</font>

2397
01:21:28,519 --> 01:21:39,519
I actually created a batch program that just go and parse, here's the batch program.

2398
01:21:28,519 --> 01:21:39,519
<font color="#ffff54">제가 실제로 그냥 가서 파싱하는 배치 프로그램을 만들었는데, 여기 배치 프로그램이 있습니다.</font>

2399
01:21:39,519 --> 01:21:45,519
I created a batch program that goes and basically just watch for Kubernetes network policies.

2400
01:21:39,519 --> 01:21:45,519
<font color="#ffff54">기본적으로 쿠버네티스 네트워크 정책을 감시하는 배치 프로그램을 만들었습니다.</font>

2401
01:21:45,519 --> 01:21:48,519
You would actually use Golang and the client, the kube client for that.

2402
01:21:45,519 --> 01:21:48,519
<font color="#ffff54">실제로는 골랑과 클라이언트인 큐브 클라이언트를 사용합니다.</font>

2403
01:21:48,519 --> 01:21:49,519
Don't use that.

2404
01:21:48,519 --> 01:21:49,519
<font color="#ffff54">그건 사용하지 마세요.</font>

2405
01:21:49,720 --> 01:21:53,720
But in this case, what I'm doing is I'm looking for any network policy,

2406
01:21:49,720 --> 01:21:53,720
<font color="#ffff54">하지만 이 경우에는 네트워크 정책을 찾고 있습니다,</font>

2407
01:21:53,720 --> 01:22:00,720
and I'm actually taking a look at if the source and destination address are allowed,

2408
01:21:53,720 --> 01:22:00,720
<font color="#ffff54">그리고 실제로 소스 및 대상 주소가 허용되는지 살펴보고 있습니다,</font>

2409
01:22:00,720 --> 01:22:02,720
then put an IP rule to allow the traffic.

2410
01:22:00,720 --> 01:22:02,720
<font color="#ffff54">그런 다음 트래픽을 허용하는 IP 규칙을 넣습니다.</font>

2411
01:22:02,720 --> 01:22:05,720
If not, deny all other traffic.

2412
01:22:02,720 --> 01:22:05,720
<font color="#ffff54">그렇지 않은 경우 다른 모든 트래픽을 거부합니다.</font>

2413
01:22:05,720 --> 01:22:08,720
So by default, everything is blocked.

2414
01:22:05,720 --> 01:22:08,720
<font color="#ffff54">따라서 기본적으로 모든 것이 차단됩니다.</font>

2415
01:22:08,720 --> 01:22:16,720
But if I have a kube network policy that is explicitly allowing traffic from A to B,

2416
01:22:08,720 --> 01:22:16,720
<font color="#ffff54">하지만 A에서 B로의 트래픽을 명시적으로 허용하는 큐브 네트워크 정책을 가지고 있다면,</font>

2417
01:22:16,720 --> 01:22:18,720
then allow that, right?

2418
01:22:16,720 --> 01:22:18,720
<font color="#ffff54">그럼 허용해야겠죠?</font>

2419
01:22:18,920 --> 01:22:19,920
It's very simple.

2420
01:22:18,920 --> 01:22:19,920
<font color="#ffff54">아주 간단합니다.</font>

2421
01:22:19,920 --> 01:22:25,920
So if I use this code, I'm going to deploy this here.

2422
01:22:19,920 --> 01:22:25,920
<font color="#ffff54">이 코드를 사용하면 여기에 배포할 수 있습니다.</font>

2423
01:22:27,920 --> 01:22:30,720
Basically, by default, it's blocking all the traffic.

2424
01:22:27,920 --> 01:22:30,720
<font color="#ffff54">기본적으로 모든 트래픽을 차단하고 있습니다.</font>

2425
01:22:30,720 --> 01:22:31,720
There you go.

2426
01:22:30,720 --> 01:22:31,720
<font color="#ffff54">여기까지입니다.</font>

2427
01:22:31,720 --> 01:22:36,720
Now, look, let's create this super basic network policy in Kubernetes.

2428
01:22:31,720 --> 01:22:36,720
<font color="#ffff54">이제 쿠버네티스에서 이 아주 기본적인 네트워크 정책을 생성해 보자.</font>

2429
01:22:36,720 --> 01:22:40,720
We're defining, hey, the matching label, actually, you know, the destination label,

2430
01:22:36,720 --> 01:22:40,720
<font color="#ffff54">우리는 일치하는 레이블, 즉 대상 레이블을 정의하고 있습니다,</font>

2431
01:22:40,720 --> 01:22:46,720
in this case, HTTP bin, and the source address is sleep.

2432
01:22:40,720 --> 01:22:46,720
<font color="#ffff54">이 경우, HTTP bin이고 소스 주소는 sleep입니다.</font>

2433
01:22:46,720 --> 01:22:56,720
So if we execute this code again, which is actually allowing calling from sleep to HTTP bin,

2434
01:22:46,720 --> 01:22:56,720
<font color="#ffff54">따라서 이 코드를 다시 실행하면 실제로 절전 모드에서 HTTP 빈으로 호출을 허용합니다,</font>

2435
01:22:56,720 --> 01:22:57,720
it's not working, right?

2436
01:22:56,720 --> 01:22:57,720
<font color="#ffff54">작동하지 않죠?</font>

2437
01:22:57,720 --> 01:22:59,720
Because by default, I'm blocking all this traffic.

2438
01:22:57,720 --> 01:22:59,720
<font color="#ffff54">기본적으로 이 모든 트래픽을 차단하고 있기 때문입니다.</font>

2439
01:22:59,720 --> 01:23:08,720
But if I go and copy my network policy, create that in Kubernetes,

2440
01:22:59,720 --> 01:23:08,720
<font color="#ffff54">하지만 내 네트워크 정책을 복사해서 쿠버네티스에 생성하면 된다,</font>

2441
01:23:08,720 --> 01:23:10,720
see if that's got created.

2442
01:23:08,720 --> 01:23:10,720
<font color="#ffff54">생성되었는지 확인한다.</font>

2443
01:23:12,720 --> 01:23:13,720
There you go.

2444
01:23:12,720 --> 01:23:13,720
<font color="#ffff54">됐어요.</font>

2445
01:23:13,720 --> 01:23:14,720
It got created on Kubernetes now.

2446
01:23:13,720 --> 01:23:14,720
<font color="#ffff54">이제 쿠버네티스에서 생성되었다.</font>

2447
01:23:14,720 --> 01:23:18,720
My code is running, you know, I'm just doing a loop of like 10 seconds.

2448
01:23:14,720 --> 01:23:18,720
<font color="#ffff54">내 코드가 실행 중입니다. 10초 정도의 루프를 실행 중입니다.</font>

2449
01:23:18,720 --> 01:23:19,720
So it's going to go.

2450
01:23:18,720 --> 01:23:19,720
<font color="#ffff54">그럼 실행됩니다.</font>

2451
01:23:19,720 --> 01:23:20,720
There you go.

2452
01:23:19,720 --> 01:23:20,720
<font color="#ffff54">됐어요.</font>

2453
01:23:20,720 --> 01:23:21,720
It detected the kube policy.

2454
01:23:20,720 --> 01:23:21,720
<font color="#ffff54">큐브 정책을 감지했습니다.</font>

2455
01:23:21,720 --> 01:23:28,720
It's allowing traffic now from the pod that is ending with 200 and the pod that's ending with 15,

2456
01:23:21,720 --> 01:23:28,720
<font color="#ffff54">이제 200으로 끝나는 파드와 15로 끝나는 파드의 트래픽을 허용한다,</font>

2457
01:23:28,720 --> 01:23:31,720
which is the sleep pod and the HTTP bin pod.

2458
01:23:28,720 --> 01:23:31,720
<font color="#ffff54">이는 슬립 파드와 HTTP 빈 파드이다.</font>

2459
01:23:31,720 --> 01:23:38,720
And if I run the code again, there you go.

2460
01:23:31,720 --> 01:23:38,720
<font color="#ffff54">코드를 다시 실행하면 다음과 같습니다.</font>

2461
01:23:39,720 --> 01:23:45,720
We just created a very tiny, tiny, tiny, silly, all right?

2462
01:23:39,720 --> 01:23:45,720
<font color="#ffff54">방금 아주 작고, 아주 작고, 아주 작고, 아주 바보 같은 것을 만들었어, 알겠어?</font>

2463
01:23:45,720 --> 01:23:52,720
Let's basically take a Kubernetes policy, create, you know, write a value in a map,

2464
01:23:45,720 --> 01:23:52,720
<font color="#ffff54">기본적으로 쿠버네티스 정책을 가져와서 맵에 값을 작성해 봅시다,</font>

2465
01:23:52,720 --> 01:23:58,720
get an EBPF code that's been attached with a CNI to enforce a certain security rule.

2466
01:23:52,720 --> 01:23:58,720
<font color="#ffff54">특정 보안 규칙을 적용하기 위해 CNI와 함께 첨부된 EBPF 코드를 가져온다.</font>

2467
01:23:58,720 --> 01:24:04,720
And with that being said, this is the end of this workshop.

2468
01:23:58,720 --> 01:24:04,720
<font color="#ffff54">이것으로 이 워크샵은 끝입니다.</font>

2469
01:24:04,720 --> 01:24:06,720
I hope you guys enjoyed it.

2470
01:24:04,720 --> 01:24:06,720
<font color="#ffff54">다들 즐거웠길 바랍니다.</font>

2471
01:24:06,720 --> 01:24:08,720
There's much things to talk about.

2472
01:24:06,720 --> 01:24:08,720
<font color="#ffff54">할 얘기가 많네요.</font>

2473
01:24:08,720 --> 01:24:13,720
All right, thank you.

2474
01:24:08,720 --> 01:24:13,720
<font color="#ffff54">알았어, 고마워.</font>

2475
01:24:13,720 --> 01:24:16,720
Again, don't recreate that.

2476
01:24:13,720 --> 01:24:16,720
<font color="#ffff54">다시 말하지만, 다시 만들지 마세요.</font>

2477
01:24:16,720 --> 01:24:21,720
I want you, after this session, to be able to open the hood of a car and saying this is the battery

2478
01:24:16,720 --> 01:24:21,720
<font color="#ffff54">이 세션이 끝나면 자동차 보닛을 열어서 이게 배터리라고 말할 수 있기를 바랍니다.</font>

2479
01:24:21,720 --> 01:24:22,720
and this is the engine.

2480
01:24:21,720 --> 01:24:22,720
<font color="#ffff54">이건 엔진이고요.</font>

2481
01:24:22,720 --> 01:24:26,720
And you've opened like, you know, your Kubernetes cluster and look at things like, hey,

2482
01:24:22,720 --> 01:24:26,720
<font color="#ffff54">그리고 쿠버네티스 클러스터를 열면 다음과 같은 것을 볼 수 있습니다,</font>

2483
01:24:26,720 --> 01:24:30,720
well, this is probably a map and this is how things are enforced, okay?

2484
01:24:26,720 --> 01:24:30,720
<font color="#ffff54">이게 아마 지도일 것이고, 이게 어떻게 적용되는지 알겠죠?</font>

2485
01:24:30,720 --> 01:24:31,720
Yeah.

2486
01:24:30,720 --> 01:24:31,720
<font color="#ffff54">그래</font>

2487
01:24:31,720 --> 01:24:33,720
Yeah.

2488
01:24:31,720 --> 01:24:33,720
<font color="#ffff54">Yes.</font>

2489
01:24:33,720 --> 01:24:40,720
Okay, great question.

2490
01:24:33,720 --> 01:24:40,720
<font color="#ffff54">좋아, 좋은 질문이야.</font>

2491
01:24:40,720 --> 01:24:45,720
The question is, is C the only language we can use to write this program?

2492
01:24:40,720 --> 01:24:45,720
<font color="#ffff54">문제는 이 프로그램을 작성하는 데 사용할 수 있는 언어가 C뿐이냐는 것입니다.</font>

2493
01:24:45,720 --> 01:24:49,720
Unfortunately, on the kernel side, it's C.

2494
01:24:45,720 --> 01:24:49,720
<font color="#ffff54">불행히도 커널 쪽에서는 C입니다.</font>

2495
01:24:49,720 --> 01:24:52,720
You're going to have to write your code in C.

2496
01:24:49,720 --> 01:24:52,720
<font color="#ffff54">코드를 C로 작성해야 합니다.</font>

2497
01:24:52,720 --> 01:24:58,720
On the kernel side, for the user space, then you have more flexibility.

2498
01:24:52,720 --> 01:24:58,720
<font color="#ffff54">커널 쪽에서는 사용자 공간에 대해 더 많은 유연성이 있습니다.</font>

2499
01:24:58,720 --> 01:25:04,720
Again, I was going to show you actually this cool project.

2500
01:24:58,720 --> 01:25:04,720
<font color="#ffff54">다시 한 번, 이 멋진 프로젝트를 보여드리려고 합니다.</font>

2501
01:25:04,720 --> 01:25:10,720
If you take a look at the Selium, you know, the Selium EPPF repository,

2502
01:25:04,720 --> 01:25:10,720
<font color="#ffff54">셀리움을 보시면 아시겠지만, 셀리움 EPPF 저장소가 있습니다,</font>

2503
01:25:10,720 --> 01:25:18,720
it has a good example about how to actually load a certain example, like K-probe, for example.

2504
01:25:10,720 --> 01:25:18,720
<font color="#ffff54">예를 들어 K-probe와 같은 특정 예제를 실제로 로드하는 방법에 대한 좋은 예제가 있습니다.</font>

2505
01:25:18,720 --> 01:25:27,720
K-probe will have the backend code and you're going to have some, you know, let's say, user space code.

2506
01:25:18,720 --> 01:25:27,720
<font color="#ffff54">K-프로브에는 백엔드 코드가 있고, 여러분은 사용자 공간 코드가 있을 것입니다.</font>

2507
01:25:27,720 --> 01:25:30,720
Lib eppf2, Rust can be an option.

2508
01:25:27,720 --> 01:25:30,720
<font color="#ffff54">라이브러리 eppf2, 러스트는 옵션이 될 수 있습니다.</font>

2509
01:25:30,720 --> 01:25:37,720
There are certain technologies that now is kind of doing working on what we call binding, right, on the user space.

2510
01:25:30,720 --> 01:25:37,720
<font color="#ffff54">현재 사용자 공간에서 바인딩이라고 부르는 작업을 하는 특정 기술이 있습니다.</font>

2511
01:25:37,720 --> 01:25:42,720
But the backend, it's still going to be C, like a kernel.

2512
01:25:37,720 --> 01:25:42,720
<font color="#ffff54">하지만 백엔드는 여전히 커널처럼 C로 되어 있습니다.</font>

2513
01:25:42,720 --> 01:25:46,720
Yeah.

2514
01:25:42,720 --> 01:25:46,720
<font color="#ffff54">그렇군요.</font>

2515
01:25:46,720 --> 01:25:50,720
Yes, a Rust on the user space.

2516
01:25:46,720 --> 01:25:50,720
<font color="#ffff54">예, 사용자 공간에 녹이 있습니다.</font>

2517
01:25:50,720 --> 01:25:58,720
I mean, I'm pretty sure that's not something that I'm 100% sure that, you know, let's take a look at lib eppf, actually.

2518
01:25:50,720 --> 01:25:58,720
<font color="#ffff54">제 말은, 제가 100% 확신할 수 있는 것은 아닌 것 같은데, 실제로 lib eppf를 살펴봅시다.</font>

2519
01:25:58,720 --> 01:26:04,720
Look, if you go to BPF, BPF bootstrap, it has good examples.

2520
01:25:58,720 --> 01:26:04,720
<font color="#ffff54">BPF, BPF 부트스트랩에 가보면 좋은 예제가 있습니다.</font>

2521
01:26:04,720 --> 01:26:09,720
If you go example here, you can take a look, there's a Rust repo to give you a couple things.

2522
01:26:04,720 --> 01:26:09,720
<font color="#ffff54">여기 예제를 보시면 몇 가지를 알려주는 Rust 저장소가 있습니다.</font>

2523
01:26:09,720 --> 01:26:12,720
Let's take a look at XDP.

2524
01:26:09,720 --> 01:26:12,720
<font color="#ffff54">XDP를 살펴봅시다.</font>

2525
01:26:12,720 --> 01:26:13,720
So, yeah.

2526
01:26:12,720 --> 01:26:13,720
<font color="#ffff54">그러네요.</font>

2527
01:26:13,720 --> 01:26:19,720
Actually, BPF, now I think the BPF itself was written in C, right?

2528
01:26:13,720 --> 01:26:19,720
<font color="#ffff54">사실, BPF, 이제 BPF 자체가 C로 작성된 것 같지 않나요?</font>

2529
01:26:19,720 --> 01:26:21,720
But I think the loading was in Rust.

2530
01:26:19,720 --> 01:26:21,720
<font color="#ffff54">하지만 로딩은 Rust로 된 것 같아요.</font>

2531
01:26:21,720 --> 01:26:25,720
I think that's where it is.

2532
01:26:21,720 --> 01:26:25,720
<font color="#ffff54">거기 있는 것 같아요.</font>

2533
01:26:25,720 --> 01:26:30,720
In the kernel space, do you have to worry about normal concurrency constructs and stuff like that?

2534
01:26:25,720 --> 01:26:30,720
<font color="#ffff54">커널 공간에서 일반적인 동시성 구조나 그런 것들에 대해 걱정할 필요가 있나요?</font>

2535
01:26:30,720 --> 01:26:32,720
Because when you're doing the incrementing, there's...

2536
01:26:30,720 --> 01:26:32,720
<font color="#ffff54">왜냐하면 증분을 할 때...</font>

2537
01:26:32,720 --> 01:26:35,720
Yeah, I mean, you should probably...

2538
01:26:32,720 --> 01:26:35,720
<font color="#ffff54">네, 제 말은, 아마...</font>

2539
01:26:35,720 --> 01:26:40,720
I didn't very much double talk too much on the BPF map.

2540
01:26:35,720 --> 01:26:40,720
<font color="#ffff54">BPF 맵에서 너무 이중적인 말을 많이 하지 않았어.</font>

2541
01:26:40,720 --> 01:26:45,720
There's BPF maps that are very much isolated by CPU and so on.

2542
01:26:40,720 --> 01:26:45,720
<font color="#ffff54">CPU 등에 의해 매우 고립된 BPF 맵이 있습니다.</font>

2543
01:26:45,720 --> 01:26:50,720
So you can define, you know, when you're writing any resource, obviously, concurrency is a...

2544
01:26:45,720 --> 01:26:50,720
<font color="#ffff54">그래서 어떤 리소스를 작성할 때, 분명히 동시성을 정의할 수 있습니다.</font>

2545
01:26:50,720 --> 01:26:51,720
It may be a problem.

2546
01:26:50,720 --> 01:26:51,720
<font color="#ffff54">문제가 될 수 있습니다.</font>

2547
01:26:51,720 --> 01:26:56,720
But most of the time, you just need to design the right thing.

2548
01:26:51,720 --> 01:26:56,720
<font color="#ffff54">하지만 대부분의 경우 제대로 설계하기만 하면 됩니다.</font>

2549
01:26:56,720 --> 01:27:03,720
So if you're writing a map, just try to figure out the right use case for you.

2550
01:26:56,720 --> 01:27:03,720
<font color="#ffff54">따라서 지도를 작성할 때는 자신에게 맞는 사용 사례를 찾아보세요.</font>

2551
01:27:03,720 --> 01:27:10,720
If something that is very much segregated for a node, for example, to limit the interaction between multiple users, it can be an option.

2552
01:27:03,720 --> 01:27:10,720
<font color="#ffff54">예를 들어 여러 사용자 간의 상호 작용을 제한하기 위해 노드에 대해 매우 분리된 무언가가 있다면, 그것은 옵션이 될 수 있습니다.</font>

2553
01:27:10,720 --> 01:27:14,720
But yeah, I think that's something that you still have to worry about.

2554
01:27:10,720 --> 01:27:14,720
<font color="#ffff54">하지만 네, 그건 여전히 걱정해야 할 부분이라고 생각합니다.</font>

2555
01:27:14,720 --> 01:27:21,720
But if you look at libBPF and look at a lot of projects, there's a lot of...

2556
01:27:14,720 --> 01:27:21,720
<font color="#ffff54">하지만 libBPF를 보고 많은 프로젝트를 보면, 많은...</font>

2557
01:27:21,720 --> 01:27:28,720
It's emerging. There's a lot of new code, new technology that kind of simplifies life for you.

2558
01:27:21,720 --> 01:27:28,720
<font color="#ffff54">떠오르고 있습니다. 새로운 코드, 새로운 기술이 많이 등장해서 삶을 단순화시켜주고 있습니다.</font>

2559
01:27:28,720 --> 01:27:36,720
Like when you write a specific code, I didn't talk about it much, but eBPF is very strict, very strict.

2560
01:27:28,720 --> 01:27:36,720
<font color="#ffff54">특정 코드를 작성할 때처럼, 제가 많이 이야기하지는 않았지만 eBPF는 매우 엄격하고 매우 엄격합니다.</font>

2561
01:27:36,720 --> 01:27:38,720
You cannot just go and create any C code.

2562
01:27:36,720 --> 01:27:38,720
<font color="#ffff54">아무 코드나 아무렇게나 만들 수 없습니다.</font>

2563
01:27:38,720 --> 01:27:47,720
Once it detects that you are going to write something out of range or do something that it should not be doing, it's not going to allow you to even build it.

2564
01:27:38,720 --> 01:27:47,720
<font color="#ffff54">범위를 벗어난 코드를 작성하거나 해서는 안 되는 일을 하려는 것을 감지하면 빌드조차 허용하지 않습니다.</font>

2565
01:27:47,720 --> 01:27:51,720
Or if it builds it, it doesn't allow you to mount it.

2566
01:27:47,720 --> 01:27:51,720
<font color="#ffff54">또는 빌드하더라도 마운트할 수 없습니다.</font>

2567
01:27:51,720 --> 01:27:53,720
So I think you have a lot of controls there.

2568
01:27:51,720 --> 01:27:53,720
<font color="#ffff54">그래서 거기에 많은 컨트롤이 있는 것 같아요.</font>

2569
01:27:53,720 --> 01:27:58,720
And if you look at the BPF code, look at the BPF tools, it helps you answer these questions you have.

2570
01:27:53,720 --> 01:27:58,720
<font color="#ffff54">그리고 BPF 코드를 보면, BPF 도구를 보면 이런 질문에 답하는 데 도움이 됩니다.</font>

2571
01:28:02,720 --> 01:28:04,720
Any other questions?

2572
01:28:02,720 --> 01:28:04,720
<font color="#ffff54">다른 질문이 있나요?</font>

2573
01:28:04,720 --> 01:28:14,720
Is there a way to see what BPF code has been noted?

2574
01:28:04,720 --> 01:28:14,720
<font color="#ffff54">어떤 BPF 코드가 기록되었는지 확인할 수 있는 방법이 있나요?</font>

2575
01:28:14,720 --> 01:28:20,720
Like if I was on the server and you wrote some block home, both RAM and then went home.

2576
01:28:14,720 --> 01:28:20,720
<font color="#ffff54">예를 들어 제가 서버에 있을 때 어떤 블록을 램과 램 모두에 쓴 다음 집으로 돌아갔다면요.</font>

2577
01:28:20,720 --> 01:28:24,720
Is there a way to break BPF code?

2578
01:28:20,720 --> 01:28:24,720
<font color="#ffff54">BPF 코드를 깨는 방법이 있나요?</font>

2579
01:28:24,720 --> 01:28:27,720
To know that actually this BPF code got bit invoked? Is that what you're saying?

2580
01:28:24,720 --> 01:28:27,720
<font color="#ffff54">실제로 이 BPF 코드가 호출되었다는 것을 알고 싶으신가요? 그런 뜻인가요?</font>

2581
01:28:27,720 --> 01:28:31,720
Yeah, so you saw what we did with IP rules.

2582
01:28:27,720 --> 01:28:31,720
<font color="#ffff54">네, 우리가 IP 규칙으로 뭘 했는지 보셨죠?</font>

2583
01:28:31,720 --> 01:28:36,720
We set like zero and like if the rule got blocked, it's like a one or something.

2584
01:28:31,720 --> 01:28:36,720
<font color="#ffff54">0으로 설정하고 규칙이 차단되면 1로 설정하는 식으로요.</font>

2585
01:28:36,720 --> 01:28:38,720
That's how you should design probably your eBPF code.

2586
01:28:36,720 --> 01:28:38,720
<font color="#ffff54">이것이 아마도 여러분의 eBPF 코드를 설계하는 방법일 것입니다.</font>

2587
01:28:38,720 --> 01:28:41,720
You should actually think about, okay, I'm going to define the rule.

2588
01:28:38,720 --> 01:28:41,720
<font color="#ffff54">실제로 규칙을 정의해야 합니다.</font>

2589
01:28:41,720 --> 01:28:46,720
The rule for me is to block A to B, but also I need to define the monitoring aspect.

2590
01:28:41,720 --> 01:28:46,720
<font color="#ffff54">내 규칙은 A에서 B로 차단하는 것이지만 모니터링 측면도 정의해야 합니다.</font>

2591
01:28:46,720 --> 01:29:02,720
And let's define the, let's say you can create a metric like we did earlier to say every time I'm blocking from A to B because of my code, go create this metric that you can go and put that in Prometheus and alert on it.

2592
01:28:46,720 --> 01:29:02,720
<font color="#ffff54">그리고 앞서 했던 것처럼 내 코드 때문에 A에서 B로 차단할 때마다 이 메트릭을 만들어서 Prometheus에 넣고 알림을 보낼 수 있는 메트릭을 만들 수 있다고 가정해 봅시다.</font>

2593
01:29:02,720 --> 01:29:08,720
Again, when you create your eBPF code, think about the monitoring aspect and also the enforcement aspect.

2594
01:29:02,720 --> 01:29:08,720
<font color="#ffff54">다시 한 번 강조하지만, eBPF 코드를 만들 때는 모니터링 측면과 실행 측면을 모두 고려하세요.</font>

2595
01:29:09,720 --> 01:29:15,720
Maybe you're asking about the delivery that already comes from the computer or not.

2596
01:29:09,720 --> 01:29:15,720
<font color="#ffff54">컴퓨터에서 이미 전달된 배달에 대해 묻는 것일 수도 있습니다.</font>

2597
01:29:15,720 --> 01:29:28,720
Oh, so you're saying, can we take a look if a certain, okay, so if you use like, in my example, I'm using BPF tool, right?

2598
01:29:15,720 --> 01:29:28,720
<font color="#ffff54">아, 그러니까 특정, 그러니까 예를 들어 제 예제에서는 BPF 도구를 사용하는지 살펴볼 수 있느냐는 말씀이시죠?</font>

2599
01:29:28,720 --> 01:29:31,720
BPF tool is pretty cool and you can use different things.

2600
01:29:28,720 --> 01:29:31,720
<font color="#ffff54">BPF 도구는 꽤 멋지고 다양한 것을 사용할 수 있습니다.</font>

2601
01:29:31,720 --> 01:29:35,720
You can use BPF cool, BPF cool, that's a good name.

2602
01:29:31,720 --> 01:29:35,720
<font color="#ffff54">BPF 멋지다, BPF 멋지다, 좋은 이름이야.</font>

2603
01:29:35,720 --> 01:29:42,720
BPF tool on a certain interface is going to list all the eBPF code that's been attached to this interface.

2604
01:29:35,720 --> 01:29:42,720
<font color="#ffff54">특정 인터페이스의 BPF 도구는 이 인터페이스에 첨부된 모든 eBPF 코드를 나열합니다.</font>

2605
01:29:42,720 --> 01:29:47,720
So you can always go back and say, oh, well, like what this kind of actually thing is not working.

2606
01:29:42,720 --> 01:29:47,720
<font color="#ffff54">그래서 언제든 돌아가서 이런 것이 실제로 작동하지 않는다고 말할 수 있습니다.</font>

2607
01:29:47,720 --> 01:29:49,720
Oh, like let's run BPF tool on a certain interface.

2608
01:29:47,720 --> 01:29:49,720
<font color="#ffff54">아, 특정 인터페이스에서 BPF 도구를 실행해 봅시다.</font>

2609
01:29:49,720 --> 01:29:52,720
Okay, well, all these things are being attached.

2610
01:29:49,720 --> 01:29:52,720
<font color="#ffff54">좋아, 이 모든 것들이 연결되고 있네요.</font>

2611
01:29:52,720 --> 01:29:54,720
Therefore, this is why it's enforced.

2612
01:29:52,720 --> 01:29:54,720
<font color="#ffff54">따라서 이것이 시행되는 이유입니다.</font>

2613
01:30:00,720 --> 01:30:02,720
Network interface, correct.

2614
01:30:00,720 --> 01:30:02,720
<font color="#ffff54">네트워크 인터페이스, 맞습니다.</font>

2615
01:30:05,720 --> 01:30:12,720
Yeah, yeah, eBPF is definitely, again, we are just seeing that in the context of networking.

2616
01:30:05,720 --> 01:30:12,720
<font color="#ffff54">네, 네, 네, eBPF는 확실히 네트워킹의 맥락에서 볼 수 있습니다.</font>

2617
01:30:12,720 --> 01:30:24,720
But eBPF code can be running for, let's say, SIS calls or like system calls or opening a file here, you know, things that are in, you know, let's say you want to monitor other aspects of Linux.

2618
01:30:12,720 --> 01:30:24,720
<font color="#ffff54">하지만 eBPF 코드는 예를 들어 학생 정보 시스템 호출이나 시스템 호출, 파일 열기 등 리눅스의 다른 측면을 모니터링하고 싶을 때 실행될 수 있습니다.</font>

2619
01:30:24,720 --> 01:30:26,720
It doesn't have to be networking.

2620
01:30:24,720 --> 01:30:26,720
<font color="#ffff54">꼭 네트워킹일 필요는 없습니다.</font>

2621
01:30:26,720 --> 01:30:30,720
But obviously, interface comes in discussion when we're talking about networking for sure.

2622
01:30:26,720 --> 01:30:30,720
<font color="#ffff54">하지만 분명히 네트워킹에 대해 이야기할 때 인터페이스가 논의되는 것은 당연합니다.</font>

2623
01:30:30,720 --> 01:30:40,720
Okay, thank you very much for joining this session. Hope to see you soon and have a good KubeCon.

2624
01:30:30,720 --> 01:30:40,720
<font color="#ffff54">좋아요, 이 세션에 참여해 주셔서 대단히 감사합니다. 곧 다시 뵙고 즐거운 KubeCon이 되길 바랍니다.</font>
