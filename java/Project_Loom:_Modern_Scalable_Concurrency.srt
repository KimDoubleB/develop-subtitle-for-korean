1
00:00:00,000 --> 00:00:12,640
Hello, I'm here to talk about Project Loom.
<font color="#0eade1">안녕하세요, 프로젝트 룸에 대해 이야기하러 왔습니다.</font>

2
00:00:12,640 --> 00:00:17,920
Can I just get a quick show of hands who's actually tried virtual threads already?
<font color="#0eade1">가상 실을 사용해 보신 분들 손 좀 들어주실래요?</font>

3
00:00:17,920 --> 00:00:20,519
Okay, maybe about a third of the people.
<font color="#0eade1">좋아요, 아마 1/3 정도일 거예요.</font>

4
00:00:20,519 --> 00:00:21,600
Okay, thanks very much.
<font color="#0eade1">좋아요, 감사합니다.</font>

5
00:00:21,600 --> 00:00:24,480
Just wanted to get an idea.
<font color="#0eade1">그냥 아이디어를 얻고 싶었어요.</font>

6
00:00:24,480 --> 00:00:27,800
Okay, so Project Loom, what's it about?
<font color="#0eade1">좋아, 그럼 프로젝트 룸은 뭐지?</font>

7
00:00:27,800 --> 00:00:33,240
So Project Loom is a project in OpenJDK that's really about upgrading the Java concurrency
<font color="#0eade1">프로젝트 룸은 Java 동시성을 업그레이드하는 OpenJDK의 프로젝트입니다.</font>

8
00:00:33,240 --> 00:00:34,439
model.
<font color="#0eade1">모델입니다.</font>

9
00:00:34,439 --> 00:00:37,359
It's all about high-scale server applications.
<font color="#0eade1">대규모 서버 애플리케이션에 관한 모든 것입니다.</font>

10
00:00:37,359 --> 00:00:41,280
So there's a lot of concurrency and a great story for concurrency in the Java platform
<font color="#0eade1">따라서 Java 플랫폼에는 많은 동시성과 동시성에 대한 훌륭한 스토리가 있습니다.</font>

11
00:00:41,280 --> 00:00:44,000
right from all the way back to JDK 1.
<font color="#0eade1">JDK 1까지 거슬러 올라갑니다.</font>

12
00:00:44,000 --> 00:00:46,320
First-class support for Java monitors.
<font color="#0eade1">Java 모니터에 대한 최고 수준의 지원.</font>

13
00:00:46,320 --> 00:00:52,519
Since Java 5, there's a Java 2 concurrency, concurrent APIs for more advanced concurrency
<font color="#0eade1">Java 5부터 Java 2 동시성, 고급 동시성을 위한 동시 API가 있습니다.</font>

14
00:00:52,519 --> 00:00:54,400
features.
<font color="#0eade1">기능이 추가되었습니다.</font>

15
00:00:54,400 --> 00:00:56,760
And so this is all good.
<font color="#0eade1">이제 모두 정상입니다.</font>

16
00:00:56,759 --> 00:01:04,000
But what Project Loom, at least initially, is focusing on concurrency, which is about
<font color="#0eade1">하지만 적어도 초기에 프로젝트 룸은 동시성에 초점을 맞추고 있습니다.</font>

17
00:01:04,000 --> 00:01:08,920
thread per request or thread per task or thread per connection, which is very much the traditional
<font color="#0eade1">요청당 스레드 또는 작업당 스레드 또는 연결당 스레드, 이는 매우 전통적인</font>

18
00:01:08,920 --> 00:01:11,400
thread per task scheduling model.
<font color="#0eade1">작업당 스레드입니다.</font>

19
00:01:11,400 --> 00:01:16,400
This is something that we all know and like, because it's very simple to work with, but
<font color="#0eade1">이것은 작업하기가 매우 간단하기 때문에 우리 모두가 알고 있고 좋아하는 것입니다.</font>

20
00:01:16,400 --> 00:01:21,439
it really only tops out with a few thousand concurrent tasks when you're actually mapping
<font color="#0eade1">실제로 매핑을 할 때는 수천 개의 동시 작업으로만 정점을 찍습니다.</font>

21
00:01:21,560 --> 00:01:28,319
those tasks to an operating system or, since JDK 19, what we call a platform thread.
<font color="#0eade1">이러한 작업을 운영 체제 또는 JDK 19부터는 플랫폼 스레드라고 부르는 것에 매핑합니다.</font>

22
00:01:28,319 --> 00:01:31,560
What we think with Project Loom and with virtual threads is that we can actually scale this
<font color="#0eade1">프로젝트 룸과 가상 스레드를 사용하면 실제로 다음과 같이 확장할 수 있다고 생각합니다.</font>

23
00:01:31,560 --> 00:01:33,319
model a lot further.
<font color="#0eade1">모델을 훨씬 더 확장할 수 있습니다.</font>

24
00:01:33,319 --> 00:01:37,079
Some other languages and runtimes have done this kind of thing as well.
<font color="#0eade1">다른 언어와 런타임에서도 이런 종류의 작업을 수행했습니다.</font>

25
00:01:37,079 --> 00:01:41,620
So instead of topping out at a couple of few thousand concurrent tasks, we should be able
<font color="#0eade1">따라서 몇 천 개의 동시 작업에서 정점을 찍는 대신 다음과 같이 할 수 있어야 합니다.</font>

26
00:01:41,620 --> 00:01:46,259
to scale up to have a couple of hundred thousand tasks, concurrent tasks, or even millions
<font color="#0eade1">수십만 개의 작업, 동시 작업 또는 수백만 개의 작업으로 확장할 수 있어야 합니다.</font>

27
00:01:46,259 --> 00:01:48,959
of concurrent tasks.
<font color="#0eade1">동시 작업의 수입니다.</font>

28
00:01:48,960 --> 00:01:55,360
So what we've done is expose this thing called virtual threads, and they're exposed to developers
<font color="#0eade1">그래서 우리가 한 일은 가상 스레드라는 것을 노출한 것이고, 개발자에게 노출된 것입니다.</font>

29
00:01:55,360 --> 00:01:58,560
with the Java API.
<font color="#0eade1">자바 API로.</font>

30
00:01:58,560 --> 00:02:03,560
So the old API that we've actually been there since JDK 1.0, but cleaned up, some of the
<font color="#0eade1">따라서 JDK 1.0부터 실제로 존재했지만 정리된 이전 API 중 일부인</font>

31
00:02:03,560 --> 00:02:08,319
baggage is gone, but with a much more scalable implementation.
<font color="#0eade1">수하물은 사라졌지만 훨씬 더 확장 가능한 구현으로 바뀌었습니다.</font>

32
00:02:08,319 --> 00:02:15,360
The big advantage of this is that we can continue with very sequential blocking code that's
<font color="#0eade1">이 방법의 가장 큰 장점은 다음과 같은 매우 순차적인 차단 코드를 계속 사용할 수 있다는 것입니다.</font>

33
00:02:15,360 --> 00:02:20,800
very, very easy to read and write, and it also has very understandable control flow.
<font color="#0eade1">읽기 및 쓰기가 매우 쉽고 제어 흐름도 매우 이해하기 쉽습니다.</font>

34
00:02:20,800 --> 00:02:26,040
And understandable control flow is really important when actually maintaining code.
<font color="#0eade1">실제로 코드를 유지 관리할 때 이해하기 쉬운 제어 흐름은 정말 중요합니다.</font>

35
00:02:26,040 --> 00:02:30,560
The alternative to this is what some, at least advanced developers, have been doing for the
<font color="#0eade1">이에 대한 대안으로 일부, 적어도 고급 개발자들은</font>

36
00:02:30,560 --> 00:02:39,480
last while is, because things were topping out at a couple of thousand concurrent threads,
<font color="#0eade1">에 대한 대안은 동시 스레드 수가 수천 개에 달했기 때문입니다,</font>

37
00:02:39,480 --> 00:02:43,600
is they've been making use of the async and reactive type APIs.
<font color="#0eade1">비동기 및 반응형 API를 사용하고 있다는 것입니다.</font>

38
00:02:43,719 --> 00:02:48,560
That leads to very contorted code in some cases.
<font color="#0eade1">이로 인해 경우에 따라 매우 왜곡된 코드가 생성됩니다.</font>

39
00:02:48,560 --> 00:02:52,560
It might be okay to read, it might look okay, but it's very, very hard code to maintain,
<font color="#0eade1">읽기에는 괜찮고 보기에는 괜찮을지 모르지만 유지 관리하기에는 매우 어려운 코드입니다,</font>

40
00:02:52,560 --> 00:02:55,199
debug, profile, and so on.
<font color="#0eade1">디버그, 프로파일 등.</font>

41
00:02:55,199 --> 00:02:59,680
Things like stack traces and stuff don't always make sense in those kind of environments.
<font color="#0eade1">스택 추적과 같은 것들이 이런 환경에서는 항상 의미가 있는 것은 아닙니다.</font>

42
00:02:59,680 --> 00:03:04,919
There's a couple of other aspects to Project Loom, and I'm going to talk a little bit about
<font color="#0eade1">프로젝트 룸에는 몇 가지 다른 측면이 있는데, 그 중 몇 가지에 대해 조금 이야기해볼게요.</font>

43
00:03:04,919 --> 00:03:12,439
this today, particularly around grouping of tasks that are part of some larger unit of
<font color="#0eade1">특히 더 큰 단위의 일부인 작업 그룹화에 대해 이야기하겠습니다.</font>

44
00:03:12,439 --> 00:03:13,439
work.
<font color="#0eade1">작업.</font>

45
00:03:13,439 --> 00:03:19,039
So, virtual threads, as I said, are just a different implementation of threading.
<font color="#0eade1">따라서 가상 스레드는 앞서 말했듯이 스레딩의 다른 구현일 뿐입니다.</font>

46
00:03:19,039 --> 00:03:23,439
So, rather than being tied to an operating system thread and carrying around this big
<font color="#0eade1">따라서 운영 체제 스레드에 묶여 이 큰 파일을 가지고 다니는 대신</font>

47
00:03:23,439 --> 00:03:29,639
continuous stack, virtual threads work a little bit differently in that they're managed by
<font color="#0eade1">연속 스택을 가지고 다니는 대신, 가상 스레드는 다음과 같이 관리된다는 점에서 약간 다르게 작동합니다.</font>

48
00:03:29,639 --> 00:03:32,759
the Java runtime.
<font color="#0eade1">에 의해 관리됩니다.</font>

49
00:03:32,759 --> 00:03:38,879
The thread stack is actually a sort of a pay-as-you-go stack that's actually stored in the Java heap.
<font color="#0eade1">스레드 스택은 실제로 Java 힙에 저장되는 일종의 종량제 스택입니다.</font>

50
00:03:38,879 --> 00:03:46,519
It makes use of some lower level constructs in the VM to be able to support this.
<font color="#0eade1">이를 지원하기 위해 VM의 일부 하위 수준 구성을 사용합니다.</font>

51
00:03:46,519 --> 00:03:52,960
And what it means is that we can have a lot more virtual threads than we can have platform
<font color="#0eade1">그리고 이것이 의미하는 바는 플랫폼보다 훨씬 더 많은 가상 스레드를 가질 수 있다는 것입니다.</font>

52
00:03:52,960 --> 00:03:53,960
threads.
<font color="#0eade1">스레드.</font>

53
00:03:53,960 --> 00:03:59,199
If you've ever seen any diagrams of different threading models, what we have is kind of
<font color="#0eade1">다른 스레딩 모델에 대한 다이어그램을 본 적이 있다면, 우리가 가진 것은 일종의</font>

54
00:03:59,199 --> 00:04:04,479
closer to what we call an end-to-end model, where you've got n virtual threads, let's
<font color="#0eade1">n개의 가상 스레드가 있는 엔드투엔드 모델에 더 가깝다고 할 수 있습니다.</font>

55
00:04:04,480 --> 00:04:12,440
say a million virtual threads, and they sit on top of, are carried by n platform threads,
<font color="#0eade1">백만 개의 가상 스레드가 있고, 그 위에 플랫폼 스레드 n개가 있다고 가정해 보겠습니다,</font>

56
00:04:12,440 --> 00:04:13,640
or operating system threads.
<font color="#0eade1">또는 운영 체제 스레드에 의해 수행됩니다.</font>

57
00:04:13,640 --> 00:04:19,560
And we refer to these threads that are managed by a scheduler in the Java runtime, we refer
<font color="#0eade1">그리고 Java 런타임에서 스케줄러에 의해 관리되는 이러한 스레드를 참조합니다.</font>

58
00:04:19,560 --> 00:04:24,720
to those as carrier threads when they're in use.
<font color="#0eade1">를 사용 중일 때 캐리어 스레드라고 합니다.</font>

59
00:04:24,720 --> 00:04:29,080
So I said about that we use a Java thread API.
<font color="#0eade1">Java 스레드 API를 사용한다고 말씀드렸습니다.</font>

60
00:04:30,039 --> 00:04:37,000
One of the things is we spent over five years working on Project Loom.
<font color="#0eade1">프로젝트 룸을 개발하는 데 5년이 넘게 걸렸습니다.</font>

61
00:04:37,000 --> 00:04:41,719
Project Loom was very much a jack up the houses, replace the foundations, and put the house
<font color="#0eade1">프로젝트 룸은 집을 들어 올리고, 기초를 교체하고, 집을 짓는 작업이었어요.</font>

62
00:04:41,719 --> 00:04:45,240
down without actually breaking anything type of feature.
<font color="#0eade1">어떤 기능도 실제로 파괴하지 않고 무너뜨렸습니다.</font>

63
00:04:45,240 --> 00:04:48,839
And the API surface that it actually exposes is tiny.
<font color="#0eade1">그리고 실제로 노출되는 API 표면은 아주 작습니다.</font>

64
00:04:48,839 --> 00:04:54,959
There's some upgrades to the Java Lang thread API, there's some new factory methods on Java
<font color="#0eade1">Java Lang 스레드 API에 몇 가지 업그레이드가 있었고, Java에 몇 가지 새로운 팩토리 메서드가 있습니다.</font>

65
00:04:55,000 --> 00:05:00,799
util concurrent executors, and that's about it for the developer facing APIs.
<font color="#0eade1">동시 실행자 활용, 그리고 개발자가 API를 대면하는 데는 여기까지입니다.</font>

66
00:05:00,799 --> 00:05:08,680
There's a whole bunch of other stuff that is interesting for tools, debuggers, troubleshooting
<font color="#0eade1">도구, 디버거, 문제 해결에 흥미로운 다른 많은 것들이 있습니다.</font>

67
00:05:08,680 --> 00:05:15,479
type of APIs, where there's more surface there.
<font color="#0eade1">더 많은 표면이 있는 API 유형.</font>

68
00:05:15,479 --> 00:05:18,039
But for this talk, I'm not going to talk too much about that.
<font color="#0eade1">하지만 이번 강연에서는 이에 대해 너무 많이 이야기하지 않겠습니다.</font>

69
00:05:18,039 --> 00:05:23,240
But just to say is that this is a whole platform type of feature.
<font color="#0eade1">다만 말씀드리고 싶은 것은 이것이 전체 플랫폼 유형의 기능이라는 것입니다.</font>

70
00:05:23,319 --> 00:05:29,600
Although the developer facing APIs are tiny, reimplementing threads basically required
<font color="#0eade1">개발자 대면 API는 작지만 기본적으로 스레드 재구현이 필요합니다.</font>

71
00:05:29,600 --> 00:05:33,040
revisiting almost every area of the platform.
<font color="#0eade1">플랫폼의 거의 모든 영역을 재검토해야 했습니다.</font>

72
00:05:33,040 --> 00:05:39,000
Okay, so I just want to show just a couple of examples just to actually to show you using
<font color="#0eade1">자, 이제 몇 가지 예시를 보여드리겠습니다.</font>

73
00:05:39,000 --> 00:05:40,439
virtual threads.
<font color="#0eade1">가상 스레드.</font>

74
00:05:40,439 --> 00:05:47,960
What I've got here is a piece of code that makes a connection to oracle.com, downloads
<font color="#0eade1">여기에는 오라클닷컴에 연결하고, 다운로드하는 코드 조각이 있습니다.</font>

75
00:05:48,039 --> 00:05:55,599
the index.html file as a page and copies it to a local file.
<font color="#0eade1">index.html 파일을 페이지로 만들고 로컬 파일에 복사합니다.</font>

76
00:05:55,599 --> 00:05:57,159
This is boring code.
<font color="#0eade1">지루한 코드입니다.</font>

77
00:05:57,159 --> 00:05:58,560
This is really, really boring code.
<font color="#0eade1">정말, 정말 지루한 코드입니다.</font>

78
00:05:58,560 --> 00:06:00,120
And that's really what the point of this is.
<font color="#0eade1">이게 바로 이 코드의 요점입니다.</font>

79
00:06:00,120 --> 00:06:01,279
There's nothing new here.
<font color="#0eade1">여기엔 새로운 게 없어요.</font>

80
00:06:01,279 --> 00:06:04,919
This is code that you've probably seen 100 times.
<font color="#0eade1">아마 100번은 봤을 코드입니다.</font>

81
00:06:04,919 --> 00:06:09,479
This is code that's using the old synchronous IO APIs.
<font color="#0eade1">이전 동기 IO API를 사용하는 코드입니다.</font>

82
00:06:09,479 --> 00:06:16,240
But the interesting thing is that it's not consuming, it's an operating system thread
<font color="#0eade1">하지만 흥미로운 점은 이것이 소비하는 것이 아니라 운영 체제 스레드라는 것입니다.</font>

83
00:06:16,360 --> 00:06:18,639
for the entire duration of this code.
<font color="#0eade1">이 코드의 전체 기간 동안.</font>

84
00:06:18,639 --> 00:06:23,360
When it's blocking to actually do something, then it can actually return that operating
<font color="#0eade1">실제로 무언가를 수행하는 것을 차단하는 경우 실제로 해당 작동을 반환할 수 있습니다.</font>

85
00:06:23,360 --> 00:06:27,759
system thread back to the runtime and allow that operating system thread to be used to
<font color="#0eade1">시스템 스레드를 런타임으로 되돌리고 해당 운영 체제 스레드를 사용할 수 있도록 허용합니다.</font>

86
00:06:27,759 --> 00:06:29,199
do other work.
<font color="#0eade1">다른 작업을 수행합니다.</font>

87
00:06:29,199 --> 00:06:32,040
So that's the interesting thing about this example.
<font color="#0eade1">이것이 이 예제의 흥미로운 점입니다.</font>

88
00:06:32,040 --> 00:06:36,360
Now when you look at this example, there's a lot of actually blocking IO, a lot of blocking
<font color="#0eade1">이제 이 예제를 보면 실제로 차단하는 IO가 많고, 차단하는 것이 많습니다.</font>

89
00:06:36,360 --> 00:06:37,360
going on here.
<font color="#0eade1">계속되고 있습니다.</font>

90
00:06:37,360 --> 00:06:40,600
I do a DNS lookup of oracle.com.
<font color="#0eade1">oracle.com의 DNS 조회를 수행합니다.</font>

91
00:06:40,600 --> 00:06:46,000
I'm going to make a connection to its HTTP connection.
<font color="#0eade1">HTTP 연결에 연결합니다.</font>

92
00:06:46,040 --> 00:06:47,480
It's actually HTTPS.
<font color="#0eade1">실제로는 HTTPS입니다.</font>

93
00:06:47,480 --> 00:06:52,759
So in addition to making a TCP connection, I'm going to have this little chatter where
<font color="#0eade1">따라서 TCP 연결을 만드는 것 외에도 다음과 같은 작은 잡담을 할 것입니다.</font>

94
00:06:52,759 --> 00:06:57,560
I'm going to talk SSL to and negotiate with the server on the other end.
<font color="#0eade1">상대방 서버와 SSL로 대화하고 협상할 것입니다.</font>

95
00:06:57,560 --> 00:06:59,879
There's a lot of blocking actually going on here.
<font color="#0eade1">실제로 많은 차단이 진행되고 있습니다.</font>

96
00:06:59,879 --> 00:07:03,560
And when I start reading the page from, I'm doing a lot of blocking IO.
<font color="#0eade1">그리고 내가 페이지를 읽기 시작할 때, 나는 많은 차단 IO를 하고 있습니다.</font>

97
00:07:03,560 --> 00:07:10,319
And this is all code that is interesting for virtual threads because it can be implemented
<font color="#0eade1">그리고 이것은 모두 가상 스레드에서 구현할 수 있기 때문에 흥미로운 코드입니다.</font>

98
00:07:10,319 --> 00:07:11,319
very, very efficiently.
<font color="#0eade1">매우, 매우 효율적으로 구현할 수 있기 때문입니다.</font>

99
00:07:11,639 --> 00:07:17,120
Now in terms of APIs here, the only new API being used here is just a factory method on
<font color="#0eade1">이제 API 측면에서 볼 때, 여기서 사용되는 유일한 새로운 API는 단지</font>

100
00:07:17,120 --> 00:07:20,560
Java Lang thread, which starts a virtual thread.
<font color="#0eade1">가상 스레드를 시작하는 Java Lang 스레드입니다.</font>

101
00:07:20,560 --> 00:07:22,279
That's all it did.
<font color="#0eade1">여기까지입니다.</font>

102
00:07:22,279 --> 00:07:25,399
You give it a task in the form of a runnable.
<font color="#0eade1">실행 가능한 형태의 태스크를 제공합니다.</font>

103
00:07:25,399 --> 00:07:28,000
It starts a virtual thread to run that task.
<font color="#0eade1">해당 태스크를 실행하기 위해 가상 스레드를 시작합니다.</font>

104
00:07:28,000 --> 00:07:29,000
That's it.
<font color="#0eade1">끝입니다.</font>

105
00:07:29,000 --> 00:07:30,360
Nothing too interesting.
<font color="#0eade1">별로 흥미로운 건 없습니다.</font>

106
00:07:30,360 --> 00:07:35,000
That factory method is actually shorthand for what the code I've showed here, which
<font color="#0eade1">이 팩토리 메서드는 사실 제가 여기서 보여드린 코드의 줄임말입니다.</font>

107
00:07:35,000 --> 00:07:38,100
is using thread of builder and then a start method.
<font color="#0eade1">은 빌더의 스레드를 사용한 다음 시작 메서드를 사용하고 있습니다.</font>

108
00:07:38,100 --> 00:07:42,220
What we have here is a new builder API for creating threads.
<font color="#0eade1">여기에는 스레드 생성을 위한 새로운 빌더 API가 있습니다.</font>

109
00:07:42,220 --> 00:07:44,540
This allows you to wait to start threads.
<font color="#0eade1">이를 통해 스레드 시작을 기다릴 수 있습니다.</font>

110
00:07:44,540 --> 00:07:48,700
You can set properties of the thread, like its thread name.
<font color="#0eade1">스레드 이름과 같은 스레드의 속성을 설정할 수 있습니다.</font>

111
00:07:48,700 --> 00:07:51,340
There's also interesting methods in there for creating unstarted threads or creating
<font color="#0eade1">시작되지 않은 스레드를 생성하거나 다음과 같은 흥미로운 방법도 있습니다.</font>

112
00:07:51,340 --> 00:07:54,300
a thread factory.
<font color="#0eade1">스레드 공장.</font>

113
00:07:54,300 --> 00:08:01,860
That makes migration very, very easy and makes it easy to integrate code with new code using
<font color="#0eade1">이렇게 하면 마이그레이션이 매우 쉬워지고 다음을 사용하여 코드를 새 코드와 쉽게 통합할 수 있습니다.</font>

114
00:08:01,860 --> 00:08:06,540
virtual threads and existing code that uses thread factories and so on.
<font color="#0eade1">가상 스레드 및 스레드 팩토리 등을 사용하는 기존 코드와 쉽게 통합할 수 있습니다.</font>

115
00:08:06,540 --> 00:08:13,500
Now, the only other API then is, as you may have heard of, Executor Service.
<font color="#0eade1">이제 다른 유일한 API는 여러분도 들어보셨겠지만 Executor 서비스입니다.</font>

116
00:08:13,500 --> 00:08:17,580
That's the interface that's actually used for things like thread pools in Java, Util
<font color="#0eade1">이것은 실제로 Java의 스레드 풀과 같은 것들에 사용되는 인터페이스입니다.</font>

117
00:08:17,580 --> 00:08:20,220
Concurrent.
<font color="#0eade1">동시성.</font>

118
00:08:20,220 --> 00:08:27,540
Thread pools are about reusing a set of threads to execute tasks.
<font color="#0eade1">스레드 풀은 스레드 집합을 재사용하여 작업을 실행하는 것입니다.</font>

119
00:08:27,540 --> 00:08:33,500
But the Executor Service interface can be actually re-implemented with other policies.
<font color="#0eade1">그러나 실행자 서비스 인터페이스는 실제로 다른 정책으로 다시 구현할 수 있습니다.</font>

120
00:08:33,500 --> 00:08:36,460
We have a very simple implementation of Executor Service.
<font color="#0eade1">실행자 서비스를 매우 간단하게 구현했습니다.</font>

121
00:08:36,460 --> 00:08:40,179
It implements the policy of creating a virtual thread for every task.
<font color="#0eade1">모든 작업에 대해 가상 스레드를 생성하는 정책을 구현합니다.</font>

122
00:08:40,179 --> 00:08:46,580
Virtual threads are so cheap, we can actually create a virtual thread for every task.
<font color="#0eade1">가상 스레드는 매우 저렴하기 때문에 실제로 모든 작업에 대해 가상 스레드를 생성할 수 있습니다.</font>

123
00:08:46,580 --> 00:08:49,259
That's the whole point.
<font color="#0eade1">그게 요점입니다.</font>

124
00:08:49,259 --> 00:08:51,820
Virtual threads were a preview feature in Java 19 and 20.
<font color="#0eade1">가상 스레드는 Java 19와 20의 미리보기 기능입니다.</font>

125
00:08:51,820 --> 00:08:53,980
There was a lot of articles written about it.
<font color="#0eade1">이에 대한 많은 기사가 작성되었습니다.</font>

126
00:08:53,980 --> 00:08:56,580
It actually created quite a lot of buzz.
<font color="#0eade1">실제로 꽤 많은 화제를 불러일으켰죠.</font>

127
00:08:56,580 --> 00:09:03,139
In fact, at one point, we actually even had a Wikipedia page called Virtual Threads.
<font color="#0eade1">사실 한때는 가상 스레드라는 위키피디아 페이지가 있을 정도였죠.</font>

128
00:09:03,779 --> 00:09:11,220
I should say this is to credit Brian Goetz for coming up with the term virtual threads.
<font color="#0eade1">가상 스레드라는 용어를 생각해낸 브라이언 괴츠에게 감사의 말을 전하고 싶네요.</font>

129
00:09:11,220 --> 00:09:18,179
We had tried different names in all the different prototypes and things, but he correctly compared
<font color="#0eade1">우리는 모든 다른 프로토타입과 물건에서 다른 이름을 시도했지만 그는 정확하게 비교했습니다.</font>

130
00:09:18,179 --> 00:09:23,299
it to virtual memory and memory management systems.
<font color="#0eade1">가상 메모리와 메모리 관리 시스템으로 바꿨어요.</font>

131
00:09:23,299 --> 00:09:24,899
So the term virtual thread was born.
<font color="#0eade1">그래서 가상 스레드라는 용어가 탄생했습니다.</font>

132
00:09:24,899 --> 00:09:28,899
Now, since, by the way, this Wikipedia page has actually disappeared, someone has actually
<font color="#0eade1">그런데, 이 위키피디아 페이지는 실제로 사라졌기 때문에, 누군가가 실제로</font>

133
00:09:28,899 --> 00:09:32,659
replaced it with a Wikipedia page called On Green Threads.
<font color="#0eade1">라는 위키백과 페이지로 대체했습니다.</font>

134
00:09:33,620 --> 00:09:38,179
Anyway, there's a lot of interesting people kicking the tires.
<font color="#0eade1">어쨌든, 많은 흥미로운 사람들이 타이어를 차고 있습니다.</font>

135
00:09:38,179 --> 00:09:41,659
One of the things that surprised me a little bit is the number of people that actually
<font color="#0eade1">저를 조금 놀라게 한 것 중 하나는 실제로 다음과 같은 사람들이 있다는 것입니다.</font>

136
00:09:41,659 --> 00:09:47,860
were using virtual threads with things like re-implementing things like consensus algorithms
<font color="#0eade1">합의 알고리즘과 같은 것을 재구현하는 데 가상 스레드를 사용하고 있었다는 것입니다.</font>

137
00:09:47,860 --> 00:09:53,819
and doing a lot of things with blocking queues and other sort of CSP type things.
<font color="#0eade1">그리고 대기열을 차단하고 다른 종류의 CSP 유형으로 많은 작업을 수행했습니다.</font>

138
00:09:53,819 --> 00:09:55,620
That was actually interesting to go and see.
<font color="#0eade1">실제로 가서 보니 정말 흥미로웠어요.</font>

139
00:09:55,620 --> 00:10:00,659
So a lot of articles, literally hundreds of them, seemed to create quite a buzz.
<font color="#0eade1">말 그대로 수백 개에 달하는 많은 기사들이 꽤나 화제를 불러일으켰습니다.</font>

140
00:10:00,659 --> 00:10:04,100
And then there was many, many projects that actually spun up as well, which is actually
<font color="#0eade1">그리고 실제로 스핀업된 프로젝트도 정말 많았습니다.</font>

141
00:10:04,100 --> 00:10:07,819
interesting to see during this time frame.
<font color="#0eade1">이 기간 동안 흥미로웠습니다.</font>

142
00:10:07,819 --> 00:10:10,259
There was literally hundreds of people actually trying things out.
<font color="#0eade1">말 그대로 수백 명의 사람들이 실제로 무언가를 시도하고 있었습니다.</font>

143
00:10:10,259 --> 00:10:16,419
I think hats off to Elliot Barless because he dusted off things like Conway's Game of
<font color="#0eade1">엘리엇 바리스에게 경의를 표합니다. 그는 콘웨이의 게임 오브</font>

144
00:10:16,419 --> 00:10:17,539
Life using virtual threads.
<font color="#0eade1">가상 스레드를 사용하는 삶.</font>

145
00:10:17,539 --> 00:10:22,659
It was nice to see a puffer train going across the screen, which had 50,000 or 60,000 virtual
<font color="#0eade1">5만 또는 6만 개의 가상 스레드가 있는 화면을 가로지르는 복어 열차를 보는 것이 좋았습니다.</font>

146
00:10:22,659 --> 00:10:24,579
threads using blocking queues between them.
<font color="#0eade1">스레드 사이에 차단 대기열을 사용하는 것이 좋았습니다.</font>

147
00:10:24,579 --> 00:10:26,459
That was actually quite interesting.
<font color="#0eade1">사실 꽤 흥미로웠습니다.</font>

148
00:10:27,060 --> 00:10:34,780
I said about having a thread per task or thread per connection is one of his little demos
<font color="#0eade1">작업당 스레드 또는 연결당 스레드를 갖는 것에 대해 말씀드린 것은 그의 작은 데모 중 하나입니다.</font>

149
00:10:34,780 --> 00:10:39,980
actually had a little, I think it was a little chat server with 10 million TCP connections
<font color="#0eade1">실제로는 천만 개의 TCP 연결이 있는 작은 채팅 서버였던 것 같습니다.</font>

150
00:10:39,980 --> 00:10:42,780
with a virtual thread per connection.
<font color="#0eade1">연결당 가상 스레드를 사용했습니다.</font>

151
00:10:42,780 --> 00:10:43,780
That was actually cool to see.
<font color="#0eade1">정말 멋지네요.</font>

152
00:10:43,780 --> 00:10:48,340
And lots of other people did other interesting things as well.
<font color="#0eade1">다른 많은 사람들도 다른 재미있는 것들을 했어요.</font>

153
00:10:48,340 --> 00:10:52,860
Then queue all the frameworks, all the microservices frameworks.
<font color="#0eade1">그런 다음 모든 프레임워크와 모든 마이크로서비스 프레임워크를 대기열에 넣습니다.</font>

154
00:10:52,860 --> 00:10:57,500
We've all been looking at virtual threads as well.
<font color="#0eade1">가상 스레드도 살펴봤습니다.</font>

155
00:10:57,500 --> 00:11:01,980
From what I can see, I'm not familiar with all of these frameworks, of course, is they
<font color="#0eade1">물론 제가 보기에 이 모든 프레임워크에 익숙하지는 않습니다.</font>

156
00:11:01,980 --> 00:11:07,060
all seem to have come with some solution to be able to work with virtual threads.
<font color="#0eade1">모두 가상 스레드로 작업 할 수있는 솔루션이 제공된 것 같습니다.</font>

157
00:11:07,060 --> 00:11:09,419
Some of it is more deeply embedded than others.
<font color="#0eade1">일부는 다른 것보다 더 깊게 내장되어 있습니다.</font>

158
00:11:09,419 --> 00:11:15,180
Some are actually just doing handoff to virtual threads to run user code and so on.
<font color="#0eade1">일부는 실제로 사용자 코드 등을 실행하기 위해 가상 스레드에 핸드오프만 하고 있습니다.</font>

159
00:11:15,180 --> 00:11:16,180
But it's actually interesting to see.
<font color="#0eade1">하지만 실제로 보면 흥미롭습니다.</font>

160
00:11:16,460 --> 00:11:23,460
One of the things I like working on, what I like is that is JDK 21 only shipped very,
<font color="#0eade1">제가 작업하면서 좋아하는 것 중 하나는 JDK 21이 매우 빠르게 출시되었다는 것입니다,</font>

161
00:11:23,460 --> 00:11:27,540
very recently, but on that date, almost all of the frameworks actually had something working
<font color="#0eade1">아주 최근에 출시되었지만, 그 날짜에는 거의 모든 프레임워크가 실제로 작동하고 있었습니다.</font>

162
00:11:27,540 --> 00:11:28,540
with virtual threads.
<font color="#0eade1">가상 스레드로.</font>

163
00:11:28,540 --> 00:11:33,940
That was actually very, very nice to see.
<font color="#0eade1">정말 보기 좋네요.</font>

164
00:11:33,940 --> 00:11:39,660
One of the things on that slide was the Heladon folks is they went a little bit further actually
<font color="#0eade1">이 슬라이드의 내용 중 하나는 헬라돈 사람들이 실제로 조금 더 나아갔다는 것입니다.</font>

165
00:11:39,660 --> 00:11:44,900
than some of the other frameworks, or at least maybe they got off to an early start.
<font color="#0eade1">다른 프레임워크보다 더 빨리 시작했거나 적어도 일찍 시작했을 수도 있습니다.</font>

166
00:11:44,899 --> 00:11:51,659
Their existing core seemed to be based on Netty and Event Loop.
<font color="#0eade1">기존 핵심은 네티와 이벤트 루프를 기반으로 한 것 같습니다.</font>

167
00:11:51,659 --> 00:11:57,340
They started off with some very naive, simple importing to virtual threads, but they ran
<font color="#0eade1">매우 순진하고 간단한 가상 스레드 임포트로 시작했지만, 다음과 같이 실행되었습니다.</font>

168
00:11:57,340 --> 00:12:01,379
into a lot of problems because they were trying to use a lot of these libraries that depended
<font color="#0eade1">에 의존하는 많은 라이브러리를 사용하려고 했기 때문에 많은 문제가 발생했습니다.</font>

169
00:12:01,379 --> 00:12:06,100
on thread locals and native memory and things that didn't work too well with virtual threads.
<font color="#0eade1">스레드 로컬과 네이티브 메모리, 그리고 가상 스레드에서 잘 작동하지 않는 것들을 많이 사용하려고 했기 때문입니다.</font>

170
00:12:06,100 --> 00:12:09,579
I'll talk a bit more about that later on.
<font color="#0eade1">나중에 좀 더 자세히 설명하겠습니다.</font>

171
00:12:09,580 --> 00:12:13,900
What they decided to do, which was...
<font color="#0eade1">그들이 결정한 것은...</font>

172
00:12:13,900 --> 00:12:16,820
We lost the screen.
<font color="#0eade1">화면이 끊겼습니다.</font>

173
00:12:16,820 --> 00:12:18,900
Okay.
<font color="#0eade1">괜찮아</font>

174
00:12:18,900 --> 00:12:21,379
Can we see something's lost here?
<font color="#0eade1">여기서 뭔가 사라진 게 보여?</font>

175
00:12:21,379 --> 00:12:29,139
Anyway, what I'll say is that they re-implemented their core completely, replacing their Netty
<font color="#0eade1">어쨌든, 제가 말씀드리고 싶은 것은 그들이 네티를 대체하여 코어를 완전히 다시 구현했다는 것입니다.</font>

176
00:12:29,139 --> 00:12:32,259
core and replaced it with blocking IO.
<font color="#0eade1">코어를 차단 IO로 대체했습니다.</font>

177
00:12:32,259 --> 00:12:36,980
Believe it or not, they're actually using JavaNet Socket, which is a very, very simple
<font color="#0eade1">믿거나 말거나, 실제로는 매우 간단한 JavaNet 소켓을 사용하고 있습니다.</font>

178
00:12:36,980 --> 00:12:39,860
JDK one-year type of API.
<font color="#0eade1">JDK 1년형 API입니다.</font>

179
00:12:39,860 --> 00:12:45,940
Oh, we've something disconnected here.
<font color="#0eade1">여기 연결이 끊어졌습니다.</font>

180
00:12:45,940 --> 00:12:49,139
That was actually interesting to see.
<font color="#0eade1">정말 재미있네요.</font>

181
00:12:49,139 --> 00:12:52,740
Are we back?
<font color="#0eade1">돌아왔나?</font>

182
00:12:52,740 --> 00:12:54,220
Okay.
<font color="#0eade1">됐어.</font>

183
00:12:54,220 --> 00:12:57,860
I'll need to move on here because...
<font color="#0eade1">여기서 넘어가야겠어...</font>

184
00:12:57,860 --> 00:12:59,259
Okay, we have something back.
<font color="#0eade1">좋아, 뭔가 돌아왔어.</font>

185
00:12:59,259 --> 00:13:00,259
Okay, good.
<font color="#0eade1">좋아, 좋아.</font>

186
00:13:00,340 --> 00:13:06,939
What was interesting with their experiments is that by re-implementing their core with
<font color="#0eade1">이 실험에서 흥미로운 점은 코어를 다음과 같이 다시 구현함으로써</font>

187
00:13:06,939 --> 00:13:10,700
virtual threads and blocking IO, they were actually able to outperform their previous
<font color="#0eade1">가상 스레드로 코어를 재구현하고 IO를 차단함으로써 실제로 이전의</font>

188
00:13:10,700 --> 00:13:15,539
version of their microservices framework, which was very, very impressive to actually
<font color="#0eade1">마이크로서비스 프레임워크 버전을 능가할 수 있었는데, 이는 실제로 매우 인상적이었습니다.</font>

189
00:13:15,539 --> 00:13:16,539
go and see.
<font color="#0eade1">가서 보세요.</font>

190
00:13:16,539 --> 00:13:22,259
They've also published a whole bunch of performance data, and they seem to be quite comparable
<font color="#0eade1">그들은 또한 많은 성능 데이터를 발표했는데, 꽤 비슷한 것 같습니다.</font>

191
00:13:22,259 --> 00:13:27,139
with the other existing frameworks that are also in that space.
<font color="#0eade1">그 공간에 있는 다른 기존 프레임워크와도 꽤 비슷해 보입니다.</font>

192
00:13:27,139 --> 00:13:32,019
That was actually very, very interesting to see.
<font color="#0eade1">정말 흥미로웠어요.</font>

193
00:13:32,019 --> 00:13:40,179
We have a lot of usages already of virtual threads within the ecosystem.
<font color="#0eade1">이미 생태계 내에서 가상 스레드를 많이 사용하고 있습니다.</font>

194
00:13:40,179 --> 00:13:45,059
My colleague Ron Pressler and I, we've literally looked at dozens of articles and many, many
<font color="#0eade1">제 동료인 Ron Pressler와 저는 말 그대로 수십 개의 기사와 수많은</font>

195
00:13:45,059 --> 00:13:48,779
projects as to see how people are actually using virtual threads.
<font color="#0eade1">프로젝트를 통해 사람들이 실제로 가상 스레드를 어떻게 사용하는지 살펴봤습니다.</font>

196
00:13:48,779 --> 00:13:54,659
What we actually see is that some people, not all, are actually making mistakes.
<font color="#0eade1">실제로 모든 사람이 아니라 일부 사람들이 실제로 실수를 저지르고 있다는 것을 알 수 있습니다.</font>

197
00:13:54,659 --> 00:14:00,059
Virtual threads, if you take one thing from this talk, is virtual threads are not magic
<font color="#0eade1">가상 스레드, 이 강연에서 한 가지를 취한다면 가상 스레드는 마법이 아니라는 것입니다.</font>

198
00:14:00,059 --> 00:14:03,500
pixie dust that you can actually just sprinkle over your existing code and actually make
<font color="#0eade1">실제로 기존 코드 위에 뿌려서 실제로 만들 수 있는 픽시 먼지가 아닙니다.</font>

199
00:14:03,500 --> 00:14:06,559
it faster.
<font color="#0eade1">더 빨리.</font>

200
00:14:06,559 --> 00:14:14,059
Making something run a virtual thread that doesn't make that code run any faster.
<font color="#0eade1">가상 스레드를 실행해도 코드가 더 빨리 실행되지 않습니다.</font>

201
00:14:14,059 --> 00:14:18,860
Where we see the mistakes making is people that are actually just blindly replacing platform
<font color="#0eade1">우리가 실수를 저지르는 곳은 실제로 맹목적으로 플랫폼을 교체하는 사람들입니다.</font>

202
00:14:18,860 --> 00:14:24,179
threads with virtual threads and expecting to see some difference.
<font color="#0eade1">스레드를 가상 스레드로 교체하고 어떤 차이를 기대하는 것입니다.</font>

203
00:14:24,180 --> 00:14:26,380
It doesn't always work like that.
<font color="#0eade1">항상 그렇게 작동하는 것은 아닙니다.</font>

204
00:14:26,380 --> 00:14:31,300
Also as well, we see people that are actually replacing the thread factory for thread pools
<font color="#0eade1">또한 스레드 풀을 위해 스레드 팩토리를 실제로 대체하는 사람들도 있습니다.</font>

205
00:14:31,300 --> 00:14:35,060
and actually replacing with a thread factory that creates virtual threads.
<font color="#0eade1">그리고 실제로 가상 스레드를 생성하는 스레드 팩토리로 대체하고 있습니다.</font>

206
00:14:35,060 --> 00:14:38,860
Well, virtual threads are not really intended to be pooled.
<font color="#0eade1">가상 스레드는 실제로 풀링을 위한 것이 아닙니다.</font>

207
00:14:38,860 --> 00:14:41,820
There's very, very few reasons why you would want to do this.
<font color="#0eade1">이렇게 해야 할 이유는 거의 없습니다.</font>

208
00:14:41,820 --> 00:14:47,020
Now, there is one issue we see, and I'll talk a little bit more about this later on in the
<font color="#0eade1">이제 한 가지 문제가 발견되었는데, 이 문제에 대해서는 나중에</font>

209
00:14:47,020 --> 00:14:49,100
talk, is we have this issue with pinning.
<font color="#0eade1">이야기에서 고정과 관련된 문제가 있습니다.</font>

210
00:14:49,100 --> 00:14:54,300
We have a quality of implementation issue where currently parking while holding a monitor
<font color="#0eade1">현재 모니터를 들고 주차하는 경우 구현 품질 문제가 있습니다.</font>

211
00:14:54,300 --> 00:14:58,700
doesn't release the underlying carrier thread.
<font color="#0eade1">기본 캐리어 스레드를 해제하지 않습니다.</font>

212
00:14:58,700 --> 00:15:02,899
That becomes a scalability issue, can lead to other issues like this.
<font color="#0eade1">이는 확장성 문제가 되고, 이와 같은 다른 문제로 이어질 수 있습니다.</font>

213
00:15:02,899 --> 00:15:07,740
A lot of developers that are kicking the tires of virtual threads are aware of this, but
<font color="#0eade1">가상 스레드를 사용하는 많은 개발자들이 이 사실을 알고 있습니다.</font>

214
00:15:07,740 --> 00:15:13,899
they're making the assumption that they've got to replace all usages of monitors with
<font color="#0eade1">로 모든 모니터 사용을 대체해야 한다는 가정을 하고 있습니다.</font>

215
00:15:13,899 --> 00:15:15,820
Java tilt concurrent locks.
<font color="#0eade1">자바 틸트 동시 잠금.</font>

216
00:15:15,820 --> 00:15:17,620
That isn't really the case.
<font color="#0eade1">실제로는 그렇지 않습니다.</font>

217
00:15:17,620 --> 00:15:23,100
It's understandable why there would be issues there.
<font color="#0eade1">왜 거기서 문제가 발생하는지 이해할 수 있습니다.</font>

218
00:15:23,100 --> 00:15:29,620
We also see an issue with there's a lot of libraries and frameworks that make use of
<font color="#0eade1">또한 다음과 같은 라이브러리와 프레임워크를 사용하는 많은 라이브러리와 프레임워크에도 문제가 있습니다.</font>

219
00:15:29,620 --> 00:15:30,620
thread locals.
<font color="#0eade1">스레드 로컬.</font>

220
00:15:30,620 --> 00:15:33,700
That's all okay, but there is a lot of libraries that just make the assumption that they're
<font color="#0eade1">괜찮지만, 다음과 같이 가정하는 라이브러리가 많이 있습니다.</font>

221
00:15:33,700 --> 00:15:35,500
always running a pooled thread.
<font color="#0eade1">항상 풀링된 스레드를 실행한다고 가정합니다.</font>

222
00:15:35,500 --> 00:15:43,379
They're caching some huge, big, mutable data in a thread local, and the assumption is that
<font color="#0eade1">스레드 로컬에 변경 가능한 대용량 데이터를 캐싱하고 있으며, 가정은 다음과 같습니다.</font>

223
00:15:43,379 --> 00:15:45,180
they're in a thread pool.
<font color="#0eade1">스레드 풀에 있다고 가정합니다.</font>

224
00:15:45,180 --> 00:15:48,660
That isn't the case when you actually are using virtual threads, because virtual threads
<font color="#0eade1">실제로 가상 스레드를 사용하는 경우에는 그렇지 않습니다.</font>

225
00:15:48,660 --> 00:15:50,740
are about having a new thread for each task.
<font color="#0eade1">는 각 작업에 대해 새 스레드를 갖는 것이기 때문입니다.</font>

226
00:15:50,740 --> 00:15:52,980
You're not going to get the benefit of those thread locals.
<font color="#0eade1">스레드 로컬의 이점을 얻지 못할 것입니다.</font>

227
00:15:52,980 --> 00:15:59,340
In fact, thread locals can actually work against you because you're creating one for every
<font color="#0eade1">사실, 스레드 로컬은 모든 스레드에 대해 하나씩 생성하기 때문에 실제로 불리하게 작용할 수 있다.</font>

228
00:15:59,340 --> 00:16:01,580
single task.
<font color="#0eade1">단일 작업마다.</font>

229
00:16:01,580 --> 00:16:07,980
We also see people publishing benchmarks that don't take into account a warmup.
<font color="#0eade1">또한 워밍업을 고려하지 않은 벤치마크를 게시하는 사람들도 있습니다.</font>

230
00:16:07,980 --> 00:16:11,220
We see people doing very, very complicated stuff, trying to mix blocking and non-blocking
<font color="#0eade1">블로킹과 비 블로킹을 혼합하여 매우 복잡한 작업을 수행하는 사람들을 볼 수 있습니다.</font>

231
00:16:11,220 --> 00:16:16,379
in I.O., and it ends up just being too complicated to reason about.
<font color="#0eade1">그리고 결국에는 추론하기에는 너무 복잡해지죠.</font>

232
00:16:16,379 --> 00:16:22,700
I suppose the summary from a lot of things that we've looked at is that sometimes there's
<font color="#0eade1">우리가 살펴본 많은 것들을 요약하면, 때때로 다음과 같은 경우가 있다는 것입니다.</font>

233
00:16:22,700 --> 00:16:26,480
a misunderstanding from where the performance benefits of Loom come from, or where the performance
<font color="#0eade1">Loom의 성능 이점이 어디에서 오는지, 또는 성능이 어디에서 오는지에 대한 오해입니다.</font>

234
00:16:26,480 --> 00:16:29,779
benefits of virtual threads come from.
<font color="#0eade1">가상 스레드의 이점이 어디에서 오는지에 대한 오해.</font>

235
00:16:29,779 --> 00:16:36,100
The benefit comes from their number, and it's as simple as that.
<font color="#0eade1">가상 스레드의 이점은 그 숫자에서 비롯되며, 간단합니다.</font>

236
00:16:36,100 --> 00:16:39,500
Here's a very important slide that we have.
<font color="#0eade1">여기에 매우 중요한 슬라이드가 있습니다.</font>

237
00:16:39,500 --> 00:16:44,539
Based on all these articles that we read and given our feeling for how we thought that
<font color="#0eade1">우리가 읽은 모든 기사를 바탕으로 우리가 어떻게 생각했는지에 대한 느낌을 주었습니다.</font>

238
00:16:44,539 --> 00:16:49,899
developers were understanding virtual threads, we have written up a number of points around
<font color="#0eade1">개발자들이 가상 스레드를 이해하고 있다고 생각하여 다음과 같은 몇 가지 요점을 정리했습니다.</font>

239
00:16:49,899 --> 00:16:54,779
migration or guidelines for how you actually move to virtual threads.
<font color="#0eade1">마이그레이션 또는 실제로 가상 스레드로 이동하는 방법에 대한 지침을 작성했습니다.</font>

240
00:16:54,779 --> 00:16:58,899
Number one point is keeping code as simple as possible.
<font color="#0eade1">가장 중요한 점은 코드를 최대한 단순하게 유지하는 것입니다.</font>

241
00:16:58,899 --> 00:17:07,940
Usynchronous blocking APIs is because virtual threads like blocking and simple code.
<font color="#0eade1">비동기 블로킹 API는 블로킹과 같은 가상 스레드와 간단한 코드를 사용하기 때문입니다.</font>

242
00:17:07,940 --> 00:17:13,380
Migrating to virtual threads is about migrating tasks to virtual threads, not platform threads
<font color="#0eade1">가상 스레드로 마이그레이션하는 것은 플랫폼 스레드가 아닌 가상 스레드로 작업을 마이그레이션하는 것입니다.</font>

243
00:17:13,380 --> 00:17:14,380
to virtual threads.
<font color="#0eade1">가상 스레드로 마이그레이션합니다.</font>

244
00:17:14,380 --> 00:17:16,759
That's an important point.
<font color="#0eade1">중요한 지점입니다.</font>

245
00:17:16,759 --> 00:17:27,740
One of the things with thread pools is that they work as a way of limiting concurrency.
<font color="#0eade1">스레드 풀의 장점 중 하나는 동시성을 제한하는 방식으로 작동한다는 것입니다.</font>

246
00:17:27,740 --> 00:17:34,700
If you have an infinite number or unbounded number of virtual threads, where do you want
<font color="#0eade1">가상 스레드 수가 무한대이거나 무제한인 경우, 어디에</font>

247
00:17:34,700 --> 00:17:36,019
to actually limit your concurrency?
<font color="#0eade1">로 동시성을 실제로 제한하고 싶으신가요?</font>

248
00:17:36,099 --> 00:17:38,139
Is it going to be your connections to your database?
<font color="#0eade1">데이터베이스에 대한 연결이 될까요?</font>

249
00:17:38,139 --> 00:17:39,139
Is it going to be something else?
<font color="#0eade1">다른 문제일까요?</font>

250
00:17:39,139 --> 00:17:43,220
There'll be some other bottleneck that's going to come out of the woodwork and some scalability
<font color="#0eade1">다른 병목 현상과 확장성 문제가 있을 겁니다.</font>

251
00:17:43,220 --> 00:17:48,859
bottleneck that you will have to reason about when using virtual threads.
<font color="#0eade1">가상 스레드를 사용할 때 추론해야 할 병목 현상이 있습니다.</font>

252
00:17:48,859 --> 00:17:53,700
Because of our quality of implementation issue at the moment with monitors, we have to avoid
<font color="#0eade1">현재 모니터의 구현 품질 문제로 인해, 우리는</font>

253
00:17:53,700 --> 00:17:58,500
scenarios where you're actually doing blocking I.O. and blocking for long periods of time
<font color="#0eade1">실제로 차단 I.O. 및 장시간 차단을 수행하는 시나리오를 피해야 합니다.</font>

254
00:17:58,500 --> 00:18:00,259
while holding monitors.
<font color="#0eade1">모니터를 들고 있는 동안</font>

255
00:18:00,259 --> 00:18:04,859
That's just an implementation limitation that we want to address.
<font color="#0eade1">이는 우리가 해결하고자 하는 구현상의 한계입니다.</font>

256
00:18:04,860 --> 00:18:05,900
These are the main points.
<font color="#0eade1">이것이 요점입니다.</font>

257
00:18:05,900 --> 00:18:09,140
We summarized them in JEP444.
<font color="#0eade1">JEP444에 요약했습니다.</font>

258
00:18:09,140 --> 00:18:15,700
JEP444 is the JEP that actually made virtual threads a permanent feature in Java 21.
<font color="#0eade1">JEP444는 실제로 Java 21에서 가상 스레드를 영구적인 기능으로 만든 JEP입니다.</font>

259
00:18:15,700 --> 00:18:21,820
We've also written an adoption guide at the end, which has a bit more detail on all of
<font color="#0eade1">또한 마지막에 채택 가이드를 작성했는데, 여기에는 다음과 같은 모든 사항에 대해 좀 더 자세히 설명되어 있습니다.</font>

260
00:18:21,820 --> 00:18:22,820
these points.
<font color="#0eade1">이 포인트에 대해 자세히 설명합니다.</font>

261
00:18:22,820 --> 00:18:25,860
I'll link that at the end as well.
<font color="#0eade1">이것도 마지막에 링크하겠습니다.</font>

262
00:18:25,860 --> 00:18:32,620
I want to move on and actually talk a little bit about structure concurrency.
<font color="#0eade1">이제 구조 동시성에 대해 조금 더 이야기하고 싶습니다.</font>

263
00:18:32,620 --> 00:18:38,900
This is something I've talked about briefly in previous presentations here, but we've
<font color="#0eade1">이전 프레젠테이션에서도 잠깐 언급했던 내용입니다.</font>

264
00:18:38,900 --> 00:18:46,220
moved on this feature for quite a bit since then.
<font color="#0eade1">그 이후로 이 기능에 대해 꽤 많은 작업을 진행했습니다.</font>

265
00:18:46,220 --> 00:18:50,380
The notion of structure concurrency isn't in any way a new concept.
<font color="#0eade1">구조체 동시성 개념은 결코 새로운 개념이 아닙니다.</font>

266
00:18:50,380 --> 00:18:52,700
It goes back decades.
<font color="#0eade1">수십 년 전으로 거슬러 올라갑니다.</font>

267
00:18:52,700 --> 00:18:58,340
But the term has come into use in the last couple of years.
<font color="#0eade1">하지만 이 용어는 지난 몇 년 동안 사용되기 시작했습니다.</font>

268
00:18:58,340 --> 00:19:01,940
Structure concurrency is really about treating groups of related tasks running in different
<font color="#0eade1">구조적 동시성은 실제로 서로 다른 곳에서 실행되는 관련 작업 그룹을 처리하는 것입니다.</font>

269
00:19:02,259 --> 00:19:04,299
threads as a single unit of work.
<font color="#0eade1">스레드를 하나의 작업 단위로 취급하는 것입니다.</font>

270
00:19:04,299 --> 00:19:08,340
It becomes important when we have virtual threads that make things very, very cheap
<font color="#0eade1">가상 스레드를 사용하면 매우 저렴하게 만들 수 있습니다.</font>

271
00:19:08,340 --> 00:19:11,980
to use.
<font color="#0eade1">사용할 수 있습니다.</font>

272
00:19:11,980 --> 00:19:20,019
We end up wondering how we would actually organize these groups of virtual threads.
<font color="#0eade1">이 가상 스레드 그룹을 실제로 어떻게 구성할지 궁금해집니다.</font>

273
00:19:20,019 --> 00:19:23,660
Another way to put it, and you'll see it in a lot of articles and blogs, is that structure
<font color="#0eade1">많은 기사와 블로그에서 볼 수 있는 또 다른 방법은 다음과 같은 구조입니다.</font>

274
00:19:23,660 --> 00:19:29,539
concurrency could be thought of as when control splits into multiple concurrent paths.
<font color="#0eade1">동시성은 제어가 여러 개의 동시 경로로 분할되는 경우로 생각할 수 있습니다.</font>

275
00:19:29,539 --> 00:19:34,379
We split, we decompose something into multiple concurrent subtasks, they must actually join
<font color="#0eade1">우리는 분할하고, 무언가를 여러 개의 동시 하위 작업으로 분해하고, 실제로 합류해야 합니다.</font>

276
00:19:34,379 --> 00:19:35,379
up again.
<font color="#0eade1">다시 올라갑니다.</font>

277
00:19:35,379 --> 00:19:38,899
That's really what the concept is all about.
<font color="#0eade1">이것이 바로 이 컨셉의 핵심입니다.</font>

278
00:19:38,899 --> 00:19:45,299
When you're dealing with concurrent programs, this is something that helps with the problems
<font color="#0eade1">동시 프로그램을 다룰 때 다음과 같은 문제를 해결하는 데 도움이 됩니다.</font>

279
00:19:45,299 --> 00:19:47,500
of cancellation and shutdown.
<font color="#0eade1">취소 및 종료합니다.</font>

280
00:19:47,500 --> 00:19:50,460
If you've read concurrency in practice, you'll know that this is a very problematic area
<font color="#0eade1">실제로 동시성을 읽어본 적이 있다면, 이것이 매우 문제가 많은 영역이라는 것을 알 수 있습니다.</font>

281
00:19:50,460 --> 00:19:57,460
with concurrency, because it leads to things like problems with threads leaking or delaying
<font color="#0eade1">스레드 누수나 지연과 같은 문제가 발생하기 때문입니다.</font>

282
00:19:57,460 --> 00:19:59,299
with cancellation.
<font color="#0eade1">취소되었습니다.</font>

283
00:19:59,539 --> 00:20:05,740
I want to just show you a brief example, which is going to provide the motivation for the
<font color="#0eade1">간단한 예시를 보여드리고자 합니다.</font>

284
00:20:05,740 --> 00:20:10,339
types of things that we can actually do with the API that we've actually previewed in 21.
<font color="#0eade1">21에서 미리 살펴본 API로 실제로 할 수 있는 일의 유형을 보여드리겠습니다.</font>

285
00:20:10,339 --> 00:20:15,500
I'm going to show you a very, very simple, this is a boring piece of code.
<font color="#0eade1">아주 간단하고 지루한 코드를 보여드리겠습니다.</font>

286
00:20:15,500 --> 00:20:20,299
It's a method called handle that basically aggregates the results of two methods.
<font color="#0eade1">기본적으로 두 메서드의 결과를 합산하는 핸들이라는 메서드입니다.</font>

287
00:20:20,299 --> 00:20:23,259
One method fetches a username from somewhere, another fetches an order.
<font color="#0eade1">한 메서드는 어딘가에서 사용자 이름을 가져오고, 다른 메서드는 주문을 가져옵니다.</font>

288
00:20:23,259 --> 00:20:27,700
I have no idea what a user or an order is, just assume that they're doing something like
<font color="#0eade1">사용자나 주문이 무엇인지 모르겠지만, 그냥 다음과 같은 작업을 하고 있다고 가정합니다.</font>

289
00:20:27,740 --> 00:20:32,700
querying a database, accessing some remote endpoint.
<font color="#0eade1">데이터베이스 쿼리, 원격 엔드포인트 액세스.</font>

290
00:20:32,700 --> 00:20:34,860
They're doing something expensive.
<font color="#0eade1">뭔가 비싼 일을 하고 있습니다.</font>

291
00:20:34,860 --> 00:20:38,779
This is the sequential version of this piece of code.
<font color="#0eade1">이 코드의 순차 버전입니다.</font>

292
00:20:38,779 --> 00:20:43,420
If the find user method fails, throws an exception, in other words, the handle method will throw,
<font color="#0eade1">사용자 찾기 메서드가 실패하면 예외를 던집니다. 즉, 핸들 메서드가 예외를 던집니다,</font>

293
00:20:43,420 --> 00:20:45,220
we're all good.
<font color="#0eade1">모두 괜찮습니다.</font>

294
00:20:45,220 --> 00:20:49,420
If the find order method fails, throws an exception, the handle method throws, we're
<font color="#0eade1">찾기 순서 메서드가 실패하면 예외가 발생하고, 핸들 메서드가 예외를 발생하면 다음과 같습니다.</font>

295
00:20:49,420 --> 00:20:50,420
all good.
<font color="#0eade1">모두 정상입니다.</font>

296
00:20:50,420 --> 00:20:51,420
There's no cleanup actually required.
<font color="#0eade1">실제로 정리가 필요하지 않습니다.</font>

297
00:20:52,140 --> 00:20:59,380
Now, let's suppose we actually try to make these two methods actually run concurrently.
<font color="#0eade1">이제 실제로 이 두 메서드를 동시에 실행한다고 가정해 봅시다.</font>

298
00:20:59,380 --> 00:21:04,580
This is the concurrent version of it where I'm going to create, I'm going to use an executor
<font color="#0eade1">다음은 제가 만들 동시 실행 버전으로, 실행자를 사용하겠습니다.</font>

299
00:21:04,580 --> 00:21:10,220
service, which I've called executor in this example, and I'm going to submit two tasks
<font color="#0eade1">서비스(이 예제에서는 실행자라고 부릅니다)를 사용하여 두 개의 작업을 제출하겠습니다.</font>

300
00:21:10,220 --> 00:21:13,620
that will potentially run concurrently.
<font color="#0eade1">동시에 실행될 수 있습니다.</font>

301
00:21:13,620 --> 00:21:17,779
Then what we do is we're going to call the future get method.
<font color="#0eade1">그런 다음 미래의 get 메서드를 호출합니다.</font>

302
00:21:17,779 --> 00:21:21,740
By the way, if you're not familiar with executor service, it returns you back this thing called
<font color="#0eade1">참고로 실행자 서비스에 익숙하지 않다면, 이 메서드는</font>

303
00:21:21,740 --> 00:21:26,700
a promise or a future, it's called a future, and there's a get method which basically blocks
<font color="#0eade1">약속 또는 미래, 미래라고하며 기본적으로 차단하는 get 메서드가 있습니다.</font>

304
00:21:26,700 --> 00:21:30,339
waiting for the result.
<font color="#0eade1">결과를 기다립니다.</font>

305
00:21:30,339 --> 00:21:31,819
Aggregation is basically two gets.
<font color="#0eade1">집계는 기본적으로 두 개의 가져옴입니다.</font>

306
00:21:31,819 --> 00:21:37,500
Wait for the result to find user, wait for the result to find order, compose the response,
<font color="#0eade1">결과가 사용자를 찾을 때까지 기다리고, 결과가 순서를 찾을 때까지 기다렸다가 응답을 작성합니다,</font>

307
00:21:37,500 --> 00:21:38,500
we're done.
<font color="#0eade1">끝났습니다.</font>

308
00:21:38,500 --> 00:21:40,099
What's wrong with this code?
<font color="#0eade1">이 코드에 무슨 문제가 있나요?</font>

309
00:21:40,099 --> 00:21:45,539
Well, let's have a look what's wrong with this code.
<font color="#0eade1">이 코드에 무엇이 잘못되었는지 살펴봅시다.</font>

310
00:21:46,220 --> 00:21:53,180
If both of these tasks succeed, we're all good.
<font color="#0eade1">이 두 작업이 모두 성공하면 모두 정상입니다.</font>

311
00:21:53,180 --> 00:21:58,139
Get will return the user, order get will return the order, we create a response, we're all
<font color="#0eade1">Get은 사용자를 반환하고, order get은 주문을 반환하고, 응답을 생성하고, 모두 정상입니다.</font>

312
00:21:58,139 --> 00:21:59,139
good.
<font color="#0eade1">good.</font>

313
00:21:59,139 --> 00:22:05,059
Now, let's actually think about what happens if one of these actually fail.
<font color="#0eade1">이제 이 중 하나가 실제로 실패하면 어떻게 되는지 생각해 봅시다.</font>

314
00:22:05,059 --> 00:22:12,099
Let's suppose the find user goes to some database and the database isn't available or something,
<font color="#0eade1">찾기 사용자가 어떤 데이터베이스로 이동했는데 해당 데이터베이스를 사용할 수 없다고 가정해 봅시다,</font>

315
00:22:12,140 --> 00:22:17,780
there's some error, and let's suppose that that task fails.
<font color="#0eade1">오류가 발생하여 해당 작업이 실패한다고 가정해 봅시다.</font>

316
00:22:17,780 --> 00:22:24,180
User.get is actually going to throw, which will cause handle to throw, but our task that's
<font color="#0eade1">User.get이 실제로 throw를 발생시켜 핸들을 던지겠지만, 우리의 태스크는</font>

317
00:22:24,180 --> 00:22:28,260
running find order is going to continue on running.
<font color="#0eade1">실행 중인 찾기 순서는 계속 실행됩니다.</font>

318
00:22:28,260 --> 00:22:31,100
We've got a bit of a leak there.
<font color="#0eade1">거기서 약간의 누수가 발생했습니다.</font>

319
00:22:31,100 --> 00:22:35,180
We haven't canceled the find order, it's just continuing to run.
<font color="#0eade1">찾기 명령을 취소하지 않고 계속 실행 중입니다.</font>

320
00:22:35,259 --> 00:22:43,259
Now, let's do the other way around where the find order was actually going to fail.
<font color="#0eade1">이제 실제로 찾기 명령이 실패할 경우를 반대로 해보겠습니다.</font>

321
00:22:43,259 --> 00:22:48,620
What's going to happen here is we're going to block for a long time waiting for find
<font color="#0eade1">여기서 일어날 일은 찾기를 기다리는 동안 오랫동안 차단하는 것입니다.</font>

322
00:22:48,620 --> 00:22:52,220
user and then we're going to call order get and it's going to throw and handle is going
<font color="#0eade1">사용자를 호출한 다음, get을 호출하고, 이 호출을 던져서</font>

323
00:22:52,220 --> 00:22:53,220
to throw.
<font color="#0eade1">던질 것입니다.</font>

324
00:22:53,220 --> 00:22:59,140
Okay, there's no additional cleanup to be done here, but I've wasted my time waiting
<font color="#0eade1">좋아, 여기서 추가로 정리할 건 없지만 기다리느라 시간을 낭비했어.</font>

325
00:22:59,140 --> 00:23:07,020
for find user to complete before I discover that find order fails.
<font color="#0eade1">사용자 찾기가 완료되기를 기다리느라 시간을 낭비했습니다.</font>

326
00:23:07,020 --> 00:23:13,500
Two things running concurrently, you kind of want to bail out when the first one fails.
<font color="#0eade1">두 가지 작업이 동시에 실행 중인데, 첫 번째 작업이 실패할 때 빠져나오고 싶을 것입니다.</font>

327
00:23:13,500 --> 00:23:14,500
These are the type of examples.
<font color="#0eade1">이러한 유형의 예제입니다.</font>

328
00:23:14,500 --> 00:23:22,620
We've actually got many, many examples like this where this motivated it to create a structure
<font color="#0eade1">실제로 이와 같은 예제에서 구조를 생성하도록 동기를 부여한 예제가 많이 있습니다.</font>

329
00:23:22,620 --> 00:23:23,860
concurrency API.
<font color="#0eade1">동시성 API.</font>

330
00:23:23,860 --> 00:23:28,540
I think when I presented here in 2018, we had prototype versions.
<font color="#0eade1">2018년에 여기서 발표했을 때는 프로토타입 버전이었던 것 같습니다.</font>

331
00:23:28,940 --> 00:23:32,339
We were using terminology like fiber and Fiberscope then sounded like a medical device, but it's
<font color="#0eade1">당시에는 파이버, 파이버스코프 같은 용어를 사용해 의료기기처럼 들리기도 했지만</font>

332
00:23:32,339 --> 00:23:37,220
since changed and it's now called Structured Task Scope in Java tool concurrent.
<font color="#0eade1">이후 변경되어 지금은 Java 도구 동시에서 구조화된 작업 범위라고 불립니다.</font>

333
00:23:37,220 --> 00:23:39,619
This is a preview API.
<font color="#0eade1">미리보기 API입니다.</font>

334
00:23:39,619 --> 00:23:45,500
We did have it in incubator module in 19 or 20 for people to actually to try out.
<font color="#0eade1">19년이나 20년에 사람들이 실제로 사용해 볼 수 있도록 인큐베이터 모듈에 포함시켰습니다.</font>

335
00:23:45,500 --> 00:23:50,859
This supports the general notion of actually structuring a task as a group of related sub
<font color="#0eade1">이는 실제로 작업을 관련 하위 작업 그룹으로 구성하는 일반적인 개념을 뒷받침합니다.</font>

336
00:23:50,859 --> 00:23:55,559
tasks and then trying to coordinate them as a unit.
<font color="#0eade1">작업의 그룹으로 구성한 다음 하나의 단위로 조정하려고 시도합니다.</font>

337
00:23:55,559 --> 00:24:03,379
It defines a fork method which goes and forks a thread to execute a sub task because virtual
<font color="#0eade1">가상 스레드가 하위 작업을 실행하기 위해 스레드를 포크하는 포크 메서드를 정의합니다.</font>

338
00:24:03,379 --> 00:24:04,879
threads are so cheap.
<font color="#0eade1">스레드가 너무 싸기 때문입니다.</font>

339
00:24:04,879 --> 00:24:08,399
The default is this is to go and fork a virtual thread.
<font color="#0eade1">기본값은 가상 스레드를 포크하는 것입니다.</font>

340
00:24:08,399 --> 00:24:11,679
We do fork, fork, fork, and then we do a join method.
<font color="#0eade1">포크, 포크, 포크를 반복한 다음 조인 메서드를 수행합니다.</font>

341
00:24:11,679 --> 00:24:16,720
This is a join that does a join as a unit.
<font color="#0eade1">이것은 하나의 단위로 조인을 수행하는 조인입니다.</font>

342
00:24:16,720 --> 00:24:20,519
By default, it's going to wait for all sub tasks to complete.
<font color="#0eade1">기본적으로 모든 하위 작업이 완료될 때까지 기다립니다.</font>

343
00:24:20,519 --> 00:24:22,519
That's kind of useful.
<font color="#0eade1">꽤 유용하네요.</font>

344
00:24:22,519 --> 00:24:24,440
It's one way.
<font color="#0eade1">한 가지 방법이야.</font>

345
00:24:24,440 --> 00:24:30,759
The overall shape of this API is that it's an auto-closable intended to be used with
<font color="#0eade1">이 API의 전체적인 모양은 다음과 함께 사용하도록 의도된 자동 폐쇄형입니다.</font>

346
00:24:30,759 --> 00:24:33,640
the tri-with resource construct.
<font color="#0eade1">와 함께 사용하기 위한 것입니다.</font>

347
00:24:33,640 --> 00:24:41,279
I'll show an example and then I want to talk through how it actually works.
<font color="#0eade1">예제를 보여드리고 실제로 어떻게 작동하는지 설명해드리겠습니다.</font>

348
00:24:41,279 --> 00:24:45,240
Here's our handle method rewritten to use Structured Task Scope.
<font color="#0eade1">다음은 구조화된 작업 범위를 사용하도록 재작성한 핸들 메서드입니다.</font>

349
00:24:45,240 --> 00:24:49,940
I'm using tri-with resources, so we create a Structured Task Scope.
<font color="#0eade1">트라이 위드 리소스를 사용하고 있으므로 구조화된 작업 범위를 생성합니다.</font>

350
00:24:49,940 --> 00:24:56,059
In this example, I'm using a Structured Task Scope called Shutdown on Failure.
<font color="#0eade1">이 예제에서는 실패 시 종료라는 구조화된 작업 범위를 사용하고 있습니다.</font>

351
00:24:56,059 --> 00:25:01,740
Shutdown on Failure is an implementation of Structured Task Scope that implements a policy
<font color="#0eade1">실패 시 종료는 정책을 구현하는 구조화된 작업 범위의 구현입니다.</font>

352
00:25:01,740 --> 00:25:05,420
to shut down the scope when any sub task fails.
<font color="#0eade1">하위 작업이 실패할 때 범위를 종료합니다.</font>

353
00:25:05,420 --> 00:25:09,059
It's a very, very simple policy.
<font color="#0eade1">아주 간단한 정책입니다.</font>

354
00:25:09,059 --> 00:25:15,460
We open it at the beginning by creating a Structured Task Scope and it gets closed at
<font color="#0eade1">구조화된 작업 범위를 생성하여 처음에 열면 다음에서 닫힙니다.</font>

355
00:25:15,460 --> 00:25:19,180
the end implicitly in this code because it's tri-with resources.
<font color="#0eade1">이 코드에서 암시적으로 끝은 리소스가 세 개이기 때문입니다.</font>

356
00:25:19,180 --> 00:25:21,460
What do we have inside the block here?
<font color="#0eade1">여기 블록 안에는 무엇이 있을까요?</font>

357
00:25:21,460 --> 00:25:29,259
We have fork, fork, join, and then we have some processing of the outcome.
<font color="#0eade1">포크, 포크, 조인, 그리고 결과에 대한 처리가 있습니다.</font>

358
00:25:29,259 --> 00:25:34,340
The two forks are exactly as this submit in the previous one.
<font color="#0eade1">두 개의 포크는 이전 제출한 것과 똑같습니다.</font>

359
00:25:34,340 --> 00:25:39,539
You give it the task or the sub task in this case and it goes and forks.
<font color="#0eade1">이 경우 태스크 또는 서브 태스크를 전달하면 두 개의 포크가 발생합니다.</font>

360
00:25:39,539 --> 00:25:43,340
It creates a new virtual thread, returns me back a handle in the form of a supplier in
<font color="#0eade1">새 가상 스레드를 생성하고, 공급자의 형태로 핸들을 반환합니다.</font>

361
00:25:43,340 --> 00:25:46,660
this example to the result.
<font color="#0eade1">의 핸들을 결과로 반환합니다.</font>

362
00:25:46,660 --> 00:25:47,660
We do our two forks.
<font color="#0eade1">두 개의 포크를 수행합니다.</font>

363
00:25:47,660 --> 00:25:48,660
Then we do a join.
<font color="#0eade1">그런 다음 조인을 수행합니다.</font>

364
00:25:49,140 --> 00:25:52,180
We're waiting for both of them.
<font color="#0eade1">둘 다 기다리고 있습니다.</font>

365
00:25:52,180 --> 00:25:56,259
In the case of Structured on Failure, it defines a method called throw a fail.
<font color="#0eade1">구조형 온 페일리의 경우 throw a fail라는 메서드를 정의합니다.</font>

366
00:25:56,259 --> 00:25:59,100
There's a whole variance of this one.
<font color="#0eade1">이것은 완전히 다릅니다.</font>

367
00:25:59,100 --> 00:26:03,860
What this does is it'll propagate the exception of the first one that fails.
<font color="#0eade1">이것이 하는 일은 실패한 첫 번째 예외를 전파하는 것입니다.</font>

368
00:26:03,860 --> 00:26:06,460
Those are the ways you can do mapping of exceptions and things like that.
<font color="#0eade1">이런 식으로 예외 매핑 등을 할 수 있습니다.</font>

369
00:26:06,460 --> 00:26:09,140
I'll just keep it simple for this example.
<font color="#0eade1">이 예제에서는 간단하게 해보겠습니다.</font>

370
00:26:09,140 --> 00:26:16,140
In the case that both succeeds, then we just aggregate the result from both.
<font color="#0eade1">둘 다 성공하면 둘의 결과를 합산합니다.</font>

371
00:26:16,140 --> 00:26:19,900
As a supplier, it defines a get method so you do get to get the result and we're all
<font color="#0eade1">공급자로서는 결과를 얻을 수 있도록 get 메서드를 정의하고 있습니다.</font>

372
00:26:19,900 --> 00:26:20,900
good.
<font color="#0eade1">좋아.</font>

373
00:26:20,900 --> 00:26:26,140
Somewhat similar shape to what we've seen in the previous examples, but we're only waiting
<font color="#0eade1">이전 예제에서 본 것과 다소 비슷한 모양이지만, 대기 중입니다.</font>

374
00:26:26,140 --> 00:26:30,020
once here, a single join.
<font color="#0eade1">여기서 한 번만 조인합니다.</font>

375
00:26:30,020 --> 00:26:31,020
What do we get from this?
<font color="#0eade1">이걸로 무엇을 얻을 수 있을까요?</font>

376
00:26:31,020 --> 00:26:34,500
Well, we're going to get error handling with short cutting.
<font color="#0eade1">단축 커팅으로 오류 처리를 할 수 있습니다.</font>

377
00:26:34,500 --> 00:26:37,580
We're going to get cleanup to avoid thread leaks.
<font color="#0eade1">스레드 누수를 방지하기 위해 정리를 하겠습니다.</font>

378
00:26:37,580 --> 00:26:41,980
We're going to avoid having delayed cancellation.
<font color="#0eade1">취소 지연을 피하려고 합니다.</font>

379
00:26:41,980 --> 00:26:45,020
Let's look at what happens when it succeeds.
<font color="#0eade1">성공하면 어떤 일이 일어나는지 살펴봅시다.</font>

380
00:26:46,019 --> 00:26:52,500
FindUser succeeds, findOrder succeeds, join wakes up when they're both completed, throw
<font color="#0eade1">FindUser가 성공하고, findOrder가 성공하고, 둘 다 완료되면 join이 깨어나고, throw</font>

381
00:26:52,500 --> 00:26:57,619
a fail does nothing because there's no exception, and we call the toGet methods, aggregate the
<font color="#0eade1">실패는 예외가 없으므로 아무 일도 하지 않으며, toGet 메서드를 호출하고</font>

382
00:26:57,619 --> 00:27:00,859
result and return it.
<font color="#0eade1">결과를 합산하여 반환합니다.</font>

383
00:27:00,859 --> 00:27:02,660
We're all good.
<font color="#0eade1">모두 정상입니다.</font>

384
00:27:02,660 --> 00:27:09,180
Now let's see what happens if findOrder fails.
<font color="#0eade1">이제 findOrder가 실패하면 어떻게 되는지 살펴봅시다.</font>

385
00:27:09,180 --> 00:27:11,700
FindUser running away, findOrder fails.
<font color="#0eade1">FindUser가 도망가고, findOrder는 실패합니다.</font>

386
00:27:11,700 --> 00:27:16,140
What happens is that leads to the shutdown of the scope, join method wakes up, and then
<font color="#0eade1">이로 인해 범위가 종료되고 조인 메서드가 깨어난 다음</font>

387
00:27:16,140 --> 00:27:19,779
we use the throw a fail that actually propagates the exception.
<font color="#0eade1">실제로 예외를 전파하는 throw a fail를 사용합니다.</font>

388
00:27:19,779 --> 00:27:27,539
Part of the shutdown on failure means that when findOrder fails, it cancels, by way of
<font color="#0eade1">실패 시 셧다운의 일부는 findOrder가 실패하면 다음과 같이 취소한다는 것을 의미합니다.</font>

389
00:27:27,539 --> 00:27:31,940
thread interruption, the other tasks that are running in this scope.
<font color="#0eade1">스레드 중단을 통해 이 범위에서 실행 중인 다른 작업을 취소합니다.</font>

390
00:27:31,940 --> 00:27:38,980
In this case, when findOrder fails, it will cancel findUser.
<font color="#0eade1">이 경우 findOrder가 실패하면 findUser가 취소됩니다.</font>

391
00:27:38,980 --> 00:27:47,819
The close method in this resources will ensure that it waits until any cleanup is done.
<font color="#0eade1">이 리소스의 close 메서드는 정리가 완료될 때까지 기다립니다.</font>

392
00:27:47,819 --> 00:27:54,700
If there's any stragglers or a little bit slow to respond to cancellation or interrupt,
<font color="#0eade1">지연자가 있거나 취소 또는 중단에 대한 응답이 약간 느린 경우,</font>

393
00:27:54,700 --> 00:27:59,579
then it waits for them to clean up so that you're not leaving any threads behind.
<font color="#0eade1">스레드가 남지 않도록 정리될 때까지 기다립니다.</font>

394
00:27:59,579 --> 00:28:02,140
Now let's look at the same thing when findUser fails.
<font color="#0eade1">이제 findUser가 실패할 때도 똑같이 살펴봅시다.</font>

395
00:28:02,140 --> 00:28:06,740
If findUser fails, then findOrder will be canceled by way of thread interrupt.
<font color="#0eade1">findUser가 실패하면 스레드 인터럽트를 통해 findOrder가 취소됩니다.</font>

396
00:28:06,740 --> 00:28:13,500
The join method will wake up, and throwOfIfFailed will propagate the exception.
<font color="#0eade1">조인 메서드가 깨어나고 throwOfIfFailed가 예외를 전파합니다.</font>

397
00:28:13,500 --> 00:28:15,779
So that's it.
<font color="#0eade1">이제 끝입니다.</font>

398
00:28:15,779 --> 00:28:19,779
It's a very simple API.
<font color="#0eade1">매우 간단한 API입니다.</font>

399
00:28:19,779 --> 00:28:24,539
So the example I've used is a shutdown on failure, which I said shuts down the task
<font color="#0eade1">그래서 제가 사용한 예제는 실패 시 작업을 종료하는 셧다운입니다.</font>

400
00:28:24,539 --> 00:28:27,500
scope when a subtask fails.
<font color="#0eade1">하위 작업이 실패할 때 종료합니다.</font>

401
00:28:27,500 --> 00:28:32,579
The API also has another built-in policy, which is called shutdown on success, which
<font color="#0eade1">API에는 성공 시 종료라는 또 다른 기본 제공 정책도 있습니다.</font>

402
00:28:32,619 --> 00:28:40,299
is like the equivalent of the invokeAny combinator, where when some subtask returns a result,
<font color="#0eade1">는 어떤 서브태스크가 결과를 반환할 때 invokeAny 결합자와 같은 역할을 합니다,</font>

403
00:28:40,299 --> 00:28:43,500
then you cancel the rest because you don't care about those.
<font color="#0eade1">를 반환하면 나머지는 신경 쓰지 않으므로 취소합니다.</font>

404
00:28:43,500 --> 00:28:48,419
The idea with this API, and this is one we need to get more feedback from usage, is that
<font color="#0eade1">이 API의 아이디어는, 그리고 우리가 사용으로부터 더 많은 피드백을 얻어야 하는 아이디어는 다음과 같습니다.</font>

405
00:28:48,419 --> 00:28:51,619
it can be extended to implement other policies.
<font color="#0eade1">다른 정책을 구현하도록 확장할 수 있다는 것입니다.</font>

406
00:28:51,619 --> 00:28:56,980
So it can be extended to do more collection of results.
<font color="#0eade1">따라서 더 많은 결과 수집을 수행하도록 확장할 수 있습니다.</font>

407
00:28:57,860 --> 00:29:02,620
It can be extended to go and define a...
<font color="#0eade1">확장하여 정의할 수 있습니다.</font>

408
00:29:02,620 --> 00:29:13,539
So that the subtask defines APIs that make available the outcome of the overall task
<font color="#0eade1">하위 태스크가 전체 태스크의 결과를 사용할 수 있는 API를 정의하도록 합니다.</font>

409
00:29:13,539 --> 00:29:14,539
to the main task.
<font color="#0eade1">메인 태스크에</font>

410
00:29:14,539 --> 00:29:19,019
And that's actually quite interesting, because both shutdown on failure and shutdown on success
<font color="#0eade1">실패 시 종료와 성공 시 종료가 모두 이루어지기 때문에 실제로 매우 흥미롭습니다.</font>

411
00:29:19,019 --> 00:29:24,500
also define specific APIs for dealing with results in those cases.
<font color="#0eade1">또한 이러한 경우 결과를 처리하기 위한 특정 API를 정의합니다.</font>

412
00:29:24,500 --> 00:29:31,299
Another thing just to say about structured task scope is it's not the end story on structured
<font color="#0eade1">구조화된 작업 범위에 대해 한 가지 더 말씀드리자면, 구조화된 작업 범위에 대한 이야기의 끝이 아닙니다.</font>

413
00:29:31,299 --> 00:29:32,619
concurrency.
<font color="#0eade1">동시성입니다.</font>

414
00:29:32,619 --> 00:29:37,339
This is all built on something that will allow us in the future to be able to define other
<font color="#0eade1">이 모든 것은 향후에 우리가 다른</font>

415
00:29:37,339 --> 00:29:41,619
structured concurrency APIs if we need it.
<font color="#0eade1">구조화된 동시성 API를 정의할 수 있습니다.</font>

416
00:29:41,619 --> 00:29:45,980
So right now, this API is in preview in Java 21.
<font color="#0eade1">현재 이 API는 Java 21에서 프리뷰 버전입니다.</font>

417
00:29:45,980 --> 00:29:49,059
I just spotted there's a typo on my slides as Java 11.
<font color="#0eade1">방금 슬라이드에 Java 11로 오타가 있는 것을 발견했습니다.</font>

418
00:29:49,059 --> 00:29:50,059
Ignore the typo.
<font color="#0eade1">오타는 무시하세요.</font>

419
00:29:50,059 --> 00:29:52,940
I should have canceled on fail there.
<font color="#0eade1">거기서 실패하면 취소했어야 했는데.</font>

420
00:29:53,820 --> 00:29:57,980
At this point, we expect to preview it again in 22.
<font color="#0eade1">이 시점에서 22시에 다시 미리 볼 수 있을 것으로 예상됩니다.</font>

421
00:29:57,980 --> 00:30:03,220
So that's all I'm going to say for the moment for structured concurrency.
<font color="#0eade1">구조적 동시성에 대한 설명은 여기까지입니다.</font>

422
00:30:03,220 --> 00:30:05,740
Now I want to move on and talk about thread locals.
<font color="#0eade1">이제 스레드 로컬에 대해 이야기하고 싶습니다.</font>

423
00:30:05,740 --> 00:30:09,980
So just a quick show of hands is who's used thread local?
<font color="#0eade1">그럼 누가 스레드 로컬을 사용해 보셨나요?</font>

424
00:30:09,980 --> 00:30:13,900
Okay, I think maybe about half of the people.
<font color="#0eade1">좋아, 아마 절반 정도일 거야.</font>

425
00:30:13,900 --> 00:30:15,779
Okay, so people know what this is all about.
<font color="#0eade1">좋아, 사람들은 이게 무슨 일인지 알겠군.</font>

426
00:30:15,779 --> 00:30:21,500
But if you haven't used it, it's really about just associating data with the current thread
<font color="#0eade1">하지만 사용해보지 않으셨다면 현재 스레드에 데이터를 연결하기만 하면 됩니다.</font>

427
00:30:21,539 --> 00:30:23,700
of execution.
<font color="#0eade1">실행하는 것입니다.</font>

428
00:30:23,700 --> 00:30:26,819
And thread local is a very, very general mechanism.
<font color="#0eade1">그리고 스레드 로컬은 매우 일반적인 메커니즘입니다.</font>

429
00:30:26,819 --> 00:30:29,700
It's been there since JDK 1.2.
<font color="#0eade1">JDK 1.2부터 있었습니다.</font>

430
00:30:29,700 --> 00:30:32,099
It's used for all sorts of things.
<font color="#0eade1">다양한 용도로 사용됩니다.</font>

431
00:30:32,099 --> 00:30:34,180
Frameworks and libraries love thread locals.
<font color="#0eade1">프레임워크와 라이브러리는 스레드 로컬을 좋아합니다.</font>

432
00:30:34,180 --> 00:30:37,819
They do all sorts of stuff with thread locals.
<font color="#0eade1">그들은 스레드 로컬로 모든 종류의 작업을 수행합니다.</font>

433
00:30:37,819 --> 00:30:44,380
And because it's such a general purpose mechanism, it's used for some wild and crazy things in
<font color="#0eade1">워낙 범용적인 메커니즘이기 때문에, 다음과 같은 엉뚱하고 미친 짓에 사용되기도 합니다.</font>

434
00:30:44,380 --> 00:30:45,380
some cases.
<font color="#0eade1">어떤 경우에는요.</font>

435
00:30:45,380 --> 00:30:51,460
But there are two things that it gets used for a lot.
<font color="#0eade1">하지만 두 가지 용도로 많이 사용됩니다.</font>

436
00:30:51,460 --> 00:30:53,140
One is caching.
<font color="#0eade1">하나는 캐싱입니다.</font>

437
00:30:53,140 --> 00:30:57,259
So if you've got threads in a thread pool, and when I say thread pool, I mean about a
<font color="#0eade1">따라서 스레드 풀에 스레드가 있고, 스레드 풀이라고 하면</font>

438
00:30:57,259 --> 00:31:01,740
thread that's running many, many tasks on the same thread of execution, it can provide
<font color="#0eade1">스레드가 동일한 실행 스레드에서 많은 작업을 실행하는 경우, 이 스레드는</font>

439
00:31:01,740 --> 00:31:10,299
a performance benefit for objects that are very, very expensive to create and are mutable.
<font color="#0eade1">생성 비용이 매우 많이 들고 변경 가능한 객체에 대한 성능 이점을 제공합니다.</font>

440
00:31:10,299 --> 00:31:14,980
They're not safe or they can be modified.
<font color="#0eade1">안전하지 않거나 수정할 수 있습니다.</font>

441
00:31:14,980 --> 00:31:18,019
It's a useful way for actually caching those things.
<font color="#0eade1">실제로 캐싱하는 데 유용한 방법입니다.</font>

442
00:31:18,019 --> 00:31:24,700
It's also used by frameworks for supporting things like callbacks, be able to get data
<font color="#0eade1">또한 콜백 같은 것을 지원하기 위해 프레임워크에서 사용되며, 데이터를 가져올 수 있습니다.</font>

443
00:31:24,700 --> 00:31:31,139
from my call to the API to somewhere, some faraway callee, which is the callback.
<font color="#0eade1">API에 대한 내 호출에서 멀리 떨어진 호출자, 즉 콜백으로 데이터를 전송합니다.</font>

444
00:31:31,139 --> 00:31:34,700
So it's essentially working as an implicit parameter in that case.
<font color="#0eade1">따라서 이 경우에는 기본적으로 암시적 매개변수로 작동합니다.</font>

445
00:31:34,700 --> 00:31:38,180
There's other libraries use it for things like implicit return values as well.
<font color="#0eade1">다른 라이브러리에서도 암시적 반환값과 같은 용도로 사용합니다.</font>

446
00:31:38,180 --> 00:31:40,859
I'm not going to get into that.
<font color="#0eade1">그 얘기는 하지 않겠습니다.</font>

447
00:31:40,859 --> 00:31:44,740
There's a lot of issues with thread locals.
<font color="#0eade1">스레드 로컬에 많은 문제가 있습니다.</font>

448
00:31:44,779 --> 00:31:48,420
Those that put up their hands to use thread locals, I'm guessing is that some percentage
<font color="#0eade1">스레드 로컬을 사용하겠다고 손을 든 사람들은, 아마도 몇 퍼센트가</font>

449
00:31:48,420 --> 00:31:53,339
of you have had problems with so-called memory leaks and thread locals.
<font color="#0eade1">중 일부는 소위 메모리 누수 및 스레드 로컬에 문제가 있었을 것입니다.</font>

450
00:31:53,339 --> 00:32:00,019
So some piece of code goes and stashes its collection of cats in a thread local, and
<font color="#0eade1">그래서 어떤 코드가 스레드 로컬에 고양이 컬렉션을 숨겨놓고</font>

451
00:32:00,019 --> 00:32:05,819
it's a gigabyte of cats, and that thread just continues forever.
<font color="#0eade1">기가바이트의 고양이가 저장되고 그 스레드는 영원히 계속됩니다.</font>

452
00:32:05,819 --> 00:32:09,700
That's a lot of memory wasted, even though the other subtasks that run on that never
<font color="#0eade1">그 스레드에서 실행되는 다른 서브 태스크는 절대 실행되지 않음에도 불구하고 많은 메모리가 낭비됩니다.</font>

453
00:32:09,700 --> 00:32:13,980
make use of that code again.
<font color="#0eade1">그 코드를 다시 사용해야 합니다.</font>

454
00:32:13,980 --> 00:32:21,339
Other issues with it is that there's essentially this problem of unconstrained immutability.
<font color="#0eade1">다른 문제점은 본질적으로 제약되지 않은 불변성이라는 문제가 있다는 것입니다.</font>

455
00:32:21,339 --> 00:32:24,860
If you have access to the thread local, you can actually change its value.
<font color="#0eade1">로컬에서 스레드에 접근할 수 있다면 실제로 값을 변경할 수 있습니다.</font>

456
00:32:24,860 --> 00:32:28,259
Inheritance is problematic with thread local.
<font color="#0eade1">스레드 로컬에서 상속이 문제가 있습니다.</font>

457
00:32:28,259 --> 00:32:33,259
When we do corpus scans of code bases, we don't see a huge amount of inheritable thread
<font color="#0eade1">코드 베이스의 말뭉치 스캔을 수행하면 상속 가능한 스레드의 양이 엄청나게 많지 않습니다.</font>

458
00:32:33,259 --> 00:32:36,140
local usage because it's so expensive.
<font color="#0eade1">너무 비싸기 때문에 로컬 사용.</font>

459
00:32:36,140 --> 00:32:38,740
It's inheritance at creation time.
<font color="#0eade1">생성 시 상속입니다.</font>

460
00:32:38,740 --> 00:32:41,220
So there's a lot of issues there.
<font color="#0eade1">그래서 많은 문제가 있습니다.</font>

461
00:32:41,860 --> 00:32:47,779
Main things that I think that people run into with thread locals is just the issue around lifetime.
<font color="#0eade1">제가 생각하는 스레드 로컬에서 사람들이 겪는 주요 문제는 수명에 관한 문제입니다.</font>

462
00:32:48,900 --> 00:32:53,059
They don't get cleaned up unless they're explicitly cleaned up.
<font color="#0eade1">명시적으로 정리하지 않는 한 정리되지 않습니다.</font>

463
00:32:53,059 --> 00:32:57,779
Okay, so virtual threads and thread locals.
<font color="#0eade1">좋아, 가상 스레드와 스레드 로컬.</font>

464
00:32:57,779 --> 00:33:04,860
This is where it gets kind of interesting, is that virtual threads are threads.
<font color="#0eade1">여기서 흥미로운 점이 있는데, 가상 스레드는 스레드라는 점입니다.</font>

465
00:33:04,860 --> 00:33:09,420
Therefore they must support thread locals.
<font color="#0eade1">따라서 스레드 로컬을 지원해야 합니다.</font>

466
00:33:09,420 --> 00:33:15,180
It's kind of a forced move because there's so much existing code uses thread locals.
<font color="#0eade1">스레드 로컬을 사용하는 기존 코드가 너무 많기 때문에 어쩔 수 없이 변경한 것입니다.</font>

467
00:33:15,180 --> 00:33:22,220
We did at one point attempt to provide a way to opt out of supporting thread locals when
<font color="#0eade1">한때 스레드 로컬 지원을 거부할 수 있는 방법을 제공하려고 시도한 적이 있습니다.</font>

468
00:33:22,220 --> 00:33:26,900
creating virtual threads, but it was problematic for running existing code.
<font color="#0eade1">가상 스레드를 생성할 때 스레드 로컬 지원을 거부하는 방법을 제공하려고 했지만, 기존 코드를 실행하는 데 문제가 있었습니다.</font>

469
00:33:26,900 --> 00:33:30,940
It meant some kind of bifurcation of the ecosystem in that this is code that runs on a platform
<font color="#0eade1">이것은 플랫폼에서 실행되는 코드라는 점에서 생태계의 일종의 분기점을 의미했습니다.</font>

470
00:33:30,940 --> 00:33:32,340
thread, it can use thread locals.
<font color="#0eade1">스레드를 사용하면 스레드 로컬을 사용할 수 있습니다.</font>

471
00:33:32,340 --> 00:33:34,660
This is code that can't use thread locals.
<font color="#0eade1">스레드 로컬을 사용할 수 없는 코드입니다.</font>

472
00:33:35,100 --> 00:33:40,460
That's not a good place to be, so we backed away from that.
<font color="#0eade1">좋은 위치가 아니므로 여기서 물러났습니다.</font>

473
00:33:40,460 --> 00:33:44,580
Why it's problematic for virtual threads is because remember we're migrating from tasks
<font color="#0eade1">가상 스레드에 문제가 있는 이유는 우리가 작업에서 마이그레이션하고 있다는 것을 기억하기 때문입니다.</font>

474
00:33:44,580 --> 00:33:47,779
to virtual threads, not platform threads to virtual threads.
<font color="#0eade1">에서 가상 스레드로 마이그레이션하는 것이지 플랫폼 스레드에서 가상 스레드로 마이그레이션하는 것이 아닙니다.</font>

475
00:33:47,779 --> 00:33:56,580
So if a virtual thread and a task is a one-to-one relationship, then if the first use of some
<font color="#0eade1">따라서 가상 스레드와 태스크가 일대일 관계인 경우, 처음 사용하는 경우</font>

476
00:33:56,580 --> 00:34:04,220
library creates some expensive object, stashes it in the thread local and never uses it again,
<font color="#0eade1">라이브러리는 값비싼 객체를 생성하여 스레드 로컬에 저장하고 다시는 사용하지 않습니다,</font>

477
00:34:04,259 --> 00:34:10,980
that's going to penalize all usages of that code running in virtual threads.
<font color="#0eade1">가상 스레드에서 실행되는 해당 코드의 모든 사용에 불이익을 줄 것입니다.</font>

478
00:34:10,980 --> 00:34:19,980
And caching can be very, very negative, particularly with some of the modern garbage collectors.
<font color="#0eade1">그리고 캐싱은 특히 최신 가비지 컬렉터 중 일부에서 매우 부정적인 영향을 미칠 수 있습니다.</font>

479
00:34:19,980 --> 00:34:28,099
So when we want to migrate to using virtual threads, we have to start thinking about our
<font color="#0eade1">따라서 가상 스레드 사용으로 마이그레이션하고 싶을 때, 우리는 우리의</font>

480
00:34:28,099 --> 00:34:29,099
thread local usage.
<font color="#0eade1">스레드 로컬 사용량을 고려해야 합니다.</font>

481
00:34:29,099 --> 00:34:32,980
There's some diagnostics and stuff for helping to detect some of these things.
<font color="#0eade1">이러한 것들을 감지하는 데 도움이 되는 몇 가지 진단 및 기능이 있습니다.</font>

482
00:34:32,980 --> 00:34:37,860
The main thing is thinking about, do I really need to cache this expensive object in a thread
<font color="#0eade1">가장 중요한 것은 이 비싼 객체를 스레드에 캐시할 필요가 있느냐는 것입니다.</font>

483
00:34:37,860 --> 00:34:38,860
local?
<font color="#0eade1">local?</font>

484
00:34:38,860 --> 00:34:45,900
If it's a mutable object, is there some immutable alternative that I should use?
<font color="#0eade1">변경 가능한 객체라면 제가 사용해야 할 불변 대체물이 있나요?</font>

485
00:34:45,900 --> 00:34:53,300
A good example is when we do corpus analysis, we find many, many classes are actually stashing
<font color="#0eade1">좋은 예는 말뭉치 분석을 할 때 많은 클래스가 실제로 숨어있는 것을 발견하는 것입니다.</font>

486
00:34:53,300 --> 00:34:59,019
away a simple date format in a static final thread local.
<font color="#0eade1">정적 최종 스레드 로컬에 간단한 날짜 형식을 숨기고 있습니다.</font>

487
00:34:59,099 --> 00:35:00,099
Why are they doing that?
<font color="#0eade1">왜 저러는 걸까요?</font>

488
00:35:00,099 --> 00:35:05,780
Because these simple date formatters are expensive to create and they're mutable.
<font color="#0eade1">이러한 간단한 날짜 포맷터는 만드는 데 비용이 많이 들고 변경이 가능하기 때문입니다.</font>

489
00:35:05,780 --> 00:35:10,940
But there's a better alternative with the Java time API and Java time formatter that
<font color="#0eade1">하지만 Java 시간 API와 Java 시간 포맷터를 사용하면 더 나은 대안이 있습니다.</font>

490
00:35:10,940 --> 00:35:16,059
allows me to store that as an immutable object in a static final field, and I don't need
<font color="#0eade1">를 사용하면 정적 최종 필드에 불변 객체로 저장할 수 있으며, 이를 위해</font>

491
00:35:16,059 --> 00:35:17,059
a thread local.
<font color="#0eade1">를 로컬 스레드에 저장할 필요가 없습니다.</font>

492
00:35:17,059 --> 00:35:19,699
And there's other examples of this kind of thing.
<font color="#0eade1">이런 종류의 다른 예도 있습니다.</font>

493
00:35:19,699 --> 00:35:27,619
There's other cases where using some cache or some other kind of more interesting caching
<font color="#0eade1">캐시나 다른 종류의 더 흥미로운 캐싱을 사용하는 다른 사례도 있습니다.</font>

494
00:35:27,659 --> 00:35:35,500
can avoid using these thread locals as well.
<font color="#0eade1">를 사용하면 이러한 스레드 로컬 사용을 피할 수 있습니다.</font>

495
00:35:35,500 --> 00:35:42,699
So I guess our message when we're migrating to virtual threads is moving away from thread
<font color="#0eade1">따라서 가상 스레드로 마이그레이션할 때 우리의 메시지는 스레드에서 멀어지고 있다는 것입니다.</font>

496
00:35:42,699 --> 00:35:46,219
locals if it makes sense.
<font color="#0eade1">로 이동하는 것 같습니다.</font>

497
00:35:46,219 --> 00:35:52,339
In the JDK and particularly in the base module, base module is the core module of the Java
<font color="#0eade1">JDK, 특히 베이스 모듈에서 베이스 모듈은 Java의 핵심 모듈입니다.</font>

498
00:35:52,339 --> 00:35:54,099
platform.
<font color="#0eade1">플랫폼의 핵심 모듈입니다.</font>

499
00:35:54,099 --> 00:35:58,500
One of the exercises we did over the last couple of releases is we evaluated the usages
<font color="#0eade1">지난 몇 번의 릴리스에서 수행한 연습 중 하나는 사용량을 평가하는 것입니다.</font>

500
00:35:58,500 --> 00:36:04,779
of thread locals in many, many areas and found that they had negative performance.
<font color="#0eade1">의 스레드 로컬 사용량을 평가한 결과 성능이 저하되는 것을 확인했습니다.</font>

501
00:36:04,779 --> 00:36:11,659
They were added as caching, some performance solution many, many years ago.
<font color="#0eade1">수년 전에 캐싱, 일부 성능 솔루션으로 추가되었습니다.</font>

502
00:36:11,659 --> 00:36:17,739
But since then, we've moved to G1, there's basically better garbage collection and better
<font color="#0eade1">하지만 그 이후로 우리는 G1으로 이전했고, 기본적으로 가비지 컬렉션이 더 좋아졌고, 더 나은</font>

503
00:36:17,740 --> 00:36:24,100
VM implementation means that the caching ends up having negative benefits rather than
<font color="#0eade1">VM 구현은 캐싱이 결국 부정적인 이점을 가지게 된다는 것을 의미합니다.</font>

504
00:36:24,100 --> 00:36:25,100
positive benefits.
<font color="#0eade1">긍정적 이점이 있습니다.</font>

505
00:36:25,100 --> 00:36:30,980
So we were able to reimplement and re-implement that part of code and get rid of the caching.
<font color="#0eade1">따라서 해당 코드 부분을 다시 구현하고 재구현하여 캐싱을 제거할 수 있었습니다.</font>

506
00:36:30,980 --> 00:36:34,940
And I think as well as this is, I should say, is this is a part of Project Loom is we've
<font color="#0eade1">그리고 이것뿐만 아니라 프로젝트 룸의 한 부분이라고 해야 할까요?</font>

507
00:36:34,940 --> 00:36:44,340
had to explore a number of other possible APIs as alternatives for thread locals for
<font color="#0eade1">에 대한 스레드 로컬의 대안으로 가능한 다른 여러 API를 탐색해야 했습니다.</font>

508
00:36:44,340 --> 00:36:46,620
particular use cases.
<font color="#0eade1">특정 사용 사례.</font>

509
00:36:46,699 --> 00:36:51,539
I'm not going to talk about these in any detail today, but maybe previous presentations you
<font color="#0eade1">오늘은 이에 대해 자세히 설명하지는 않겠지만, 이전 프레젠테이션에서 다음과 같이 설명한 적이 있을 것입니다.</font>

510
00:36:51,539 --> 00:36:55,139
would have seen us talk about things like processor locals and a few other things like
<font color="#0eade1">에서 프로세서 로컬과 같은 것들에 대해 이야기하는 것을 보셨을 것입니다.</font>

511
00:36:55,139 --> 00:36:56,460
that.
<font color="#0eade1">그.</font>

512
00:36:56,460 --> 00:37:04,659
The one I do want to talk about is the common use case of the callbacks are essentially
<font color="#0eade1">제가 이야기하고 싶은 것은 콜백의 일반적인 사용 사례입니다.</font>

513
00:37:04,659 --> 00:37:08,299
using thread locals as a form of implicit parameter.
<font color="#0eade1">스레드 로컬을 암시적 매개변수의 한 형태로 사용하는 것입니다.</font>

514
00:37:08,299 --> 00:37:16,380
It's essentially transmission of some data to some faraway colleague, typically a callback
<font color="#0eade1">본질적으로 멀리 떨어진 동료에게 일부 데이터를 전송하는 것인데, 일반적으로 콜백입니다.</font>

515
00:37:16,539 --> 00:37:18,820
without using a method parameter.
<font color="#0eade1">메서드 매개변수를 사용하지 않고.</font>

516
00:37:18,820 --> 00:37:24,940
So I want to talk about that type of usage because we've added this API.
<font color="#0eade1">이 API를 추가했기 때문에 이러한 유형의 사용법에 대해 이야기하고 싶습니다.</font>

517
00:37:24,940 --> 00:37:29,460
It's actually Andrew Haley actually added this effort.
<font color="#0eade1">실제로 이 작업을 추가한 것은 앤드류 헤일리입니다.</font>

518
00:37:29,460 --> 00:37:35,980
We've added this as a scope value API, as a preview API in 21, which specifically targets
<font color="#0eade1">21에서 미리보기 API로 범위 값 API로 추가했으며, 특히 다음 대상을 대상으로 합니다.</font>

519
00:37:35,980 --> 00:37:43,780
this use case in a very nice way and essentially provides both a safe and a very efficient
<font color="#0eade1">이 사용 사례는 매우 멋진 방식으로, 본질적으로 안전하고 매우 효율적인</font>

520
00:37:43,820 --> 00:37:49,380
way of actually sharing to callbacks without using method parameters.
<font color="#0eade1">메서드 매개변수를 사용하지 않고 콜백에 실제로 공유할 수 있는 방법을 제공합니다.</font>

521
00:37:49,380 --> 00:37:59,300
All of the frames in between the framework and the callback have no access to this implicit
<font color="#0eade1">프레임워크와 콜백 사이에 있는 모든 프레임은 이 암시적 프레임에 접근할 수 없습니다.</font>

522
00:37:59,300 --> 00:38:02,220
or hidden parameter, if you like.
<font color="#0eade1">또는 원하는 경우 숨겨진 매개변수에 액세스할 수 있습니다.</font>

523
00:38:02,220 --> 00:38:04,019
So here's a motivating example.
<font color="#0eade1">여기 동기부여가 되는 예시가 있습니다.</font>

524
00:38:04,019 --> 00:38:08,460
I've just taken a stack trace because I like showing slides with stack traces.
<font color="#0eade1">스택 트레이스로 슬라이드를 표시하는 것이 좋아서 방금 스택 트레이스를 찍었습니다.</font>

525
00:38:08,460 --> 00:38:13,699
This one here is just...
<font color="#0eade1">이건 그냥...</font>

526
00:38:13,699 --> 00:38:15,380
I don't know what half the components are in here.
<font color="#0eade1">여기 구성 요소의 절반이 뭔지 모르겠어요.</font>

527
00:38:15,380 --> 00:38:20,300
There's Jetty, Jersey, HK2, and a whole bunch of other stuff in this stack trace.
<font color="#0eade1">이 스택 추적에는 제티, 저지, HK2 및 기타 여러 가지가 있습니다.</font>

528
00:38:20,300 --> 00:38:26,619
Oh, by the way, when looking at stack traces in my slides, they all start at the bottom
<font color="#0eade1">아참, 슬라이드에서 스택 트레이스를 보면 모두 아래쪽부터 시작하네요.</font>

529
00:38:26,619 --> 00:38:28,980
up, but other people like to do a top down.
<font color="#0eade1">위쪽에서 시작하지만 다른 사람들은 위에서 아래로 하는 것을 좋아합니다.</font>

530
00:38:28,980 --> 00:38:34,139
But for this slide, bottom up is where the initial frame is.
<font color="#0eade1">하지만 이 슬라이드의 경우 초기 프레임이 있는 곳이 상향식입니다.</font>

531
00:38:34,139 --> 00:38:39,420
Now I want to zoom in on just a little small portion of this stack trace, and hopefully
<font color="#0eade1">이제 이 스택 트레이스의 아주 작은 부분만 확대하고 싶습니다.</font>

532
00:38:39,420 --> 00:38:41,099
it's actually readable here.
<font color="#0eade1">여기서 읽을 수 있기를 바랍니다.</font>

533
00:38:41,099 --> 00:38:44,019
Because when we actually zoom in here, I actually see a callback.
<font color="#0eade1">실제로 여기를 확대하면 콜백이 보이니까요.</font>

534
00:38:44,019 --> 00:38:47,699
In fact, you can actually zoom in on a couple of parts of this, and there's actually many,
<font color="#0eade1">실제로 이 부분의 몇 가지를 확대하면 실제로 많은 부분이 있습니다,</font>

535
00:38:47,699 --> 00:38:48,699
many callbacks.
<font color="#0eade1">많은 콜백이 있습니다.</font>

536
00:38:48,699 --> 00:38:51,179
But I've just picked one of them.
<font color="#0eade1">하지만 방금 그중 하나를 골랐어요.</font>

537
00:38:51,179 --> 00:38:55,559
And this callback is something in some code called Jersey, which I think is something
<font color="#0eade1">그리고 이 콜백은 저지(Jersey)라는 코드에 있는 것인데, 제가 생각하기에는</font>

538
00:38:55,559 --> 00:39:00,859
in the Jax-RS area, where it's got this method called run in scope, where I see it actually
<font color="#0eade1">라는 메서드가 있는데, 이 메서드에는 범위 내에서 실행이라는 메서드가 있습니다.</font>

539
00:39:00,860 --> 00:39:10,140
sets a thread local, and then further in the call chain, we see it calling request
<font color="#0eade1">는 스레드를 로컬로 설정한 다음 호출 체인에서 더 나아가 요청을 호출하는 것을 볼 수 있습니다.</font>

540
00:39:10,140 --> 00:39:11,940
scope dot current.
<font color="#0eade1">스코프 도트 전류.</font>

541
00:39:11,940 --> 00:39:16,660
So what's going on here is the framework called Jersey is setting some thread local, and then
<font color="#0eade1">여기서 무슨 일이 일어나고 있는지는 Jersey라는 프레임워크가 일부 스레드를 로컬로 설정한 다음</font>

542
00:39:16,660 --> 00:39:26,660
it's reading it way further on in the execution with this request scope dot current.
<font color="#0eade1">이 요청 범위 도트 전류로 실행에서 훨씬 더 멀리 읽습니다.</font>

543
00:39:26,660 --> 00:39:28,539
So it's doing a set in one place, get another.
<font color="#0eade1">그래서 한 곳에서 세트를 수행하고 다른 세트를 가져옵니다.</font>

544
00:39:28,539 --> 00:39:32,579
It's basically providing some context or data, or let's call it some context scope
<font color="#0eade1">기본적으로 컨텍스트 또는 데이터를 제공하거나 컨텍스트 범위라고 부를 수 있습니다.</font>

545
00:39:32,579 --> 00:39:33,739
thing.
<font color="#0eade1">같은 거요.</font>

546
00:39:33,739 --> 00:39:37,980
And it's making it available to the callback without using a parameter.
<font color="#0eade1">그리고 매개변수를 사용하지 않고 콜백에서 사용할 수 있도록 합니다.</font>

547
00:39:37,980 --> 00:39:39,019
That's actually interesting to see.
<font color="#0eade1">정말 흥미롭습니다.</font>

548
00:39:39,019 --> 00:39:42,019
And as I say, many of the frameworks, you actually see this.
<font color="#0eade1">그리고 제가 말씀드린 것처럼 많은 프레임워크에서 실제로 이것을 볼 수 있습니다.</font>

549
00:39:42,019 --> 00:39:45,139
Now let's look at what this code might look like.
<font color="#0eade1">이제 이 코드가 어떻게 생겼는지 살펴봅시다.</font>

550
00:39:45,139 --> 00:39:47,420
This, by the way, is not the code from Jersey.
<font color="#0eade1">그건 그렇고, 이것은 저지의 코드가 아닙니다.</font>

551
00:39:47,420 --> 00:39:52,139
This is just sort of a simplified version, just to give you an idea of what's actually
<font color="#0eade1">이것은 일종의 단순화 된 버전으로, 실제로 무엇이 있는지 아이디어를 제공하기 위해</font>

552
00:39:52,139 --> 00:39:53,340
going on.
<font color="#0eade1">진행 중입니다.</font>

553
00:39:53,340 --> 00:39:57,900
So I've got this run in scope method that's setting a thread local, and then there's a
<font color="#0eade1">그래서 스레드를 로컬로 설정하는 범위 내에서 실행하는 메서드가 있고, 그 다음</font>

554
00:39:57,900 --> 00:40:00,539
current method that actually returns the thread local.
<font color="#0eade1">현재 메서드가 실제로 스레드를 로컬로 반환합니다.</font>

555
00:40:00,539 --> 00:40:05,820
And the thread local, the value in this case, is of type of request context, which I've
<font color="#0eade1">그리고 이 경우의 값인 스레드 로컬은 요청 컨텍스트 유형입니다.</font>

556
00:40:05,820 --> 00:40:06,820
just made up, by the way.
<font color="#0eade1">방금 만들어낸 값입니다.</font>

557
00:40:06,820 --> 00:40:09,380
It's not what this code uses.
<font color="#0eade1">이 코드가 사용하는 것이 아닙니다.</font>

558
00:40:09,380 --> 00:40:12,860
Now if we focus on just a little piece of this code, let's actually go and see what's
<font color="#0eade1">이제 이 코드의 일부분만 집중해서 살펴봅시다.</font>

559
00:40:12,860 --> 00:40:14,340
actually going on.
<font color="#0eade1">실제로 무슨 일이 일어나고 있는지 살펴봅시다.</font>

560
00:40:14,340 --> 00:40:18,780
So it creates one of these request context objects.
<font color="#0eade1">따라서 이러한 요청 컨텍스트 객체 중 하나가 생성됩니다.</font>

561
00:40:18,780 --> 00:40:21,220
Remember, we don't know what that is.
<font color="#0eade1">기억하세요, 우리는 그것이 무엇인지 모릅니다.</font>

562
00:40:21,220 --> 00:40:26,099
And it's setting it as a thread local, making a call to something called errors dot process.
<font color="#0eade1">그리고 스레드 로컬로 설정하고 오류 도트 프로세스라는 것을 호출하고 있습니다.</font>

563
00:40:26,099 --> 00:40:27,660
I have no idea what that does.
<font color="#0eade1">그게 뭘 하는 건지 모르겠어요.</font>

564
00:40:28,420 --> 00:40:31,420
And then it's got a finally block where it's actually going to remove the thread local.
<font color="#0eade1">그리고 마지막으로 실제로 스레드를 로컬로 제거하는 블록이 있습니다.</font>

565
00:40:31,420 --> 00:40:37,139
Now this code and this framework thing seems to be able to support kind of nested type
<font color="#0eade1">이제 이 코드와 이 프레임워크는 일종의 중첩된 유형을 지원할 수 있는 것 같습니다.</font>

566
00:40:37,139 --> 00:40:38,139
of context.
<font color="#0eade1">의 컨텍스트를 지원합니다.</font>

567
00:40:38,139 --> 00:40:40,420
So this is essentially working like a stack.
<font color="#0eade1">따라서 이것은 본질적으로 스택처럼 작동합니다.</font>

568
00:40:40,420 --> 00:40:47,379
It fetches the, gets the current value of the thread local, saves that, sets it to some
<font color="#0eade1">로컬 스레드의 현재 값을 가져와서 저장한 다음, 이를 일부</font>

569
00:40:47,379 --> 00:40:53,059
new value, calls whatever the code is, and then the finally block is actually essentially
<font color="#0eade1">새 값으로 설정하고, 코드가 무엇이든 호출한 다음, 최종적으로 블록은 실제로 본질적으로</font>

570
00:40:53,059 --> 00:40:54,059
a restore.
<font color="#0eade1">복원이 됩니다.</font>

571
00:40:54,380 --> 00:40:59,699
So the restore is either restoring it to the previous value, or it's doing a remove.
<font color="#0eade1">따라서 복원은 이전 값으로 복원하거나 제거를 수행합니다.</font>

572
00:40:59,699 --> 00:41:04,739
This is a kind of a pattern that we see in quite a few frameworks.
<font color="#0eade1">이것은 꽤 많은 프레임워크에서 볼 수 있는 일종의 패턴입니다.</font>

573
00:41:04,739 --> 00:41:11,139
And it's just one example of using implicit parameters.
<font color="#0eade1">이는 암시적 매개변수 사용의 한 예시일 뿐입니다.</font>

574
00:41:11,139 --> 00:41:14,579
So let's go and look at this equivalent code using a scoped value.
<font color="#0eade1">이제 범위 지정 값을 사용하는 이와 동등한 코드를 살펴보겠습니다.</font>

575
00:41:14,579 --> 00:41:18,980
Now this is a little bit shorter, just because scope value kind of supports this thing.
<font color="#0eade1">범위 값이 이것을 지원하기 때문에 이것은 조금 더 짧습니다.</font>

576
00:41:18,980 --> 00:41:21,139
So the scope value is the first of the top.
<font color="#0eade1">그래서 범위 값은 맨 위의 첫 번째입니다.</font>

577
00:41:21,139 --> 00:41:23,179
We actually see there's a request context.
<font color="#0eade1">실제로 요청 컨텍스트가 있음을 알 수 있습니다.</font>

578
00:41:23,299 --> 00:41:25,739
It's a static final field as well.
<font color="#0eade1">정적 최종 필드이기도 합니다.</font>

579
00:41:25,739 --> 00:41:27,940
And it has a type parameter for the request context.
<font color="#0eade1">그리고 요청 컨텍스트에 대한 타입 매개변수도 있습니다.</font>

580
00:41:27,940 --> 00:41:32,980
So it's kind of similar to thread local in terms of its setup and the access control
<font color="#0eade1">따라서 설정과 접근 제어 측면에서 스레드 로컬과 비슷합니다.</font>

581
00:41:32,980 --> 00:41:40,099
that you typically use to guard access to the scope value field itself.
<font color="#0eade1">일반적으로 범위 값 필드 자체에 대한 액세스를 보호하는 데 사용합니다.</font>

582
00:41:40,099 --> 00:41:45,219
We create a request context as before.
<font color="#0eade1">이전과 마찬가지로 요청 컨텍스트를 생성합니다.</font>

583
00:41:45,219 --> 00:41:49,339
And then what we're going to do is we're actually going to run a piece of code with the scope
<font color="#0eade1">그런 다음 실제로 다음 범위의 코드를 실행합니다.</font>

584
00:41:49,380 --> 00:41:54,260
value set some new request context that I create.
<font color="#0eade1">값으로 제가 만든 새로운 요청 컨텍스트를 설정합니다.</font>

585
00:41:54,260 --> 00:41:59,340
So what we see here is scope value dot run where, and then you've got essentially a key
<font color="#0eade1">따라서 여기서 볼 수 있는 것은 범위 값 도트 실행 위치이며, 본질적으로 키</font>

586
00:41:59,340 --> 00:42:00,539
and a value.
<font color="#0eade1">와 값</font>

587
00:42:00,539 --> 00:42:07,140
So the key is the request context variable, and then the request context value.
<font color="#0eade1">따라서 키는 요청 컨텍스트 변수이고, 그다음은 요청 컨텍스트 값입니다.</font>

588
00:42:07,140 --> 00:42:08,860
And then in this case, it's a runnable.
<font color="#0eade1">그리고 이 경우에는 런처블입니다.</font>

589
00:42:08,860 --> 00:42:12,180
There's variations of this for callables and suppliers.
<font color="#0eade1">콜러블과 공급자에 대한 변형이 있습니다.</font>

590
00:42:12,219 --> 00:42:19,699
But the point is this sets up a binding for the duration of the errors dot process method.
<font color="#0eade1">하지만 요점은 이것이 오류 도트 프로세스 메서드의 지속 시간에 대한 바인딩을 설정한다는 것입니다.</font>

591
00:42:19,699 --> 00:42:24,299
So when that method actually completes, the binding is removed or restored to its previous
<font color="#0eade1">따라서 해당 메서드가 실제로 완료되면 바인딩이 제거되거나 이전으로 복원됩니다.</font>

592
00:42:24,299 --> 00:42:25,299
value.
<font color="#0eade1">값으로 복원됩니다.</font>

593
00:42:25,299 --> 00:42:33,099
And that's actually very, very nice because we don't have any leakage here.
<font color="#0eade1">여기에는 누수가 전혀 없으니 정말 아주 좋은 결과입니다.</font>

594
00:42:33,099 --> 00:42:34,739
We're not leaving anything behind.
<font color="#0eade1">우리는 아무것도 남기지 않을 거야.</font>

595
00:42:34,739 --> 00:42:38,819
This is actually really, really nice to use.
<font color="#0eade1">이건 정말 사용하기 정말 좋네요.</font>

596
00:42:38,820 --> 00:42:43,700
So just a quick summary on scope value is this.
<font color="#0eade1">범위 값에 대한 간단한 요약은 다음과 같습니다.</font>

597
00:42:43,700 --> 00:42:46,620
When this API becomes permanent, this would be the preferred way of doing essentially
<font color="#0eade1">이 API가 영구화되면, 기본적으로 다음과 같은 방식이 선호될 것입니다.</font>

598
00:42:46,620 --> 00:42:48,500
the one-way transmission.
<font color="#0eade1">단방향 전송입니다.</font>

599
00:42:48,500 --> 00:42:50,900
It's how you will actually do implicit parameters.
<font color="#0eade1">이것이 실제로 암시적 매개변수를 수행하는 방법입니다.</font>

600
00:42:50,900 --> 00:42:55,559
It's how to support the callbacks type of use case.
<font color="#0eade1">콜백 유형의 사용 사례를 지원하는 방법입니다.</font>

601
00:42:55,559 --> 00:43:00,700
It's a lot better than thread locals for this type of use case.
<font color="#0eade1">이러한 유형의 사용 사례에는 스레드 로컬보다 훨씬 낫습니다.</font>

602
00:43:00,700 --> 00:43:08,380
One reason is that your faraway callee can't change the binding.
<font color="#0eade1">한 가지 이유는 멀리 있는 캘리가 바인딩을 변경할 수 없기 때문입니다.</font>

603
00:43:08,380 --> 00:43:12,940
It can establish a new binding and call additional code, but it can't change the existing binding.
<font color="#0eade1">새 바인딩을 설정하고 추가 코드를 호출할 수는 있지만 기존 바인딩을 변경할 수는 없습니다.</font>

604
00:43:12,940 --> 00:43:16,320
This bounded lifetime, because as I said, it's a where method.
<font color="#0eade1">이 바인딩 수명은 앞서 말했듯이 where 메서드이기 때문입니다.</font>

605
00:43:16,320 --> 00:43:21,980
It's bound for the duration of the, in this case, the runnable.
<font color="#0eade1">이 경우에는 실행 가능한 기간 동안 바인딩됩니다.</font>

606
00:43:21,980 --> 00:43:25,500
It actually works with inheritance and in structured context.
<font color="#0eade1">실제로 상속과 구조화된 컨텍스트에서 작동합니다.</font>

607
00:43:25,500 --> 00:43:26,860
So this is actually kind of interesting.
<font color="#0eade1">그래서 이것은 사실 좀 흥미롭습니다.</font>

608
00:43:26,860 --> 00:43:29,460
I'm not going to show it to you because we don't have too much time.
<font color="#0eade1">시간이 많지 않아서 보여드리지 않겠습니다.</font>

609
00:43:29,460 --> 00:43:33,980
But if we combine it with our structure concurrency where we actually decompose some task into
<font color="#0eade1">하지만 실제로 어떤 작업을 다음과 같이 분해하는 구조 동시성과 결합하면</font>

610
00:43:33,980 --> 00:43:42,059
multiple subtasks, you can actually inherit the scope value into all of the subtasks transparently.
<font color="#0eade1">여러 개의 서브 태스크로 분해하면 실제로 모든 서브 태스크에 범위 값을 투명하게 상속할 수 있습니다.</font>

611
00:43:42,059 --> 00:43:43,619
And that's actually really, really nice.
<font color="#0eade1">정말 정말 좋은 기능입니다.</font>

612
00:43:43,619 --> 00:43:48,460
And performance-wise, this is actually better than a thread local.
<font color="#0eade1">성능 측면에서는 실제로 스레드 로컬보다 낫습니다.</font>

613
00:43:48,460 --> 00:43:49,539
It's optimized.
<font color="#0eade1">최적화되었습니다.</font>

614
00:43:49,539 --> 00:43:56,139
The access to a scope value is close to the accessing a field, which is really, really
<font color="#0eade1">범위 값에 대한 액세스는 필드에 액세스하는 것과 비슷합니다.</font>

615
00:43:56,139 --> 00:43:57,139
nice.
<font color="#0eade1">nice.</font>

616
00:43:57,139 --> 00:44:03,139
Now, in terms of status of this API, we're going to need more feedback and real-world
<font color="#0eade1">이제 이 API의 상태와 관련하여 더 많은 피드백과 실제 세계가 필요합니다.</font>

617
00:44:03,139 --> 00:44:05,539
usage before it becomes a permanent API.
<font color="#0eade1">사용량이 더 필요합니다.</font>

618
00:44:05,539 --> 00:44:09,019
So it's likely preview again in 22.
<font color="#0eade1">따라서 22시에 다시 미리보기가 될 가능성이 높습니다.</font>

619
00:44:09,019 --> 00:44:10,980
OK.
<font color="#0eade1">OK.</font>

620
00:44:10,980 --> 00:44:15,259
So overall current status then of where we are with virtual threads.
<font color="#0eade1">가상 스레드에 대한 전반적인 현재 상태입니다.</font>

621
00:44:15,259 --> 00:44:18,219
So as I said, it became a permanent feature in Java 21.
<font color="#0eade1">앞서 말했듯이 자바 21의 영구적인 기능이 되었습니다.</font>

622
00:44:18,219 --> 00:44:22,299
I think overall, it's been very well received by the ecosystem.
<font color="#0eade1">전반적으로 생태계에서 매우 호평을 받고 있다고 생각합니다.</font>

623
00:44:22,299 --> 00:44:30,659
I think there's a lot of interest in going back to simple, maintainable blocking code
<font color="#0eade1">단순하고 유지 관리가 가능한 차단 코드로 돌아가는 것에 많은 관심이 있는 것 같습니다.</font>

624
00:44:30,739 --> 00:44:37,179
just to avoid the more complicated and hard to maintain async type of code.
<font color="#0eade1">더 복잡하고 유지 관리가 어려운 비동기식 코드를 피하기 위해서 말이죠.</font>

625
00:44:37,179 --> 00:44:44,699
Most of the mainstream frameworks have got something working with virtual threads.
<font color="#0eade1">대부분의 주류 프레임워크는 가상 스레드와 함께 작동하는 무언가를 가지고 있습니다.</font>

626
00:44:44,699 --> 00:44:47,899
Some of it mightn't be all that efficient for a first version.
<font color="#0eade1">첫 번째 버전에서는 그다지 효율적이지 않을 수도 있습니다.</font>

627
00:44:47,899 --> 00:44:50,379
There might be a lot of additional handoff going on.
<font color="#0eade1">추가적으로 많은 핸드오프가 진행될 수 있습니다.</font>

628
00:44:50,379 --> 00:44:54,699
But it's nice to have something working on day one.
<font color="#0eade1">그래도 첫날부터 뭔가 작동하는 게 있으니 좋네요.</font>

629
00:44:54,699 --> 00:44:59,899
Overall, the performance has actually been really, really, really good in terms of the
<font color="#0eade1">전반적으로 성능은 실제로 정말, 정말, 정말 좋았습니다.</font>

630
00:45:00,139 --> 00:45:01,139
runtime support.
<font color="#0eade1">런타임 지원.</font>

631
00:45:01,139 --> 00:45:04,260
There's a couple of exceptions that are a little bit problematic, particularly with
<font color="#0eade1">특히 다음과 같이 약간 문제가 되는 몇 가지 예외가 있습니다.</font>

632
00:45:04,260 --> 00:45:06,619
profilers and JVMTI.
<font color="#0eade1">프로파일러와 JVMTI.</font>

633
00:45:06,619 --> 00:45:09,099
That's something that's being worked on.
<font color="#0eade1">작업 중입니다.</font>

634
00:45:09,099 --> 00:45:12,220
Reliability has actually been quite good.
<font color="#0eade1">안정성은 실제로 꽤 좋았어요.</font>

635
00:45:12,220 --> 00:45:15,220
There's been very few issues around that.
<font color="#0eade1">관련 문제도 거의 없었습니다.</font>

636
00:45:15,220 --> 00:45:23,660
The main thing that's coming up is pinning, which this is, of course, not something we
<font color="#0eade1">가장 중요한 것은 고정인데, 물론 이것은 저희가</font>

637
00:45:23,660 --> 00:45:24,660
raced into.
<font color="#0eade1">달려들었죠.</font>

638
00:45:24,779 --> 00:45:34,099
The limitation is that for 21, the synchronization is problematic.
<font color="#0eade1">21의 경우 동기화에 문제가 있다는 한계가 있습니다.</font>

639
00:45:34,099 --> 00:45:39,420
As I said, the other APIs, the Structured Concurrency and Scope Value API, they are
<font color="#0eade1">앞서 말했듯이 다른 API인 구조화된 동시성 및 범위 값 API는 다음과 같습니다.</font>

640
00:45:39,420 --> 00:45:40,899
preview for 21.
<font color="#0eade1">21에 대한 미리보기.</font>

641
00:45:40,899 --> 00:45:43,299
That's the current status of things.
<font color="#0eade1">현재 상태입니다.</font>

642
00:45:43,299 --> 00:45:47,219
Looking forward then, where are we?
<font color="#0eade1">그럼 어디까지 왔죠?</font>

643
00:45:47,219 --> 00:45:50,619
We'll likely do a second preview of the two APIs mentioned.
<font color="#0eade1">앞서 언급한 두 가지 API에 대한 두 번째 프리뷰를 진행할 예정입니다.</font>

644
00:45:50,619 --> 00:45:53,940
We need to get more feedback before we can make them permanent.
<font color="#0eade1">영구화하기 전에 더 많은 피드백이 필요합니다.</font>

645
00:45:54,220 --> 00:45:56,539
There is ongoing work for Java monitors.
<font color="#0eade1">자바 모니터에 대한 작업이 진행 중입니다.</font>

646
00:45:56,539 --> 00:45:58,780
We know that this is actually a pain point.
<font color="#0eade1">이것이 실제로 고충이라는 것을 알고 있습니다.</font>

647
00:45:58,780 --> 00:46:00,260
There's actually two efforts going on.
<font color="#0eade1">실제로 두 가지 작업이 진행 중입니다.</font>

648
00:46:00,260 --> 00:46:05,139
One is the longer term reimplementation of Java monitors.
<font color="#0eade1">하나는 자바 모니터의 장기적인 재구현입니다.</font>

649
00:46:05,139 --> 00:46:08,500
I can't say which release this will actually show up in.
<font color="#0eade1">이것이 실제로 어느 릴리스에 나타날지는 말할 수 없습니다.</font>

650
00:46:08,500 --> 00:46:12,940
This is many person years of work touching many, many areas.
<font color="#0eade1">많은 사람이 수년간 많은 분야에 걸쳐 작업한 결과물입니다.</font>

651
00:46:12,940 --> 00:46:20,820
However, we have a shorter term direction that's currently being worked on, which is
<font color="#0eade1">하지만 현재 작업 중인 단기적인 방향은 다음과 같습니다.</font>

652
00:46:20,940 --> 00:46:27,460
change the existing Java monitors implementation to be more friendly to virtual threads.
<font color="#0eade1">기존 Java 모니터 구현을 가상 스레드에 더 친화적으로 변경하는 것입니다.</font>

653
00:46:27,460 --> 00:46:31,500
This will allow when you're parking while holding a monitor, it allows the carrier to
<font color="#0eade1">이렇게 하면 모니터를 들고 주차할 때 캐리어가</font>

654
00:46:31,500 --> 00:46:32,940
be released.
<font color="#0eade1">이 해제됩니다.</font>

655
00:46:32,940 --> 00:46:36,620
It'll also allow us to deal with the contended case.
<font color="#0eade1">또한 경합 중인 사건을 처리할 수 있습니다.</font>

656
00:46:36,620 --> 00:46:39,180
Contended monitor entry will allow us to release the carrier.
<font color="#0eade1">경합 모니터 진입으로 캐리어를 해제할 수 있습니다.</font>

657
00:46:39,180 --> 00:46:44,059
Then, further along, we want to also try to release the carrier for object at wait.
<font color="#0eade1">그리고 더 나아가 대기 중인 객체에 대해서도 캐리어를 해제하려고 합니다.</font>

658
00:46:44,059 --> 00:46:47,740
The nice thing about this is all these pieces don't actually have to come together.
<font color="#0eade1">이 작업의 좋은 점은 이 모든 조각들이 실제로 함께 모일 필요가 없다는 것입니다.</font>

659
00:46:48,460 --> 00:46:52,460
They can actually be split up a little bit.
<font color="#0eade1">실제로는 약간 분할할 수 있습니다.</font>

660
00:46:52,460 --> 00:46:53,460
This is good.
<font color="#0eade1">이거 좋네요.</font>

661
00:46:53,460 --> 00:46:54,460
This is all very promising.
<font color="#0eade1">매우 유망하군요.</font>

662
00:46:54,460 --> 00:46:57,980
Maybe at some point, we'll actually have some Loom early access builds with this for people
<font color="#0eade1">언젠가는 실제로 이 기능이 포함된 Loom 얼리 액세스 빌드를 사람들에게 제공할 수 있을지도 모르겠네요.</font>

663
00:46:57,980 --> 00:47:01,020
actually to try out.
<font color="#0eade1">실제로 사용해볼 수 있게요.</font>

664
00:47:01,020 --> 00:47:02,700
This is the short term thing.
<font color="#0eade1">이것은 단기적인 것입니다.</font>

665
00:47:02,700 --> 00:47:05,980
The longer term is reimplementation of monitors.
<font color="#0eade1">장기적으로는 모니터 재구현입니다.</font>

666
00:47:05,980 --> 00:47:09,660
There's a whole bunch of things going on at the moment around performance and footprint,
<font color="#0eade1">현재 성능과 설치 공간과 관련하여 많은 일이 일어나고 있습니다,</font>

667
00:47:09,660 --> 00:47:13,700
particularly around compression of stack frames.
<font color="#0eade1">특히 스택 프레임 압축과 관련해서는요.</font>

668
00:47:13,700 --> 00:47:19,300
We've got some scalability issues with timers that we want to work on.
<font color="#0eade1">타이머와 관련된 몇 가지 확장성 문제를 해결해야 합니다.</font>

669
00:47:19,300 --> 00:47:24,260
File IO and some of the operating system integration is something that needs improvement.
<font color="#0eade1">파일 IO와 일부 운영 체제 통합은 개선이 필요한 부분입니다.</font>

670
00:47:24,260 --> 00:47:29,020
Also, JVM TI performance is problematic.
<font color="#0eade1">또한 JVM TI 성능에 문제가 있습니다.</font>

671
00:47:29,020 --> 00:47:34,300
There's also work going on around serviceability.
<font color="#0eade1">서비스 가능성 관련 작업도 진행 중입니다.</font>

672
00:47:34,300 --> 00:47:40,780
A lot of the serviceability budget was spent twice over getting the debugger working with
<font color="#0eade1">서비스 가능성 예산의 상당 부분이 디버거를 작동시키는 데 두 번이나 사용되었습니다.</font>

673
00:47:40,780 --> 00:47:46,220
virtual threads at the cost of or the expense of some of the other serviceability features.
<font color="#0eade1">가상 스레드에 대한 비용 또는 다른 서비스 가능성 기능의 일부를 희생했습니다.</font>

674
00:47:46,220 --> 00:47:50,300
At the moment, thread dumps that include virtual threads don't include lock information, deadlock
<font color="#0eade1">현재 가상 스레드를 포함하는 스레드 덤프에는 잠금 정보, 교착 상태, 데드락이 포함되지 않습니다.</font>

675
00:47:50,300 --> 00:47:51,300
detection.
<font color="#0eade1">감지.</font>

676
00:47:51,300 --> 00:47:52,940
That's not something we need to work on.
<font color="#0eade1">그건 우리가 해결해야 할 문제가 아닙니다.</font>

677
00:47:52,940 --> 00:47:59,460
We need to expose in the more medium long term is better APIs for some of the tooling
<font color="#0eade1">중장기적으로는 일부 툴링에 대해 더 나은 API를 노출해야 합니다.</font>

678
00:47:59,460 --> 00:48:01,580
to be able to enumerate threads.
<font color="#0eade1">스레드를 열거할 수 있도록 수정했습니다.</font>

679
00:48:01,580 --> 00:48:08,700
That's currently what will happen beyond JDK 21.
<font color="#0eade1">이것이 현재 JDK 21 이후에 일어날 일입니다.</font>

680
00:48:08,700 --> 00:48:10,580
Just then, a couple of links.
<font color="#0eade1">바로 그 때, 몇 개의 링크가 있습니다.</font>

681
00:48:11,380 --> 00:48:12,380
The link to the JEP and the adoption guide.
<font color="#0eade1">JEP 및 채택 가이드 링크입니다.</font>

682
00:48:12,380 --> 00:48:15,619
Remember the migration to virtual threads is important.
<font color="#0eade1">가상 스레드로의 마이그레이션이 중요하다는 것을 기억하세요.</font>

683
00:48:15,619 --> 00:48:19,179
Link to the other JEPs and the mailing list.
<font color="#0eade1">다른 JEP와 메일링 리스트에 링크합니다.</font>

684
00:48:19,179 --> 00:48:20,299
That's all I have for now.
<font color="#0eade1">지금은 여기까지입니다.</font>

685
00:48:20,299 --> 00:48:23,299
We have two minutes for questions.
<font color="#0eade1">질문할 시간이 2분 남았습니다.</font>

686
00:48:23,299 --> 00:48:27,139
If anyone wants to shout, then please do.
<font color="#0eade1">외치고 싶은 사람 있으면 외쳐주세요.</font>

687
00:48:27,139 --> 00:48:28,139
Mario.
<font color="#0eade1">마리오.</font>

688
00:48:28,139 --> 00:48:35,139
Can you go back to the structure and concurrency example?
<font color="#0eade1">구조와 동시성 예제로 돌아가 볼까요?</font>

689
00:48:35,139 --> 00:48:36,139
Yeah.
<font color="#0eade1">네</font>

690
00:48:36,139 --> 00:48:37,139
Sorry.
<font color="#0eade1">죄송합니다.</font>

691
00:48:38,139 --> 00:48:44,139
Sorry, where is me?
<font color="#0eade1">미안, 나 어디 있어?</font>

692
00:48:54,139 --> 00:48:55,139
OK.
<font color="#0eade1">OK.</font>

693
00:48:55,139 --> 00:48:56,139
Let's look at this guy.
<font color="#0eade1">이 녀석 좀 보자.</font>

694
00:48:56,139 --> 00:48:57,139
Just to understand if I'm understanding correctly.
<font color="#0eade1">내가 제대로 이해했는지 확인하려고.</font>

695
00:48:57,139 --> 00:49:06,139
This one does the same thing of combining two completable features, right?
<font color="#0eade1">이것도 완성 가능한 두 기능을 결합하는 것과 같은 일을 하는 거죠?</font>

696
00:49:06,139 --> 00:49:09,219
The question is, is this combining,
<font color="#0eade1">문제는 이게 결합이냐는 거죠,</font>

697
00:49:09,219 --> 00:49:11,139
is this a bit like computable futures?
<font color="#0eade1">계산 가능한 선물과 비슷한가요?</font>

698
00:49:11,139 --> 00:49:13,539
And the answer is yes, but more in a synchronous
<font color="#0eade1">대답은 '예'이지만 동기식 선물에 더 가깝습니다.</font>

699
00:49:15,460 --> 00:49:17,299
imperative style, yes.
<font color="#0eade1">명령형 스타일입니다.</font>

700
00:49:17,299 --> 00:49:20,019
Okay, yeah, yeah, sure.
<font color="#0eade1">그래, 그래, 알았어.</font>

701
00:49:20,019 --> 00:49:23,339
I mean, it's easier to rate it, it is the advantage.
<font color="#0eade1">평가하기가 더 쉽다는 게 장점이지.</font>

702
00:49:23,339 --> 00:49:25,739
The effect is the same, but it is easier to rate.
<font color="#0eade1">효과는 같지만 평가하기가 더 쉽습니다.</font>

703
00:49:25,739 --> 00:49:29,139
Right, and so the question is, is the effect the same?
<font color="#0eade1">그래요, 그럼 문제는 효과는 동일하냐는 거죠?</font>

704
00:49:29,139 --> 00:49:30,980
Yes, but there's some cleanup situations
<font color="#0eade1">네, 하지만 몇 가지 정리 상황이 있습니다.</font>

705
00:49:30,980 --> 00:49:34,739
which are problematic with computable future.
<font color="#0eade1">계산 가능한 미래에 문제가 있습니다.</font>

706
00:49:34,739 --> 00:49:35,659
Sorry, there was a question here.
<font color="#0eade1">죄송합니다, 여기에 질문이 있습니다.</font>

707
00:49:35,659 --> 00:49:37,619
It's hard for me to actually see hands.
<font color="#0eade1">실제로 손이 잘 안 보여요.</font>

708
00:49:39,219 --> 00:49:40,059
Which exception did you get?
<font color="#0eade1">어떤 예외를 얻었나요?</font>

709
00:49:40,059 --> 00:49:41,619
Did you get the original exception
<font color="#0eade1">원래 예외를 얻었습니까?</font>

710
00:49:41,619 --> 00:49:43,859
or did you get the wrapped?
<font color="#0eade1">아니면 포장된 것을 얻었나요?</font>

711
00:49:43,859 --> 00:49:45,940
Okay, so the question is, is what exception
<font color="#0eade1">좋아, 그럼 문제는 어떤 예외가</font>

712
00:49:45,940 --> 00:49:47,500
is thrown here by throw of failed?
<font color="#0eade1">에 의해 여기에 던져지는 예외가 무엇일까요?</font>

713
00:49:47,500 --> 00:49:49,299
And in this particular method,
<font color="#0eade1">그리고 이 특정 메서드에서는</font>

714
00:49:49,299 --> 00:49:50,619
it's actually a wrapped exception.
<font color="#0eade1">실제로는 래핑된 예외입니다.</font>

715
00:49:50,619 --> 00:49:52,059
It's an execution exception
<font color="#0eade1">실행 예외입니다.</font>

716
00:49:52,059 --> 00:49:53,940
that actually wraps the original exception.
<font color="#0eade1">이 원래 예외를 실제로 감싸고 있습니다.</font>

717
00:49:53,940 --> 00:49:55,859
There's variations of this throw of failed,
<font color="#0eade1">이 실패의 변형이 있습니다,</font>

718
00:49:55,859 --> 00:49:57,379
which actually gives you the original exception,
<font color="#0eade1">실제로는 원래의 예외를 제공합니다,</font>

719
00:49:57,379 --> 00:49:58,420
allows you to map it.
<font color="#0eade1">를 매핑할 수 있습니다.</font>

720
00:49:58,420 --> 00:50:01,500
You can actually map it to itself if you want.
<font color="#0eade1">원한다면 실제로 자체에 매핑할 수 있습니다.</font>

721
00:50:01,500 --> 00:50:03,299
And so you have flexibility
<font color="#0eade1">따라서 유연성이 있습니다.</font>

722
00:50:03,299 --> 00:50:05,179
on how exceptions are propagated.
<font color="#0eade1">예외가 전파되는 방식에 대해 설명합니다.</font>

723
00:50:05,659 --> 00:50:06,500
Thank you.
<font color="#0eade1">고마워요.</font>

724
00:50:12,500 --> 00:50:13,940
There are a couple of instances you mentioned
<font color="#0eade1">언급하신 몇 가지 사례가 있습니다.</font>

725
00:50:13,940 --> 00:50:16,899
about the synchronized method of increment throw
<font color="#0eade1">증분 던지기의 동기화된 메서드에 대해</font>

726
00:50:16,899 --> 00:50:21,899
where the virtual thread gets the carrier thread.
<font color="#0eade1">여기서 가상 스레드가 캐리어 스레드를 가져옵니다.</font>

727
00:50:22,659 --> 00:50:23,940
There's also one more event
<font color="#0eade1">이벤트가 하나 더 있습니다.</font>

728
00:50:23,940 --> 00:50:27,739
which is capturing of the platform thread.
<font color="#0eade1">플랫폼 스레드 캡처입니다.</font>

729
00:50:27,739 --> 00:50:29,139
I know that for synchronized method,
<font color="#0eade1">동기화된 메소드의 경우</font>

730
00:50:29,139 --> 00:50:29,980
there is some work going on,
<font color="#0eade1">작업이 진행 중입니다,</font>

731
00:50:29,980 --> 00:50:33,339
so you don't have to worry about the synchronization method.
<font color="#0eade1">따라서 동기화 방법에 대해 걱정할 필요가 없습니다.</font>

732
00:50:33,980 --> 00:50:36,660
What is that one for, capturing?
<font color="#0eade1">저건 뭐야, 캡처?</font>

733
00:50:38,620 --> 00:50:40,740
Okay, so the question was,
<font color="#0eade1">좋아, 질문은,</font>

734
00:50:40,740 --> 00:50:42,180
is there's work going on in synchronized?
<font color="#0eade1">동기화에서 작업이 진행 중인가요?</font>

735
00:50:42,180 --> 00:50:43,140
Is there other work going on
<font color="#0eade1">다른 작업이 진행 중입니까?</font>

736
00:50:43,140 --> 00:50:45,700
around capturing a platform thread?
<font color="#0eade1">플랫폼 스레드 캡처와 관련된 다른 작업이 진행 중인가요?</font>

737
00:50:46,900 --> 00:50:50,740
Okay, I'm not quite sure what you mean by that.
<font color="#0eade1">무슨 뜻인지 잘 모르겠는데요.</font>

738
00:50:50,740 --> 00:50:51,660
I think we're out of time,
<font color="#0eade1">시간이 다 된 것 같아,</font>

739
00:50:51,660 --> 00:50:54,019
but if you come up, I'll deal with it here.
<font color="#0eade1">네가 올라오면 내가 여기서 처리할게.</font>

740
00:50:55,260 --> 00:50:56,100
Thank you.
<font color="#0eade1">고마워요.</font>

741
00:50:56,100 --> 00:50:56,940
Thank you.
<font color="#0eade1">고마워요.</font>

742
00:50:56,940 --> 00:50:57,780
Thank you.
<font color="#0eade1">고마워요.</font>

743
00:50:57,780 --> 00:50:58,620
Thank you.
<font color="#0eade1">고마워요.</font>

744
00:50:58,620 --> 00:50:59,460
Thank you.
<font color="#0eade1">고마워요.</font>

745
00:50:59,460 --> 00:51:00,300
Thank you.
<font color="#0eade1">고마워요.</font>

746
00:51:00,300 --> 00:51:01,140
Thank you.
<font color="#0eade1">고마워요.</font>

747
00:51:01,140 --> 00:51:01,980
Thank you.
<font color="#0eade1">고마워요.</font>

748
00:51:01,980 --> 00:51:02,820
Thank you.
<font color="#0eade1">고마워요.</font>

749
00:51:03,340 --> 00:51:04,180
Thank you.
<font color="#0eade1">고마워요.</font>

750
00:51:04,180 --> 00:51:05,019
Thank you.
<font color="#0eade1">고마워요.</font>

751
00:51:05,019 --> 00:51:05,860
Thank you.
<font color="#0eade1">고마워요.</font>

752
00:51:05,860 --> 00:51:06,700
Thank you.
<font color="#0eade1">고마워요.</font>

753
00:51:06,700 --> 00:51:07,539
Thank you.
<font color="#0eade1">고마워요.</font>

754
00:51:07,539 --> 00:51:08,380
Thank you.
<font color="#0eade1">고마워요.</font>

755
00:51:08,380 --> 00:51:09,220
Thank you.
<font color="#0eade1">고마워요.</font>

756
00:51:09,220 --> 00:51:10,059
Thank you.
<font color="#0eade1">고마워요.</font>

757
00:51:10,059 --> 00:51:10,900
Thank you.
<font color="#0eade1">고마워요.</font>

758
00:51:10,900 --> 00:51:11,740
Thank you.
<font color="#0eade1">고마워요.</font>

759
00:51:11,740 --> 00:51:12,539
Thank you.
<font color="#0eade1">고마워요.</font>

760
00:51:12,539 --> 00:51:13,380
Thank you.
<font color="#0eade1">고마워요.</font>

761
00:51:13,380 --> 00:51:14,220
Thank you.
<font color="#0eade1">고마워요.</font>

762
00:51:14,220 --> 00:51:15,059
Thank you.
<font color="#0eade1">고마워요.</font>

763
00:51:15,059 --> 00:51:15,900
Thank you.
<font color="#0eade1">고마워요.</font>

764
00:51:15,900 --> 00:51:16,740
Thank you.
<font color="#0eade1">고마워요.</font>

765
00:51:16,740 --> 00:51:17,580
Thank you.
<font color="#0eade1">고마워요.</font>

766
00:51:17,580 --> 00:51:18,420
Thank you.
<font color="#0eade1">고마워요.</font>

767
00:51:18,420 --> 00:51:19,260
Thank you.
<font color="#0eade1">고마워요.</font>

768
00:51:19,260 --> 00:51:20,100
Thank you.
<font color="#0eade1">고마워요.</font>

769
00:51:20,100 --> 00:51:20,940
Thank you.
<font color="#0eade1">고마워요.</font>

770
00:51:20,940 --> 00:51:21,780
Thank you.
<font color="#0eade1">고마워요.</font>

771
00:51:21,780 --> 00:51:22,620
Thank you.
<font color="#0eade1">고마워요.</font>

772
00:51:22,620 --> 00:51:23,460
Thank you.
<font color="#0eade1">고마워요.</font>

773
00:51:23,460 --> 00:51:24,300
Thank you.
<font color="#0eade1">고마워요.</font>

774
00:51:24,300 --> 00:51:25,140
Thank you.
<font color="#0eade1">고마워요.</font>

775
00:51:25,140 --> 00:51:25,980
Thank you.
<font color="#0eade1">고마워요.</font>

776
00:51:25,980 --> 00:51:26,820
Thank you.
<font color="#0eade1">고마워요.</font>

777
00:51:26,820 --> 00:51:27,660
Thank you.
<font color="#0eade1">고마워요.</font>

778
00:51:27,660 --> 00:51:28,500
Thank you.
<font color="#0eade1">고마워요.</font>

779
00:51:28,500 --> 00:51:29,340
Thank you.
<font color="#0eade1">고마워요.</font>

780
00:51:29,340 --> 00:51:30,180
Thank you.
<font color="#0eade1">고마워요.</font>

781
00:51:30,180 --> 00:51:31,019
Thank you.
<font color="#0eade1">고마워요.</font>

782
00:51:31,019 --> 00:51:31,860
Thank you.
<font color="#0eade1">고마워요.</font>
