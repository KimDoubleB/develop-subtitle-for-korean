1
00:00:00,000 --> 00:00:12,280
All right, welcome everybody.

2
00:00:00,000 --> 00:00:12,280
<font color="#ffff54">자, 모두 환영합니다.</font>

3
00:00:12,280 --> 00:00:17,920
So today I want to talk about one of the newer projects going on in OpenJDK.

4
00:00:12,280 --> 00:00:17,920
<font color="#ffff54">오늘은 OpenJDK에서 진행 중인 새로운 프로젝트 중 하나에 대해 이야기하고 싶습니다.</font>

5
00:00:17,920 --> 00:00:22,800
At the keynote this morning, you know, I showed a long list of projects, Loom, Panama, Valhalla,

6
00:00:17,920 --> 00:00:22,800
<font color="#ffff54">오늘 아침 기조연설에서 Loom, Panama, Valhalla 등 많은 프로젝트 목록을 보여드렸습니다,</font>

7
00:00:22,800 --> 00:00:23,800
Babylon.

8
00:00:22,800 --> 00:00:23,800
<font color="#ffff54">바빌론.</font>

9
00:00:23,800 --> 00:00:28,060
And Leiden is one of the newer projects we started working on it maybe six months ago

10
00:00:23,800 --> 00:00:28,060
<font color="#ffff54">라이덴은 약 6개월 전에 시작한 새로운 프로젝트 중 하나입니다.</font>

11
00:00:28,060 --> 00:00:35,020
or so, which is aimed at improving startup and warm-up of Java applications.

12
00:00:28,060 --> 00:00:35,020
<font color="#ffff54">정도이며, Java 애플리케이션의 시작 및 워밍업을 개선하는 데 목적이 있습니다.</font>

13
00:00:35,020 --> 00:00:42,340
So to define our terms a little bit, what is startup and what is warm-up?

14
00:00:35,020 --> 00:00:42,340
<font color="#ffff54">용어를 조금 정의하자면, 스타트업과 웜업이란 무엇일까요?</font>

15
00:00:42,340 --> 00:00:47,460
Startup is the amount of time it takes to get to the first useful unit of work.

16
00:00:42,340 --> 00:00:47,460
<font color="#ffff54">시작은 첫 번째 유용한 작업 단위에 도달하는 데 걸리는 시간입니다.</font>

17
00:00:47,460 --> 00:00:53,020
Warm-up is the time it takes for an application to reach peak performance.

18
00:00:47,460 --> 00:00:53,020
<font color="#ffff54">워밍업은 애플리케이션이 최고 성능에 도달하는 데 걸리는 시간입니다.</font>

19
00:00:53,020 --> 00:01:03,020
So both of these things include a mix of activities, both work that is done by an application

20
00:00:53,020 --> 00:01:03,020
<font color="#ffff54">따라서 이 두 가지 모두 애플리케이션이 수행하는 여러 가지 작업이 혼합되어 있습니다.</font>

21
00:01:03,020 --> 00:01:05,560
and work that is done on behalf of an application.

22
00:01:03,020 --> 00:01:05,560
<font color="#ffff54">그리고 애플리케이션을 대신하여 수행되는 작업.</font>

23
00:01:05,560 --> 00:01:10,379
So if you have a typical server application, when it starts up, it's going to go through

24
00:01:05,560 --> 00:01:10,379
<font color="#ffff54">따라서 일반적인 서버 애플리케이션이 있다면, 애플리케이션이 시작될 때 다음과 같은 과정을 거치게 됩니다.</font>

25
00:01:10,379 --> 00:01:16,579
the usual parse the configuration file, open some sockets, create listeners, create loggers,

26
00:01:10,379 --> 00:01:16,579
<font color="#ffff54">구성 파일을 파싱하고, 소켓을 열고, 리스너를 생성하고, 로거를 생성하는 일반적인 과정을 거칩니다,</font>

27
00:01:16,579 --> 00:01:19,659
create more loggers, create a lot of loggers.

28
00:01:16,579 --> 00:01:19,659
<font color="#ffff54">더 많은 로거를 생성하고, 많은 로거를 생성합니다.</font>

29
00:01:19,979 --> 00:01:23,219
And that is work that is done by the application.

30
00:01:19,979 --> 00:01:23,219
<font color="#ffff54">그리고 이것은 애플리케이션이 하는 일입니다.</font>

31
00:01:23,219 --> 00:01:29,659
At the same time, the JVM is doing work on behalf of the application.

32
00:01:23,219 --> 00:01:29,659
<font color="#ffff54">동시에 JVM은 애플리케이션을 대신하여 작업을 수행하고 있습니다.</font>

33
00:01:29,659 --> 00:01:36,900
It's loading classes, it's validating class files, it's jitting classes, it's resolving

34
00:01:29,659 --> 00:01:36,900
<font color="#ffff54">클래스를 로드하고, 클래스 파일의 유효성을 검사하고, 클래스를 지팅하고, 해결하고 있습니다.</font>

35
00:01:36,900 --> 00:01:43,659
constant pool entries, it's symbolically linking call sites, things like that.

36
00:01:36,900 --> 00:01:43,659
<font color="#ffff54">상수 풀 항목, 호출 사이트 등을 상징적으로 연결하고 있습니다.</font>

37
00:01:43,659 --> 00:01:48,379
And startup and warm-up are an issue for some Java applications, not for all.

38
00:01:43,659 --> 00:01:48,379
<font color="#ffff54">그리고 시작 및 워밍업은 일부 Java 애플리케이션의 문제이지 모든 애플리케이션의 문제는 아닙니다.</font>

39
00:01:49,179 --> 00:01:54,099
I want to talk first a little bit about where these issues come from, if they are issues,

40
00:01:49,179 --> 00:01:54,099
<font color="#ffff54">먼저 이러한 문제가 발생하는 원인에 대해 조금 이야기하고 싶습니다,</font>

41
00:01:54,099 --> 00:01:59,259
and then what we're doing to offer a range of choices to make it better.

42
00:01:54,099 --> 00:01:59,259
<font color="#ffff54">그리고 이를 개선하기 위해 다양한 선택지를 제공하기 위해 우리가 무엇을 하고 있는지에 대해 이야기하고 싶습니다.</font>

43
00:01:59,259 --> 00:02:03,539
The main reason why startup and warm-up are an issue for Java applications is because

44
00:01:59,259 --> 00:02:03,539
<font color="#ffff54">Java 애플리케이션에서 시작 및 워밍업이 문제가 되는 주된 이유는 다음과 같습니다.</font>

45
00:02:03,539 --> 00:02:06,979
of Java's dynamism.

46
00:02:03,539 --> 00:02:06,979
<font color="#ffff54">자바의 역동성 때문입니다.</font>

47
00:02:06,979 --> 00:02:13,180
And some of you are thinking, probably, wait a second, I thought Java was a static language.

48
00:02:06,979 --> 00:02:13,180
<font color="#ffff54">잠깐만요, 자바는 정적인 언어인 줄 알았는데요, 라고 생각하시는 분들도 계실 겁니다.</font>

49
00:02:13,180 --> 00:02:17,259
So I want to talk about the terms static and dynamic because they're frequently misused

50
00:02:13,180 --> 00:02:17,259
<font color="#ffff54">그래서 정적과 동적이라는 용어가 자주 오용되기 때문에 이 용어에 대해 이야기하고 싶습니다.</font>

51
00:02:17,259 --> 00:02:19,139
and abused.

52
00:02:17,259 --> 00:02:19,139
<font color="#ffff54">남용되고 있습니다.</font>

53
00:02:19,139 --> 00:02:22,419
And they mean a lot of different things in different contexts.

54
00:02:19,139 --> 00:02:22,419
<font color="#ffff54">이 단어들은 서로 다른 맥락에서 다양한 의미를 지니고 있습니다.</font>

55
00:02:22,419 --> 00:02:26,340
So I'm going to start with a very simplistic notion of static versus dynamic, which is

56
00:02:22,419 --> 00:02:26,340
<font color="#ffff54">그래서 저는 정적과 동적에 대한 아주 단순한 개념으로 시작하겠습니다.</font>

57
00:02:26,340 --> 00:02:30,819
wrong but we'll get to something better, where let's assume that static means at compile

58
00:02:26,340 --> 00:02:30,819
<font color="#ffff54">잘못되었지만 더 나은 것을 얻게 될 것입니다, 여기서 정적은 컴파일 시점에</font>

59
00:02:30,819 --> 00:02:33,780
time and dynamic means at runtime.

60
00:02:30,819 --> 00:02:33,780
<font color="#ffff54">시간, 동적은 런타임을 의미한다고 가정해봅시다.</font>

61
00:02:33,780 --> 00:02:37,519
Like I said, not a good starting assumption, but we have to start somewhere.

62
00:02:33,780 --> 00:02:37,519
<font color="#ffff54">앞서 말했듯이 좋은 출발점은 아니지만 어디선가 시작해야 합니다.</font>

63
00:02:37,519 --> 00:02:44,739
So the question I would ask is, is Java statically typed or dynamically typed?

64
00:02:37,519 --> 00:02:44,739
<font color="#ffff54">제가 묻고 싶은 질문은 자바가 정적 타입인가, 동적 타입인가 하는 것입니다.</font>

65
00:02:44,740 --> 00:02:49,260
The answer is yes.

66
00:02:44,740 --> 00:02:49,260
<font color="#ffff54">정답은 '예'입니다.</font>

67
00:02:49,260 --> 00:02:53,219
The answer is Java is both statically typed and dynamically typed.

68
00:02:49,260 --> 00:02:53,219
<font color="#ffff54">정답은 Java는 정적 타입과 동적 타입 모두입니다.</font>

69
00:02:53,219 --> 00:02:59,700
So Java has a static type system that's enforced by the compiler, and it has various rules

70
00:02:53,219 --> 00:02:59,700
<font color="#ffff54">따라서 Java에는 컴파일러에 의해 강제되는 정적 유형 시스템이 있으며 다양한 규칙이 있습니다.</font>

71
00:02:59,700 --> 00:03:04,900
about conversion and overload selection and such.

72
00:02:59,700 --> 00:03:04,900
<font color="#ffff54">변환과 과부하 선택 등에 관한 규칙이 있습니다.</font>

73
00:03:04,900 --> 00:03:09,780
Java also has a dynamic type system, which is enforced at runtime by the JVM.

74
00:03:04,900 --> 00:03:09,780
<font color="#ffff54">Java에는 런타임에 JVM에 의해 강제 적용되는 동적 유형 시스템도 있습니다.</font>

75
00:03:10,300 --> 00:03:17,259
The two have a lot in common in both the static and dynamic type systems.

76
00:03:10,300 --> 00:03:17,259
<font color="#ffff54">정적 타입 시스템과 동적 타입 시스템 모두 공통점이 많습니다.</font>

77
00:03:17,259 --> 00:03:21,879
String is a subtype of object, but they also have significant differences.

78
00:03:17,259 --> 00:03:21,879
<font color="#ffff54">문자열은 객체의 하위 유형이지만 상당한 차이점도 있습니다.</font>

79
00:03:21,879 --> 00:03:27,539
And it's not that one is a pure subset of the other, although in general the dynamic

80
00:03:21,879 --> 00:03:27,539
<font color="#ffff54">그리고 일반적으로 둘 중 하나가 다른 하나의 순수한 하위 집합은 아니지만, 일반적으로 동적인</font>

81
00:03:27,539 --> 00:03:31,319
type system tends to be weaker than the static type system.

82
00:03:27,539 --> 00:03:31,319
<font color="#ffff54">타입 시스템은 정적 타입 시스템보다 약한 경향이 있습니다.</font>

83
00:03:31,319 --> 00:03:33,219
And that's true across a lot of languages.

84
00:03:31,319 --> 00:03:33,219
<font color="#ffff54">이는 많은 언어에서 마찬가지입니다.</font>

85
00:03:33,219 --> 00:03:37,800
But for example, some things that are part of the static type system that are not part

86
00:03:33,219 --> 00:03:37,800
<font color="#ffff54">하지만 예를 들어 정적 타입 시스템의 일부이지만 일부가 아닌 것들도 있습니다.</font>

87
00:03:37,840 --> 00:03:42,420
of the dynamic type system are things like generics.

88
00:03:37,840 --> 00:03:42,420
<font color="#ffff54">동적 타입 시스템의 일부가 아닌 것들은 제네릭과 같은 것들입니다.</font>

89
00:03:42,420 --> 00:03:48,000
We type check generics at compile time, and then we erase them away.

90
00:03:42,420 --> 00:03:48,000
<font color="#ffff54">컴파일 시 제네릭을 타입 검사한 다음 지워버립니다.</font>

91
00:03:48,000 --> 00:03:52,320
The check-ed-ness of exceptions also happens to be something erased away at compilation

92
00:03:48,000 --> 00:03:52,320
<font color="#ffff54">예외를 검사하는 것도 컴파일 시에 지워집니다.</font>

93
00:03:52,320 --> 00:03:53,320
time.

94
00:03:52,320 --> 00:03:53,320
<font color="#ffff54">시간.</font>

95
00:03:53,320 --> 00:03:54,840
Not everybody's aware of that.

96
00:03:53,320 --> 00:03:54,840
<font color="#ffff54">모두가 알고 있는 것은 아닙니다.</font>

97
00:03:54,840 --> 00:03:57,960
Definite assignment analysis is part of the static type system.

98
00:03:54,840 --> 00:03:57,960
<font color="#ffff54">정적 할당 분석은 정적 유형 시스템의 일부입니다.</font>

99
00:03:57,960 --> 00:04:04,320
So Java requires that you initialize a local variable before you use it.

100
00:03:57,960 --> 00:04:04,320
<font color="#ffff54">따라서 Java에서는 지역 변수를 사용하기 전에 반드시 초기화해야 합니다.</font>

101
00:04:04,319 --> 00:04:08,519
The JVM doesn't enforce that, but the compiler does.

102
00:04:04,319 --> 00:04:08,519
<font color="#ffff54">JVM은 이를 강제하지 않지만 컴파일러는 강제합니다.</font>

103
00:04:08,519 --> 00:04:13,919
Overload resolution is another of what we call language fictions, which is checked at

104
00:04:08,519 --> 00:04:13,919
<font color="#ffff54">과부하 해결은 우리가 언어의 허구라고 부르는 또 다른 문제이며, 다음에서 확인됩니다.</font>

105
00:04:13,919 --> 00:04:17,620
compile time and then ignored thereafter.

106
00:04:13,919 --> 00:04:17,620
<font color="#ffff54">컴파일 시간에 검사되고 그 이후에는 무시됩니다.</font>

107
00:04:17,620 --> 00:04:21,800
On the other hand, there are aspects of the dynamic type system that are not part of the

108
00:04:17,620 --> 00:04:21,800
<font color="#ffff54">반면에, 동적 타입 시스템에서는</font>

109
00:04:21,800 --> 00:04:22,959
static type system.

110
00:04:21,800 --> 00:04:22,959
<font color="#ffff54">정적 유형 시스템.</font>

111
00:04:22,959 --> 00:04:26,399
The best example of that is array store exception.

112
00:04:22,959 --> 00:04:26,399
<font color="#ffff54">가장 좋은 예는 배열 저장소 예외입니다.</font>

113
00:04:26,399 --> 00:04:34,639
So if I have an array that is an object array, and I go to store a string in it using the

114
00:04:26,399 --> 00:04:34,639
<font color="#ffff54">예를 들어 객체 배열인 배열이 있고 그 배열에 문자열을 저장하려고 하면</font>

115
00:04:34,639 --> 00:04:41,519
ASTORE bytecode, I may get an array store exception.

116
00:04:34,639 --> 00:04:41,519
<font color="#ffff54">ASTORE 바이트코드를 사용하면 배열 저장소 예외가 발생할 수 있습니다.</font>

117
00:04:41,519 --> 00:04:45,879
And the reason is that object array might actually be an array of integers.

118
00:04:41,519 --> 00:04:45,879
<font color="#ffff54">그 이유는 객체 배열이 실제로 정수의 배열일 수 있기 때문입니다.</font>

119
00:04:45,879 --> 00:04:49,120
It may be an integer array because arrays are covariant in Java.

120
00:04:45,879 --> 00:04:49,120
<font color="#ffff54">자바에서 배열은 공변량이기 때문에 정수 배열일 수 있습니다.</font>

121
00:04:49,120 --> 00:04:53,239
So I can cast an integer array to an object array, and then if I try to put a string into

122
00:04:49,120 --> 00:04:53,239
<font color="#ffff54">따라서 정수 배열을 객체 배열로 형변환한 다음 문자열을 넣으려고 하면</font>

123
00:04:53,240 --> 00:04:57,040
the array, the runtime will say, no, you can't do that.

124
00:04:53,240 --> 00:04:57,040
<font color="#ffff54">배열에 문자열을 넣으려고 하면 런타임이 '안 됩니다'라고 말합니다.</font>

125
00:04:57,040 --> 00:05:03,280
So this is all a long-winded way of saying that even the simplistic notion of static

126
00:04:57,040 --> 00:05:03,280
<font color="#ffff54">이 모든 것은 정적이라는 단순한 개념조차도 장황하게 설명한 것입니다.</font>

127
00:05:03,280 --> 00:05:09,199
and dynamic are about compile time versus runtime, and that static and dynamic are only

128
00:05:03,280 --> 00:05:09,199
<font color="#ffff54">와 동적은 컴파일 시간 대 런타임에 관한 것이고, 정적과 동적은 단지</font>

129
00:05:09,199 --> 00:05:16,360
about typing, even with these simplistic assumptions, Java doesn't fit neatly into a category of

130
00:05:09,199 --> 00:05:16,360
<font color="#ffff54">이러한 단순한 가정에도 불구하고, 자바는 다음과 같은 범주에 깔끔하게 들어맞지 않습니다.</font>

131
00:05:16,360 --> 00:05:18,280
static or dynamic.

132
00:05:16,360 --> 00:05:18,280
<font color="#ffff54">정적 또는 동적.</font>

133
00:05:18,280 --> 00:05:23,360
So let's backpedal on some of these assumptions.

134
00:05:18,280 --> 00:05:23,360
<font color="#ffff54">이제 몇 가지 가정을 다시 살펴봅시다.</font>

135
00:05:23,360 --> 00:05:29,960
Now whenever you get confused about the meaning of terms, it's always a good idea to look

136
00:05:23,360 --> 00:05:29,960
<font color="#ffff54">이제 용어의 의미가 헷갈릴 때마다 항상 다음을 살펴보는 것이 좋습니다.</font>

137
00:05:29,960 --> 00:05:31,240
in the dictionary.

138
00:05:29,960 --> 00:05:31,240
<font color="#ffff54">를 사전에서 찾아보세요.</font>

139
00:05:31,240 --> 00:05:40,920
So if you look up static and dynamic, for static you get a lot of words about at rest,

140
00:05:31,240 --> 00:05:40,920
<font color="#ffff54">정적과 동적을 찾아보면, 정적의 경우 정지 상태에 대한 단어가 많이 나옵니다,</font>

141
00:05:40,920 --> 00:05:46,520
without motion, in equilibrium, showing little change.

142
00:05:40,920 --> 00:05:46,520
<font color="#ffff54">움직임이 없고, 평형 상태이며, 변화가 거의 없습니다.</font>

143
00:05:46,519 --> 00:05:52,159
For dynamic, you see a lot of definitions that talk about marked by change, marked by

144
00:05:46,519 --> 00:05:52,159
<font color="#ffff54">동적의 경우, 다음과 같이 변화로 표시되는 것에 대해 이야기하는 많은 정의를 볼 수 있습니다.</font>

145
00:05:52,159 --> 00:05:57,240
a productive activity, energetic, forceful, changing, et cetera.

146
00:05:52,159 --> 00:05:57,240
<font color="#ffff54">생산적인 활동, 활기찬, 힘찬, 변화하는 등등.</font>

147
00:05:57,240 --> 00:06:03,919
So we sort of have a general idea here that the distinction between static and dynamic

148
00:05:57,240 --> 00:06:03,919
<font color="#ffff54">그래서 우리는 정적인 것과 동적인 것을 구분하는 일반적인 아이디어를 가지고 있습니다.</font>

149
00:06:03,919 --> 00:06:05,799
is changing versus unchanging.

150
00:06:03,919 --> 00:06:05,799
<font color="#ffff54">는 변화하는 것과 변하지 않는 것입니다.</font>

151
00:06:05,799 --> 00:06:08,120
So let's run with that.

152
00:06:05,799 --> 00:06:08,120
<font color="#ffff54">그럼 실행해 봅시다.</font>

153
00:06:08,120 --> 00:06:11,199
And there's a couple of aspects here that we want to tease apart.

154
00:06:08,120 --> 00:06:11,199
<font color="#ffff54">여기서 몇 가지 살펴보고 싶은 부분이 있습니다.</font>

155
00:06:11,199 --> 00:06:15,479
One is, well, what is actually changing?

156
00:06:11,199 --> 00:06:15,479
<font color="#ffff54">하나는, 실제로 무엇이 바뀌고 있는가?</font>

157
00:06:15,480 --> 00:06:20,879
And in the context when we talk about languages being static or dynamic, we tend to think

158
00:06:15,480 --> 00:06:20,879
<font color="#ffff54">그리고 언어가 정적인지 동적인지에 대해 이야기할 때, 우리는 다음과 같이 생각하는 경향이 있습니다.</font>

159
00:06:20,879 --> 00:06:23,280
of this strictly in terms of typing.

160
00:06:20,879 --> 00:06:23,280
<font color="#ffff54">엄격하게 타이핑의 관점에서만 생각하는 경향이 있습니다.</font>

161
00:06:23,280 --> 00:06:26,319
Java is statically typed, Python is dynamically typed.

162
00:06:23,280 --> 00:06:26,319
<font color="#ffff54">자바는 정적 타입이고, 파이썬은 동적 타입입니다.</font>

163
00:06:26,319 --> 00:06:31,379
But in fact, there are many, many other axes of static versus dynamic that languages and

164
00:06:26,319 --> 00:06:31,379
<font color="#ffff54">하지만 사실 정적 대 동적의 다른 많은 축이 있으며 언어와</font>

165
00:06:31,379 --> 00:06:34,560
runtimes might engage in.

166
00:06:31,379 --> 00:06:34,560
<font color="#ffff54">런타임이 관여할 수 있습니다.</font>

167
00:06:34,560 --> 00:06:40,939
So for example, Java has, as I just talked about, dynamic typing.

168
00:06:34,560 --> 00:06:40,939
<font color="#ffff54">예를 들어 Java에는 방금 말씀드린 것처럼 동적 타이핑이 있습니다.</font>

169
00:06:40,939 --> 00:06:48,259
It also has dynamic class loading, dynamic class verification, dynamic class redefinition,

170
00:06:40,939 --> 00:06:48,259
<font color="#ffff54">또한 동적 클래스 로딩, 동적 클래스 검증, 동적 클래스 재정의도 있습니다,</font>

171
00:06:48,259 --> 00:06:54,860
dynamic compilation, which we call JIT compilation, dynamic recompilation, which we call deoptimization.

172
00:06:48,259 --> 00:06:54,860
<font color="#ffff54">동적 컴파일(JIT 컴파일), 동적 재컴파일(디옵티마이제이션)이 있습니다.</font>

173
00:06:54,860 --> 00:07:01,899
This is where we may have JIT compiled a class, and then for whatever reason, the VM decides,

174
00:06:54,860 --> 00:07:01,899
<font color="#ffff54">이 시점에서 JIT 컴파일을 통해 클래스를 컴파일한 후 어떤 이유로든 VM이 결정할 수 있습니다,</font>

175
00:07:01,899 --> 00:07:03,500
I don't like that compilation.

176
00:07:01,899 --> 00:07:03,500
<font color="#ffff54">컴파일이 마음에 들지 않습니다.</font>

177
00:07:03,500 --> 00:07:07,779
I want to throw it away and change it.

178
00:07:03,500 --> 00:07:07,779
<font color="#ffff54">버리고 바꾸고 싶어요.</font>

179
00:07:07,780 --> 00:07:13,060
So what happens is we evict the compiled code from the code cache, go back to the interpreter,

180
00:07:07,780 --> 00:07:13,060
<font color="#ffff54">그래서 컴파일된 코드를 코드 캐시에서 내보내고 인터프리터로 돌아갑니다,</font>

181
00:07:13,060 --> 00:07:16,500
and maybe recompile later.

182
00:07:13,060 --> 00:07:16,500
<font color="#ffff54">그리고 나중에 다시 컴파일합니다.</font>

183
00:07:16,500 --> 00:07:19,920
Call sites and field accesses in Java are dynamically linked.

184
00:07:16,500 --> 00:07:19,920
<font color="#ffff54">Java에서 호출 사이트와 필드 액세스가 동적으로 연결됩니다.</font>

185
00:07:19,920 --> 00:07:26,180
What that means is the first time client code calls a method in another class, there's a

186
00:07:19,920 --> 00:07:26,180
<font color="#ffff54">즉, 클라이언트 코드가 다른 클래스의 메서드를 처음 호출할 때</font>

187
00:07:26,180 --> 00:07:31,580
bunch of activity for, OK, what method are you actually calling?

188
00:07:26,180 --> 00:07:31,580
<font color="#ffff54">에 대한 많은 활동이 발생하는데, 실제로 어떤 메서드를 호출하는 걸까요?</font>

189
00:07:31,580 --> 00:07:36,780
And this involves comparing strings for field and method descriptors.

190
00:07:31,580 --> 00:07:36,780
<font color="#ffff54">여기에는 필드와 메서드 설명자에 대한 문자열 비교가 포함됩니다.</font>

191
00:07:36,780 --> 00:07:39,660
It only happens on the first call thereafter.

192
00:07:36,780 --> 00:07:39,660
<font color="#ffff54">이후 첫 번째 호출에서만 발생합니다.</font>

193
00:07:39,660 --> 00:07:44,620
The linkage information is cached, so it's not as slow as it sounds.

194
00:07:39,660 --> 00:07:44,620
<font color="#ffff54">연결 정보가 캐시되어 있기 때문에 생각보다 느리지 않습니다.</font>

195
00:07:44,620 --> 00:07:51,500
But we do linkage dynamically, and that is what enables us to take a jar and drop a new

196
00:07:44,620 --> 00:07:51,500
<font color="#ffff54">하지만 우리는 동적으로 연결하기 때문에 항아리를 가져다가 새로운</font>

197
00:07:51,500 --> 00:07:55,620
jar onto the class path and have everything just work.

198
00:07:51,500 --> 00:07:55,620
<font color="#ffff54">jar를 클래스 경로에 놓으면 모든 것이 정상적으로 작동합니다.</font>

199
00:07:55,620 --> 00:07:59,060
Java has dynamic dispatch through virtual methods.

200
00:07:55,620 --> 00:07:59,060
<font color="#ffff54">Java에는 가상 메서드를 통한 동적 디스패치가 있습니다.</font>

201
00:07:59,060 --> 00:08:05,200
It has dynamic introspection through reflection and features like instance of and casting.

202
00:07:59,060 --> 00:08:05,200
<font color="#ffff54">리플렉션을 통한 동적 성찰과 인스턴스 및 캐스팅과 같은 기능이 있습니다.</font>

203
00:08:05,199 --> 00:08:12,479
So even though we'd like to think that Java is a mostly static language, Java is actually

204
00:08:05,199 --> 00:08:12,479
<font color="#ffff54">따라서 자바가 대부분 정적인 언어라고 생각하고 싶지만, 사실 자바는</font>

205
00:08:12,479 --> 00:08:16,199
really dynamic.

206
00:08:12,479 --> 00:08:16,199
<font color="#ffff54">정말 동적입니다.</font>

207
00:08:16,199 --> 00:08:22,279
So one dimension of static versus dynamic is what is changing and what is not changing.

208
00:08:16,199 --> 00:08:22,279
<font color="#ffff54">정적인 것과 동적인 것의 한 차원은 변화하는 것과 변화하지 않는 것입니다.</font>

209
00:08:22,279 --> 00:08:24,879
The other dimension is when is it changing?

210
00:08:22,279 --> 00:08:24,879
<font color="#ffff54">또 다른 차원은 언제 변하는가입니다.</font>

211
00:08:24,879 --> 00:08:28,180
Over what period is it changing or not changing?

212
00:08:24,879 --> 00:08:28,180
<font color="#ffff54">어느 기간 동안 변화하거나 변화하지 않는가?</font>

213
00:08:28,180 --> 00:08:34,779
So earlier I described the sort of naive division of compile time versus runtime, which is usually

214
00:08:28,180 --> 00:08:34,779
<font color="#ffff54">앞서 컴파일 시간과 런타임의 순진한 구분을 설명했는데, 보통은 다음과 같습니다.</font>

215
00:08:34,779 --> 00:08:38,879
the thing that comes to mind when we talk about something being done statically or something

216
00:08:34,779 --> 00:08:38,879
<font color="#ffff54">정적으로 수행되는 무언가에 대해 이야기할 때 떠오르는 것들입니다.</font>

217
00:08:38,879 --> 00:08:40,439
done dynamically.

218
00:08:38,879 --> 00:08:40,439
<font color="#ffff54">동적으로 수행됩니다.</font>

219
00:08:40,439 --> 00:08:46,879
But in reality, there are many, many interesting phase transitions in a program where something

220
00:08:40,439 --> 00:08:46,879
<font color="#ffff54">하지만 실제로 프로그램에는 흥미로운 위상 전환이 아주 많이 존재합니다.</font>

221
00:08:46,879 --> 00:08:53,879
that happens before a phase transition and is held constant throughout the next phase

222
00:08:46,879 --> 00:08:53,879
<font color="#ffff54">위상 전이 전에 발생하고 다음 위상 내내 일정하게 유지됩니다.</font>

223
00:08:53,879 --> 00:08:57,439
is called static, even though it was dynamic in the previous phase.

224
00:08:53,879 --> 00:08:57,439
<font color="#ffff54">이전 단계에서는 동적이었더라도 정적이라고 합니다.</font>

225
00:08:57,439 --> 00:09:02,039
And as an example of that, take a line of code like this, where we say static final

226
00:08:57,439 --> 00:09:02,039
<font color="#ffff54">그 예로, 정적 최종이라고 하는 다음과 같은 코드 줄을 살펴봅시다.</font>

227
00:09:02,299 --> 00:09:07,500
int seed equals, and then we go off to the hardware randomness source and we ask it for

228
00:09:02,299 --> 00:09:07,500
<font color="#ffff54">int 시드 같다고 한 다음, 하드웨어 임의성 소스로 가서</font>

229
00:09:07,500 --> 00:09:09,539
a random number.

230
00:09:07,500 --> 00:09:09,539
<font color="#ffff54">난수를 요청합니다.</font>

231
00:09:09,539 --> 00:09:12,059
So is that static or dynamic?

232
00:09:09,539 --> 00:09:12,059
<font color="#ffff54">정적인가, 아니면 동적인가?</font>

233
00:09:12,059 --> 00:09:15,980
Well, duh, it says static right there, right?

234
00:09:12,059 --> 00:09:15,980
<font color="#ffff54">저기 정적이라고 되어 있잖아요?</font>

235
00:09:15,980 --> 00:09:18,860
Well, so that's part of the story.

236
00:09:15,980 --> 00:09:18,860
<font color="#ffff54">그게 이야기의 일부군요.</font>

237
00:09:18,860 --> 00:09:21,860
But when does that initializer run, the get random number?

238
00:09:18,860 --> 00:09:21,860
<font color="#ffff54">하지만 그 이니셜라이저는 언제 실행될까요, 난수 추출은?</font>

239
00:09:21,860 --> 00:09:22,860
That runs at runtime.

240
00:09:21,860 --> 00:09:22,860
<font color="#ffff54">런타임에 실행됩니다.</font>

241
00:09:22,860 --> 00:09:25,939
That sounds pretty dynamic to me.

242
00:09:22,860 --> 00:09:25,939
<font color="#ffff54">꽤 역동적으로 들리네요.</font>

243
00:09:25,940 --> 00:09:32,940
On the other hand, the value of that seed is held constant for the entirety of its visible

244
00:09:25,940 --> 00:09:32,940
<font color="#ffff54">반면에, 해당 시드의 값은 보이는 전체 기간 동안 일정하게 유지됩니다.</font>

245
00:09:32,940 --> 00:09:33,800
lifetime.

246
00:09:32,940 --> 00:09:33,800
<font color="#ffff54">수명 동안 일정하게 유지됩니다.</font>

247
00:09:33,800 --> 00:09:35,960
So no one can ever see it change.

248
00:09:33,800 --> 00:09:35,960
<font color="#ffff54">그래서 아무도 변하는 것을 볼 수 없습니다.</font>

249
00:09:35,960 --> 00:09:36,960
Well, unchanging.

250
00:09:35,960 --> 00:09:36,960
<font color="#ffff54">음, 변하지 않네요.</font>

251
00:09:36,960 --> 00:09:39,280
That sounds kind of static.

252
00:09:36,960 --> 00:09:39,280
<font color="#ffff54">좀 정적이네요.</font>

253
00:09:39,280 --> 00:09:44,480
But on the other, other, other hand, this lifetime doesn't coincide with the sort of

254
00:09:39,280 --> 00:09:44,480
<font color="#ffff54">하지만 다른 한편으로, 다른 한편으로, 이 수명은 일치하지 않습니다.</font>

255
00:09:44,480 --> 00:09:48,160
compile time versus runtime distinction.

256
00:09:44,480 --> 00:09:48,160
<font color="#ffff54">컴파일 시간과 런타임을 구분합니다.</font>

257
00:09:48,159 --> 00:09:54,679
So it kind of gives you an idea that we're used to playing very fast and loose with these

258
00:09:48,159 --> 00:09:54,679
<font color="#ffff54">이를 통해 우리가 매우 빠르고 느슨하게 플레이하는 데 익숙하다는 것을 알 수 있습니다.</font>

259
00:09:54,679 --> 00:09:58,600
terms and that can often get us in trouble.

260
00:09:54,679 --> 00:09:58,600
<font color="#ffff54">종종 곤경에 처할 수 있습니다.</font>

261
00:09:58,600 --> 00:10:06,600
So one of the things that the JVM is very good at is optimizing things that were born

262
00:09:58,600 --> 00:10:06,600
<font color="#ffff54">따라서 JVM이 매우 잘하는 것 중 하나는 이미 만들어진 것을 최적화하는 것입니다.</font>

263
00:10:06,600 --> 00:10:09,819
dynamic as if they were static.

264
00:10:06,600 --> 00:10:09,819
<font color="#ffff54">동적인 것을 마치 정적인 것처럼 최적화하는 것입니다.</font>

265
00:10:09,819 --> 00:10:18,000
So for example, the static final field example, what the JVM is going to do is it is going

266
00:10:09,819 --> 00:10:18,000
<font color="#ffff54">예를 들어, 정적 최종 필드 예제에서 JVM이 수행하는 작업은 다음과 같습니다.</font>

267
00:10:18,000 --> 00:10:25,480
to aggressively inline that as a constant into things like generated code and constant

268
00:10:18,000 --> 00:10:25,480
<font color="#ffff54">을 생성된 코드와 상수 같은 것에 상수로 적극적으로 인라인하는 것입니다.</font>

269
00:10:25,480 --> 00:10:30,440
folding, constant propagation and all of that, even though there's a real element of dynamism

270
00:10:25,480 --> 00:10:30,440
<font color="#ffff54">폴딩, 상수 전파 등 실제 동적 요소가 있음에도 불구하고 말이죠.</font>

271
00:10:30,440 --> 00:10:32,600
going on here.

272
00:10:30,440 --> 00:10:32,600
<font color="#ffff54">계속 진행 중입니다.</font>

273
00:10:32,600 --> 00:10:38,559
And this is really part of the JVM philosophy that there is this yin and yang of static

274
00:10:32,600 --> 00:10:38,559
<font color="#ffff54">이것은 정적과 동적의 음과 양이 존재한다는 JVM 철학의 일부입니다.</font>

275
00:10:38,559 --> 00:10:43,080
versus dynamic that is not a contradiction.

276
00:10:38,559 --> 00:10:43,080
<font color="#ffff54">모순이 아닌 동적이라는 음과 양이 있습니다.</font>

277
00:10:43,080 --> 00:10:44,360
It's a strength.

278
00:10:43,080 --> 00:10:44,360
<font color="#ffff54">강점입니다.</font>

279
00:10:44,759 --> 00:10:52,000
Rather than choosing static versus dynamic, the Java answers almost always both please.

280
00:10:44,759 --> 00:10:52,000
<font color="#ffff54">정적과 동적 중 하나를 선택하기보다는 자바는 거의 항상 두 가지 모두 만족스럽게 대답합니다.</font>

281
00:10:52,000 --> 00:11:01,220
And so we consider it a core JVM competency to optimize calculations that may look static

282
00:10:52,000 --> 00:11:01,220
<font color="#ffff54">따라서 정적으로 보일 수 있는 계산을 최적화하는 것이 JVM의 핵심 역량이라고 생각합니다.</font>

283
00:11:01,220 --> 00:11:05,720
for a certain period of time even though they were dynamic in an earlier phase.

284
00:11:01,220 --> 00:11:05,720
<font color="#ffff54">이전 단계에서는 동적이었더라도 일정 기간 동안은 정적으로 보일 수 있습니다.</font>

285
00:11:05,720 --> 00:11:11,360
And that includes things like the field initialization example that I just showed.

286
00:11:05,720 --> 00:11:11,360
<font color="#ffff54">여기에는 방금 보여드린 필드 초기화 예제 같은 것들이 포함됩니다.</font>

287
00:11:11,360 --> 00:11:19,960
And it also includes things like class loading, which is done dynamically and lazily.

288
00:11:11,360 --> 00:11:19,960
<font color="#ffff54">또한 동적이고 느리게 수행되는 클래스 로딩과 같은 것들도 포함됩니다.</font>

289
00:11:19,960 --> 00:11:24,200
And lots and lots of JIT optimizations take advantage of that.

290
00:11:19,960 --> 00:11:24,200
<font color="#ffff54">그리고 수많은 JIT 최적화가 이를 활용합니다.</font>

291
00:11:24,200 --> 00:11:28,360
Another thing JVMs like to do and are very good at is hiding the evidence when it guesses

292
00:11:24,200 --> 00:11:28,360
<font color="#ffff54">JVM이 좋아하고 매우 잘하는 또 다른 일은 추측할 때 증거를 숨기는 것입니다.</font>

293
00:11:28,360 --> 00:11:29,419
wrong.

294
00:11:28,360 --> 00:11:29,419
<font color="#ffff54">틀렸다.</font>

295
00:11:29,419 --> 00:11:38,960
So one of the coolest optimizations that JVMs do routinely is class hierarchy based speculative

296
00:11:29,419 --> 00:11:38,960
<font color="#ffff54">JVM이 일상적으로 수행하는 가장 멋진 최적화 중 하나는 클래스 계층 구조 기반의 추측성 최적화입니다.</font>

297
00:11:38,960 --> 00:11:42,280
optimization of polymorphic call sites.

298
00:11:38,960 --> 00:11:42,280
<font color="#ffff54">다형성 호출 사이트의 최적화입니다.</font>

299
00:11:42,280 --> 00:11:51,040
And what that means is when you go to call a method that's defined, say, in an interface,

300
00:11:42,280 --> 00:11:51,040
<font color="#ffff54">이는 예를 들어 인터페이스에 정의된 메서드를 호출할 때를 의미합니다,</font>

301
00:11:51,040 --> 00:11:53,360
ordinarily you would think, oh, that has to be a virtual call.

302
00:11:51,040 --> 00:11:53,360
<font color="#ffff54">보통은 가상 호출이어야 한다고 생각할 것입니다.</font>

303
00:11:53,360 --> 00:11:57,720
And you have some idea of what the mechanics of a virtual call is with looking things up

304
00:11:53,360 --> 00:11:57,720
<font color="#ffff54">그리고 가상 통화의 메커니즘에 대해 어느 정도는 알고 있습니다.</font>

305
00:11:57,720 --> 00:12:00,000
in VTables and things like that.

306
00:11:57,720 --> 00:12:00,000
<font color="#ffff54">같은 것들에서요.</font>

307
00:12:00,000 --> 00:12:05,960
But the JVM is entirely free to say, I happen to know that there's only one implementation

308
00:12:00,000 --> 00:12:05,960
<font color="#ffff54">하지만 JVM은 전적으로 자유롭게 말할 수 있으며, 제가 알기로는 구현이 하나뿐인 것으로 알고 있습니다.</font>

309
00:12:05,960 --> 00:12:07,560
of that interface loaded.

310
00:12:05,960 --> 00:12:07,560
<font color="#ffff54">가 로드되었습니다.</font>

311
00:12:07,560 --> 00:12:09,400
So I know exactly where this call is going.

312
00:12:07,560 --> 00:12:09,400
<font color="#ffff54">그래서 저는 이 호출이 어디로 가는지 정확히 알고 있습니다.</font>

313
00:12:09,400 --> 00:12:10,720
And I'm not going to go through the VTable.

314
00:12:09,400 --> 00:12:10,720
<font color="#ffff54">그리고 난 VTable을 통과하지 않을 거야.</font>

315
00:12:10,720 --> 00:12:12,120
I'm going to do a direct call.

316
00:12:10,720 --> 00:12:12,120
<font color="#ffff54">직접 전화를 걸겠습니다.</font>

317
00:12:12,120 --> 00:12:14,440
In fact, I'm going to inline through it.

318
00:12:12,120 --> 00:12:14,440
<font color="#ffff54">사실, 인라인으로 통과하겠습니다.</font>

319
00:12:14,440 --> 00:12:17,060
And this is something that the VM does.

320
00:12:14,440 --> 00:12:17,060
<font color="#ffff54">그리고 이것은 VM이 하는 일입니다.</font>

321
00:12:17,060 --> 00:12:22,680
But it's kind of a dodgy thing to do because a minute later I can load another class that

322
00:12:17,060 --> 00:12:22,680
<font color="#ffff54">하지만 1분 후에 다른 클래스를 로드할 수 있기 때문에 이는 다소 애매한 작업입니다.</font>

323
00:12:22,680 --> 00:12:28,880
violates that assumption and invalidates the optimization that I just described.

324
00:12:22,680 --> 00:12:28,880
<font color="#ffff54">이 가정을 위반하고 방금 설명한 최적화를 무효화하기 때문입니다.</font>

325
00:12:28,880 --> 00:12:30,800
Not a problem.

326
00:12:28,880 --> 00:12:30,800
<font color="#ffff54">문제 없습니다.</font>

327
00:12:30,800 --> 00:12:33,820
It's the same JVM that's doing the class loading that's doing the JITing.

328
00:12:30,800 --> 00:12:33,820
<font color="#ffff54">클래스 로딩을 수행하는 JVM이 JIT를 수행하는 것과 동일합니다.</font>

329
00:12:33,820 --> 00:12:39,700
So when you go to load something that would violate a previous assumption, it says, wait

330
00:12:33,820 --> 00:12:39,700
<font color="#ffff54">따라서 이전 가정을 위반할 수 있는 무언가를 로드하려고 하면 다음과 같이 표시됩니다.</font>

331
00:12:39,700 --> 00:12:42,060
a second, hold off on this class loading for a minute.

332
00:12:39,700 --> 00:12:42,060
<font color="#ffff54">이 클래스 로딩을 1분간 보류합니다.</font>

333
00:12:42,060 --> 00:12:45,700
Let me go evict some code from the code cache because it has bad assumptions now.

334
00:12:42,060 --> 00:12:45,700
<font color="#ffff54">코드 캐시에 잘못된 가정이 있으므로 코드 캐시에서 일부 코드를 제거하겠습니다.</font>

335
00:12:45,700 --> 00:12:51,300
That will fall back to interpretation and get reoptimized later.

336
00:12:45,700 --> 00:12:51,300
<font color="#ffff54">나중에 다시 해석해서 다시 최적화하겠습니다.</font>

337
00:12:51,300 --> 00:12:54,140
And then I'll continue with the class loading.

338
00:12:51,300 --> 00:12:54,140
<font color="#ffff54">그리고 나서 클래스 로딩을 계속하겠습니다.</font>

339
00:12:54,140 --> 00:12:58,340
So this is an example of something that is dynamic.

340
00:12:54,140 --> 00:12:58,340
<font color="#ffff54">이것이 동적인 것의 예시입니다.</font>

341
00:12:58,340 --> 00:13:02,820
But if you squint, it might be static for long enough that it's worth trying to optimize

342
00:12:58,340 --> 00:13:02,820
<font color="#ffff54">하지만 눈을 가늘게 뜨면 충분히 오랫동안 정적일 수 있으므로 최적화를 시도할 가치가 있습니다.</font>

343
00:13:02,820 --> 00:13:03,820
something.

344
00:13:02,820 --> 00:13:03,820
<font color="#ffff54">뭔가.</font>

345
00:13:03,820 --> 00:13:08,980
And if you're wrong, the VM is able to recover without exposing a failure.

346
00:13:03,820 --> 00:13:08,980
<font color="#ffff54">그리고 잘못 입력한 경우에도 장애를 노출하지 않고 VM이 복구할 수 있습니다.</font>

347
00:13:08,980 --> 00:13:11,300
So this is something that VMs do all the time.

348
00:13:08,980 --> 00:13:11,300
<font color="#ffff54">이 작업은 VM이 항상 수행하는 작업입니다.</font>

349
00:13:11,300 --> 00:13:12,340
We don't even notice it.

350
00:13:11,300 --> 00:13:12,340
<font color="#ffff54">우리는 눈치채지 못합니다.</font>

351
00:13:12,340 --> 00:13:13,460
It's a wonderful thing.

352
00:13:12,340 --> 00:13:13,460
<font color="#ffff54">멋진 일이야.</font>

353
00:13:13,460 --> 00:13:23,420
This is why Java can often outperform C because it's allowed to make optimizations that are

354
00:13:13,460 --> 00:13:23,420
<font color="#ffff54">이것이 바로 Java가 종종 C보다 성능이 뛰어난 이유입니다.</font>

355
00:13:23,420 --> 00:13:29,420
not provably true as long as we will know when they become invalidated.

356
00:13:23,420 --> 00:13:29,420
<font color="#ffff54">언제 무효화되는지 알 수 있는 한 증명할 수 없는 사실입니다.</font>

357
00:13:29,620 --> 00:13:35,380
Similarly, we may want to deoptimize on the basis of we gather profile information, compile

358
00:13:29,620 --> 00:13:35,380
<font color="#ffff54">마찬가지로, 우리는 프로필 정보를 수집하고, 컴파일하여</font>

359
00:13:35,380 --> 00:13:40,020
code in a certain way, then we gather more profile information and decide, you know what?

360
00:13:35,380 --> 00:13:40,020
<font color="#ffff54">코드를 컴파일한 다음, 더 많은 프로필 정보를 수집하고 결정할 수 있습니다.</font>

361
00:13:40,020 --> 00:13:41,260
That was a bad compilation.

362
00:13:40,020 --> 00:13:41,260
<font color="#ffff54">컴파일이 잘못됐어.</font>

363
00:13:41,260 --> 00:13:42,900
I can imagine a better compilation.

364
00:13:41,260 --> 00:13:42,900
<font color="#ffff54">더 나은 컴파일을 상상할 수 있어요.</font>

365
00:13:42,900 --> 00:13:46,400
I'm going to kick that code out of the code cache and recompile it.

366
00:13:42,900 --> 00:13:46,400
<font color="#ffff54">코드 캐시에서 해당 코드를 걷어내고 다시 컴파일하겠습니다.</font>

367
00:13:46,400 --> 00:13:52,500
So this is like business as usual in the JVM, is balancing this static and dynamic reasoning.

368
00:13:46,400 --> 00:13:52,500
<font color="#ffff54">정적 추론과 동적 추론의 균형을 맞추는 것은 JVM의 일반적인 업무와 같습니다.</font>

369
00:13:52,500 --> 00:13:53,740
OK.

370
00:13:52,500 --> 00:13:53,740
<font color="#ffff54">알겠습니다.</font>

371
00:13:53,740 --> 00:13:56,500
So none of this has anything to do with startup, right?

372
00:13:53,740 --> 00:13:56,500
<font color="#ffff54">이 모든 것이 시작과 관련이 없는 거죠?</font>

373
00:13:56,500 --> 00:14:00,220
Well, let's talk about what happens at startup.

374
00:13:56,500 --> 00:14:00,220
<font color="#ffff54">그럼 스타트 업에서 일어나는 일에 대해 이야기해 봅시다.</font>

375
00:14:00,220 --> 00:14:05,980
So when a program starts up, like I said, there are activities that might be part of

376
00:14:00,220 --> 00:14:05,980
<font color="#ffff54">프로그램이 시작되면, 제가 말씀드린 것처럼, 다음과 같은 활동이 있을 수 있습니다.</font>

377
00:14:05,980 --> 00:14:11,120
your program or your framework or libraries that you use, like reading configuration files

378
00:14:05,980 --> 00:14:11,120
<font color="#ffff54">구성 파일 읽기 같은 프로그램이나 프레임워크, 사용하는 라이브러리의 일부일 수 있습니다.</font>

379
00:14:11,120 --> 00:14:19,259
or scanning for annotations, opening sockets, creating loggers, like I said, and also class

380
00:14:11,120 --> 00:14:19,259
<font color="#ffff54">또는 주석 검색, 소켓 열기, 로거 생성, 내가 말했던 것처럼 클래스</font>

381
00:14:19,259 --> 00:14:28,819
loading, class verification, class file metadata construction, static initializers, interpretation,

382
00:14:19,259 --> 00:14:28,819
<font color="#ffff54">로딩, 클래스 검증, 클래스 파일 메타데이터 구성, 정적 이니셜라이저, 해석,</font>

383
00:14:28,819 --> 00:14:35,460
profile gathering, call site linkage, all of these things happen at startup.

384
00:14:28,819 --> 00:14:35,460
<font color="#ffff54">프로필 수집, 통화 사이트 연결, 이 모든 것이 시작과 동시에 이루어집니다.</font>

385
00:14:35,460 --> 00:14:42,700
And similarly, at warmup, warmup sort of extends over a longer period of time than startup,

386
00:14:35,460 --> 00:14:42,700
<font color="#ffff54">마찬가지로 워밍업 단계에서는 시작보다 더 오랜 시간 동안 워밍업이 진행됩니다,</font>

387
00:14:42,700 --> 00:14:47,340
we see the same split of there are activities that are part of the program that govern warmup,

388
00:14:42,700 --> 00:14:47,340
<font color="#ffff54">워밍업을 관장하는 프로그램의 일부인 활동이 동일하게 분할되는 것을 볼 수 있습니다,</font>

389
00:14:47,340 --> 00:14:53,660
like populating caches, and there are JVM activities, like JIT compilation of hot code

390
00:14:47,340 --> 00:14:53,660
<font color="#ffff54">캐시 채우기와 같은 프로그램이 있고, 핫 코드의 JIT 컴파일과 같은 JVM 활동이 있습니다.</font>

391
00:14:53,660 --> 00:14:56,220
that affect warmup.

392
00:14:53,660 --> 00:14:56,220
<font color="#ffff54">워밍업에 영향을 줍니다.</font>

393
00:14:56,220 --> 00:14:57,800
OK.

394
00:14:56,220 --> 00:14:57,800
<font color="#ffff54">OK.</font>

395
00:14:57,800 --> 00:15:02,120
So million dollar question, why do we do it this way?

396
00:14:57,800 --> 00:15:02,120
<font color="#ffff54">백만 달러짜리 질문인데, 왜 이런 식으로 하는 거죠?</font>

397
00:15:02,120 --> 00:15:07,460
At first, it sounds really inefficient to do what I just described, to do all of that

398
00:15:02,120 --> 00:15:07,460
<font color="#ffff54">처음에는 방금 설명한 대로 모든 작업을 수행하는 것이 정말 비효율적으로 들립니다.</font>

399
00:15:07,460 --> 00:15:09,620
work every time the program starts.

400
00:15:07,460 --> 00:15:09,620
<font color="#ffff54">프로그램이 시작될 때마다 작업합니다.</font>

401
00:15:09,620 --> 00:15:14,280
Are you crazy?

402
00:15:09,620 --> 00:15:14,280
<font color="#ffff54">미쳤어?</font>

403
00:15:14,279 --> 00:15:21,179
And the reason is dynamism benefits both the programming model and the performance model.

404
00:15:14,279 --> 00:15:21,179
<font color="#ffff54">그 이유는 역동성이 프로그래밍 모델과 성능 모델 모두에 도움이 되기 때문입니다.</font>

405
00:15:21,179 --> 00:15:27,279
So dynamic features like on the fly class loading and reflection make Java programs

406
00:15:21,179 --> 00:15:27,279
<font color="#ffff54">따라서 온 더 플라이 클래스 로딩 및 리플렉션과 같은 동적 기능은 Java 프로그램에서</font>

407
00:15:27,279 --> 00:15:28,360
more expressive.

408
00:15:27,279 --> 00:15:28,360
<font color="#ffff54">더 표현력이 풍부해집니다.</font>

409
00:15:28,360 --> 00:15:34,279
The frameworks that we use every day would be much harder to write if we didn't have

410
00:15:28,360 --> 00:15:34,279
<font color="#ffff54">우리가 매일 사용하는 프레임워크는 다음과 같은 기능이 없었다면 작성하기가 훨씬 더 어려웠을 것입니다.</font>

411
00:15:34,279 --> 00:15:38,639
reflection, if we didn't have annotations, if we didn't have dynamic class loading.

412
00:15:34,279 --> 00:15:38,639
<font color="#ffff54">리플렉션이 없다면, 어노테이션이 없다면, 동적 클래스 로딩이 없다면, 우리가 매일 사용하는 프레임워크를 작성하기가 훨씬 더 어려웠을 것입니다.</font>

413
00:15:38,919 --> 00:15:46,319
Similarly, dynamic compilation, JIT compilation, generally produces better code than static

414
00:15:38,919 --> 00:15:46,319
<font color="#ffff54">마찬가지로, 동적 컴파일인 JIT 컴파일은 일반적으로 정적 컴파일보다 더 나은 코드를 생성합니다.</font>

415
00:15:46,319 --> 00:15:50,980
compilation for the very obvious reason that if you're compiling at runtime, you have more

416
00:15:46,319 --> 00:15:50,980
<font color="#ffff54">컴파일보다 더 나은 코드를 생성하는데, 그 이유는 런타임에 컴파일하는 경우 더 많은</font>

417
00:15:50,980 --> 00:15:55,559
information than if you were compiling at build time.

418
00:15:50,980 --> 00:15:55,559
<font color="#ffff54">더 많은 정보를 얻을 수 있기 때문입니다.</font>

419
00:15:55,559 --> 00:16:00,480
You have information about the hardware you're actually running on, not just the abstract

420
00:15:55,559 --> 00:16:00,480
<font color="#ffff54">추상적인 정보뿐만 아니라 실제로 실행 중인 하드웨어에 대한 정보도 얻을 수 있습니다.</font>

421
00:16:00,480 --> 00:16:02,100
Intel instruction set.

422
00:16:00,480 --> 00:16:02,100
<font color="#ffff54">인텔 명령어 세트.</font>

423
00:16:02,100 --> 00:16:08,399
You have information about that was gathered during profiling of what has the program actually

424
00:16:02,100 --> 00:16:08,399
<font color="#ffff54">프로그램이 실제로 무엇을 가지고 있는지에 대한 프로파일링 중에 수집된 정보가 있습니다.</font>

425
00:16:08,399 --> 00:16:13,720
done, has this branch actually been taken, has a null ever shown up at this dispatch

426
00:16:08,399 --> 00:16:13,720
<font color="#ffff54">완료되었는지, 이 분기를 실제로 가져갔는지, 이 디스패치에 널이 나타난 적이 있는지?</font>

427
00:16:13,720 --> 00:16:15,759
site, et cetera.

428
00:16:13,720 --> 00:16:15,759
<font color="#ffff54">사이트 등</font>

429
00:16:15,759 --> 00:16:19,439
And so we can use that information to produce better code.

430
00:16:15,759 --> 00:16:19,439
<font color="#ffff54">그리고 그 정보를 이용해 더 나은 코드를 만들 수 있습니다.</font>

431
00:16:19,439 --> 00:16:24,199
And then if it turns out that we gather more data and our opinions change about what would

432
00:16:19,439 --> 00:16:24,199
<font color="#ffff54">그리고 더 많은 데이터를 수집하고 의견이 바뀐다면 어떻게 해야 할까요?</font>

433
00:16:24,199 --> 00:16:30,600
constitute a good optimization, we can de-optimize and re-optimize.

434
00:16:24,199 --> 00:16:30,600
<font color="#ffff54">최적화를 해제하고 다시 최적화할 수 있습니다.</font>

435
00:16:30,600 --> 00:16:35,159
And we can do that based on observed program behavior.

436
00:16:30,600 --> 00:16:35,159
<font color="#ffff54">그리고 관찰된 프로그램 동작을 기반으로 그렇게 할 수 있습니다.</font>

437
00:16:35,159 --> 00:16:42,480
So all of this dynamism makes for a good user programming model and excellent peak

438
00:16:35,159 --> 00:16:42,480
<font color="#ffff54">이 모든 역동성이 좋은 사용자 프로그래밍 모델과 우수한 피크를 만들어냅니다.</font>

439
00:16:42,480 --> 00:16:43,480
performance.

440
00:16:42,480 --> 00:16:43,480
<font color="#ffff54">성능.</font>

441
00:16:43,480 --> 00:16:44,480
So what's the cost?

442
00:16:43,480 --> 00:16:44,480
<font color="#ffff54">그럼 비용은 얼마인가요?</font>

443
00:16:44,480 --> 00:16:45,480
Everything's a trade-off.

444
00:16:44,480 --> 00:16:45,480
<font color="#ffff54">모든 건 장단점이 있죠.</font>

445
00:16:45,480 --> 00:16:48,679
The cost of that is slower startup and warm-up.

446
00:16:45,480 --> 00:16:48,679
<font color="#ffff54">그 대가는 느린 시작과 워밍업입니다.</font>

447
00:16:48,679 --> 00:16:53,120
For some applications, like think about a WebLogic server which starts up and runs for

448
00:16:48,679 --> 00:16:53,120
<font color="#ffff54">일부 애플리케이션의 경우, 예를 들어 시작 및 실행되는 웹로직 서버를 생각해보십시오.</font>

449
00:16:53,120 --> 00:16:56,039
months, this is an excellent trade-off.

450
00:16:53,120 --> 00:16:56,039
<font color="#ffff54">개월 동안 실행되는 서버를 생각해보면, 이것은 훌륭한 절충안입니다.</font>

451
00:16:56,039 --> 00:16:59,879
The fact that it takes a while to start up may not be an issue.

452
00:16:56,039 --> 00:16:59,879
<font color="#ffff54">시작하는 데 시간이 걸린다는 사실은 문제가 되지 않을 수 있습니다.</font>

453
00:16:59,879 --> 00:17:03,860
And the fact that you get better peak performance is definitely a good thing.

454
00:16:59,879 --> 00:17:03,860
<font color="#ffff54">그리고 최고 성능이 향상된다는 사실은 확실히 좋은 일입니다.</font>

455
00:17:03,860 --> 00:17:07,259
On the other hand, if you have something like a command line application, the user is waiting

456
00:17:03,860 --> 00:17:07,259
<font color="#ffff54">반면에, 명령줄 애플리케이션과 같은 것이 있다면 사용자는</font>

457
00:17:07,259 --> 00:17:11,579
to see feedback, they may care more about startup and they probably don't care about

458
00:17:07,259 --> 00:17:11,579
<font color="#ffff54">피드백을 보기 위해, 시작에 더 신경을 쓸 수 있고 아마도</font>

459
00:17:11,579 --> 00:17:15,620
peak performance because your short-running command line application probably doesn't

460
00:17:11,579 --> 00:17:15,620
<font color="#ffff54">단기 실행 명령줄 응용 프로그램은 아마도 그렇지 않을 것이기 때문에 최고 성능</font>

461
00:17:15,620 --> 00:17:17,920
even get out of the interpreter.

462
00:17:15,620 --> 00:17:17,920
<font color="#ffff54">심지어 인터프리터에서 빠져나올 수도 있습니다.</font>

463
00:17:17,920 --> 00:17:22,420
So all of this is to say that different workloads have different requirements and we want Java

464
00:17:17,920 --> 00:17:22,420
<font color="#ffff54">이 모든 것은 워크로드마다 요구사항이 다르고, 우리는 자바가</font>

465
00:17:22,420 --> 00:17:24,620
to be good for all of them.

466
00:17:22,420 --> 00:17:24,620
<font color="#ffff54">가 모든 워크로드에 적합하기를 바랍니다.</font>

467
00:17:24,620 --> 00:17:30,539
So to sort of visualize startup and warm-up, imagine there's an ideal behavior, which is

468
00:17:24,620 --> 00:17:30,539
<font color="#ffff54">따라서 시작과 워밍업을 시각화하기 위해 다음과 같은 이상적인 동작이 있다고 상상해 보세요.</font>

469
00:17:30,859 --> 00:17:37,859
by this green line at the bottom here, where this is the amount of time it takes to do

470
00:17:30,859 --> 00:17:37,859
<font color="#ffff54">여기 하단의 녹색 선은 이 작업을 수행하는 데 걸리는 시간입니다.</font>

471
00:17:38,259 --> 00:17:42,359
each task in a program that does repetitive tasks, which a lot of programs do.

472
00:17:38,259 --> 00:17:42,359
<font color="#ffff54">반복적인 작업을 수행하는 프로그램에서 각 작업을 수행하는 데 걸리는 시간입니다.</font>

473
00:17:42,359 --> 00:17:44,460
Some programs just do one thing and exit.

474
00:17:42,359 --> 00:17:44,460
<font color="#ffff54">어떤 프로그램은 한 가지 일만 하고 종료합니다.</font>

475
00:17:44,460 --> 00:17:50,619
And you can see that the timeline for the first task is going to be higher than for

476
00:17:44,460 --> 00:17:50,619
<font color="#ffff54">그리고 첫 번째 작업의 타임라인이 다음 작업보다 더 길어지는 것을 볼 수 있습니다.</font>

477
00:17:50,619 --> 00:17:56,019
subsequent tasks because we do more work before the first task than we do before the second

478
00:17:50,619 --> 00:17:56,019
<font color="#ffff54">두 번째 작업보다 첫 번째 작업 전에 더 많은 작업을 수행하기 때문입니다.</font>

479
00:17:56,019 --> 00:17:57,019
task.

480
00:17:56,019 --> 00:17:57,019
<font color="#ffff54">작업.</font>

481
00:17:57,019 --> 00:18:04,019
Now, most programs end up with something more like the yellow line, where you have the same

482
00:17:57,019 --> 00:18:04,019
<font color="#ffff54">이제 대부분의 프로그램은 노란색 선과 비슷한 형태로 끝납니다.</font>

483
00:18:04,139 --> 00:18:09,960
qualitative shape, but the reality is that there's a big head on startup.

484
00:18:04,139 --> 00:18:09,960
<font color="#ffff54">질적인 모양을 가지고 있지만, 현실은 시작에 큰 머리가 있다는 것입니다.</font>

485
00:18:09,960 --> 00:18:16,960
And then there is a gradual convergence between the observed performance and the ideal performance.

486
00:18:09,960 --> 00:18:16,960
<font color="#ffff54">그리고 관찰된 성능과 이상적인 성능 사이에 점진적인 수렴이 일어납니다.</font>

487
00:18:19,059 --> 00:18:26,059
So the work under this first unit of time is startup activity, and typically that's

488
00:18:19,059 --> 00:18:26,059
<font color="#ffff54">따라서 이 첫 번째 시간 단위의 작업은 시작 활동이며, 일반적으로 다음과 같습니다.</font>

489
00:18:26,059 --> 00:18:33,059
driven by things like class loading, class initialization, which are unique to the first

490
00:18:26,059 --> 00:18:33,059
<font color="#ffff54">클래스 로딩, 클래스 초기화 같은 것들에 의해 구동됩니다.</font>

491
00:18:33,139 --> 00:18:34,500
iteration.

492
00:18:33,139 --> 00:18:34,500
<font color="#ffff54">이터레이션.</font>

493
00:18:34,500 --> 00:18:41,500
And the stuff that is below the other line is generally online JIT activity for identifying

494
00:18:34,500 --> 00:18:41,500
<font color="#ffff54">그리고 다른 줄 아래에 있는 항목은 일반적으로 식별을 위한 온라인 JIT 활동입니다.</font>

495
00:18:43,259 --> 00:18:50,259
hot classes, compiling hot classes, and it's going to take a certain amount of time for

496
00:18:43,259 --> 00:18:50,259
<font color="#ffff54">핫 클래스, 핫 클래스 컴파일, 그리고 일정 시간이 걸릴 것입니다.</font>

497
00:18:51,179 --> 00:18:54,779
the hot code to all be compiled, which is what warm-up basically means.

498
00:18:51,179 --> 00:18:54,779
<font color="#ffff54">핫 코드가 모두 컴파일되는 데 일정 시간이 걸리는데, 이것이 바로 워밍업의 기본 의미입니다.</font>

499
00:18:54,779 --> 00:18:58,660
So startup tends to be a very short-lived thing.

500
00:18:54,779 --> 00:18:58,660
<font color="#ffff54">따라서 시작은 매우 짧게 끝나는 경향이 있습니다.</font>

501
00:18:58,660 --> 00:19:02,220
Warm-up tends to be a longer-lived thing.

502
00:18:58,660 --> 00:19:02,220
<font color="#ffff54">워밍업은 더 오래 지속되는 경향이 있습니다.</font>

503
00:19:02,220 --> 00:19:06,420
So if we want to improve startup and warm-up, what do we have to do?

504
00:19:02,220 --> 00:19:06,420
<font color="#ffff54">그렇다면 스타트와 워밍업을 개선하려면 어떻게 해야 할까요?</font>

505
00:19:06,420 --> 00:19:13,420
Well we have to find a way to push the first point down if we're looking to optimize startup

506
00:19:06,420 --> 00:19:13,420
<font color="#ffff54">시작을 최적화하려면 첫 번째 지점을 낮추는 방법을 찾아야 합니다.</font>

507
00:19:15,660 --> 00:19:22,660
and to push the whole curve down if we're looking to optimize warm-up.

508
00:19:15,660 --> 00:19:22,660
<font color="#ffff54">워밍업을 최적화하려면 전체 곡선을 아래로 밀어내야 합니다.</font>

509
00:19:22,740 --> 00:19:26,140
Okay, so how do we push these curves down?

510
00:19:22,740 --> 00:19:26,140
<font color="#ffff54">그럼 이 커브를 어떻게 아래로 내릴까요?</font>

511
00:19:26,140 --> 00:19:29,779
Well we need to move work off the critical path.

512
00:19:26,140 --> 00:19:29,779
<font color="#ffff54">작업을 임계 경로에서 벗어나야 합니다.</font>

513
00:19:29,779 --> 00:19:36,140
That might mean moving it later in time, like being lazy about things, not creating loggers

514
00:19:29,779 --> 00:19:36,140
<font color="#ffff54">그건 일을 게으르게 처리하고 로거를 만들지 않는 것처럼 나중에 옮기는 것을 의미할 수 있습니다.</font>

515
00:19:36,140 --> 00:19:38,540
that we don't need to create immediately.

516
00:19:36,140 --> 00:19:38,540
<font color="#ffff54">당장 만들 필요가 없는 것들.</font>

517
00:19:38,540 --> 00:19:44,540
Or we could shift work earlier in time, from runtime to build time or deploy time or packaging

518
00:19:38,540 --> 00:19:44,540
<font color="#ffff54">또는 런타임에서 빌드 시간이나 배포 시간 또는 패키징 시간으로 작업을 앞당길 수도 있습니다.</font>

519
00:19:44,540 --> 00:19:49,860
time or some earlier phase of execution where we're going to run some Java code and remember

520
00:19:44,540 --> 00:19:49,860
<font color="#ffff54">시간 또는 자바 코드를 실행하는 초기 실행 단계로 작업을 옮길 수 있습니다.</font>

521
00:19:49,860 --> 00:19:51,580
the answer.

522
00:19:49,860 --> 00:19:51,580
<font color="#ffff54">을 기억합니다.</font>

523
00:19:52,579 --> 00:19:58,619
And we can shift work, both of these categories of work, work that's part of the application,

524
00:19:52,579 --> 00:19:58,619
<font color="#ffff54">그리고 우리는 이 두 가지 범주의 작업, 즉 애플리케이션의 일부인 작업을 교대 근무로 전환할 수 있습니다,</font>

525
00:19:58,619 --> 00:20:02,619
as well as shifting work on behalf of the application.

526
00:19:58,619 --> 00:20:02,619
<font color="#ffff54">애플리케이션을 대신하여 작업을 이동시킬 수도 있습니다.</font>

527
00:20:02,619 --> 00:20:05,579
And this is sort of old hat for what JVMs do.

528
00:20:02,619 --> 00:20:05,579
<font color="#ffff54">그리고 이것은 JVM이 하는 일에 대해 일종의 오래된 방식입니다.</font>

529
00:20:05,579 --> 00:20:11,919
JVM already employs a lot of computation shifting techniques, such as garbage collection and

530
00:20:05,579 --> 00:20:11,919
<font color="#ffff54">JVM은 이미 가비지 컬렉션과 같은 많은 연산 이동 기법을 사용하고 있습니다.</font>

531
00:20:11,919 --> 00:20:15,539
constant folding and lazy class loading, etc.

532
00:20:11,919 --> 00:20:15,539
<font color="#ffff54">상수 폴딩과 지연 클래스 로딩 등 많은 연산 이동 기법을 사용하고 있습니다.</font>

533
00:20:15,539 --> 00:20:22,379
So a lot of these optimizations just fall out of the normal semantics of Java programs.

534
00:20:15,539 --> 00:20:22,379
<font color="#ffff54">따라서 이러한 최적화의 대부분은 자바 프로그램의 일반적인 의미론에서 벗어난 것입니다.</font>

535
00:20:22,379 --> 00:20:33,379
So if you have an arithmetic expression, x equals 2 plus 3, well we could push a 2 and

536
00:20:22,379 --> 00:20:33,379
<font color="#ffff54">예를 들어, x가 2 더하기 3과 같은 산술식이 있다면, 우리는 2를 밀어넣고</font>

537
00:20:34,019 --> 00:20:38,700
a 3 on the stack at runtime and add them, or we could do the computation at compile

538
00:20:34,019 --> 00:20:38,700
<font color="#ffff54">를 런타임에 스택에 밀어넣고 더하거나, 컴파일할 때 계산을 할 수도 있습니다.</font>

539
00:20:38,700 --> 00:20:39,859
time.

540
00:20:38,700 --> 00:20:39,859
<font color="#ffff54">시간.</font>

541
00:20:39,859 --> 00:20:45,519
And the language specification allows us to do either, because it just tells us what answer

542
00:20:39,859 --> 00:20:45,519
<font color="#ffff54">그리고 언어 명세는 어떤 답을 알려주기 때문에 어느 쪽이든 할 수 있습니다.</font>

543
00:20:45,599 --> 00:20:46,720
we're supposed to get.

544
00:20:45,599 --> 00:20:46,720
<font color="#ffff54">얻을 수 있습니다.</font>

545
00:20:46,720 --> 00:20:49,440
It doesn't tell us how efficiently we're supposed to do it.

546
00:20:46,720 --> 00:20:49,440
<font color="#ffff54">얼마나 효율적으로 해야 하는지는 알려주지 않습니다.</font>

547
00:20:49,440 --> 00:20:55,879
So there are a lot of optimizations that we can do where the specification is agnostic

548
00:20:49,440 --> 00:20:55,879
<font color="#ffff54">따라서 사양에 구애받지 않고 할 수 있는 최적화가 많이 있습니다.</font>

549
00:20:55,879 --> 00:20:56,879
on what we're doing.

550
00:20:55,879 --> 00:20:56,879
<font color="#ffff54">우리가 하는 일에 대해.</font>

551
00:20:56,879 --> 00:21:01,599
Similarly, garbage collection, the timing of garbage collection is not specified.

552
00:20:56,879 --> 00:21:01,599
<font color="#ffff54">마찬가지로 가비지 컬렉션도 가비지 컬렉션의 타이밍이 지정되지 않았습니다.</font>

553
00:21:01,599 --> 00:21:07,240
Class loading is defined to be lazy, and class initialization is defined to be lazy.

554
00:21:01,599 --> 00:21:07,240
<font color="#ffff54">클래스 로딩이 지연으로 정의되어 있고 클래스 초기화가 지연으로 정의되어 있습니다.</font>

555
00:21:07,240 --> 00:21:13,039
And so these things happen, these things just fall out of the natural semantics of class loading.

556
00:21:07,240 --> 00:21:13,039
<font color="#ffff54">그래서 이런 일들이 일어나는데, 이런 일들은 클래스 로딩의 자연스러운 의미론에서 벗어나는 것입니다.</font>

557
00:21:13,039 --> 00:21:16,980
There are other optimizations that involve work shifting that we might like to do that

558
00:21:13,039 --> 00:21:16,980
<font color="#ffff54">작업 이동을 수반하는 다른 최적화 방법도 있습니다.</font>

559
00:21:16,980 --> 00:21:23,920
might require some work by the user to enable or some specification changes to enable.

560
00:21:16,980 --> 00:21:23,920
<font color="#ffff54">를 활성화하려면 사용자가 일부 작업을 수행하거나 사양을 변경해야 할 수 있습니다.</font>

561
00:21:23,920 --> 00:21:29,680
So for example, in the past we had an experimental AOT compiler which involves running a tool

562
00:21:23,920 --> 00:21:29,680
<font color="#ffff54">예를 들어, 과거에는 도구를 실행하는 것과 관련된 실험적인 AOT 컴파일러가 있었습니다.</font>

563
00:21:29,680 --> 00:21:33,980
at build time saying compile those classes ahead of time.

564
00:21:29,680 --> 00:21:33,980
<font color="#ffff54">빌드 시점에 해당 클래스를 미리 컴파일하라는 메시지를 표시합니다.</font>

565
00:21:33,980 --> 00:21:40,319
And similarly we have the class data sharing mechanism which involves caching information

566
00:21:33,980 --> 00:21:40,319
<font color="#ffff54">그리고 마찬가지로 정보를 캐싱하는 클래스 데이터 공유 메커니즘이 있습니다.</font>

567
00:21:40,319 --> 00:21:44,319
from a training run to accelerate startup.

568
00:21:40,319 --> 00:21:44,319
<font color="#ffff54">훈련 실행을 통해 시작을 가속화합니다.</font>

569
00:21:44,319 --> 00:21:51,559
And shifting work is fair game as long as the program's meaning is preserved.

570
00:21:44,319 --> 00:21:51,559
<font color="#ffff54">그리고 프로그램의 의미가 유지되는 한 업무 이동은 공정한 게임입니다.</font>

571
00:21:51,559 --> 00:22:03,240
So Leiden will lean on what we're already doing with computation shifting by expanding

572
00:21:51,559 --> 00:22:03,240
<font color="#ffff54">따라서 라이덴은 우리가 이미 연산 이동으로 하고 있는 것을 확장하여</font>

573
00:22:03,240 --> 00:22:05,439
the opportunities for computation shifting.

574
00:22:03,240 --> 00:22:05,439
<font color="#ffff54">계산 이동의 기회를 확대할 것입니다.</font>

575
00:22:05,439 --> 00:22:09,159
So some kinds of shifting wouldn't require any spec changes at all.

576
00:22:05,439 --> 00:22:09,159
<font color="#ffff54">따라서 어떤 종류의 이동은 사양 변경이 전혀 필요하지 않을 것입니다.</font>

577
00:22:09,160 --> 00:22:16,640
For example, like Lambda proxies are currently spun at runtime the first time you evaluate

578
00:22:09,160 --> 00:22:16,640
<font color="#ffff54">예를 들어, 람다 프록시가 현재 런타임에 처음 평가할 때 회전하는 것처럼</font>

579
00:22:16,640 --> 00:22:18,840
a Lambda.

580
00:22:16,640 --> 00:22:18,840
<font color="#ffff54">람다.</font>

581
00:22:18,840 --> 00:22:22,120
That's something that could be moved to build time with no specification change.

582
00:22:18,840 --> 00:22:22,120
<font color="#ffff54">이는 사양 변경 없이 빌드 시간으로 이동할 수 있는 부분입니다.</font>

583
00:22:22,120 --> 00:22:25,640
Similarly, speculatively compiling code ahead of time.

584
00:22:22,120 --> 00:22:25,640
<font color="#ffff54">마찬가지로, 추측적으로 코드를 미리 컴파일하는 것도 마찬가지입니다.</font>

585
00:22:25,640 --> 00:22:30,279
When I say speculatively, that means code would be willing to throw away if something

586
00:22:25,640 --> 00:22:30,279
<font color="#ffff54">추측적으로 컴파일한다는 말은, 코드가 다음과 같은 경우 기꺼이 버릴 수 있다는 뜻입니다.</font>

587
00:22:30,279 --> 00:22:31,720
changed.

588
00:22:30,279 --> 00:22:31,720
<font color="#ffff54">변경되었습니다.</font>

589
00:22:31,720 --> 00:22:36,580
There are other kinds of shifting that we might want to do that aren't allowed now,

590
00:22:31,720 --> 00:22:36,580
<font color="#ffff54">지금은 허용되지 않는 다른 종류의 이동을 하고 싶을 수도 있습니다,</font>

591
00:22:36,580 --> 00:22:38,680
but we might extend the specification to allow it.

592
00:22:36,580 --> 00:22:38,680
<font color="#ffff54">하지만 우리는 그것을 허용하도록 사양을 확장할 수 있습니다.</font>

593
00:22:38,680 --> 00:22:46,519
So for example, if you want to strip out code that you know is not going to be run

594
00:22:38,680 --> 00:22:46,519
<font color="#ffff54">예를 들어, 실행되지 않을 것으로 예상되는 코드를 제거하려는 경우</font>

595
00:22:46,519 --> 00:22:48,519
or you promise is not going to be run.

596
00:22:46,519 --> 00:22:48,519
<font color="#ffff54">또는 실행되지 않을 것이라고 약속한 코드를 제거할 수 있습니다.</font>

597
00:22:48,519 --> 00:22:54,000
Currently you're not allowed to do that because it could always be invoked reflectively.

598
00:22:48,519 --> 00:22:54,000
<font color="#ffff54">현재는 항상 반사적으로 호출될 수 있기 때문에 그렇게 할 수 없습니다.</font>

599
00:22:54,000 --> 00:22:59,120
We would need to make some spec changes, which we may be willing to do, in order to support

600
00:22:54,000 --> 00:22:59,120
<font color="#ffff54">다음을 지원하려면 몇 가지 사양을 변경해야 하는데, 기꺼이 그렇게 할 수 있습니다.</font>

601
00:22:59,120 --> 00:23:04,400
that kind of computation shifting.

602
00:22:59,120 --> 00:23:04,400
<font color="#ffff54">그런 종류의 연산 이동을 지원합니다.</font>

603
00:23:04,400 --> 00:23:11,680
We may also investigate adding things to the programming model that allow you to talk about

604
00:23:04,400 --> 00:23:11,680
<font color="#ffff54">프로그래밍 모델에 다음과 같이 이야기할 수 있는 것들을 추가하는 것도 검토할 수 있습니다.</font>

605
00:23:11,680 --> 00:23:14,080
constraints on the timing of computations.

606
00:23:11,680 --> 00:23:14,080
<font color="#ffff54">계산 타이밍에 대한 제약 조건을 추가할 수도 있습니다.</font>

607
00:23:14,080 --> 00:23:20,560
So for example, maybe marking some static fields as lazy, which would mean you don't

608
00:23:14,080 --> 00:23:20,560
<font color="#ffff54">예를 들어, 일부 정적 필드를 지연된 것으로 표시하면</font>

609
00:23:20,560 --> 00:23:22,840
have to do this immediately, you can do it later if you want.

610
00:23:20,560 --> 00:23:22,840
<font color="#ffff54">이 작업을 즉시 수행하지 않아도 되고, 원한다면 나중에 수행할 수 있습니다.</font>

611
00:23:22,840 --> 00:23:25,320
Or maybe you can do it earlier if you want.

612
00:23:22,840 --> 00:23:25,320
<font color="#ffff54">아니면 원한다면 더 일찍 할 수도 있습니다.</font>

613
00:23:25,320 --> 00:23:29,400
There's also an exploration going on called computed constants, which I'll talk about,

614
00:23:25,320 --> 00:23:29,400
<font color="#ffff54">계산된 상수라는 탐색도 진행 중인데, 이에 대해 이야기하겠습니다,</font>

615
00:23:29,400 --> 00:23:32,620
which is a library-based programming model for shifting.

616
00:23:29,400 --> 00:23:32,620
<font color="#ffff54">시프트를 위한 라이브러리 기반 프로그래밍 모델입니다.</font>

617
00:23:32,620 --> 00:23:39,300
So there's a lot of different options that we might want to pursue here.

618
00:23:32,620 --> 00:23:39,300
<font color="#ffff54">따라서 여기서 추구할 수 있는 다양한 옵션이 있습니다.</font>

619
00:23:39,300 --> 00:23:44,740
Now some of the optimizations we might want to do might not be practical or safe without

620
00:23:39,300 --> 00:23:44,740
<font color="#ffff54">이제 우리가 하고자 하는 최적화 중 일부는 다음과 같은 조건이 없으면 실용적이지 않거나 안전하지 않을 수 있습니다.</font>

621
00:23:44,740 --> 00:23:50,500
some additional permission from the user in the form of constraints like, I promise this

622
00:23:44,740 --> 00:23:50,500
<font color="#ffff54">와 같은 제약 조건의 형태로 사용자의 추가 권한이 필요합니다.</font>

623
00:23:50,500 --> 00:23:51,500
won't happen.

624
00:23:50,500 --> 00:23:51,500
<font color="#ffff54">는 일어나지 않습니다.</font>

625
00:23:51,500 --> 00:23:55,640
I promise this class will never be redefined.

626
00:23:51,500 --> 00:23:55,640
<font color="#ffff54">이 클래스는 절대 재정의되지 않을 거라고 약속할게.</font>

627
00:23:55,640 --> 00:23:59,060
And some programs may be willing to accept those constraints.

628
00:23:55,640 --> 00:23:59,060
<font color="#ffff54">그리고 일부 프로그램은 이러한 제약을 기꺼이 받아들일 수도 있습니다.</font>

629
00:23:59,059 --> 00:24:03,579
And they may be willing to accept quite a lot of constraints if there is sufficient

630
00:23:59,059 --> 00:24:03,579
<font color="#ffff54">그리고 그들은 충분한 조건이 있다면 꽤 많은 제약을 기꺼이 받아들일 수도 있습니다.</font>

631
00:24:03,579 --> 00:24:04,619
benefit.

632
00:24:03,579 --> 00:24:04,619
<font color="#ffff54">이익이 있다면.</font>

633
00:24:04,619 --> 00:24:12,379
So one of the key values of Project Leiden is that we want users to be in charge of choosing

634
00:24:04,619 --> 00:24:12,379
<font color="#ffff54">따라서 프로젝트 라이덴의 핵심 가치 중 하나는 사용자가 직접 선택할 수 있도록 하는 것입니다.</font>

635
00:24:12,379 --> 00:24:16,859
which constraints they're willing to accept in order to get the benefits that they want.

636
00:24:12,379 --> 00:24:16,859
<font color="#ffff54">원하는 혜택을 얻기 위해 어떤 제약을 기꺼이 받아들일지 결정하는 것입니다.</font>

637
00:24:16,859 --> 00:24:21,919
Because we know that different programs have different requirements and different goals

638
00:24:16,859 --> 00:24:21,919
<font color="#ffff54">프로그램마다 요구 사항과 목표가 다르다는 것을 알고 있기 때문에</font>

639
00:24:21,919 --> 00:24:26,099
and different performance needs.

640
00:24:21,919 --> 00:24:26,099
<font color="#ffff54">성능에 대한 요구사항도 다르기 때문입니다.</font>

641
00:24:26,100 --> 00:24:33,960
If you look at the extreme end of the spectrum, there's a somewhat severe constraint, which

642
00:24:26,100 --> 00:24:33,960
<font color="#ffff54">스펙트럼의 극단적인 끝을 보면 다소 심각한 제약이 있습니다.</font>

643
00:24:33,960 --> 00:24:39,580
is the closed world assumption that the native image tool makes.

644
00:24:33,960 --> 00:24:39,580
<font color="#ffff54">은 네이티브 이미지 도구의 닫힌 세계 가정입니다.</font>

645
00:24:39,580 --> 00:24:44,860
And this basically says, I promise there isn't going to be any dynamic class loading.

646
00:24:39,580 --> 00:24:44,860
<font color="#ffff54">이것은 기본적으로 동적 클래스 로딩이 없을 것이라고 약속합니다.</font>

647
00:24:44,860 --> 00:24:50,020
I promise that I'm not going to do any reflection except for the list of methods I give you.

648
00:24:44,860 --> 00:24:50,020
<font color="#ffff54">제가 알려드리는 메서드 목록 외에는 어떤 반성도 하지 않겠다고 약속드립니다.</font>

649
00:24:50,019 --> 00:24:58,139
And if you're willing to accept that constraint, then we can shift a great deal more computation

650
00:24:50,019 --> 00:24:58,139
<font color="#ffff54">만약 당신이 그 제약을 기꺼이 받아들인다면, 우리는 훨씬 더 많은 계산을 옮길 수 있어요.</font>

651
00:24:58,139 --> 00:25:00,740
from runtime to compile time.

652
00:24:58,139 --> 00:25:00,740
<font color="#ffff54">런타임에서 컴파일 타임으로 옮길 수 있습니다.</font>

653
00:25:00,740 --> 00:25:03,700
Not all applications are willing to live with such a constraint.

654
00:25:00,740 --> 00:25:03,700
<font color="#ffff54">모든 애플리케이션이 이러한 제약을 감수할 수 있는 것은 아닙니다.</font>

655
00:25:03,700 --> 00:25:10,059
And so what we want to do is explore a broader range of constraints that may start with no

656
00:25:03,700 --> 00:25:10,059
<font color="#ffff54">그래서 우리가 하고자 하는 것은 아니요로 시작할 수 있는 더 넓은 범위의 제약 조건을 탐색하는 것입니다.</font>

657
00:25:10,059 --> 00:25:11,859
constraints at all.

658
00:25:10,059 --> 00:25:11,859
<font color="#ffff54">제약 조건이 전혀 없을 수도 있습니다.</font>

659
00:25:11,859 --> 00:25:14,180
And maybe we can give you something with no constraints.

660
00:25:11,859 --> 00:25:14,180
<font color="#ffff54">어쩌면 제약 조건이 없는 것을 줄 수도 있습니다.</font>

661
00:25:14,180 --> 00:25:16,539
And then we can give you a little bit more with some constraints.

662
00:25:14,180 --> 00:25:16,539
<font color="#ffff54">그리고 약간의 제약이 있는 것을 조금 더 줄 수 있습니다.</font>

663
00:25:16,700 --> 00:25:20,420
And then we can give you a lot more if you accept a lot of constraints.

664
00:25:16,700 --> 00:25:20,420
<font color="#ffff54">그리고 많은 제약 조건을 받아들이면 더 많은 것을 줄 수 있습니다.</font>

665
00:25:20,420 --> 00:25:26,500
But the key is we want developers to be in charge of making these constraints and how

666
00:25:20,420 --> 00:25:26,500
<font color="#ffff54">하지만 핵심은 개발자가 이러한 제약 조건을 만들고 그 제약 조건을 어떻게</font>

667
00:25:26,500 --> 00:25:32,139
willing they are to trade functionality for performance.

668
00:25:26,500 --> 00:25:32,139
<font color="#ffff54">성능을 위해 기능을 희생할 의향이 있는지입니다.</font>

669
00:25:32,139 --> 00:25:41,059
So the sort of key concepts in this model are temporal shifting of computation, both

670
00:25:32,139 --> 00:25:41,059
<font color="#ffff54">따라서 이 모델의 핵심 개념은 계산의 시간적 이동입니다.</font>

671
00:25:41,059 --> 00:25:44,299
forward and backwards.

672
00:25:41,059 --> 00:25:44,299
<font color="#ffff54">앞뒤로 이동하는 것입니다.</font>

673
00:25:44,339 --> 00:25:50,740
Constraints on Java's dynamism as necessary to support the kinds of computation shifting

674
00:25:44,339 --> 00:25:50,740
<font color="#ffff54">연산 이동의 종류를 지원하는 데 필요한 Java의 역동성에 대한 제약 조건</font>

675
00:25:50,740 --> 00:25:56,779
that a user may say, I'd like to get this benefit and I'm willing to consent to the

676
00:25:50,740 --> 00:25:56,779
<font color="#ffff54">사용자가 이 혜택을 받고 싶다고 말할 수 있으며 기꺼이 동의합니다.</font>

677
00:25:56,779 --> 00:25:58,379
requirements.

678
00:25:56,779 --> 00:25:58,379
<font color="#ffff54">요구 사항에 동의합니다.</font>

679
00:25:58,379 --> 00:26:04,740
We also want developers to be able to choose which optimizations they want and not, which

680
00:25:58,379 --> 00:26:04,740
<font color="#ffff54">또한 개발자가 원하는 최적화와 그렇지 않은 최적화를 선택할 수 있기를 바랍니다.</font>

681
00:26:04,740 --> 00:26:07,299
constraints they're willing to accept and not.

682
00:26:04,740 --> 00:26:07,299
<font color="#ffff54">제약 조건을 받아들일지 말지 선택할 수 있기를 바랍니다.</font>

683
00:26:07,299 --> 00:26:10,259
And this always has to preserve the meaning of the program.

684
00:26:07,299 --> 00:26:10,259
<font color="#ffff54">그리고 이것은 항상 프로그램의 의미를 보존해야 합니다.</font>

685
00:26:10,259 --> 00:26:14,819
So these are the sort of ambitious goals of the project.

686
00:26:10,259 --> 00:26:14,819
<font color="#ffff54">이것이 이 프로젝트의 야심찬 목표입니다.</font>

687
00:26:14,819 --> 00:26:16,420
So how are we going to achieve this?

688
00:26:14,819 --> 00:26:16,420
<font color="#ffff54">그럼 어떻게 달성할 수 있을까요?</font>

689
00:26:16,420 --> 00:26:23,019
So a new concept that Leiden will introduce is a concept of a condenser.

690
00:26:16,420 --> 00:26:23,019
<font color="#ffff54">그래서 라이덴이 도입할 새로운 개념은 콘덴서라는 개념입니다.</font>

691
00:26:23,019 --> 00:26:30,140
A condenser is a tool that runs at build time or package time or something like that, that

692
00:26:23,019 --> 00:26:30,140
<font color="#ffff54">콘덴서는 빌드 시간이나 패키지 시간 또는 이와 유사한 시간에 실행되는 도구입니다.</font>

693
00:26:30,140 --> 00:26:35,140
takes a program image, performs some of the computation in that image, and creates a new

694
00:26:30,140 --> 00:26:35,140
<font color="#ffff54">프로그램 이미지를 가져와서, 그 이미지에서 일부 연산을 수행한 다음, 새로운 이미지를 만듭니다.</font>

695
00:26:35,220 --> 00:26:41,060
program image that embodies the result of that computation.

696
00:26:35,220 --> 00:26:41,060
<font color="#ffff54">프로그램 이미지를 새로 만듭니다.</font>

697
00:26:41,060 --> 00:26:45,340
That might be new code because we did some ahead of time compilation.

698
00:26:41,060 --> 00:26:45,340
<font color="#ffff54">미리 컴파일을 했기 때문에 새로운 코드일 수 있습니다.</font>

699
00:26:45,340 --> 00:26:48,020
That might be new data.

700
00:26:45,340 --> 00:26:48,020
<font color="#ffff54">새로운 데이터일 수 있습니다.</font>

701
00:26:48,020 --> 00:26:51,820
It might be new metadata like preloaded classes or pre-resolved call sites.

702
00:26:48,020 --> 00:26:51,820
<font color="#ffff54">미리 로드된 클래스나 미리 확인된 호출 사이트와 같은 새로운 메타데이터일 수 있습니다.</font>

703
00:26:51,820 --> 00:26:56,580
It may be new constraints.

704
00:26:51,820 --> 00:26:56,580
<font color="#ffff54">새로운 제약 조건일 수 있습니다.</font>

705
00:26:56,580 --> 00:27:01,060
The limitations on condensers is they have to be meaning preserving.

706
00:26:56,580 --> 00:27:01,060
<font color="#ffff54">콘덴서에 대한 제약은 보존을 의미해야 한다는 것입니다.</font>

707
00:27:01,060 --> 00:27:04,920
They can't do arbitrary transformations of the semantics of the program.

708
00:27:01,060 --> 00:27:04,920
<font color="#ffff54">프로그램의 의미를 임의로 변환할 수 없습니다.</font>

709
00:27:04,920 --> 00:27:09,100
The resulting image has to have the same meaning under the selected set of constraints.

710
00:27:04,920 --> 00:27:09,100
<font color="#ffff54">결과 이미지는 선택된 제약 조건 하에서 동일한 의미를 가져야 합니다.</font>

711
00:27:09,100 --> 00:27:14,100
We want condensation to be composable, that you can feed the output of one condenser into

712
00:27:09,100 --> 00:27:14,100
<font color="#ffff54">하나의 콘덴서의 출력을 다음에 공급할 수 있는 합성 가능한 콘덴서를 원합니다.</font>

713
00:27:14,100 --> 00:27:18,160
the input of another potentially multiple times if you have to.

714
00:27:14,100 --> 00:27:18,160
<font color="#ffff54">다른 콘덴서의 입력을 잠재적으로 여러 번 공급할 수 있어야 합니다.</font>

715
00:27:18,160 --> 00:27:22,519
And we want the users to be in charge of selecting how to condense and when.

716
00:27:18,160 --> 00:27:22,519
<font color="#ffff54">그리고 압축 방법과 시기는 사용자가 선택하도록 해야 합니다.</font>

717
00:27:22,519 --> 00:27:27,279
And like maybe if you're just doing testing or debugging, then you don't have to bother

718
00:27:22,519 --> 00:27:27,279
<font color="#ffff54">테스트나 디버깅만 하는 경우라면 굳이</font>

719
00:27:27,279 --> 00:27:28,279
with any condensation.

720
00:27:27,279 --> 00:27:28,279
<font color="#ffff54">응축이 있을 수 있습니다.</font>

721
00:27:28,279 --> 00:27:31,180
You can just run dynamically.

722
00:27:28,279 --> 00:27:31,180
<font color="#ffff54">동적으로 실행할 수 있습니다.</font>

723
00:27:31,340 --> 00:27:36,460
And to the degree that shifting computation may require accepting constraints, the condenser

724
00:27:31,340 --> 00:27:36,460
<font color="#ffff54">그리고 계산을 바꾸려면 제약 조건을 받아들여야 할 수도 있습니다.</font>

725
00:27:36,460 --> 00:27:44,539
configuration represents a certain set of tradeoffs between functionality and performance.

726
00:27:36,460 --> 00:27:44,539
<font color="#ffff54">구성은 기능과 성능 사이의 특정 트레이드 오프 세트를 나타냅니다.</font>

727
00:27:44,539 --> 00:27:46,840
So we already do some of this in the JDK today.

728
00:27:44,539 --> 00:27:46,840
<font color="#ffff54">그래서 우리는 이미 오늘날 JDK에서 이 중 일부를 수행하고 있습니다.</font>

729
00:27:46,840 --> 00:27:49,220
How many people here use AppCDS?

730
00:27:46,840 --> 00:27:49,220
<font color="#ffff54">얼마나 많은 사람들이 AppCDS를 사용하나요?</font>

731
00:27:49,220 --> 00:27:52,460
How many people here know what AppCDS is?

732
00:27:49,220 --> 00:27:52,460
<font color="#ffff54">AppCDS가 무엇인지 아는 사람이 몇 명인가요?</font>

733
00:27:52,460 --> 00:27:55,600
Okay, you guys are missing out on something here.

734
00:27:52,460 --> 00:27:55,600
<font color="#ffff54">좋아, 너희들 뭔가 놓치고 있구나.</font>

735
00:27:55,600 --> 00:28:00,860
So this is a feature that's been in the JDK for two decades.

736
00:27:55,600 --> 00:28:00,860
<font color="#ffff54">이 기능은 JDK에 20년 동안 있었던 기능입니다.</font>

737
00:28:00,860 --> 00:28:06,140
It started out as class data sharing, CDS, in the Java 5 timeframe.

738
00:28:00,860 --> 00:28:06,140
<font color="#ffff54">이 기능은 Java 5에서 클래스 데이터 공유인 CDS로 시작되었습니다.</font>

739
00:28:06,140 --> 00:28:11,980
And it's basically a startup cache where it takes class file bytes for common system classes

740
00:28:06,140 --> 00:28:11,980
<font color="#ffff54">그리고 기본적으로 공통 시스템 클래스에 대한 클래스 파일 바이트를 가져오는 시작 캐시입니다.</font>

741
00:28:11,980 --> 00:28:18,140
like string and integer and such that get loaded in every invocation and caches them

742
00:28:11,980 --> 00:28:18,140
<font color="#ffff54">모든 호출에서 로드되는 문자열과 정수 같은 것들을 캐시에 저장합니다.</font>

743
00:28:18,140 --> 00:28:21,380
in a binary file that can be used to improve startup.

744
00:28:18,140 --> 00:28:21,380
<font color="#ffff54">시작을 개선하는 데 사용할 수 있는 바이너리 파일에 저장합니다.</font>

745
00:28:21,380 --> 00:28:28,220
And because every invocation is going to load string and integer and security manager and

746
00:28:21,380 --> 00:28:28,220
<font color="#ffff54">그리고 모든 호출이 문자열과 정수를 로드하고 보안 관리자와</font>

747
00:28:28,299 --> 00:28:35,640
the same usual suspects, a few hundred classes, this was a significant performance improvement.

748
00:28:28,299 --> 00:28:35,640
<font color="#ffff54">수백 개의 클래스를 불러오기 때문에 성능이 크게 향상되었습니다.</font>

749
00:28:35,640 --> 00:28:38,259
But that's what CDS did 20 years ago.

750
00:28:35,640 --> 00:28:38,259
<font color="#ffff54">하지만 20년 전 CDS가 했던 일입니다.</font>

751
00:28:38,259 --> 00:28:41,220
CDS has improved dramatically over time.

752
00:28:38,259 --> 00:28:41,220
<font color="#ffff54">CDS는 시간이 지남에 따라 극적으로 개선되었습니다.</font>

753
00:28:41,220 --> 00:28:46,339
So in Java 8, it was enhanced to cache lab and proxy classes.

754
00:28:41,220 --> 00:28:46,339
<font color="#ffff54">그래서 Java 8에서는 랩 및 프록시 클래스를 캐시하도록 개선되었습니다.</font>

755
00:28:46,339 --> 00:28:52,700
In Java 10, there was added tooling so that you could say, hey, cache these classes too.

756
00:28:46,339 --> 00:28:52,700
<font color="#ffff54">Java 10에서는 이러한 클래스도 캐시할 수 있는 도구가 추가되었습니다.</font>

757
00:28:52,700 --> 00:28:53,900
Here are my application classes.

758
00:28:52,700 --> 00:28:53,900
<font color="#ffff54">다음은 제 애플리케이션 클래스입니다.</font>

759
00:28:53,900 --> 00:28:55,640
I know we're going to get loaded at startup.

760
00:28:53,900 --> 00:28:55,640
<font color="#ffff54">시작하면 부하가 걸릴 것 같아.</font>

761
00:28:55,640 --> 00:28:59,000
Just put them in the app CDS archive as well.

762
00:28:55,640 --> 00:28:59,000
<font color="#ffff54">앱 CDS 아카이브에도 넣어주세요.</font>

763
00:28:59,000 --> 00:29:05,560
And then in Java 12, we added caching the module graph as well.

764
00:28:59,000 --> 00:29:05,560
<font color="#ffff54">그리고 Java 12에서는 모듈 그래프 캐싱도 추가했습니다.</font>

765
00:29:05,560 --> 00:29:12,680
So this is a mechanism that stood us really well for a long period of time that has allowed

766
00:29:05,560 --> 00:29:12,680
<font color="#ffff54">이 메커니즘은 오랜 기간 동안 우리를 정말 잘 버텨준 메커니즘입니다.</font>

767
00:29:12,680 --> 00:29:19,200
us to shift computation to build time to accelerate startup.

768
00:29:12,680 --> 00:29:19,200
<font color="#ffff54">계산을 전환하여 시작을 가속화할 수 있는 시간을 확보할 수 있었습니다.</font>

769
00:29:19,200 --> 00:29:24,920
And so if this has been working so well, let's double down on that and let's use that for

770
00:29:19,200 --> 00:29:24,920
<font color="#ffff54">이 방법이 잘 작동하고 있다면, 이 방법을 두 배로 늘려서</font>

771
00:29:24,920 --> 00:29:30,920
caching other things that can improve startup like profile data, like compiled code, like

772
00:29:24,920 --> 00:29:30,920
<font color="#ffff54">프로파일 데이터, 컴파일된 코드와 같이 시작을 향상시킬 수 있는 다른 것들을 캐싱합니다.</font>

773
00:29:30,920 --> 00:29:35,480
linkage resolution for method invocations.

774
00:29:30,920 --> 00:29:35,480
<font color="#ffff54">메서드 호출에 대한 연결 해결.</font>

775
00:29:35,480 --> 00:29:43,039
So the way app CDS works is there's an archive file, which is a big file containing cached

776
00:29:35,480 --> 00:29:43,039
<font color="#ffff54">앱 CDS가 작동하는 방식은 아카이브 파일이 있고, 이 파일에는 캐시된 메소드가 포함된 큰 파일이 있습니다.</font>

777
00:29:43,039 --> 00:29:44,360
metadata.

778
00:29:43,039 --> 00:29:44,360
<font color="#ffff54">메타데이터가 들어있는 큰 파일입니다.</font>

779
00:29:44,360 --> 00:29:49,720
It gets memory mapped at runtime and is used to accelerate today class loading and tomorrow

780
00:29:44,360 --> 00:29:49,720
<font color="#ffff54">런타임에 메모리 매핑되어 오늘 클래스 로딩과 내일 로딩을 가속하는 데 사용됩니다.</font>

781
00:29:49,720 --> 00:29:51,140
more things.

782
00:29:49,720 --> 00:29:51,140
<font color="#ffff54">더 많은 것들.</font>

783
00:29:51,140 --> 00:29:55,620
The JDK has a default archive, which is built when the JDK is built.

784
00:29:51,140 --> 00:29:55,620
<font color="#ffff54">JDK에는 JDK를 빌드할 때 빌드되는 기본 아카이브가 있습니다.</font>

785
00:29:55,620 --> 00:30:00,820
That happens before you download the JDK.

786
00:29:55,620 --> 00:30:00,820
<font color="#ffff54">JDK를 다운로드하기 전에 발생합니다.</font>

787
00:30:00,820 --> 00:30:03,340
It's when we actually build the JDK image.

788
00:30:00,820 --> 00:30:03,340
<font color="#ffff54">실제로 JDK 이미지를 빌드할 때입니다.</font>

789
00:30:03,340 --> 00:30:05,100
And that will always get used unless you turn it off.

790
00:30:03,340 --> 00:30:05,100
<font color="#ffff54">그리고 끄지 않는 한 항상 사용됩니다.</font>

791
00:30:05,100 --> 00:30:06,820
You can turn it off.

792
00:30:05,100 --> 00:30:06,820
<font color="#ffff54">꺼도 됩니다.</font>

793
00:30:06,820 --> 00:30:10,060
And it contains metadata just on JDK classes.

794
00:30:06,820 --> 00:30:10,060
<font color="#ffff54">그리고 JDK 클래스에만 메타데이터가 포함되어 있습니다.</font>

795
00:30:10,060 --> 00:30:14,540
But you can select with a command line switch a different archive file.

796
00:30:10,060 --> 00:30:14,540
<font color="#ffff54">하지만 명령줄 스위치로 다른 아카이브 파일을 선택할 수 있습니다.</font>

797
00:30:14,540 --> 00:30:18,940
And you can create your own archive files and specify which classes to pre-process,

798
00:30:14,540 --> 00:30:18,940
<font color="#ffff54">또한 직접 아카이브 파일을 생성하고 전처리할 클래스를 지정할 수도 있습니다,</font>

799
00:30:18,980 --> 00:30:23,100
which includes both JDK classes and your application classes.

800
00:30:18,980 --> 00:30:23,100
<font color="#ffff54">여기에는 JDK 클래스와 애플리케이션 클래스가 모두 포함됩니다.</font>

801
00:30:23,100 --> 00:30:29,100
Now as the show of hands showed, most people aren't using this today.

802
00:30:23,100 --> 00:30:29,100
<font color="#ffff54">손짓을 통해 알 수 있듯이 오늘날 대부분의 사람들은 이것을 사용하지 않습니다.</font>

803
00:30:29,100 --> 00:30:35,100
And they probably should because you can get a reasonable startup improvement for a very,

804
00:30:29,100 --> 00:30:35,100
<font color="#ffff54">그리고 그들은 아마 그렇게 해야 할 것입니다. 왜냐하면 당신은 매우 합리적인 시작 개선을 얻을 수 있기 때문입니다,</font>

805
00:30:35,100 --> 00:30:37,059
very small amount of work.

806
00:30:35,100 --> 00:30:37,059
<font color="#ffff54">아주 적은 양의 작업으로.</font>

807
00:30:37,059 --> 00:30:38,900
It's not going to work miracles.

808
00:30:37,059 --> 00:30:38,900
<font color="#ffff54">기적이 일어나진 않을 거야.</font>

809
00:30:38,900 --> 00:30:45,779
But if it shaves 10%, 20%, 30% off startup, that may be enough for a lot of applications.

810
00:30:38,900 --> 00:30:45,779
<font color="#ffff54">하지만 시작 시간을 10%, 20%, 30% 줄인다면 많은 애플리케이션에 적용하기에 충분할 수 있습니다.</font>

811
00:30:45,779 --> 00:30:51,779
So I'll give you a flavor for what these configuration flags look like.

812
00:30:45,779 --> 00:30:51,779
<font color="#ffff54">이 구성 플래그가 어떻게 생겼는지 맛보기로 보여드리겠습니다.</font>

813
00:30:51,779 --> 00:30:54,700
They're not all that pretty.

814
00:30:51,779 --> 00:30:54,700
<font color="#ffff54">그렇게 예쁘진 않네요.</font>

815
00:30:54,700 --> 00:30:59,940
So if you were going to use AppCDS today, you would perform one or more training runs,

816
00:30:54,700 --> 00:30:59,940
<font color="#ffff54">오늘 AppCDS를 사용하려면 하나 이상의 트레이닝 실행을 수행해야 합니다,</font>

817
00:30:59,940 --> 00:31:04,619
like running a unit test or something like that, with a flag that says, dump out the

818
00:30:59,940 --> 00:31:04,619
<font color="#ffff54">단위 테스트 등을 실행하는 것과 같은 작업을 수행해야 합니다.</font>

819
00:31:04,619 --> 00:31:07,019
classes that were loaded.

820
00:31:04,619 --> 00:31:07,019
<font color="#ffff54">로드된 클래스를 덤프합니다.</font>

821
00:31:07,019 --> 00:31:08,660
And it'll dump them out to a file.

822
00:31:07,019 --> 00:31:08,660
<font color="#ffff54">그리고 파일로 덤프합니다.</font>

823
00:31:08,660 --> 00:31:09,660
It's just a text file.

824
00:31:08,660 --> 00:31:09,660
<font color="#ffff54">그냥 텍스트 파일입니다.</font>

825
00:31:09,660 --> 00:31:12,259
So you can edit it and merge them and whatever you want to do.

826
00:31:09,660 --> 00:31:12,259
<font color="#ffff54">그러니 편집하고 병합하는 등 원하는 대로 할 수 있습니다.</font>

827
00:31:12,259 --> 00:31:17,099
And then there's another set of flags where you can say, take this list of classes and

828
00:31:12,259 --> 00:31:17,099
<font color="#ffff54">그리고 또 다른 플래그 세트가 있는데, 이 클래스 목록을 가지고 다음과 같이 말할 수 있습니다.</font>

829
00:31:17,099 --> 00:31:23,099
create a AppCDS archive that caches the loading of those classes.

830
00:31:17,099 --> 00:31:23,099
<font color="#ffff54">해당 클래스의 로딩을 캐시하는 AppCDS 아카이브를 생성합니다.</font>

831
00:31:23,099 --> 00:31:26,420
And then you distribute that archive with your program.

832
00:31:23,099 --> 00:31:26,420
<font color="#ffff54">그리고 그 아카이브를 프로그램과 함께 배포합니다.</font>

833
00:31:26,420 --> 00:31:33,819
And your run script specifies that CDS archive when it goes to run your program and your

834
00:31:26,420 --> 00:31:33,819
<font color="#ffff54">그리고 실행 스크립트에서 프로그램을 실행할 때 해당 CDS 아카이브를 지정하고</font>

835
00:31:33,819 --> 00:31:34,900
program gets faster.

836
00:31:33,819 --> 00:31:34,900
<font color="#ffff54">프로그램이 더 빨라집니다.</font>

837
00:31:34,900 --> 00:31:41,019
So to give you an example of the orders of magnitude that you might see with this, so

838
00:31:34,900 --> 00:31:41,019
<font color="#ffff54">이를 통해 볼 수 있는 크기의 순서를 예로 들어보면 다음과 같습니다.</font>

839
00:31:41,059 --> 00:31:50,059
Java C compiling one file, not a bad startup test, with CDS explicitly disabled on somebody's

840
00:31:41,059 --> 00:31:50,059
<font color="#ffff54">CDS가 명시적으로 비활성화된 상태에서 시작 테스트가 아닌 하나의 파일을 컴파일하는 Java C의 경우</font>

841
00:31:50,059 --> 00:31:53,180
laptop, we got 300 milliseconds.

842
00:31:50,059 --> 00:31:53,180
<font color="#ffff54">노트북에서 300밀리초가 걸렸습니다.</font>

843
00:31:53,180 --> 00:31:58,740
With the default CDS, we got 260 milliseconds.

844
00:31:53,180 --> 00:31:58,740
<font color="#ffff54">기본 CDS를 사용하면 260밀리초입니다.</font>

845
00:31:58,740 --> 00:32:03,460
So that's like a 15% improvement, not so bad.

846
00:31:58,740 --> 00:32:03,460
<font color="#ffff54">15% 정도 개선되었으니 나쁘지 않은 수준입니다.</font>

847
00:32:03,460 --> 00:32:08,900
With AppCDS that did a training run that included the Java C classes that got loaded during

848
00:32:03,460 --> 00:32:08,900
<font color="#ffff54">425 동안 로드된 Java C 클래스를 포함하는 트레이닝 실행을 수행한 AppCDS를 사용했습니다.</font>

849
00:32:08,900 --> 00:32:18,460
compilation, we managed to knock 50% off the startup of the cold start alternative.

850
00:32:08,900 --> 00:32:18,460
<font color="#ffff54">컴파일을 통해 콜드 스타트 대안의 시작 시간을 50% 단축할 수 있었습니다.</font>

851
00:32:18,460 --> 00:32:23,660
And so this doesn't necessarily get you everything you want, but it's something that you've been

852
00:32:18,460 --> 00:32:23,660
<font color="#ffff54">이 방법으로 원하는 모든 것을 얻을 수 있는 것은 아니지만, 이 방법을 통해</font>

853
00:32:23,660 --> 00:32:25,500
able to do for a long time.

854
00:32:23,660 --> 00:32:25,500
<font color="#ffff54">오랫동안 할 수 있는 일이죠.</font>

855
00:32:25,500 --> 00:32:28,060
And it gets you quite a lot for a relatively little work.

856
00:32:25,500 --> 00:32:28,060
<font color="#ffff54">비교적 적은 양의 작업으로 많은 것을 얻을 수 있습니다.</font>

857
00:32:28,060 --> 00:32:34,300
So it may be that we take all of this and we turn it into a condenser as part of the

858
00:32:28,060 --> 00:32:34,300
<font color="#ffff54">그래서 우리는 이 모든 것을 가져다가 응축기로 바꾸어</font>

859
00:32:34,300 --> 00:32:38,660
early work in Project Leiden.

860
00:32:34,300 --> 00:32:38,660
<font color="#ffff54">프로젝트 라이덴의 초기 작업입니다.</font>

861
00:32:38,660 --> 00:32:46,860
Most all interesting techniques for startup improvement rely at some level on training

862
00:32:38,660 --> 00:32:46,860
<font color="#ffff54">스타트업을 개선하기 위한 흥미로운 기술들은 대부분 어느 정도는 교육에 의존한다.</font>

863
00:32:46,860 --> 00:32:51,580
runs, which is to actually run some part of the program and observe what it did, observe

864
00:32:46,860 --> 00:32:51,580
<font color="#ffff54">실행, 즉 실제로 프로그램의 일부를 실행하고 그것이 무엇을했는지 관찰하고 관찰하는 것입니다.</font>

865
00:32:51,580 --> 00:32:56,820
what classes it loads, observe what methods are hot, which is basically allowing us to

866
00:32:51,580 --> 00:32:56,820
<font color="#ffff54">어떤 클래스를 로드하는지, 어떤 메서드가 핫한지 관찰하는 것입니다.</font>

867
00:32:56,820 --> 00:33:02,220
discover ahead of time what we would otherwise discover when we run the program dynamically.

868
00:32:56,820 --> 00:33:02,220
<font color="#ffff54">프로그램을 동적으로 실행할 때 발견할 수 있는 것을 미리 발견할 수 있습니다.</font>

869
00:33:02,220 --> 00:33:06,660
So you write a small driver program, which you might be able to reuse an integration

870
00:33:02,220 --> 00:33:06,660
<font color="#ffff54">따라서 통합을 재사용할 수 있는 작은 드라이버 프로그램을 작성합니다.</font>

871
00:33:07,660 --> 00:33:12,700
And as part of your build, you run the training run, it dumps some data out, and then you

872
00:33:07,660 --> 00:33:12,700
<font color="#ffff54">그리고 빌드의 일부로 트레이닝 실행을 실행하고 일부 데이터를 덤프한 다음</font>

873
00:33:12,700 --> 00:33:15,900
do something with that data.

874
00:33:12,700 --> 00:33:15,900
<font color="#ffff54">그 데이터로 뭔가를 하죠.</font>

875
00:33:15,900 --> 00:33:20,019
It's a very effective technique for the same reason dynamic compilation is effective, because

876
00:33:15,900 --> 00:33:20,019
<font color="#ffff54">동적 컴파일이 효과적인 이유와 같은 이유로 매우 효과적인 기술입니다.</font>

877
00:33:20,019 --> 00:33:25,100
it allows us to base analysis and optimization on what does the program actually do, not

878
00:33:20,019 --> 00:33:25,100
<font color="#ffff54">이 아니라 프로그램이 실제로 수행하는 작업을 기반으로 분석과 최적화를 수행할 수 있기 때문입니다.</font>

879
00:33:25,100 --> 00:33:28,040
just what does the program say.

880
00:33:25,100 --> 00:33:28,040
<font color="#ffff54">프로그램이 무엇을 말하는지.</font>

881
00:33:28,039 --> 00:33:36,559
So as a kind of experiment in the last few months, we've been trying to identify what

882
00:33:28,039 --> 00:33:36,559
<font color="#ffff54">그래서 지난 몇 달 동안 일종의 실험으로, 우리는 무엇을 확인하려고 노력해왔습니다.</font>

883
00:33:36,559 --> 00:33:43,319
can we do about startup at the least constraining end of the spectrum.

884
00:33:36,559 --> 00:33:43,319
<font color="#ffff54">스펙트럼의 제약을 가장 적게 받으면서 시작할 수 있는 방법이 무엇인지 알아보고 있습니다.</font>

885
00:33:43,319 --> 00:33:48,680
Let's assume we're not willing to impose any new constraints, not change the spec, not

886
00:33:43,319 --> 00:33:48,680
<font color="#ffff54">새로운 제약을 가하지 않고 사양을 변경하지 않는다고 가정해 봅시다.</font>

887
00:33:48,680 --> 00:33:53,039
sacrifice any dynamism, not give up on running any Java code.

888
00:33:48,680 --> 00:33:53,039
<font color="#ffff54">역동성을 희생하지 않고, 자바 코드 실행을 포기하지 않습니다.</font>

889
00:33:53,039 --> 00:33:54,659
How far can we get?

890
00:33:53,039 --> 00:33:54,659
<font color="#ffff54">얼마나 멀리 갈 수 있을까요?</font>

891
00:33:54,660 --> 00:34:00,420
So I have some experimental numbers that I'll show you, but first I want to talk a little

892
00:33:54,660 --> 00:34:00,420
<font color="#ffff54">몇 가지 실험적인 수치를 보여드리겠습니다만, 그 전에 잠깐 이야기하고 싶습니다.</font>

893
00:34:00,420 --> 00:34:03,980
bit about how dynamic compilation actually works.

894
00:34:00,420 --> 00:34:03,980
<font color="#ffff54">동적 컴파일이 실제로 어떻게 작동하는지에 대해 조금 설명하겠습니다.</font>

895
00:34:03,980 --> 00:34:08,980
So in the Hotspot JVM, there are a number of tiers used for compilation.

896
00:34:03,980 --> 00:34:08,980
<font color="#ffff54">핫스팟 JVM에는 컴파일에 사용되는 여러 계층이 있습니다.</font>

897
00:34:08,980 --> 00:34:11,420
Tier 0 is the interpreter.

898
00:34:08,980 --> 00:34:11,420
<font color="#ffff54">티어 0은 인터프리터입니다.</font>

899
00:34:11,420 --> 00:34:14,460
We have two compilers.

900
00:34:11,420 --> 00:34:14,460
<font color="#ffff54">컴파일러가 두 개 있습니다.</font>

901
00:34:14,460 --> 00:34:22,500
C1 is a fast compiler that produces OK code, and then C2 or the GROL JIT are highly optimizing

902
00:34:14,460 --> 00:34:22,500
<font color="#ffff54">C1은 OK 코드를 생성하는 빠른 컴파일러이고, C2 또는 GROL JIT는 고도로 최적화되어 있습니다.</font>

903
00:34:22,500 --> 00:34:27,400
compilers that produce awesome code, but they take longer to run.

904
00:34:22,500 --> 00:34:27,400
<font color="#ffff54">컴파일러는 멋진 코드를 생성하지만 실행하는 데 시간이 오래 걸립니다.</font>

905
00:34:27,400 --> 00:34:31,019
So tier 0 is interpretation.

906
00:34:27,400 --> 00:34:31,019
<font color="#ffff54">따라서 계층 0은 해석입니다.</font>

907
00:34:31,019 --> 00:34:39,519
Tiers 1 through 3 are various configurations of the C1 compiler, and tier 4 is using the

908
00:34:31,019 --> 00:34:39,519
<font color="#ffff54">티어 1부터 3까지는 C1 컴파일러의 다양한 구성이고, 티어 4는</font>

909
00:34:39,519 --> 00:34:46,500
highly optimizing C2 or GROL JITs that benefit from profiling information gathered by running

910
00:34:39,519 --> 00:34:46,500
<font color="#ffff54">를 실행하여 수집한 프로파일링 정보의 이점을 활용하는 고도로 최적화된 C2 또는 GROL JIT를 사용합니다.</font>

911
00:34:46,500 --> 00:34:51,780
in the interpreter or running C1 compiled code, but in general don't collect nearly

912
00:34:46,500 --> 00:34:51,780
<font color="#ffff54">인터프리터에서 실행하거나 C1 컴파일된 코드를 실행하여 수집한 정보를 활용하지만, 일반적으로는 거의 수집하지 않습니다.</font>

913
00:34:51,780 --> 00:34:57,440
as much profile information.

914
00:34:51,780 --> 00:34:57,440
<font color="#ffff54">만큼 많은 프로필 정보를 수집하지 않습니다.</font>

915
00:34:57,440 --> 00:35:01,560
So startup mostly happens in tier 0 through 3.

916
00:34:57,440 --> 00:35:01,560
<font color="#ffff54">따라서 시작은 대부분 티어 0에서 3에서 발생합니다.</font>

917
00:35:01,560 --> 00:35:05,840
So we start with the interpreter, and then we graduate to C1, and then eventually we

918
00:35:01,560 --> 00:35:05,840
<font color="#ffff54">그래서 우리는 통역사부터 시작해서 C1로 졸업하고, 결국에는 다음과 같이 됩니다.</font>

919
00:35:05,840 --> 00:35:12,100
figure out what code is hot, and we compile it with C2 or GROL.

920
00:35:05,840 --> 00:35:12,100
<font color="#ffff54">어떤 코드가 핫한지 알아내서 C2나 GROL로 컴파일합니다.</font>

921
00:35:12,100 --> 00:35:19,280
And during that time, a lot of things like symbolic resolution, symbolic linkage, class

922
00:35:12,100 --> 00:35:19,280
<font color="#ffff54">그리고 그 시간 동안 심볼릭 분해, 심볼릭 연결, 클래스</font>

923
00:35:19,780 --> 00:35:20,780
initializers get run.

924
00:35:19,780 --> 00:35:20,780
<font color="#ffff54">이니셜라이저가 실행됩니다.</font>

925
00:35:20,780 --> 00:35:23,880
This all happens in the interpreter or in C1 usually.

926
00:35:20,780 --> 00:35:23,880
<font color="#ffff54">이 모든 것은 인터프리터나 C1에서 보통 발생합니다.</font>

927
00:35:23,880 --> 00:35:28,000
Warm-up happens as the code we're running shifts from the lower tiers to the higher

928
00:35:23,880 --> 00:35:28,000
<font color="#ffff54">실행 중인 코드가 하위 계층에서 상위 계층으로 이동하면서 워밍업이 발생합니다.</font>

929
00:35:28,000 --> 00:35:29,000
tiers.

930
00:35:28,000 --> 00:35:29,000
<font color="#ffff54">티어.</font>

931
00:35:29,000 --> 00:35:31,560
We use the lower tiers to gather profiling information.

932
00:35:29,000 --> 00:35:31,560
<font color="#ffff54">프로파일링 정보를 수집하기 위해 하위 계층을 사용합니다.</font>

933
00:35:31,560 --> 00:35:34,740
The JIT then uses that to make better optimizing decisions.

934
00:35:31,560 --> 00:35:34,740
<font color="#ffff54">그런 다음 JIT는 이를 사용하여 더 나은 최적화 결정을 내립니다.</font>

935
00:35:34,740 --> 00:35:41,600
And the reason that we do this in a tiered fashion is if we gather profiling information

936
00:35:34,740 --> 00:35:41,600
<font color="#ffff54">이 작업을 계층화된 방식으로 수행하는 이유는 프로파일링 정보를 수집하면 다음과 같습니다.</font>

937
00:35:41,600 --> 00:35:48,300
early, we can make better compilation decisions when we run the more expensive compiler.

938
00:35:41,600 --> 00:35:48,300
<font color="#ffff54">더 비싼 컴파일러를 실행할 때 더 나은 컴파일 결정을 내릴 수 있기 때문입니다.</font>

939
00:35:48,320 --> 00:35:53,820
And peak performance is reached when all the hot code stabilizes in tier 4.

940
00:35:48,320 --> 00:35:53,820
<font color="#ffff54">그리고 모든 핫 코드가 티어 4에서 안정화되면 최고 성능에 도달합니다.</font>

941
00:35:53,820 --> 00:35:59,580
JIT compilation is what we call speculative, which means the machine code that we generate,

942
00:35:53,820 --> 00:35:59,580
<font color="#ffff54">JIT 컴파일은 우리가 생성하는 머신 코드를 의미하는 추측성 컴파일입니다,</font>

943
00:35:59,580 --> 00:36:02,220
we're always free to throw away.

944
00:35:59,580 --> 00:36:02,220
<font color="#ffff54">우리는 언제나 자유롭게 버릴 수 있습니다.</font>

945
00:36:02,220 --> 00:36:03,700
And then we just bounce back to a lower tier.

946
00:36:02,220 --> 00:36:03,700
<font color="#ffff54">그리고 더 낮은 계층으로 되돌아갑니다.</font>

947
00:36:03,700 --> 00:36:04,700
We go back to the interpreter.

948
00:36:03,700 --> 00:36:04,700
<font color="#ffff54">다시 통역사로 돌아갑니다.</font>

949
00:36:04,700 --> 00:36:06,580
We go back to C1.

950
00:36:04,700 --> 00:36:06,580
<font color="#ffff54">C1로 돌아갑니다.</font>

951
00:36:06,580 --> 00:36:10,900
And there are many reasons why we might deoptimize and go back to a lower tier.

952
00:36:06,580 --> 00:36:10,900
<font color="#ffff54">최적화를 해제하고 더 낮은 계층으로 돌아가는 데는 여러 가지 이유가 있습니다.</font>

953
00:36:10,900 --> 00:36:14,800
Maybe there was an environmental change, like a new class got loaded that violated one of

954
00:36:10,900 --> 00:36:14,800
<font color="#ffff54">다음 중 하나를 위반하는 새로운 클래스가 로드되는 등 환경 변화가 있었을 수도 있습니다.</font>

955
00:36:14,800 --> 00:36:16,160
our assumptions.

956
00:36:14,800 --> 00:36:16,160
<font color="#ffff54">우리의 가정.</font>

957
00:36:16,159 --> 00:36:22,139
Maybe profiling data told us the code that we compiled before is no longer optimal.

958
00:36:16,159 --> 00:36:22,139
<font color="#ffff54">프로파일링 데이터를 통해 이전에 컴파일한 코드가 더 이상 최적이 아니라는 것을 알 수 있습니다.</font>

959
00:36:22,139 --> 00:36:25,339
Maybe we ran out of space in the code cache and had to make more room.

960
00:36:22,139 --> 00:36:25,339
<font color="#ffff54">코드 캐시의 공간이 부족해서 더 많은 공간을 확보해야 할 수도 있습니다.</font>

961
00:36:25,339 --> 00:36:30,279
Maybe the user is using the debugger, and that caused some code to deoptimize.

962
00:36:25,339 --> 00:36:30,279
<font color="#ffff54">사용자가 디버거를 사용 중이어서 일부 코드가 최적화되지 않았을 수 있습니다.</font>

963
00:36:30,279 --> 00:36:34,159
So JIT compilation, it's pure optimization.

964
00:36:30,279 --> 00:36:34,159
<font color="#ffff54">그래서 JIT 컴파일은 순수한 최적화입니다.</font>

965
00:36:34,159 --> 00:36:38,239
It's one that we can freely do or undo.

966
00:36:34,159 --> 00:36:38,239
<font color="#ffff54">우리가 자유롭게 실행하거나 취소할 수 있는 작업입니다.</font>

967
00:36:38,239 --> 00:36:45,000
So since we said, what can we do that doesn't involve any changes to the programming model

968
00:36:38,239 --> 00:36:45,000
<font color="#ffff54">프로그래밍 모델을 변경하지 않고도 할 수 있는 일은 무엇일까요?</font>

969
00:36:45,000 --> 00:36:50,980
or to the code, we want to lean as heavily as we can on existing components in the VM,

970
00:36:50,980 --> 00:36:53,619
like CDS and like our JITs.

971
00:36:50,980 --> 00:36:53,619
<font color="#ffff54">CDS나 JIT처럼요.</font>

972
00:36:53,619 --> 00:37:04,659
And so what we did is basically taught CDS to gather additional information that is discovered

973
00:36:53,619 --> 00:37:04,659
<font color="#ffff54">그래서 우리가 한 일은 기본적으로 CDS가 발견되는 추가 정보를 수집하도록 가르친 것입니다.</font>

974
00:37:04,659 --> 00:37:13,659
during a training run, like invocation profiles, like JIT compiled code, like class mirrors,

975
00:37:04,659 --> 00:37:13,659
<font color="#ffff54">호출 프로파일, JIT 컴파일 코드, 클래스 미러와 같은 추가 정보를 수집하도록 학습시켰습니다,</font>

976
00:37:13,659 --> 00:37:21,679
like foo.class, resolved constant pool entries, resolved linkage states, pre-initialization

977
00:37:13,659 --> 00:37:21,679
<font color="#ffff54">foo.class, 해결된 상수 풀 항목, 해결된 연결 상태, 사전 초기화 등</font>

978
00:37:21,679 --> 00:37:25,019
of some of the simplest classes.

979
00:37:21,679 --> 00:37:25,019
<font color="#ffff54">가장 간단한 클래스 중 일부입니다.</font>

980
00:37:25,019 --> 00:37:32,099
And then when we go to load a class, or we can look in the CDS archive and say, do we

981
00:37:25,019 --> 00:37:32,099
<font color="#ffff54">그리고 나서 클래스를 로드하거나 CDS 아카이브를 살펴볼 때 다음과 같이 말할 수 있습니다.</font>

982
00:37:32,099 --> 00:37:33,500
already have the metadata for this?

983
00:37:32,099 --> 00:37:33,500
<font color="#ffff54">이미 메타데이터가 있나?</font>

984
00:37:33,500 --> 00:37:34,899
Great, we'll just reuse that.

985
00:37:33,500 --> 00:37:34,899
<font color="#ffff54">좋아요, 그냥 재사용하면 되겠네요.</font>

986
00:37:34,899 --> 00:37:36,500
Do I have JIT code for it?

987
00:37:34,899 --> 00:37:36,500
<font color="#ffff54">JIT 코드가 있나요?</font>

988
00:37:36,500 --> 00:37:40,079
Fantastic, I'll just use that.

989
00:37:36,500 --> 00:37:40,079
<font color="#ffff54">멋지네요, 그냥 사용하겠습니다.</font>

990
00:37:40,079 --> 00:37:46,880
And so this is basically another big computation shifting trick where we cache profiles and

991
00:37:40,079 --> 00:37:46,880
<font color="#ffff54">이것은 기본적으로 프로필을 캐싱하고, 프로필과</font>

992
00:37:46,880 --> 00:37:54,119
compiled code and linkage states from the training run and we reuse them in later runs.

993
00:37:46,880 --> 00:37:54,119
<font color="#ffff54">트레이닝 실행에서 컴파일된 코드와 연결 상태를 캐시하고 이후 실행에서 재사용합니다.</font>

994
00:37:54,119 --> 00:37:57,079
And there's a lot of different ways to slice and dice this.

995
00:37:54,119 --> 00:37:57,079
<font color="#ffff54">이를 잘게 쪼개서 분석하는 방법에는 여러 가지가 있습니다.</font>

996
00:37:57,079 --> 00:38:06,119
We could use this information not to cache JIT code, but to do better scheduling of compilation.

997
00:37:57,079 --> 00:38:06,119
<font color="#ffff54">이 정보를 JIT 코드를 캐시하는 것이 아니라 컴파일 스케줄링을 개선하는 데 사용할 수 있습니다.</font>

998
00:38:06,119 --> 00:38:10,239
Or we could load JIT code from the archive.

999
00:38:06,119 --> 00:38:10,239
<font color="#ffff54">아니면 아카이브에서 JIT 코드를 로드할 수도 있습니다.</font>

1000
00:38:10,239 --> 00:38:17,900
And there's also tricks that we can do about, do we delay loading the code until all its

1001
00:38:10,239 --> 00:38:17,900
<font color="#ffff54">그리고 우리가 할 수 있는 트릭도 있는데, 코드를 모든</font>

1002
00:38:17,900 --> 00:38:22,619
preconditions are met, like all the classes on which it depends is initialized?

1003
00:38:17,900 --> 00:38:22,619
<font color="#ffff54">전제 조건이 모두 충족될 때까지 로딩을 지연시킬 수 있을까요?</font>

1004
00:38:22,619 --> 00:38:28,079
There's a lot of tricks that we can do with existing concepts in the runtime.

1005
00:38:22,619 --> 00:38:28,079
<font color="#ffff54">런타임에 기존 개념으로 할 수 있는 트릭이 많이 있습니다.</font>

1006
00:38:28,079 --> 00:38:34,239
The cool thing about this is all of this is still speculative.

1007
00:38:28,079 --> 00:38:34,239
<font color="#ffff54">멋진 점은 이 모든 것이 아직 추측에 불과하다는 겁니다.</font>

1008
00:38:34,240 --> 00:38:40,920
And so a cache profile or a cached code is a record of a dynamic observation of an application

1009
00:38:34,240 --> 00:38:40,920
<font color="#ffff54">따라서 캐시 프로파일 또는 캐시 코드는 애플리케이션의 동적 관찰에 대한 기록입니다.</font>

1010
00:38:40,920 --> 00:38:42,640
from a previous run.

1011
00:38:40,920 --> 00:38:42,640
<font color="#ffff54">이전 실행에서</font>

1012
00:38:42,640 --> 00:38:48,960
So we can use this information the same way, maybe with a little bit less confidence, as

1013
00:38:42,640 --> 00:38:48,960
<font color="#ffff54">따라서 이 정보를 동일한 방식으로, 아마도 조금 덜 신뢰하지만 다음과 같이 사용할 수 있습니다.</font>

1014
00:38:48,960 --> 00:38:53,280
we do for profile information gathered in the current run.

1015
00:38:48,960 --> 00:38:53,280
<font color="#ffff54">현재 실행에서 수집한 프로필 정보에 대해 하는 것과 같은 방식으로 사용할 수 있습니다.</font>

1016
00:38:53,280 --> 00:38:58,160
And if it turns out this doesn't work, if one of our assumptions is violated, we still

1017
00:38:53,280 --> 00:38:58,160
<font color="#ffff54">만약 이것이 작동하지 않거나 가정 중 하나가 위반되는 것으로 판명되면, 우리는 여전히</font>

1018
00:38:58,160 --> 00:39:02,300
have the option to deoptimize, reprofile, reoptimize, et cetera.

1019
00:38:58,160 --> 00:39:02,300
<font color="#ffff54">최적화 해제, 재파일, 재최적화 등을 할 수 있는 옵션이 있습니다.</font>

1020
00:39:02,300 --> 00:39:07,580
And so this is an approach that deals really well with surprises at runtime.

1021
00:39:02,300 --> 00:39:07,580
<font color="#ffff54">따라서 이 방법은 런타임에 발생하는 돌발 상황에 매우 잘 대처하는 접근 방식입니다.</font>

1022
00:39:07,580 --> 00:39:10,960
Because things do change between training time and production, and we don't want the

1023
00:39:07,580 --> 00:39:10,960
<font color="#ffff54">훈련 시간과 프로덕션 시간 사이에 상황이 변하기 때문에, 우리는</font>

1024
00:39:10,960 --> 00:39:12,900
application to fall over and break.

1025
00:39:10,960 --> 00:39:12,900
<font color="#ffff54">응용 프로그램이 넘어져서 깨지는 것을 원하지 않기 때문입니다.</font>

1026
00:39:12,900 --> 00:39:16,160
We're more willing to say, all right, well, it just won't start up as fast if you change

1027
00:39:12,900 --> 00:39:16,160
<font color="#ffff54">변경하면 빨리 시작되지 않습니다.</font>

1028
00:39:16,160 --> 00:39:18,600
something.

1029
00:39:16,160 --> 00:39:18,600
<font color="#ffff54">뭔가.</font>

1030
00:39:18,600 --> 00:39:22,019
And this shouldn't be surprising, because this is stuff that Java has been good at for

1031
00:39:18,600 --> 00:39:22,019
<font color="#ffff54">이것은 놀라운 일이 아닙니다. 왜냐하면 이것은 자바가 오랫동안 잘 해왔던 것이기 때문입니다.</font>

1032
00:39:22,019 --> 00:39:23,260
decades.

1033
00:39:22,019 --> 00:39:23,260
<font color="#ffff54">수십 년 동안 말이죠.</font>

1034
00:39:23,260 --> 00:39:27,140
On the fly adaptation is one of Java's biggest strengths.

1035
00:39:23,260 --> 00:39:27,140
<font color="#ffff54">즉각적인 적응은 자바의 가장 큰 강점 중 하나입니다.</font>

1036
00:39:27,140 --> 00:39:31,460
So there were 100 reasons why we might deoptimize.

1037
00:39:27,140 --> 00:39:31,460
<font color="#ffff54">비최적화를 해야 하는 이유는 100가지가 있습니다.</font>

1038
00:39:31,460 --> 00:39:36,720
Something changed since training run is just one more of those reasons.

1039
00:39:31,460 --> 00:39:36,720
<font color="#ffff54">훈련 실행 이후 변경된 사항이 그 이유 중 하나에 불과합니다.</font>

1040
00:39:36,720 --> 00:39:38,860
So some numbers.

1041
00:39:36,720 --> 00:39:38,860
<font color="#ffff54">몇 가지 숫자가 있습니다.</font>

1042
00:39:38,860 --> 00:39:45,300
So we have the same ideal green curve, which is made up.

1043
00:39:38,860 --> 00:39:45,300
<font color="#ffff54">따라서 우리는 동일한 이상적인 녹색 곡선을 가지고 있습니다.</font>

1044
00:39:45,300 --> 00:39:50,480
And we have the yellow curve, which is an observation of really running a program without

1045
00:39:45,300 --> 00:39:50,480
<font color="#ffff54">그리고 노란색 곡선이 있는데, 이는 실제로 프로그램을 실행하는 것을 관찰한 것입니다.</font>

1046
00:39:50,480 --> 00:39:51,699
any of these tricks.

1047
00:39:50,480 --> 00:39:51,699
<font color="#ffff54">없이 실행했을 때의 관찰입니다.</font>

1048
00:39:51,699 --> 00:39:55,139
And then we're going to add in this red curve, which is an observation of running the program

1049
00:39:51,699 --> 00:39:55,139
<font color="#ffff54">그리고 이 빨간색 곡선에 프로그램을 실행하는 동안 관찰한 결과를 추가하겠습니다.</font>

1050
00:39:55,139 --> 00:39:57,900
with all these tricks that I just described.

1051
00:39:55,139 --> 00:39:57,900
<font color="#ffff54">방금 설명한 모든 트릭이 적용되었습니다.</font>

1052
00:39:57,900 --> 00:40:06,180
And so for running Java C to compile 100 class files, we were able to see roughly

1053
00:39:57,900 --> 00:40:06,180
<font color="#ffff54">따라서 100개의 클래스 파일을 컴파일하기 위해 Java C를 실행하면 대략 다음과 같은 결과를 얻을 수 있습니다.</font>

1054
00:40:06,180 --> 00:40:10,400
2x startup improvement and a pretty reasonable warm up improvement.

1055
00:40:06,180 --> 00:40:10,400
<font color="#ffff54">시작 시간이 2배 향상되고 워밍업 시간도 상당히 개선되었습니다.</font>

1056
00:40:10,400 --> 00:40:16,599
We were able to bring down both the startup number and bring the yellow line down closer

1057
00:40:10,400 --> 00:40:16,599
<font color="#ffff54">시작 수치를 낮추고 노란색 선을 더 가깝게 만들 수 있었습니다.</font>

1058
00:40:16,599 --> 00:40:21,500
to the green line for not very much work.

1059
00:40:16,599 --> 00:40:21,500
<font color="#ffff54">녹색 선에 가까워졌습니다.</font>

1060
00:40:21,500 --> 00:40:22,579
We didn't have to change any code.

1061
00:40:21,500 --> 00:40:22,579
<font color="#ffff54">코드를 변경할 필요가 없었습니다.</font>

1062
00:40:22,579 --> 00:40:24,579
We didn't have to give up any dynamism.

1063
00:40:22,579 --> 00:40:24,579
<font color="#ffff54">역동성을 포기할 필요가 없었습니다.</font>

1064
00:40:24,579 --> 00:40:30,539
We just had to do a little bit more work at build time.

1065
00:40:24,579 --> 00:40:30,539
<font color="#ffff54">빌드 시간에 조금 더 많은 작업을 해야 했습니다.</font>

1066
00:40:30,539 --> 00:40:36,059
So that's a pretty decent payoff for not very much work.

1067
00:40:30,539 --> 00:40:36,059
<font color="#ffff54">작업량이 많지 않은 것에 비하면 꽤 괜찮은 보상입니다.</font>

1068
00:40:36,059 --> 00:40:44,159
And the numbers there represent not just one trick, but a lot of different tricks that

1069
00:40:36,059 --> 00:40:44,159
<font color="#ffff54">그리고 이 숫자는 한 가지 트릭이 아니라 다양한 트릭을 나타냅니다.</font>

1070
00:40:44,159 --> 00:40:51,340
work together to give us a reasonable startup improvement for not that much work.

1071
00:40:44,159 --> 00:40:51,340
<font color="#ffff54">함께 작동하여 그다지 많은 작업을 하지 않고도 합리적인 시작 개선을 제공합니다.</font>

1072
00:40:51,340 --> 00:40:54,940
Still early days.

1073
00:40:51,340 --> 00:40:54,940
<font color="#ffff54">아직 초기 단계입니다.</font>

1074
00:40:54,940 --> 00:41:01,579
One of the things we spent a lot of time on is tuning VM policies, like compilation policies.

1075
00:40:54,940 --> 00:41:01,579
<font color="#ffff54">컴파일 정책과 같은 VM 정책을 조정하는 데 많은 시간을 할애했습니다.</font>

1076
00:41:01,579 --> 00:41:04,059
And this is more of the same.

1077
00:41:01,579 --> 00:41:04,059
<font color="#ffff54">이것도 마찬가지입니다.</font>

1078
00:41:04,059 --> 00:41:07,300
And so these are just pretty much rough numbers from the lab.

1079
00:41:04,059 --> 00:41:07,300
<font color="#ffff54">이 수치는 실험실에서 나온 대략적인 수치입니다.</font>

1080
00:41:07,300 --> 00:41:13,700
Here's a kind of interesting one where we did the same thing with an XML validation

1081
00:41:07,300 --> 00:41:13,700
<font color="#ffff54">다음은 XML 유효성 검사로 동일한 작업을 수행한 흥미로운 결과입니다.</font>

1082
00:41:13,700 --> 00:41:15,960
benchmark from SpecJVM.

1083
00:41:13,700 --> 00:41:15,960
<font color="#ffff54">벤치마크입니다.</font>

1084
00:41:15,960 --> 00:41:20,700
And we didn't see any warm up improvement, but we did see like an 8x startup improvement,

1085
00:41:15,960 --> 00:41:20,700
<font color="#ffff54">워밍업 성능은 개선되지 않았지만 시작 성능은 약 8배 향상되었습니다,</font>

1086
00:41:21,060 --> 00:41:24,380
which what this tells us is different workloads have different behaviors.

1087
00:41:21,060 --> 00:41:24,380
<font color="#ffff54">이는 워크로드에 따라 동작이 달라진다는 것을 의미합니다.</font>

1088
00:41:24,380 --> 00:41:32,660
It's probably the case that there was a relatively small amount of code involved in this workload

1089
00:41:24,380 --> 00:41:32,660
<font color="#ffff54">아마도 이 워크로드에 관련된 코드의 양이 상대적으로 적기 때문일 것입니다.</font>

1090
00:41:32,660 --> 00:41:39,300
that was identified to be hot relatively early, but there was a lot of work, setup work, that

1091
00:41:32,660 --> 00:41:39,300
<font color="#ffff54">비교적 일찍 뜨거워진 것으로 확인되었지만, 많은 작업, 설정 작업이 있었습니다.</font>

1092
00:41:39,300 --> 00:41:42,180
we were able to shift at the beginning.

1093
00:41:39,300 --> 00:41:42,180
<font color="#ffff54">초반에 교대할 수 있었습니다.</font>

1094
00:41:42,180 --> 00:41:47,780
And sometimes startup is the only interesting win, and that's fine, and we can take that.

1095
00:41:42,180 --> 00:41:47,780
<font color="#ffff54">때로는 시작이 유일하게 흥미로운 승리일 때도 있지만, 그건 괜찮아요, 우리는 받아들일 수 있어요.</font>

1096
00:41:47,780 --> 00:41:49,620
All right.

1097
00:41:47,780 --> 00:41:49,620
<font color="#ffff54">알았어요.</font>

1098
00:41:49,619 --> 00:41:59,699
The last example I want to give, and then we will wrap up, is Spring Boot Pet Clinic,

1099
00:41:49,619 --> 00:41:59,699
<font color="#ffff54">마지막으로 스프링 부트 펫 클리닉을 예로 들며 마무리하겠습니다,</font>

1100
00:41:59,699 --> 00:42:05,980
which is sort of typical hello world plus plus spring application.

1101
00:41:59,699 --> 00:42:05,980
<font color="#ffff54">이것은 일종의 전형적인 헬로 월드 플러스 플러스 스프링 애플리케이션입니다.</font>

1102
00:42:05,980 --> 00:42:08,940
And there's a few data points here.

1103
00:42:05,980 --> 00:42:08,940
<font color="#ffff54">그리고 여기에 몇 가지 데이터 포인트가 있습니다.</font>

1104
00:42:08,940 --> 00:42:17,779
The first bar is startup time with just ordinary JDK 22, no tricks.

1105
00:42:08,940 --> 00:42:17,779
<font color="#ffff54">첫 번째 막대는 트릭이 없는 일반적인 JDK 22의 시작 시간입니다.</font>

1106
00:42:17,780 --> 00:42:25,060
The yellow bar involves unpacking the application, which eliminates a lot of activity of loading

1107
00:42:17,780 --> 00:42:25,060
<font color="#ffff54">노란색 막대는 애플리케이션의 압축을 풀고 있는 상태로, 로딩 작업이 많이 제거된 상태입니다.</font>

1108
00:42:25,060 --> 00:42:29,340
classes out of jars, which is something that people do all the time when they deploy these

1109
00:42:25,060 --> 00:42:29,340
<font color="#ffff54">클래스를 불러오는 작업을 제거하는데, 이는 사람들이 이러한 애플리케이션을 배포할 때 항상 하는 작업입니다.</font>

1110
00:42:29,340 --> 00:42:31,100
applications anyway.

1111
00:42:29,340 --> 00:42:31,100
<font color="#ffff54">애플리케이션을 배포할 때 항상 하는 일입니다.</font>

1112
00:42:31,100 --> 00:42:36,940
The next two bars, the light and dark blue, are various combinations of applying the improved

1113
00:42:31,100 --> 00:42:36,940
<font color="#ffff54">다음 두 막대인 하늘색과 진한 파란색은 개선된 기능을 적용한 다양한 조합입니다.</font>

1114
00:42:36,940 --> 00:42:44,100
CDS that I just described of caching different things in the CDS archive.

1115
00:42:36,940 --> 00:42:44,100
<font color="#ffff54">방금 설명한 CDS 아카이브의 다양한 캐싱에 대해 설명했습니다.</font>

1116
00:42:44,099 --> 00:42:51,219
And the last bar brings in the Spring AOT tools, which is basically like a condenser

1117
00:42:44,099 --> 00:42:51,219
<font color="#ffff54">그리고 마지막 바는 기본적으로 콘덴서와 같은 Spring AOT 도구를 가져옵니다.</font>

1118
00:42:51,219 --> 00:42:57,699
that is spring specific, which basically does a training run, observes all of the annotation

1119
00:42:51,219 --> 00:42:57,699
<font color="#ffff54">기본적으로 트레이닝 실행을 수행하고 모든 주석을 관찰하는 스프링 전용입니다.</font>

1120
00:42:57,699 --> 00:43:04,259
scanning and wiring of beans and all of that, and caches that in a faster to startup way.

1121
00:42:57,699 --> 00:43:04,259
<font color="#ffff54">스캔과 빈의 배선 등 모든 것을 관찰하고, 더 빠른 시작을 위해 캐시합니다.</font>

1122
00:43:04,259 --> 00:43:10,659
And all of these different techniques synergize so that running more of these techniques gives

1123
00:43:04,259 --> 00:43:10,659
<font color="#ffff54">그리고 이 모든 다양한 기술이 시너지 효과를 발휘하여 이러한 기술을 더 많이 실행하면 다음과 같은 이점이 있습니다.</font>

1124
00:43:10,659 --> 00:43:12,539
you a better result.

1125
00:43:10,659 --> 00:43:12,539
<font color="#ffff54">더 나은 결과를 얻을 수 있습니다.</font>

1126
00:43:12,539 --> 00:43:18,420
And so what we saw was a roughly 4x startup improvement, again, not giving up anything,

1127
00:43:12,539 --> 00:43:18,420
<font color="#ffff54">그 결과 시작 속도가 약 4배 향상되었지만 아무것도 포기하지 않았습니다,</font>

1128
00:43:18,420 --> 00:43:22,820
not giving up any dynamism, not changing any code.

1129
00:43:18,420 --> 00:43:22,820
<font color="#ffff54">역동성을 포기하지 않고 코드를 변경하지 않았습니다.</font>

1130
00:43:22,820 --> 00:43:26,659
So there were a lot of things that fed into these numbers.

1131
00:43:22,820 --> 00:43:26,659
<font color="#ffff54">이 숫자에는 많은 것들이 영향을 미쳤습니다.</font>

1132
00:43:26,659 --> 00:43:30,940
And there are more things that we're going to do in the future.

1133
00:43:26,659 --> 00:43:30,940
<font color="#ffff54">그리고 앞으로 더 많은 일들이 있을 겁니다.</font>

1134
00:43:30,940 --> 00:43:33,699
Like I said, we're sort of just getting started here.

1135
00:43:30,940 --> 00:43:33,699
<font color="#ffff54">말씀드렸듯이, 이제 막 시작한 단계입니다.</font>

1136
00:43:33,699 --> 00:43:36,259
But a lot of these tactics are additive.

1137
00:43:33,699 --> 00:43:36,259
<font color="#ffff54">하지만 이런 전술은 대부분 추가적입니다.</font>

1138
00:43:36,260 --> 00:43:43,600
And so doing more of them together can give you a cumulatively better improvement.

1139
00:43:36,260 --> 00:43:43,600
<font color="#ffff54">따라서 여러 가지를 함께 사용하면 누적적으로 더 나은 결과를 얻을 수 있습니다.</font>

1140
00:43:43,600 --> 00:43:45,940
So early class loading is a win.

1141
00:43:43,600 --> 00:43:45,940
<font color="#ffff54">따라서 클래스를 일찍 로딩하는 것이 승리입니다.</font>

1142
00:43:45,940 --> 00:43:47,220
Cache and compiled code is a win.

1143
00:43:45,940 --> 00:43:47,220
<font color="#ffff54">캐시 및 컴파일된 코드가 승리입니다.</font>

1144
00:43:47,220 --> 00:43:49,420
These are not surprising.

1145
00:43:47,220 --> 00:43:49,420
<font color="#ffff54">놀랍지 않습니다.</font>

1146
00:43:49,420 --> 00:43:55,220
Resolving invoked dynamic call sites is a smaller win, but still a worthwhile one.

1147
00:43:49,420 --> 00:43:55,220
<font color="#ffff54">호출된 동적 호출 사이트를 해결하는 것은 더 작은 승리이지만 여전히 가치 있는 승리입니다.</font>

1148
00:43:55,220 --> 00:43:59,880
The framework specific analysis that Spring does is really valuable because a big part

1149
00:43:55,220 --> 00:43:59,880
<font color="#ffff54">Spring이 수행하는 프레임워크별 분석은 정말 가치가 있습니다.</font>

1150
00:43:59,880 --> 00:44:04,660
of what applications, like Spring applications do at startup, is annotation scanning.

1151
00:43:59,880 --> 00:44:04,660
<font color="#ffff54">Spring 애플리케이션과 같은 애플리케이션이 시작할 때 수행하는 작업의 상당 부분이 어노테이션 스캐닝이기 때문입니다.</font>

1152
00:44:04,659 --> 00:44:08,899
And that involves a lot of relatively slow paths.

1153
00:44:04,659 --> 00:44:08,899
<font color="#ffff54">그리고 여기에는 상대적으로 느린 경로가 많이 포함됩니다.</font>

1154
00:44:08,899 --> 00:44:14,119
And that can be observed through a training run and recorded.

1155
00:44:08,899 --> 00:44:14,119
<font color="#ffff54">그리고 그것은 훈련 달리기를 통해 관찰하고 기록할 수 있습니다.</font>

1156
00:44:14,119 --> 00:44:19,339
But the upshot of this is that time shifting speculative optimization works pretty well.

1157
00:44:14,119 --> 00:44:19,339
<font color="#ffff54">결론은 시간 이동 투기적 최적화가 꽤 잘 작동한다는 것입니다.</font>

1158
00:44:19,339 --> 00:44:26,039
It's a promising approach that gives us significant, although not as much of a gain as you would

1159
00:44:19,339 --> 00:44:26,039
<font color="#ffff54">여러분만큼의 이득은 아니지만 상당한 이득을 얻을 수 있는 유망한 접근법입니다.</font>

1160
00:44:26,039 --> 00:44:31,539
see with something like Native Image, but not with all the constraints that Native Image

1161
00:44:26,039 --> 00:44:31,539
<font color="#ffff54">네이티브 이미지와 같은 것으로 볼 수 있지만, 네이티브 이미지가 가진 모든 제약이 있는 것은 아닙니다.</font>

1162
00:44:31,539 --> 00:44:33,519
requires you to accept.

1163
00:44:31,539 --> 00:44:33,519
<font color="#ffff54">를 사용하려면 수락해야 합니다.</font>

1164
00:44:33,519 --> 00:44:40,199
So you can get, with the giving up nothing end of the spectrum, you can get some decent

1165
00:44:33,519 --> 00:44:40,199
<font color="#ffff54">그래서 당신은 스펙트럼의 끝을 포기하지 않고도 괜찮은 것을 얻을 수 있습니다.</font>

1166
00:44:40,199 --> 00:44:46,480
gains without giving up any compatibility or dynamism or changing your code.

1167
00:44:40,199 --> 00:44:46,480
<font color="#ffff54">호환성이나 역동성을 포기하거나 코드를 변경하지 않고도 상당한 이득을 얻을 수 있습니다.</font>

1168
00:44:46,480 --> 00:44:52,000
And so what we've kind of done here is you can think of this work and Native Image as

1169
00:44:46,480 --> 00:44:52,000
<font color="#ffff54">따라서 이 작업과 네이티브 이미지를 다음과 같이 생각할 수 있습니다.</font>

1170
00:44:52,000 --> 00:44:53,880
a pair of bookends.

1171
00:44:52,000 --> 00:44:53,880
<font color="#ffff54">한 쌍의 북엔드로 생각할 수 있습니다.</font>

1172
00:44:53,880 --> 00:45:02,059
So at one end of the spectrum, we're saying, how much can I get giving up nothing?

1173
00:44:53,880 --> 00:45:02,059
<font color="#ffff54">스펙트럼의 한쪽 끝에서 우리는 아무것도 포기하지 않고 얼마를 얻을 수 있을까요?</font>

1174
00:45:02,059 --> 00:45:05,699
At the other end of the spectrum, we're saying, how much can I get giving up a lot?

1175
00:45:02,059 --> 00:45:05,699
<font color="#ffff54">스펙트럼의 다른 쪽 끝에서 우리는 얼마나 많은 것을 포기할 수 있을까요?</font>

1176
00:45:05,699 --> 00:45:09,739
And then there's a whole spectrum in the middle of, okay, can I give up some of those things

1177
00:45:05,699 --> 00:45:09,739
<font color="#ffff54">그리고 그 중간에는 전체 스펙트럼이 있습니다. 좋아, 내가 그런 것들 중 일부를 포기할 수 있을까?</font>

1178
00:45:09,739 --> 00:45:12,059
and get some of the difference?

1179
00:45:09,739 --> 00:45:12,059
<font color="#ffff54">차액을 얻을 수 있을까요?</font>

1180
00:45:12,059 --> 00:45:19,119
And we will continue to drill into the space in the middle as we move forward in this work.

1181
00:45:12,059 --> 00:45:19,119
<font color="#ffff54">그리고 우리는 이 작업을 진행하면서 중간에 있는 공간을 계속 뚫고 들어갈 것입니다.</font>

1182
00:45:19,119 --> 00:45:23,820
So I just want to talk briefly about another exploration that's going on in Project Leiden,

1183
00:45:19,119 --> 00:45:23,820
<font color="#ffff54">프로젝트 라이덴에서 진행 중인 또 다른 탐사에 대해 간단히 이야기하고 싶습니다,</font>

1184
00:45:23,820 --> 00:45:28,340
which is a library-based programming model exploration called computed constants.

1185
00:45:23,820 --> 00:45:28,340
<font color="#ffff54">계산된 상수라는 라이브러리 기반 프로그래밍 모델에 대한 탐구입니다.</font>

1186
00:45:28,340 --> 00:45:32,320
And this is about shifting computation later in time.

1187
00:45:28,340 --> 00:45:32,320
<font color="#ffff54">그리고 이것은 계산을 나중에 옮기는 것에 관한 것입니다.</font>

1188
00:45:32,320 --> 00:45:36,740
It's a mechanism for greater laziness without giving up the optimizations that you get from

1189
00:45:32,320 --> 00:45:36,740
<font color="#ffff54">최적화를 포기하지 않으면서도 더 많은 게으름을 피울 수 있는 메커니즘입니다.</font>

1190
00:45:36,740 --> 00:45:39,180
static final fields.

1191
00:45:36,740 --> 00:45:39,180
<font color="#ffff54">정적 최종 필드.</font>

1192
00:45:39,180 --> 00:45:52,460
And so the JVM already contains a known optimization for optimizing mutable static fields as if

1193
00:45:39,180 --> 00:45:52,460
<font color="#ffff54">따라서 JVM에는 이미 다음과 같이 변경 가능한 정적 필드를 최적화하는 알려진 최적화가 포함되어 있습니다.</font>

1194
00:45:53,340 --> 00:46:01,619
if it knows that it will eventually converge to a stable value.

1195
00:45:53,340 --> 00:46:01,619
<font color="#ffff54">가 결국 안정적인 값으로 수렴할 것이라는 것을 알고 있다면 말입니다.</font>

1196
00:46:01,619 --> 00:46:06,099
And it's sort of a dodgy kind of thing, and so it has not been made available as a general

1197
00:46:01,619 --> 00:46:06,099
<font color="#ffff54">그리고 그것은 일종의 회피적인 것이기 때문에 일반적으로 사용할 수 없습니다.</font>

1198
00:46:06,099 --> 00:46:10,860
purpose optimization, but it's something that you see in the JDK code.

1199
00:46:06,099 --> 00:46:10,860
<font color="#ffff54">목적의 최적화가 아니라 JDK 코드에서 볼 수 있는 것입니다.</font>

1200
00:46:10,860 --> 00:46:14,800
You see some code annotated with the internal annotation at stable.

1201
00:46:10,860 --> 00:46:14,800
<font color="#ffff54">내부 어노테이션으로 주석이 달린 코드가 안정적으로 표시됩니다.</font>

1202
00:46:14,800 --> 00:46:19,699
And this is a hint to the JVM that says, once this is initialized, treat it as if it were

1203
00:46:14,800 --> 00:46:19,699
<font color="#ffff54">그리고 이것은 일단 이것이 초기화되면 마치</font>

1204
00:46:19,699 --> 00:46:20,699
final.

1205
00:46:19,699 --> 00:46:20,699
<font color="#ffff54">final.</font>

1206
00:46:20,780 --> 00:46:24,340
So this is a really good example of that kind of static dynamic yin-yang.

1207
00:46:20,780 --> 00:46:24,340
<font color="#ffff54">이것은 정적 동적 음양의 좋은 예입니다.</font>

1208
00:46:24,340 --> 00:46:28,340
It's a fully dynamic computation, but the VM is able to say, oh, well, if I look at

1209
00:46:24,340 --> 00:46:28,340
<font color="#ffff54">완전히 동적인 계산이지만, VM은 다음과 같이 말할 수 있습니다.</font>

1210
00:46:28,340 --> 00:46:30,900
it through this lens, I can treat it as static.

1211
00:46:28,340 --> 00:46:30,900
<font color="#ffff54">이 렌즈를 통해 보면 정적인 것으로 취급할 수 있습니다.</font>

1212
00:46:30,900 --> 00:46:35,340
And if I see somebody assigned to it, well, I know the assumption is violated and I can

1213
00:46:30,900 --> 00:46:35,340
<font color="#ffff54">그리고 만약 누군가가 거기에 할당된 것을 본다면, 저는 그 가정이 어긋난다는 것을 알고</font>

1214
00:46:35,340 --> 00:46:36,980
deoptimize.

1215
00:46:35,340 --> 00:46:36,980
<font color="#ffff54">최적화 해제합니다.</font>

1216
00:46:36,980 --> 00:46:45,300
So this is a cool optimization that we do internally, but was not ready for broad consumption,

1217
00:46:36,980 --> 00:46:45,300
<font color="#ffff54">이것은 내부적으로 수행한 멋진 최적화이지만 널리 사용할 준비가 되지 않았습니다,</font>

1218
00:46:45,300 --> 00:46:47,840
which is why it's internal only.

1219
00:46:45,300 --> 00:46:47,840
<font color="#ffff54">그래서 내부 전용입니다.</font>

1220
00:46:47,840 --> 00:46:51,720
So the computed constants exploration, which is still in the early phase, it's a draft

1221
00:46:47,840 --> 00:46:51,720
<font color="#ffff54">계산된 상수 탐색은 아직 초기 단계에 있으며, 초안입니다.</font>

1222
00:46:51,720 --> 00:46:57,480
JEP for it, exposes that same optimization to user code.

1223
00:46:51,720 --> 00:46:57,480
<font color="#ffff54">사용자 코드에 동일한 최적화를 노출합니다.</font>

1224
00:46:57,480 --> 00:47:05,160
And the way it works is you declare a computed constant and you give it a lambda to initialize

1225
00:46:57,480 --> 00:47:05,160
<font color="#ffff54">작동 방식은 계산된 상수를 선언하고 초기화할 람다를 제공하는 것입니다.</font>

1226
00:47:05,160 --> 00:47:06,360
it.

1227
00:47:05,160 --> 00:47:06,360
<font color="#ffff54">it.</font>

1228
00:47:06,360 --> 00:47:12,079
And the first time anybody goes to read that computed constant, it goes and runs the initializer,

1229
00:47:06,360 --> 00:47:12,079
<font color="#ffff54">그리고 누군가가 이 계산된 상수를 처음 읽으려고 하면, 이 상수는 이니셜라이저를 실행합니다,</font>

1230
00:47:12,079 --> 00:47:16,880
and thereafter caches it using at stable so that you get basically the full performance

1231
00:47:12,079 --> 00:47:16,880
<font color="#ffff54">그리고 그 이후에는 기본적으로 전체 성능을 얻을 수 있도록 안정적으로 캐시합니다.</font>

1232
00:47:16,960 --> 00:47:24,960
of static final fields with the laziness of what looks like a dumb library for lazy initialization.

1233
00:47:16,960 --> 00:47:24,960
<font color="#ffff54">의 정적 최종 필드에 대해 게으른 초기화를 위한 멍청한 라이브러리처럼 보입니다.</font>

1234
00:47:24,960 --> 00:47:27,360
It's not as dumb as it looks.

1235
00:47:24,960 --> 00:47:27,360
<font color="#ffff54">보기만큼 멍청하지 않습니다.</font>

1236
00:47:27,360 --> 00:47:35,039
But what this lets us do is to say, identify individual calculations that say, this calculation

1237
00:47:27,360 --> 00:47:35,039
<font color="#ffff54">하지만 이를 통해 우리가 할 수 있는 것은 다음과 같은 개별 계산을 식별하는 것입니다.</font>

1238
00:47:35,039 --> 00:47:42,000
doesn't need to be done so early, so I'm going to mark that as lazy, let it be shifted until

1239
00:47:35,039 --> 00:47:42,000
<font color="#ffff54">는 그렇게 일찍 수행될 필요가 없으므로, 이를 게으른 것으로 표시하고</font>

1240
00:47:42,400 --> 00:47:47,199
it's needed without giving up any of the optimization benefits that we would ordinarily get from

1241
00:47:42,400 --> 00:47:47,199
<font color="#ffff54">로 이동시켜서 일반적으로 얻을 수 있는 최적화 이점을 포기하지 않고도 필요합니다.</font>

1242
00:47:47,199 --> 00:47:49,360
static final fields.

1243
00:47:47,199 --> 00:47:49,360
<font color="#ffff54">정적 최종 필드.</font>

1244
00:47:49,360 --> 00:47:53,559
And this mechanism may eventually be extended to talk about shifting earlier in time to

1245
00:47:49,360 --> 00:47:53,559
<font color="#ffff54">그리고 이 메커니즘은 결국 더 이른 시간으로 이동하는 것에 대해 이야기하기 위해 확장될 수 있습니다.</font>

1246
00:47:53,559 --> 00:47:58,920
earlier phases of computation, but we're still early in the process of that.

1247
00:47:53,559 --> 00:47:58,920
<font color="#ffff54">초기 계산 단계로 확장할 수도 있지만, 아직은 초기 단계입니다.</font>

1248
00:47:58,920 --> 00:48:03,159
So there's a lot of work left to do.

1249
00:47:58,920 --> 00:48:03,159
<font color="#ffff54">아직 해야 할 일이 많이 남았군요.</font>

1250
00:48:03,159 --> 00:48:06,519
We have a prototype of condensers and a condenser toolkit.

1251
00:48:03,159 --> 00:48:06,519
<font color="#ffff54">콘덴서 프로토타입과 콘덴서 툴킷이 있습니다.</font>

1252
00:48:06,519 --> 00:48:12,039
We have a lot more investigation about what other forms of computation can we shift and

1253
00:48:06,519 --> 00:48:12,039
<font color="#ffff54">우리는 어떤 다른 형태의 계산으로 전환할 수 있는지에 대해 더 많은 조사를 하고 있습니다.</font>

1254
00:48:12,039 --> 00:48:18,119
what are the most interesting middle ground constraints that might allow us to do more

1255
00:48:12,039 --> 00:48:18,119
<font color="#ffff54">더 많은 일을 할 수 있는 가장 흥미로운 중간지대의 제약 조건은 무엇일까요?</font>

1256
00:48:18,119 --> 00:48:19,880
shifting.

1257
00:48:18,119 --> 00:48:19,880
<font color="#ffff54">이동.</font>

1258
00:48:19,880 --> 00:48:24,519
And I think the biggest challenge is finding the right way to bring shiftability into the

1259
00:48:19,880 --> 00:48:24,519
<font color="#ffff54">그리고 가장 큰 도전 과제는 시프터빌리티를</font>

1260
00:48:24,519 --> 00:48:30,400
programming model so that the user is able to say, here's a computation that has certain

1261
00:48:24,519 --> 00:48:30,400
<font color="#ffff54">프로그래밍 모델에 적절한 방법을 찾는 것입니다.</font>

1262
00:48:30,400 --> 00:48:35,800
semantic properties that the JVM can then identify as, oh, under these conditions, I

1263
00:48:30,400 --> 00:48:35,800
<font color="#ffff54">의미적 속성을 가진 연산이라고 말할 수 있습니다.</font>

1264
00:48:35,800 --> 00:48:37,360
know I can shift that.

1265
00:48:35,800 --> 00:48:37,360
<font color="#ffff54">바꿀 수 있다는 것을 알 수 있습니다.</font>

1266
00:48:37,360 --> 00:48:39,519
So we're just getting started.

1267
00:48:37,360 --> 00:48:39,519
<font color="#ffff54">이제 시작이네요.</font>

1268
00:48:39,519 --> 00:48:43,200
There's a lot left to do.

1269
00:48:39,519 --> 00:48:43,200
<font color="#ffff54">아직 할 일이 많이 남았어.</font>

1270
00:48:43,200 --> 00:48:47,280
And I see my time is just about up, but I think we have time for a few questions.

1271
00:48:43,200 --> 00:48:47,280
<font color="#ffff54">시간이 거의 다 됐지만 몇 가지 질문할 시간이 있을 것 같아요.</font>

1272
00:48:47,280 --> 00:48:48,280
So all right.

1273
00:48:47,280 --> 00:48:48,280
<font color="#ffff54">알았어요.</font>

1274
00:48:48,280 --> 00:48:49,280
Any questions?

1275
00:48:48,280 --> 00:48:49,280
<font color="#ffff54">질문 있나?</font>

1276
00:48:49,280 --> 00:48:56,280
So the question is, what can you use in production today?

1277
00:48:49,280 --> 00:48:56,280
<font color="#ffff54">그렇다면 오늘 프로덕션에서 무엇을 사용할 수 있을까요?</font>

1278
00:48:56,280 --> 00:49:04,160
So all the work that I've described so far is highly experimental.

1279
00:48:56,280 --> 00:49:04,160
<font color="#ffff54">그래서 지금까지 설명한 모든 작업은 매우 실험적입니다.</font>

1280
00:49:04,159 --> 00:49:08,559
And so if you want to use experimental code in production, well, you can do whatever you

1281
00:49:04,159 --> 00:49:08,559
<font color="#ffff54">따라서 프로덕션 환경에서 실험적인 코드를 사용하고 싶다면, 뭐든지 할 수 있습니다.</font>

1282
00:49:08,559 --> 00:49:09,559
want.

1283
00:49:08,559 --> 00:49:09,559
<font color="#ffff54">하고 싶으면.</font>

1284
00:49:09,559 --> 00:49:12,519
But it's not in a JDK anywhere yet.

1285
00:49:09,559 --> 00:49:12,519
<font color="#ffff54">하지만 아직 JDK 어디에도 없습니다.</font>

1286
00:49:12,519 --> 00:49:17,699
What I expect you will start to see over the next couple of releases is some GEPs that

1287
00:49:12,519 --> 00:49:17,699
<font color="#ffff54">다음 몇 번의 릴리스에서 다음과 같은 GEP를 보게 될 것으로 예상됩니다.</font>

1288
00:49:17,699 --> 00:49:22,379
describe smaller pieces like improvements to CDS.

1289
00:49:17,699 --> 00:49:22,379
<font color="#ffff54">CDS 개선과 같은 작은 부분을 설명합니다.</font>

1290
00:49:22,379 --> 00:49:25,639
But what you can use in production today is AppCDS.

1291
00:49:22,379 --> 00:49:25,639
<font color="#ffff54">하지만 현재 프로덕션에서 사용할 수 있는 것은 AppCDS입니다.</font>

1292
00:49:25,639 --> 00:49:31,199
And that is, like I said, it's been in the JDK for years and years.

1293
00:49:25,639 --> 00:49:31,199
<font color="#ffff54">앞서 말했듯이 이 기능은 수년 전부터 JDK에 존재해 왔습니다.</font>

1294
00:49:31,200 --> 00:49:36,140
It has tooling for dumping and customizing CDS archives.

1295
00:49:31,200 --> 00:49:36,140
<font color="#ffff54">CDS 아카이브를 덤핑하고 커스터마이징하는 도구가 있습니다.</font>

1296
00:49:36,140 --> 00:49:39,920
So that's not everything that I just described.

1297
00:49:36,140 --> 00:49:39,920
<font color="#ffff54">방금 설명한 것이 전부가 아닙니다.</font>

1298
00:49:39,920 --> 00:49:41,420
But you can use that today.

1299
00:49:39,920 --> 00:49:41,420
<font color="#ffff54">하지만 오늘도 사용할 수 있습니다.</font>

1300
00:49:41,420 --> 00:49:45,600
You can also use Native Image today if your application is suitable for the constraints

1301
00:49:41,420 --> 00:49:45,600
<font color="#ffff54">애플리케이션이 제약 조건에 적합하다면 지금 바로 네이티브 이미지를 사용할 수도 있습니다.</font>

1302
00:49:45,600 --> 00:49:46,600
of Native Image.

1303
00:49:45,600 --> 00:49:46,600
<font color="#ffff54">의 네이티브 이미지입니다.</font>

1304
00:49:46,600 --> 00:49:48,960
And I see you shaking your head.

1305
00:49:46,600 --> 00:49:48,960
<font color="#ffff54">네가 고개를 흔드는 게 보여.</font>

1306
00:49:48,960 --> 00:49:54,560
So we understand not every workload is willing to accept those constraints.

1307
00:49:48,960 --> 00:49:54,560
<font color="#ffff54">모든 워크로드가 이러한 제약을 기꺼이 받아들이는 것은 아니라는 것을 알고 있습니다.</font>

1308
00:49:54,560 --> 00:49:55,560
More questions?

1309
00:49:54,560 --> 00:49:55,560
<font color="#ffff54">질문이 더 있으신가요?</font>

1310
00:49:55,560 --> 00:49:56,800
I can't see anything.

1311
00:49:55,560 --> 00:49:56,800
<font color="#ffff54">아무것도 안 보여요.</font>

1312
00:49:56,800 --> 00:50:02,519
So there's a hand over here.

1313
00:49:56,800 --> 00:50:02,519
<font color="#ffff54">여기 손이 있네요.</font>

1314
00:50:02,519 --> 00:50:03,519
OK, I'm sorry.

1315
00:50:02,519 --> 00:50:03,519
<font color="#ffff54">알았어, 미안해.</font>

1316
00:50:03,519 --> 00:50:04,519
You talked about constraints.

1317
00:50:03,519 --> 00:50:04,519
<font color="#ffff54">제약 조건에 대해 얘기했잖아요.</font>

1318
00:50:04,519 --> 00:50:05,519
What is the failure rule?

1319
00:50:04,519 --> 00:50:05,519
<font color="#ffff54">실패 규칙은 무엇인가요?</font>

1320
00:50:05,519 --> 00:50:11,240
So if I accept a constraint and it turns out later, actually violated, what happens?

1321
00:50:05,519 --> 00:50:11,240
<font color="#ffff54">제약 조건을 수락했는데 나중에 실제로 위반한 것으로 밝혀지면 어떻게 되나요?</font>

1322
00:50:11,240 --> 00:50:12,240
Yeah, that's a great question.

1323
00:50:11,240 --> 00:50:12,240
<font color="#ffff54">네, 좋은 질문이네요.</font>

1324
00:50:12,240 --> 00:50:17,440
So the question is, let's say I opt into a constraint at build time.

1325
00:50:12,240 --> 00:50:17,440
<font color="#ffff54">문제는 빌드 시점에 제약 조건을 선택한다고 가정해 봅시다.</font>

1326
00:50:17,440 --> 00:50:20,220
And then that constraint turns out to be violated.

1327
00:50:17,440 --> 00:50:20,220
<font color="#ffff54">그런데 그 제약 조건이 위반된 것으로 밝혀졌습니다.</font>

1328
00:50:20,220 --> 00:50:22,060
What happens?

1329
00:50:20,220 --> 00:50:22,060
<font color="#ffff54">어떻게 될까요?</font>

1330
00:50:22,060 --> 00:50:25,260
So I think it depends.

1331
00:50:22,060 --> 00:50:25,260
<font color="#ffff54">상황에 따라 다르겠지.</font>

1332
00:50:25,260 --> 00:50:33,220
So for example, with at stable, you're making a sort of promise to the VM that says, this

1333
00:50:25,260 --> 00:50:33,220
<font color="#ffff54">예를 들어, 스테이블에서는 가상머신에 다음과 같은 일종의 약속을 하는 것입니다.</font>

1334
00:50:33,220 --> 00:50:36,000
thing won't change after its value stabilizes.

1335
00:50:33,220 --> 00:50:36,000
<font color="#ffff54">값이 안정된 후에는 변경되지 않을 것이라고 약속하는 것입니다.</font>

1336
00:50:36,000 --> 00:50:37,800
But the JVM doesn't believe you.

1337
00:50:36,000 --> 00:50:37,800
<font color="#ffff54">하지만 JVM은 당신을 믿지 않습니다.</font>

1338
00:50:37,800 --> 00:50:40,860
So the optimization it does is speculative.

1339
00:50:37,800 --> 00:50:40,860
<font color="#ffff54">따라서 최적화는 추측에 불과합니다.</font>

1340
00:50:40,860 --> 00:50:45,820
And if it sees you do a put field or put static to that field, it will say, oh, wait a second.

1341
00:50:40,860 --> 00:50:45,820
<font color="#ffff54">그리고 만약 당신이 풋 필드를 하거나 그 필드에 스태틱을 넣는 것을 본다면, "잠깐만요"라고 말할 것입니다.</font>

1342
00:50:45,820 --> 00:50:50,660
Now I have to go and validate a whole bunch of code, which might be an expensive revocation.

1343
00:50:45,820 --> 00:50:50,660
<font color="#ffff54">이제 모든 코드의 유효성을 검사해야 하는데, 비용이 많이 들 수 있습니다.</font>

1344
00:50:50,659 --> 00:50:55,219
So the consequence might be an expensive revocation, or the consequence might be an

1345
00:50:50,659 --> 00:50:55,219
<font color="#ffff54">그래서 그 결과는 비싼 취소일 수도 있고, 그 결과는</font>

1346
00:50:55,219 --> 00:50:56,219
exception.

1347
00:50:55,219 --> 00:50:56,219
<font color="#ffff54">예외.</font>

1348
00:50:56,219 --> 00:51:01,259
If you've said, I promise I'm not going to redefine this class ever, and then someone

1349
00:50:56,219 --> 00:51:01,259
<font color="#ffff54">이 클래스를 다시는 재정의하지 않겠다고 약속합니다.</font>

1350
00:51:01,259 --> 00:51:06,559
tries to redefine that class, maybe you'll get an exception that says redefinition is

1351
00:51:01,259 --> 00:51:06,559
<font color="#ffff54">그 클래스를 재정의하려고 하면, 재정의는 다음과 같은 예외가 발생할 수 있습니다.</font>

1352
00:51:06,559 --> 00:51:11,839
denied because this condenser configuration marked this class as non-redefinable.

1353
00:51:06,559 --> 00:51:11,839
<font color="#ffff54">이 콘덴서 구성이 이 클래스를 재정의할 수 없는 것으로 표시했기 때문에 거부되었습니다.</font>

1354
00:51:11,839 --> 00:51:17,319
So I think it depends on whether there's a recovery possible or whether we just have

1355
00:51:11,839 --> 00:51:17,319
<font color="#ffff54">그래서 제 생각에는 복구가 가능한지 아니면 그냥</font>

1356
00:51:17,319 --> 00:51:19,960
to say, you lied to me.

1357
00:51:17,319 --> 00:51:19,960
<font color="#ffff54">나한테 거짓말을 했어.</font>

1358
00:51:19,960 --> 00:51:22,760
All right.

1359
00:51:19,960 --> 00:51:22,760
<font color="#ffff54">알았어.</font>

1360
00:51:22,760 --> 00:51:41,199
I think, do I see a question right under the very bright lights over there?

1361
00:51:22,760 --> 00:51:41,199
<font color="#ffff54">저기 아주 밝은 불빛 아래에 질문이 보이나요?</font>

1362
00:51:41,199 --> 00:51:44,360
Why was the field not final?

1363
00:51:41,199 --> 00:51:44,360
<font color="#ffff54">왜 필드가 마지막이 아니었나요?</font>

1364
00:51:44,360 --> 00:51:49,119
Yes, because PowerPoint is a terrible IDE.

1365
00:51:44,360 --> 00:51:49,119
<font color="#ffff54">네, 파워포인트는 끔찍한 IDE이기 때문이죠.</font>

1366
00:51:50,119 --> 00:51:53,119
So we're going to fix that right now.

1367
00:51:50,119 --> 00:51:53,119
<font color="#ffff54">그래서 지금 바로 고치겠습니다.</font>

1368
00:51:53,119 --> 00:51:56,119
OK, public static final.

1369
00:51:53,119 --> 00:51:56,119
<font color="#ffff54">좋아, 공용 정적 파이널입니다.</font>

1370
00:51:56,119 --> 00:51:58,119
OK, what were you talking about?

1371
00:51:56,119 --> 00:51:58,119
<font color="#ffff54">좋아, 무슨 소리야?</font>

1372
00:52:00,119 --> 00:52:01,119
Yeah.

1373
00:52:00,119 --> 00:52:01,119
<font color="#ffff54">그래</font>

1374
00:52:01,119 --> 00:52:04,119
So thank you, Mr. Compiler.

1375
00:52:01,119 --> 00:52:04,119
<font color="#ffff54">고마워요, 컴파일러 씨.</font>

1376
00:52:05,119 --> 00:52:07,119
Any other questions?

1377
00:52:05,119 --> 00:52:07,119
<font color="#ffff54">다른 질문은 없나요?</font>

1378
00:52:09,119 --> 00:52:11,119
Ah, yes, a question in the middle there.

1379
00:52:09,119 --> 00:52:11,119
<font color="#ffff54">아, 네, 중간에 질문이 있어요.</font>

1380
00:52:11,119 --> 00:52:14,119
And I think that's probably the last question we have time for.

1381
00:52:11,119 --> 00:52:14,119
<font color="#ffff54">아마 이게 마지막 질문인 것 같아요.</font>

1382
00:52:14,119 --> 00:52:15,119
So.

1383
00:52:14,119 --> 00:52:15,119
<font color="#ffff54">그럼.</font>

1384
00:52:15,119 --> 00:52:21,119
So the question is, how is this related to crack?

1385
00:52:15,119 --> 00:52:21,119
<font color="#ffff54">그렇다면 이것이 크랙과 어떤 관련이 있을까요?</font>

1386
00:52:21,119 --> 00:52:25,119
So they're related in the sense that they're exploring the same goal.

1387
00:52:21,119 --> 00:52:25,119
<font color="#ffff54">같은 목표를 탐구한다는 점에서 서로 연관되어 있습니다.</font>

1388
00:52:25,119 --> 00:52:33,119
So project crack basically says, let's assume a checkpoint mechanism that's outside of the

1389
00:52:25,119 --> 00:52:33,119
<font color="#ffff54">그래서 프로젝트 크랙은 기본적으로 체크포인트 메커니즘이 다음과 같이 말합니다.</font>

1390
00:52:33,119 --> 00:52:38,119
JDK, whether it be Criu or some cloud-based checkpoint mechanism.

1391
00:52:33,119 --> 00:52:38,119
<font color="#ffff54">JDK, 크리우든 클라우드 기반 체크포인트 메커니즘이든.</font>

1392
00:52:38,119 --> 00:52:43,119
Let's run the application up to a certain point, freeze dry it, and then restore it.

1393
00:52:38,119 --> 00:52:43,119
<font color="#ffff54">애플리케이션을 특정 지점까지 실행하고 동결 건조시킨 다음 복원해 봅시다.</font>

1394
00:52:43,119 --> 00:52:49,119
And then, well, that may not work because you may have done things like open socket.

1395
00:52:43,119 --> 00:52:49,119
<font color="#ffff54">그러면 오픈 소켓과 같은 작업을 수행했을 수 있으므로 작동하지 않을 수 있습니다.</font>

1396
00:52:49,119 --> 00:52:55,119
So you have to register handlers for things that have to be redone at restore time.

1397
00:52:49,119 --> 00:52:55,119
<font color="#ffff54">따라서 복원 시점에 다시 실행해야 하는 작업에 대한 핸들러를 등록해야 합니다.</font>

1398
00:52:55,119 --> 00:53:00,119
So I think crack is an interesting exploration.

1399
00:52:55,119 --> 00:53:00,119
<font color="#ffff54">그래서 크랙은 흥미로운 탐험이라고 생각합니다.</font>

1400
00:53:00,119 --> 00:53:10,119
I'm not particularly optimistic about it because it is not something that allows you to

1401
00:53:00,119 --> 00:53:10,119
<font color="#ffff54">저는 특별히 낙관적이지 않아요. 왜냐하면 그것은 당신이 할 수 있는 것이 아니기 때문입니다.</font>

1402
00:53:10,119 --> 00:53:16,119
validate that your program is correct through any sort of like sensible analysis.

1403
00:53:10,119 --> 00:53:16,119
<font color="#ffff54">어떤 종류의 합리적인 분석을 통해 프로그램이 올바른지 검증할 수 있는 것이 아니기 때문입니다.</font>

1404
00:53:16,119 --> 00:53:21,119
You sort of have to debug your way into correctness by trying things and seeing what fails.

1405
00:53:16,119 --> 00:53:21,119
<font color="#ffff54">여러 가지를 시도하고 무엇이 실패하는지 확인하면서 올바른 방향으로 디버깅해야 합니다.</font>

1406
00:53:21,119 --> 00:53:27,119
The problem with crack is that it's trying to interpret old code with new semantics

1407
00:53:21,119 --> 00:53:27,119
<font color="#ffff54">크랙의 문제는 오래된 코드를 새로운 의미로 해석하려고 한다는 것입니다.</font>

1408
00:53:27,119 --> 00:53:30,119
and hope everything is good.

1409
00:53:27,119 --> 00:53:30,119
<font color="#ffff54">모든 것이 잘되기를 바랍니다.</font>

1410
00:53:30,119 --> 00:53:32,119
And if it is good, great.

1411
00:53:30,119 --> 00:53:32,119
<font color="#ffff54">좋으면 좋죠.</font>

1412
00:53:32,119 --> 00:53:34,119
It gives you great performance numbers.

1413
00:53:32,119 --> 00:53:34,119
<font color="#ffff54">훌륭한 성능 수치를 제공합니다.</font>

1414
00:53:34,119 --> 00:53:36,119
If not, you just have broken code.

1415
00:53:34,119 --> 00:53:36,119
<font color="#ffff54">그렇지 않다면 코드가 깨진 것입니다.</font>

1416
00:53:36,119 --> 00:53:39,119
And maybe if you're lucky, you get an exception.

1417
00:53:36,119 --> 00:53:39,119
<font color="#ffff54">운이 좋으면 예외가 발생할 수도 있습니다.</font>

1418
00:53:39,119 --> 00:53:42,119
But maybe if you're unlucky, you just get wrong answers.

1419
00:53:39,119 --> 00:53:42,119
<font color="#ffff54">하지만 운이 나쁘면 오답을 얻을 수도 있습니다.</font>

1420
00:53:42,119 --> 00:53:47,119
And those wrong answers come from assumptions that are violated deep in libraries that you

1421
00:53:42,119 --> 00:53:47,119
<font color="#ffff54">그리고 그 오답은 라이브러리 깊숙이 자리 잡은 잘못된 가정에서 비롯됩니다.</font>

1422
00:53:47,119 --> 00:53:49,119
didn't even know were part of your application.

1423
00:53:47,119 --> 00:53:49,119
<font color="#ffff54">응용 프로그램의 일부인지도 몰랐던 가정에서 비롯됩니다.</font>

1424
00:53:49,119 --> 00:53:53,119
So I think crack is a good exploration.

1425
00:53:49,119 --> 00:53:53,119
<font color="#ffff54">그래서 크랙은 좋은 탐험이라고 생각해요.</font>

1426
00:53:53,119 --> 00:53:57,119
I think it's a, you know, but I'm not optimistic about it as a programming model.

1427
00:53:53,119 --> 00:53:57,119
<font color="#ffff54">알다시피 프로그래밍 모델로는 낙관적이지 않다고 생각해요.</font>

1428
00:53:57,119 --> 00:54:03,119
I would much rather give people a programming model where if they, you know, whatever code

1429
00:53:57,119 --> 00:54:03,119
<font color="#ffff54">저는 차라리 사람들이 어떤 코드를 작성하더라도</font>

1430
00:54:03,119 --> 00:54:06,119
that they have will run correctly 100% of the time.

1431
00:54:03,119 --> 00:54:06,119
<font color="#ffff54">를 입력하면 100% 올바르게 실행되는 프로그래밍 모델을 제공하고 싶습니다.</font>

1432
00:54:06,119 --> 00:54:09,119
And then if they do some more work, they can make it run faster.

1433
00:54:06,119 --> 00:54:09,119
<font color="#ffff54">그리고 더 많은 작업을 수행하면 더 빠르게 실행할 수 있습니다.</font>

1434
00:54:09,119 --> 00:54:14,119
Crack tries to make things run faster potentially at the expense of correctness.

1435
00:54:09,119 --> 00:54:14,119
<font color="#ffff54">크랙은 정확성을 희생해서라도 더 빠르게 실행하려고 합니다.</font>

1436
00:54:14,119 --> 00:54:16,119
And I don't like that tradeoff.

1437
00:54:14,119 --> 00:54:16,119
<font color="#ffff54">그리고 나는 그 트레이드오프가 마음에 들지 않는다.</font>

1438
00:54:16,119 --> 00:54:19,119
But I think it's an interesting exploration.

1439
00:54:16,119 --> 00:54:19,119
<font color="#ffff54">하지만 흥미로운 탐험이라고 생각해요.</font>

1440
00:54:19,119 --> 00:54:21,119
I'm glad it's going on.

1441
00:54:19,119 --> 00:54:21,119
<font color="#ffff54">진행 중이라 다행이네요.</font>

1442
00:54:21,119 --> 00:54:26,119
But I wouldn't bet on that direction.

1443
00:54:21,119 --> 00:54:26,119
<font color="#ffff54">하지만 그 방향에 내기를 걸진 않겠어.</font>

1444
00:54:26,119 --> 00:54:27,119
So all right.

1445
00:54:26,119 --> 00:54:27,119
<font color="#ffff54">알았어.</font>

1446
00:54:27,119 --> 00:54:29,119
Thank you very much, everyone.

1447
00:54:27,119 --> 00:54:29,119
<font color="#ffff54">모두들 수고했어요.</font>

1448
00:54:36,119 --> 00:54:38,119
Thank you.

1449
00:54:36,119 --> 00:54:38,119
<font color="#ffff54">감사합니다.</font>
